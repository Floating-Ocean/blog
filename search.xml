<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome to My Blog</title>
    <url>/blog/posts/2656694144/</url>
    <content><![CDATA[欢迎来到 Floating Ocean's Blog! 这是一个部署在 Github 上的个人博客，博客目前涵盖部分算法竞赛平台的个人题解和思路，随本人刷题进度更新，欢迎大家偷窥我是否在卷。 博客基于略微修改后的 Hexo + Butterfly 框架，支持评论、一言等拓展功能。 考虑到性能问题，将博客的 repo 镜像到了 Gitee 上，并部署到了 Gitee Pages。 因为静态网页的问题，可能存在部分 Gitee 跳转至 Github 的链接。 站点更新日志 有关文章更新日志，请移步 归档 页 23.05.23 将 repo 镜像到了 Gitee 上 23.05.20 更新 关于 页 (p.s. 塞了个私货) 根据 codeforces 的 比赛 id 加入了 "最近 CF 场" 置顶功能，并按照 id 更改了 Codeforces 标签下文章的顺序。 (p.s. 比赛 id 不完全按照时间排序) 进行一个字数统计的功能回归（ 在不知道哪个时间改了一下网站字体~ 23.05.17 在改ui和想改ui之间挣扎着 根据 codeforces 的 规则 重新比对了加减分 23.05.06 来试试新的卡片设计! 23.05.04 调整ui 更新一大堆文章 23.04.13,17 调整部分ui的hover动画 23.04.12 优化底层，对部分文章的公式略作修改 更新并添加了一些小功能 继续修复某些文章的公式显示问题 23.04.09 支持 PWA 应用，可以进行安装 修复某些文章的公式显示问题 23.04.07 完成站点主题的迁移，新增许多 Butterfly 主题的集成功能 将旧站点迁移至 /blog_old 网址下 23.04.05 迁移站点主题至 Butterfly，同步了部分功能 23.03.08 调整部分ui 23.03.07 优化站点资源加载速度 23.03.06 将所有扣分局的文章信息框标红 修复几处链接错误 23.03.04 更新主页 更新置顶功能 添加短链功能，显示在文章标题的右下角 添加 warn 标签，在文章中以红色引用框显示 这是一个带有warn标签的提示 23.03.02 添加 todo 标签，在文章中以黄色引用框显示 这是一个带有todo标签的提示 23.02.19 添加 info 标签，在文章中以绿色引用框显示 添加文章底部版权框 点击一言进入官网 这是一个带有info标签的提示 23.02.12 添加顶部加载条，和文章阅读进度条样式一致 23.02.11 全局更改了动画差值器 23.02.10 加入每日一言 优化评论区样式 23.02.09 改用 prism 渲染代码 加入 spoiler，用于 detail 标签的支持 23.02.06 优化评论区样式 23.02.02 评论区功能完善 23.02.01 新增评论区功能 23.01.30 更新图标库 加入站内搜索 23.01.24 站点独立为新的 repo 23.01.15,18,19,21 优化样式 23.01.14 搭建初始框架 到底了捏，更新还在路上~]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Welcome</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 874 Div 3</title>
    <url>/blog/posts/1575178804/</url>
    <content><![CDATA[Contestant. Rank 867. Rating +25(+75 -50). 又一次成为痛苦号（ A. Musical Puzzle 题意 给定一个字符串，输出所有相邻两个字符组成的不同字符串的个数。 思路 如题，用 \(map\) 即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7; void solve()&#123; int n; cin >> n; string s; cin >> s; map&lt;string, int> cnt; for(int i=0;i&lt;n - 1;i++)&#123; cnt[to_string(s[i]) + s[i + 1]] ++; &#125; cout &lt;&lt; cnt.size() &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 题目看半天才看懂，淦 B. Restore the Weather 题意 给定 \(n\) 天的实际温度和预估温度，其中，实际温度按天升序给出，预估温度打乱顺序后给出。 给定整数 \(k\)，满足每一天的实际温度和预估温度的差的绝对值不超过 \(k\)，输出任意一种满足条件的预估温度的排列。 其中，满足一定有解。 思路 \(k\) 是没有用的。 为何呢？因为满足一定有解，我们升序排序后，依次配对即可，这样就可以让每天的差值最小。 注意配对的时候下标变化。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7; void solve()&#123; int n, k; cin >> n >> k; vector&lt;pii> a(n); vector&lt;int> b(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i].fs; a[i].sc = i; &#125; for(int i=0;i&lt;n;i++) cin >> b[i]; sort(all(a)), sort(all(b)); vector&lt;int> w(n); for(int i=0;i&lt;n;i++) w[a[i].sc] = i; for(int i=0;i&lt;n;i++)&#123; cout &lt;&lt; b[w[i]] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 注意下标的变换，不要绕晕（ C. Vlad Building Beautiful Array 题意 给定一个序列 \(a\)，定义序列 \(b\) 中 \(b_i\) 为 \(a_i\) 和 \(a_i - a_j\) 中任选其一，其中 \(j \in [1, n]\) 可任意选择。 输出能否构造一个奇偶性相同的正整数序列 \(b\)。 思路 首先，既然要满足所有元素都是正整数，那么我们升序排序一下。 那么，对于 \(a_i - a_j\)，\(j \in [1, i - 1]\)。 考虑用 \(a_1\) 作为 \(b_1\)，那么如果 \(a_1\) 是奇数，我们一定可以将剩余不是奇数的 \(a_i\) 变为奇数。 如果 \(a_1\) 是偶数，那么其他元素都不可以是奇数，因为我们没办法改变 \(a_1\) 的奇偶性，而奇数减偶数还是奇数。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(all(a)); for(int i=1;i&lt;n;i++)&#123; if(a[i] % 2 != a[0] % 2 &amp;&amp; (a[i] - a[0]) % 2 != a[0] % 2)&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 搓题解的时候才发现下标居然打错了，还没被fst((( D. Flipper 题意 给定一个序列 \(a\)，定义操作为选定一个区间 \([l, r]\)，其中 \(1 \leq l \leq r \leq n\)，将整个区间翻转，并将剩余两侧的元素换个位置。 输出操作后最大字典序的序列。 思路 首先，不难发现的是，第一个元素在操作后一定不会在第一个位置，除非只有一个元素。 考虑到字典序的贪心性：如果某一位的两个元素能判定大小，后面的元素都不用考虑。 那么，我们就希望尽可能将最大的元素放在第一位。 由上分析，我们从第二个元素开始，找出最大的元素，并从这个元素开始，将之后的元素全都放到答案的开头。 如上，比对 \(2\ 3\ 1 \ 5\ 4\)，\(5\ 4\) 将会放在答案的开头。 其次，区间内一定有一个元素，那么最大的元素的前一个元素一定会在区间中，比如说上述例子的 \(1\) 一定包含在区间中。 接下来我们来考虑左端点的选择： 我们从最大的元素前面的第 \(2\) 个元素开始向前遍历，不难发现我们会按照这个倒序的顺序继续将元素放入答案中，而剩余的元素是按原顺序从序列的开头开始放入的。 因此，我们只需比较当前遍历到的元素是否大于序列中的第一个元素，如果小于，因为我们需要把大的元素放入答案，所以区间就不会覆盖这个元素，我们也就确定了所需的区间。 形象地说，如果剩余的序列是 \(4, 5, 1, 9, 8\)，因为 \(8 &gt; 4, 9 &gt; 4, 1 &lt; 4\)，所以我们选择 \(9, 8\) 作为区间翻转，\(4, 5, 1\) 按顺序放入，得到 \(8, 9, 4, 5, 1\)。 由上，我们会发现第二个样例过不去。 为何呢？因为区间右端点可以是 \(n\)，那么可以等效于将区间内的元素翻转并将前面剩余的拼到后面。 那么，如果最大值在最后一个元素，显然我们会出现两个选择： 区间右端点为 \(n\)； 区间右端点为 \(n - 1\) 也就是说，第二个样例对应的选择是第一个，此时就出现了 \(3 &lt; 4\) 的比较，从而得到了答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); int mx = 1; for(int i=0;i&lt;n;i++) &#123; cin >> a[i]; if(i > 0 &amp;&amp; a[i] > a[mx]) mx = i; &#125; for(int i=mx;i&lt;n;i++) cout &lt;&lt; a[i] &lt;&lt; ' '; int dist = mx - 1 - (mx == n - 1 ? 0 : 1); for(;dist>=0;dist--)&#123; if(a[dist] &lt; a[0]) break; &#125; dist = max(dist, 0ll); for(int i=mx-1;i>dist;i--) cout &lt;&lt; a[i] &lt;&lt; ' '; for(int i=0;i&lt;=dist;i++) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; WA on 1. E. Round Dance 题意 给定 \(n\) 个人，每个人的左右分别有一个邻居（可以是同一个邻居）。每个人只记得自己的一个邻居，并只能和自己的邻居一起跳舞。 令两个跳舞的人之间连一条边，那么如果出现了环，就视为一个 "Round Dance"。 输出 "Round Dance" 的最小和最大个数。 思路 我们将每个人记得的那个邻居之间连一个无向边，构成一个不完全联通的无向图，那么我们可以得到几个连通块。 对照题给条件，既然一个人只能有两个邻居，那么很明显，连通块要么是一整个环，要么是只含有 由两个元素组成的环 的基环树。 如果连通块为一整个环，那么显然这个环中每个人的邻居都是唯一确定的，肯定只能单独作为一个 "Round Dance"。 如果为一个基环树，那么我们一定可以找到一个只确定了一个邻居的人，并把多出的边和他连起来；我们也可以和其他的基环树相连，构成一条链。 因此，最小值就是整环的个数 \(+1\) 并与最大值取最小值，最大值就是连通块的个数。 为了方便遍历，在计算最小值的时候，不妨建一个有向图。 p.s. 这题可以用并查集完成。 时间复杂度：\(O(m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;set&lt;int>> e1(n + 1, set&lt;int>()), e2(n + 1, set&lt;int>()); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; e1[i].emplace(cur); e2[i].emplace(cur); e2[cur].emplace(i); &#125; int mn = 0, mx = 0; vector&lt;bool> st1(n + 1); auto dfs1 = [&amp;](auto self, int start, int x, int p, int step) -> bool&#123; bool res = false; for(auto t : e1[x])&#123; if(t == p) continue; if(st1[t])&#123; if(t == start &amp;&amp; step > 2) res = true; continue; &#125; st1[t] = true; if(self(self, start, t, x, step + 1)) res = true; &#125; return res; &#125;; for(int i=1;i&lt;=n;i++)&#123; if(st1[i]) continue; st1[i] = true; if(dfs1(dfs1, i, i, -1, 1)) mn ++; &#125; vector&lt;bool> st2(n + 1); auto dfs2 = [&amp;](auto self, int x, int p) -> void&#123; for(auto t : e2[x])&#123; if(t == p || st2[t]) continue; st2[t] = true; self(self, t, x); &#125; &#125;; for(int i=1;i&lt;=n;i++)&#123; if(st2[i]) continue; st2[i] = true; dfs2(dfs2, i, -1); mx ++; &#125; cout &lt;&lt; mn + (mn == mx ? 0 : 1) &lt;&lt; ' ' &lt;&lt; mx &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 好久没有出图论题了（ E. Ira and Flamenco 题意 给定一个多重集，以及一个整数 \(m\)，输出从多重集中取出 \(m\) 个不同的元素且任意两个元素的差的绝对值都小于 \(m\) 的方案数。 思路 首先，要满足差值的绝对值小于 \(m\)，我们就需要满足最大值和最小值的差小于 \(m\)。 因此，我们不妨遍历最左边的元素，并以这个元素确定当前能取的元素的范围，然后用组合数求解即可。 当然，这里需要取不同的元素，我们可以用下面的结论： 从一个含 \(n\) 个不同元素的多重集中取 \(m\) 个不同元素的组合数，可以看作从 \(n\) 个不同元素中取 \(m\) 个元素的组合数，再乘以每个元素出现的次数的乘积，即：\(\binom{n}{m} \times \prod_{i=1}^{n}a_i\) 。 对于范围的确定，我们既可以用滑动窗口，也可以用二分。 组合数需要 \(O(1)\) 计算，因而需要预处理。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; int fact[N], fact_inv[N]; int qp(int a, int b) &#123; int res = 1; while (b > 0) &#123; if (b &amp; 1) res = (res * a) % mod; a = (a * a) % mod; b >>= 1; &#125; return res; &#125; int inv(int n) &#123; return qp(n, mod - 2); &#125; int C(int n, int m)&#123; return (fact[n] * fact_inv[n - m] % mod) * fact_inv[m] % mod; &#125; void init()&#123; fact[0] = fact_inv[0] = 1; for(int i=1;i&lt;=2e5;i++)&#123; fact[i] = fact[i - 1] * i % mod; fact_inv[i] = inv(fact[i]); &#125; &#125; void solve()&#123; int n, m; cin >> n >> m; vector&lt;int> a(n + 1, inf); map&lt;int, int> cnt; for(int i=0;i&lt;n;i++) cin >> a[i], cnt[a[i]] ++; sort(all(a)); a.resize(n = unique(all(a)) - a.begin()); vector&lt;int> prod(n); prod[0] = cnt[a[0]]; for(int i=1;i&lt;n;i++) prod[i] = prod[i - 1] * cnt[a[i]] % mod; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int k = lower_bound(all(a), a[i] + m) - a.begin() - 1; if(k - i &lt; m - 1) continue; ans = (ans + cnt[a[i]] * C(k - i, m - 1) % mod * prod[k] % mod * inv(prod[i]) % mod) % mod; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 这个结论有点抽象 G. Ksyusha and Chinchilla 题意 给定一棵树，将其切割为若干个 三个元素组成的链（如下图），输出切割方案，如果无法切割输出 \(-1\)。 思路 首先，既然要让切割尽可能方便，我们肯定会去切割掉连接点尽可能少的边。 因此，我们不妨从叶节点开始向上遍历，找到含有三个元素的父节点，并砍掉父节点上面的边。 这个过程可以用树型 \(dp\) 实现。 具体来说，我们从任意一个顶点开始 \(dfs\)，在 \(dp\) 的过程中，传递需要从哪条边到达这个点。 那么，如果出现值为 \(3\) 的情况，我们就把传递过来的这条边砍掉，并把这个点的 \(dp\) 值改为 \(0\)。 因而，只要出现值大于 \(3\) 的情况，我们就割不了了。 当然，我们可以一开始预判一下点数是否是 \(3\) 的倍数，不然肯定有多出来的点。 时间复杂度：\(O(n + m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;vector&lt;pii>> e(n + 1); for(int i=1;i&lt;n;i++)&#123; int u, v; cin >> u >> v; e[u].pb(v, i), e[v].pb(u, i); &#125; if(n % 3 != 0)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; vector&lt;bool> st(n + 1); vector&lt;int > dp(n + 1); bool f = true; set&lt;int> ans; auto dfs = [&amp;](auto self, int x, int p, int r) -> void&#123; dp[x] = 1; for(auto [t, id] : e[x])&#123; if(t == p || st[t]) continue; st[t] = true; self(self, t, x, id); dp[x] += dp[t]; &#125; if(dp[x] > 3) f = false; else if(dp[x] == 3 &amp;&amp; r != -1)&#123; ans.emplace(r); dp[x] = 0; &#125; &#125;; st[1] = true; dfs(dfs, 1, -1, -1); if(!f)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto x : ans) cout &lt;&lt; x &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 这题怎么比上一题简单多了（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 福师大第20届校赛</title>
    <url>/blog/posts/2502331975/</url>
    <content><![CDATA[One contestant of team004. Rank 1. Solved 7/12. A. Tree Destruction 图论+组合数，待补充 B. Encore 计算几何，待补充 C. Konnakol 题意 无穷次重复斐波那契数列的前八项，构成一个序列。 给定整数 \(n, k\)，提取出前 \(n\) 个数，输出第 \(k\) 个数。 思路 首先，\(n\) 是没用的。 其次，取模即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; vector&lt;int> p = &#123;1, 1, 2, 3, 5, 8, 13, 21&#125;; int sb, x; cin >> sb >> x; cout &lt;&lt; p[(x - 1) % 8] &lt;&lt; "/8\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 骗人 \(\times 1\) D. Data Mining and Big Data 题意 给定一个只包含 \(0\) 或 \(1\) 的字符串，长度为 \(2^k, k \in [0, 2]\)，定义一次操作为：将当前的字符串中的所有二进制数取反，并拼接到原字符串的后面。 按照如上操作进行若干次后，可得一个 \(1024GB\) 的数据，输出数据中 \(0\) 的个数。 思路 显然，最后 \(0\) 和 \(1\) 的个数是相等的，那么我们直接输出长度的一半即可。 不用敲样例，答案就是 \(1 &lt;&lt; 32\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; string s; cin >> s; cout &lt;&lt; (1ll &lt;&lt; 32) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 不会真有人敲错吧（ E. Function 题意 初始状态下，令方程 \(f(x) = 0\)。 给定 \(q\) 个询问，每个询问会给定操作序号，以及操作所需的参数： 给定两个整数 \(a, b\)，将 \(f(x)\) 更新为 \(f(x) + |x - a| + b\)； 输出让 \(f(x)\) 的值最小的 \(x\)，以及 \(f(x)\) 的最小值。 对于询问，执行对应的操作。 思路 我们把 \(|x - a|\) 和 \(b\) 分成两部分考虑。 首先很明显，无论 \(x\) 是什么，右边的值都不会受到影响，因此我们可以在更新的时候顺便记录右边的值的总和。 其次，在更新了 \(n\) 次后，左边的值的总和为 \(|x - a_1| + |x - a_2| + \ldots + |x - a_n|\)。 不难发现，要让这个值最小，\(x\) 就是 \(a_1, a_2, \ldots, a_n\) 的中位数。 因此，本题最后归结到，如何动态维护中位数。 对于这个，考虑到码量，我们会优先选择对顶堆，而非线段树。 何为对顶堆？小根堆维护前 \(\frac{n}{2}\) 大的数，剩余的数由大根堆维护。 那么，我们只要保持大小根堆的大小的差值不大于 \(1\)，即可保证大根堆的队头就是中位数。 在维护大小根堆的同时，我们根据元素的位置维护左半部分的和即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 1e7 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int q; cin >> q; priority_queue&lt;int> g; priority_queue&lt;int, vector&lt;int>, greater&lt;>> l; int sum1 = 0, sum2 = 0; while(q --)&#123; int op; cin >> op; if(op == 1)&#123; int a, b; cin >> a >> b; sum2 += b; if(!l.empty() &amp;&amp; a > l.top())&#123; l.emplace(a), sum1 += a; &#125;else&#123; g.emplace(a), sum1 -= a; &#125; if(g.size() > l.size() + 1)&#123; l.emplace(g.top()), sum1 += g.top() * 2, g.pop(); &#125; if(l.size() > g.size())&#123; g.emplace(l.top()), sum1 -= l.top() * 2, l.pop(); &#125; &#125;else&#123; cout &lt;&lt; g.top() &lt;&lt; ' '; int ans = sum1 + sum2; if(g.size() > l.size()) ans += g.top(); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 妙捏 F. A * B Problem 题意 给定三个数 \(a, b, c\)，定义一次操作为：选择两个数，将某个数 \(+1\)，另一个数 \(-1\)。 输出最小的操作数，使得存在某两个数的乘积为第三个数。 思路 我们设最后得到的 \(a, b, c\) 满足 \(ab = c\)。 那么 \(a + b + ab = sum\)。 左右各加 \(1\)，化简得到 \((a + 1)(b + 1) = sum + 1\)。 也就是说，\(a + 1\) 是 \(sum + 1\) 的因子。 因此，如果这道题的数据量不大，那么解法就是线性筛+分解质因数+\(\mathtt{dfs}\)枚举因子。 wait，你可能会疑惑，为什么可以 \(\mathtt{dfs}\)。 事实上，\(1e18\) 的因子数量的数量级只有 \(1e5\) 左右，因此暴力是可行的。 好，看一下数据范围 \(1e18\)，寄。 这边需要用到 Pollard Rho 算法，用 \(O(n ^ {\frac{1}{4}})\) 的复杂度完成分解质因数。 因此，在得到因子后，我们将 \(a, b, c\) 进行排列，并与之前的 \(a, b, c\) 分别进行作差取绝对值后 求和除 \(2\)，最后取最小值即可。 时间复杂度：\(O(n ^ {\frac{1}{4}}p)\) ,p为因子个数 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() /* ************************************************* * Miller_Rabin 算法进行素数测试 * 速度快可以判断一个 &lt; 2^63 的数是不是素数 * **************************************************/ const int S = 8; //随机算法判定次数一般 8∼10 就够了 // 计算 ret = (a*b)%c a,b,c &lt; 2^63 int mult_mod(int a, int b, int c) &#123; a %= c; b %= c; int ret = 0; int tmp = a; while (b) &#123; if (b &amp; 1) &#123; ret += tmp; if (ret > c)ret -= c;//直接取模慢很多 &#125; tmp &lt;&lt;= 1; if (tmp > c)tmp -= c; b >>= 1; &#125; return ret; &#125; // 计算 ret = (a^n)%mod int pow_mod(int a, int n, int mod) &#123; int ret = 1; int temp = a % mod; while (n) &#123; if (n &amp; 1)ret = mult_mod(ret, temp, mod); temp = mult_mod(temp, temp, mod); n >>= 1; &#125; return ret; &#125; // 通过 a^(n−1)=1(mod n)来判断 n 是不是素数 // n − 1 = x ∗ 2 // 中间使用二次判断 // 是合数返回 true, 不一定是合数返回 false bool check(int a, int n, int x, int t) &#123; int ret = pow_mod(a, x, n); int last = ret; for (int i = 1; i &lt;= t; i++) &#123; ret = mult_mod(ret, ret, n); if (ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1)return true;//合数 last = ret; &#125; if (ret != 1)return true; else return false; &#125; //************************************************** // Miller_Rabin 算法 // 是素数返回 true,(可能是伪素数) // 不是素数返回 false //************************************************** bool Miller_Rabin(int n) &#123; if (n &lt; 2)return false; if (n == 2)return true; if ((n &amp; 1) == 0)return false;//偶数 int x = n - 1; int t = 0; while ((x &amp; 1) == 0) &#123; x >>= 1; t++; &#125; srand(time(NULL)); /* *************** */ for (int i = 0; i &lt; S; i++) &#123; int a = rand() % (n - 1) + 1; if (check(a, n, x, t)) return false; &#125; return true; &#125; //********************************************** // pollard_rho 算法进行质因素分解 //********************************************* int factor[1000005];//质因素分解结果（刚返回时时无序的） int tol;//质因素的个数，编号 0∼tol-1 int gcd(int a, int b) &#123; int t; while (b) &#123; t = a; a = b; b = t % b; &#125; if (a >= 0)return a; else return -a; &#125; //找出一个因子 int pollard_rho(int x, int c) &#123; int i = 1, k = 2; srand(time(NULL)); int x0 = rand() % (x - 1) + 1; int y = x0; while (1) &#123; i++; x0 = (mult_mod(x0, x0, x) + c) % x; int d = gcd(y - x0, x); if (d != 1 &amp;&amp; d != x)return d; if (y == x0)return x; if (i == k) &#123; y = x0; k += k; &#125; &#125; &#125; //对 n 进行素因子分解，存入 factor. k 设置为 107 左右即可 void findfac(int n, int k) &#123; if (n == 1)return; if (Miller_Rabin(n)) &#123; factor[tol++] = n; return; &#125; int p = n; int c = k; while (p >= n)p = pollard_rho(p, c--);//值变化，防止死循环 k findfac(p, k); findfac(n / p, k); &#125; //-------- ACM Template of kuangbin p. 30 ---------- const int inf = 0x3f3f3f3f3f3f3f3f; vector&lt;int> keys; map&lt;int, int> fact_map; set&lt;int> fact_set; int qp(int a, int b) &#123; int res = 1; while (b > 0) &#123; if (b &amp; 1) res *= a; a *= a; b >>= 1; &#125; return res; &#125; void factorize(int x)&#123; fact_map.clear(); keys.clear(); tol = 0; findfac(x, 107); for(int i=0;i&lt;tol;i++) &#123; if(fact_map[factor[i]] == 0) keys.pb(factor[i]); fact_map[factor[i]] ++; &#125; &#125; void dfs(int x, int step)&#123; if(step == fact_map.size())&#123; fact_set.emplace(x); return; &#125; for(int i=0;i&lt;=fact_map[keys[step]];i++)&#123; dfs(x * qp(keys[step], i), step + 1); &#125; &#125; void solve() &#123; int a, b, c; cin >> a >> b >> c; int sum = a + b + c; factorize(sum + 1); fact_set.clear(); dfs(1, 0); int ans = inf; for(auto e : fact_set) &#123; if(e == 1) continue; int aa = e - 1, bb = (sum + 1) / e - 1, cc = sum - aa - bb; ans = min(ans, (abs(aa - a) + abs(bb - b) + abs(cc - c)) / 2); ans = min(ans, (abs(aa - a) + abs(bb - c) + abs(cc - b)) / 2); ans = min(ans, (abs(aa - b) + abs(bb - a) + abs(cc - c)) / 2); ans = min(ans, (abs(aa - b) + abs(bb - c) + abs(cc - a)) / 2); ans = min(ans, (abs(aa - c) + abs(bb - a) + abs(cc - b)) / 2); ans = min(ans, (abs(aa - c) + abs(bb - b) + abs(cc - a)) / 2); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 但凡数据量小就很签（（ G. CET-4 赛时的样例出错，\(\mathtt{OJ}\) 上的重现赛的题面已修正 题意 \(n\) 选 \(r\) 问题中答对 \(x\) 道题的概率。 思路 首先，因为如果某道题选错，可能会影响后续的正确选项的选择，所以简单的组合数是不对的。 我们不妨考虑广义容斥的做法，或者说，这就是一道广义容斥的模板题。 考虑到我比较若，这边把官方题解搬过来了，并略微做了点修改。 我们设 \(β(x)\) 为有 \(x\) 个条件的满足的方案数。 则恰好有 \(x\) 个方案满足的方案数为 \(\displaystyle{f(x)=\sum_{i=x}^{n}(-1)^{i-x}β(x) {i\choose x}}\)。 对应到本题，求解步骤即为： \(β(x)\) 的意思是至少对 \(x\) 题，也就是先从 \(r\) 个空中选出 \(i\) 个是对的，然后对于剩下的 \(n-i\) 个选项，我们再选出 \(r-i\) 个填入剩下的空。 那么方案数为 \(\displaystyle{ {r \choose i} { {n-i} \choose {r-i} } (r-i)!}\) 。 代入公式，\(\displaystyle{f(x)=\sum_{i=x}^{r}{i \choose x}(-1)^{i-x}{r \choose i}{n-i\choose r-i }(r-i)!}\) 。 全部的方案数量为 \(\displaystyle{ {n \choose r} r! }\)，因此将 \(f(x)\) 和这个作除即可得到答案。 当然也可以用 dp 实现。 时间复杂度：看你怎么预处理 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e6 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; int fact[N], fact_inv[N]; int qp(int a, int b) &#123; int res = 1; while (b > 0) &#123; if (b &amp; 1) res = (res * a) % mod; a = (a * a) % mod; b >>= 1; &#125; return res; &#125; int inv(int x)&#123; return qp(x, mod - 2); &#125; void init()&#123; fact[0] = fact_inv[0] = 1; for(int i=1;i&lt;=2e6;i++)&#123; fact[i] = fact[i - 1] * i % mod; fact_inv[i] = inv(fact[i]); //当然这边还可以优化 &#125; &#125; int C(int n, int m)&#123; return fact[n] * fact_inv[n - m] % mod * fact_inv[m] % mod; &#125; void solve() &#123; int n, r, x; cin >> n >> r >> x; int p = 0; for(int i=x;i&lt;=r;i++)&#123; int now = C(i, x) * C(r, i) % mod * C(n - i, r - i) % mod * fact[r - i] % mod; if((i - x) % 2 == 0) p = (p + now) % mod; else p = (p + mod - now) % mod; &#125; cout &lt;&lt; p * inv(C(n, r) * fact[r] % mod) % mod &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 论我想了半天4选1对1题的概率为什么是1/6这件事 H. Group Theory 题意 定义一次操作为将整个序列向右移动一格，并将最后一个元素放到序列的开头。 给定一个字符序列，输出进行任意次操作后是否能将序列变为回文。 思路 数据量很小，所以是一道签到题。 与其模拟放置的过程，我们不妨直接在左边和右边分别复制一遍原序列，并遍历这个新序列，若出现了长度为 \(n\) 的回文序列，那么就是可行。 时间复杂度：\(O(\frac{3}{2}n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; if(n == 0)&#123; cout &lt;&lt; "YES\n"; return; &#125; vector&lt;string> a(3 * n + 3); for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; a[n + i] = a[n * 2 + i] = a[i]; &#125; bool f = false; for(int i=0;i&lt;2*n;i++)&#123; bool cur = true; for(int j=0;j&lt;n/2;j++)&#123; if(a[i + j] != a[i + (n - j - 1)])&#123; cur = false; break; &#125; &#125; if(cur)&#123; f = true; break; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 签到签到 I. Balls 题意 给定 \(n\) 个盒子，每个盒子里最多有 \(3\) 个球。 定义操作为等概率选一个盒子（包括空的），并取出一个球。 给定每个盒子内的球数，输出将所有球取出的数学期望。 思路 首先，我们来考虑 \(4\) 维 dp，其中 \(dp[i][j][k][p]\) 代表还剩 \(0, 1, 2, 3\) 个球分别对应的盒子个数 \(i, j, k, p\) 该状态的数学期望。 该状态可由下面的子状态转移得到： 从一个包含 \(3\) 个球的盒子中取出一个球，对应期望为 \(\frac{p}{n}dp[i][j][k + 1][p - 1]\)； 从一个包含 \(2\) 个球的盒子中取出一个球，对应期望为 \(\frac{k}{n}dp[i][j + 1][k - 1][p]\)； 从一个包含 \(1\) 个球的盒子中取出一个球，对应期望为 \(\frac{j}{n}dp[i + 1][j - 1][k][p]\)； 从一个包含 \(0\) 个球的盒子中取出一个球，对应期望为 \(\frac{i}{n}dp[i][j][k][p]\)； 加上自己可作为单独的一个状态的期望 \(1\)，最后整理得到式子： \(dp[i][j][k][p] = \frac{n}{j + k + p} + \frac{j}{j + k + p}dp[i + 1][j - 1][k][p] + \frac{k}{j + k + p}dp[i][j + 1][k - 1][p] + \frac{k}{j + k + p}dp[i][j][k + 1][p - 1]\) 有趣的是，\(i + j + k + p = n\)，因此我们可以拿掉一维。 最后得到状态转移方程： \(dp[i][j][k] = \frac{n}{i + j + k} + \frac{i}{i + j + k}dp[i - 1][j][k] + \frac{j}{i + j + k}dp[i + 1][j - 1][k] + \frac{k}{i + j + k}dp[i][j + 1][k - 1]\) 时间复杂度：\(O(n ^ 3)\) 对应AC代码 #include&lt;bits/stdc++.h> #define int long long using namespace std; double f[305][305][305]; int a[5], n; signed main() &#123; cin >> n; for(int i = 1, x; i &lt;= n; i++) cin >> x, a[x]++; for(int k = 0; k &lt;= n; k++) &#123; for(int j = 0; j &lt;= n; j++) &#123; for(int i = 0; i &lt;= n; i++) &#123; if(i || j || k) &#123; if(i) f[i][j][k] += f[i - 1][j][k] * i / (i + j + k); if(j) f[i][j][k] += f[i + 1][j - 1][k] * j / (i + j + k); if(k) f[i][j][k] += f[i][j + 1][k - 1] * k / (i + j + k); f[i][j][k] += 1.0 * n / (i + j + k); &#125; &#125; &#125; &#125; cout &lt;&lt; setprecision(10); cout &lt;&lt; fixed &lt;&lt; (f[a[1]][a[2]][a[3]]); return 0; &#125; 自己写的dp状态重复了（也就是以一种递归的方式正推），十分头大于是找了一篇洛谷的题解研究了一波（（ J. Wish You Can Have Fun Today 题意 输出 "Wish We Can Have Fun Today." 思路 如题，别打错。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; cout &lt;&lt; "Wish We Can Have Fun Today.\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 有人在比赛的刚开始把这题交错位置了，我不说是谁（ K. Chessboard City 题意 给定一个由 \(n\) 个横向街道和 \(m\) 个纵向街道组成的矩形城市，定义一条横向或纵向的街道只能有一个标记，只能标记在十字路口上。 给定标记总数 \(k\)，输出方案数。 思路 排列组合的签到题。 先从 \(n\) 个横向街道里选择 \(k\) 个街道，不考虑顺序，再从 \(m\) 个纵向街道里选择 \(k\) 个街道，考虑顺序，最后取模即可。 也就是说，答案是 \(C^k_nA^k_m\)。 注意需要线性求逆元哦，估计就卡死在这里了吧。 时间复杂度：看你怎么预处理 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 1e7 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; int fact[N], inv[N], fact_inv[N]; int qp(int a, int b) &#123; int res = 1; while (b > 0) &#123; if (b &amp; 1) res = (res * a) % mod; a = (a * a) % mod; b >>= 1; &#125; return res; &#125; void init()&#123; fact[0] = inv[0] = fact_inv[0] = fact[1] = inv[1] = fact_inv[1] = 1; for(int i=2;i&lt;=1e7;i++) &#123; fact[i] = fact[i - 1] * i % mod; inv[i] = inv[mod % i] % mod * (mod - mod / i) % mod; fact_inv[i] = fact_inv[i - 1] * inv[i] % mod; &#125; &#125; int C(int n, int m)&#123; return fact[n] * fact_inv[n - m] % mod * fact_inv[m] % mod; &#125; int A(int n, int m)&#123; return fact[n] * fact_inv[n - m] % mod; &#125; void solve() &#123; int n, m, k; cin >> n >> m >> k; cout &lt;&lt; C(n, k) * A(m, k) % mod &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 签到签到 L. Game 题意 给定 \(n\) 个商店，每个商店将会在 \(0.5, 1.5, 2.5, \ldots\) 时刻售出一份库存游戏。 给定家到每个商店需要的时间，以及每个商店的库存，输出买到游戏的最短时刻，以及对应的商店的编号（有多个满足条件输出全部）。 思路 首先，如果到达时间大于库存量，那么到的时候就卖光了。 其次，我们直接暴力枚举找出最小值以及对应的商店即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 1e7 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int mn = inf; set&lt;int> ans; for(int i=0;i&lt;n;i++)&#123; int a, b; cin >> a >> b; if(a > b) continue; if(a &lt; mn)&#123; mn = a, ans.clear(), ans.emplace(i + 1); &#125;else if(a == mn) ans.emplace(i + 1); &#125; if(mn == inf)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; cout &lt;&lt; mn &lt;&lt; '\n'; for(auto e: ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 居然没看到反面有题哈哈哈哈（x]]></content>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>LitCTF - Prime</title>
    <url>/blog/posts/1159249413/</url>
    <content><![CDATA[Prime 题意 给定一个数 \(a\)，按照算术基本定理分解后给出指数序列，输出最小的 \(n\)，满足 \(n! \mod a = 0\)。 思路 首先，指数序列的长度很小，不妨直接打表（不打表的话无脑线性筛筛一下即可）。 其次，既然需要被 \(p\) 整除，那么阶乘中就需要有对应数量的因子。 举个例子，如果 \(p\) 的质因子 \(7\) 的指数为 \(4\)，那么阶乘中就最好有 \(1 \times 7, 2 \times 7, 3 \times 7, 4 \times 7\)，也就是说，我们期望 \(n\) 至少为 \(28\)。 想到这里，数据量比较特殊的时候，底数和指数乘积的最大值就是答案。 那么，如果指数大于等于底数呢？就像上述例子，出现 \(7 \times 7\) 的时候，我们需要的 \(7\) 的个数就小于等于指数的大小了，因此我们不能直接取底数和指数的乘积。 这边有两个思路： 数位 \(dp\) 线性预处理； 设底数为 \(x\)，指数为 \(p\)，对于所需的最大 \(x \times p\)，二分 \(p\)。 本题数据量特别友好，我们直接二分就行。 我们在 \([1, p]\) 内进行二分。对于 \(mid\)，我们计算 \(i \in [1, mid], i \times p\) 中 \(p\) 因子的总数： 总数是什么呢？观察一下可以发现，它就是以 \(mid\) 为首项，\(\frac{1}{x}\) 为公比的等比数列的前 \(n\) 项和。 因而我们可以解得答案。 值得一提的是，上述计算方式和进制有关联，这为数位 \(dp\) 提供了思路。 时间复杂度：\(O(n \log m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; vector&lt;int> pri = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541&#125;; void solve()&#123; int m; cin >> m; int ans = 1; auto check = [&amp;](int x, int p, int mid) -> bool &#123; int ans = 0; for (int i = 1; i &lt;= mid; i *= x) ans += (mid / i); return ans >= p; &#125;; for(int t=0;t&lt;m;t++) &#123; int x = pri[t], p; cin >> p; int l = 1, r = p, mid; while(l &lt; r)&#123; mid = (l + r) >> 1; if(check(x, p, mid)) r = mid; else l = mid + 1; &#125; ans = max(ans, x * r); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 更强的数据可以看这里：#530. 「LibreOJ β Round #5」最小倍数 - 题目 - LibreOJ (loj.ac)]]></content>
      <categories>
        <category>类算法竞赛题解</category>
      </categories>
      <tags>
        <tag>LitCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 818 Div 2</title>
    <url>/blog/posts/724238676/</url>
    <content><![CDATA[Practice. A. Madoka and Strange Thoughts 题意 给定整数 \(n\)，输出二元组 \((a, b)\) 的个数，满足 \(\frac{\operatorname{lcm}(a, b)}{\operatorname{gcd}(a, b)} \leq 3\)。 思路 我们不妨打个表： n cnt 1 1 2 3 3 3 4 3 5 1 6 5 7 1 8 3 9 3 10 3 11 1 12 5 13 1 ... ... 不难发现出现了循环。 更具体地说，令 \(sum = \{0, 1, 4, 7, 10, 11\}\)，那么答案就是 \(16(\frac{n}{6}) + sum[n \% 6]\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> md = &#123;0, 1, 4, 7, 10, 11&#125;; cout &lt;&lt; 16 * (n / 6) + md[n % 6] &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 狠狠地打表 B. Madoka and Underground Competitions 题意 给定一个由 "." 和 "X" 组成的矩阵的大小 \(n \times n\)，矩阵内横向和竖向每 \(k\) 个位置内至少有一个 \(X\)，以及给定的一个坐标 \((r, c)\) 一定为 \(X\)。 输出一个方案，使 \(X\) 的个数最少。 思路 既然要最少，我们直接空 \(k - 1\) 个放一个 \(X\) 即可。 那么我们直接从给定坐标开始一行一行放即可。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, k, r, c; cin >> n >> k >> r >> c; vector&lt;vector&lt;bool>> ans(n + 1, vector&lt;bool>(n + 1)); for(int x = r, y = c; y >= 1; y --, x ++)&#123; for(int p = x; p >= 1; p -= k)&#123; if(p > n) continue; ans[p][y] = true; &#125; for(int p = x; p &lt;= n; p += k)&#123; if(p &lt; 0) continue; ans[p][y] = true; &#125; &#125; for(int x = r, y = c; y &lt;= n; y ++, x --)&#123; for(int p = x; p >= 1; p -= k)&#123; if(p > n) continue; ans[p][y] = true; &#125; for(int p = x; p &lt;= n; p += k)&#123; if(p &lt; 0) continue; ans[p][y] = true; &#125; &#125; for(int i = 1; i &lt;= n; i ++)&#123; for(int j = 1; j &lt;= n; j ++) cout &lt;&lt; (ans[i][j] ? 'X' : '.'); cout &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 喜报，RTE! C. Madoka and Formal Statement 题意 给定两个序列 \(a, b\)，定义一次操作为选定一个数 \(a_i\)，满足 \(a_i \leq a_{(i \% n) + 1}\)，并将 \(a_i\) 加上 \(1\)。 输出是否可以进行若干次操作，将 \(a\) 变为 \(b\)。 思路 观察可得下面两个条件： \(b_i \geq a_i\)； 如果 \(b_i\) 变大了，那么它的后一个数不能比这个数 \(-1\) 小。 满足条件即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n + 1), b(n + 1); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;n;i++) cin >> b[i]; a[n] = a[0], b[n] = b[0]; for(int i=0;i&lt;n;i++) &#123; if(a[i] > b[i] || (b[i] - b[i + 1] > 1 &amp;&amp; a[i] != b[i]))&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜即可乱猜即可]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 819 Div 1 plus 2</title>
    <url>/blog/posts/2622508116/</url>
    <content><![CDATA[Practice. A. Mainak and Array 题意 给定一个序列 \(a\)，定义操作为选定一个连续字符列，并将其旋转任意次，输出恰好进行一次操作后 \(a_n - a_1\) 的最大值。 思路 首先，如果选定整个序列作为旋转序列，那么显然对于两个相邻的数，前者减后者就可以作为执行操作后的 \(a_n - a_1\)，取最大值即可。 其次，我们可以固定头或者尾，如果固定头，我们就可以旋转除头以外的其他元素，将最大值旋转到 \(a_n\)，反之同理，最后再取最大值即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); int mn = inf, mx = -inf; for(int i=0;i&lt;n;i++) &#123; cin >> a[i]; mn = min(mn, a[i]); mx = max(mx, a[i]); &#125; int ans = max(a[n - 1] - mn, mx - a[0]); for(int i=0;i&lt;n;i++) &#123; int pre = (i + n - 1) % n; ans = max(ans, a[pre] - a[i]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 我测，怎么错这么多 B. Mainak and Interesting Sequence 题意 定义若一个序列满足对于任意 \(a_i\)，严格小于 \(a_i\) 的所有数的异或值都为 \(0\)，那么这个序列是有趣的。 现在，给定序列的总和以及序列的长度，构造一个序列满足序列有趣。 思路 首先，两个相同的数异或以后为 \(0\)，那么我们不妨构造一个序列，满足包含偶数个较小的数和若干个较大的数。 或者更简单地，我们直接塞上偶数个 \(1\) 即可。 那么，我们对长度进行分讨，如果长度为奇数，那么我们直接塞上 \(n - 1\) 个 \(1\)，最后放上 \(m - n + 1\) 即可； 如果长度为偶数，那么我们在前面塞上 \(n - 2\) 个 \(1\)，最后放上两个 \(\frac{m - n + 2}{2}\) 即可。 当然，后者需要我们确保总和也是偶数。 有趣的是，可以证明，当长度为奇数，总和为偶数的时候是无解的。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, m; cin >> n >> m; if(n > m || (n % 2 == 0 &amp;&amp; m % 2 == 1))&#123; cout &lt;&lt; "No\n"; return; &#125; cout &lt;&lt; "Yes\n"; if(n % 2 == 1)&#123; for(int i=0;i&lt;n-1;i++) cout &lt;&lt; 1 &lt;&lt; ' '; cout &lt;&lt; m - n + 1 &lt;&lt; '\n'; &#125;else&#123; for(int i=0;i&lt;n-2;i++) cout &lt;&lt; 1 &lt;&lt; ' '; cout &lt;&lt; (m - n + 2) / 2 &lt;&lt; ' ' &lt;&lt; (m - n + 2) / 2 &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜即可（但我怎么猜错那么多次啊啊啊啊 C. Jatayu's Balanced Bracket Sequence 题意 题目绕死了，直接给出简化版： 给定一个满足语法规则的括号字符串，输出不同的括号的个数。 此处不同代表其开始符 "\((\)" 前面没有 "\()\)"。 思路 如题，遍历即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; string s; cin >> n >> s; int now = 0; for(int i=0;i&lt;s.size();i++)&#123; if(s[i] == '(' &amp;&amp; (i == 0 || s[i - 1] == '(')) now ++; &#125; cout &lt;&lt; now &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 你就说你有没有在考阅读理解罢（半恼]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 135</title>
    <url>/blog/posts/1644830366/</url>
    <content><![CDATA[Practice. A. Colored Balls: Revisited 题意 给定 \(n\) 个染有颜色的球，定义操作为选定两个不同颜色的球并将两个球拿走。 在满足总和为奇数的情况下，输出只剩下一种颜色的球后，球的颜色编号。 思路 显然，我们将数量小的和数量次小的球拿走，最后肯定会剩下数量最多的那个颜色。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;pii> cnt(n); for(int i=0;i&lt;n;i++) &#123; cin >> cnt[i].fs; cnt[i].sc = i + 1; &#125; sort(all(cnt)); cout &lt;&lt; cnt[n - 1].sc &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 很蠢 B. Best Permutation 题意 对于一个排列 \(p\)，定义它的值的计算方式如下： 令 \(x = 0\)； 枚举 \(p_i\)，如果 \(x &lt; p_i\)，那么 \(x = x + p_1\)，否则 \(x = 0\)。 最后，\(x\) 即为 \(p\) 的值 现在，给定排列的长度，构造一个值最大的排列并输出。 思路 显然，我们不难发现，最后的 \(x\) 一定为 \(n + n - 1\)，我们找不出其他排列满足这个条件。 那么，我们来考虑如何构造： 我们将 \(n - 1, n\) 放在序列的最后，那么如果剩余的数的个数为偶数，我们直接按顺序放入 \(i, i - 1\) 即可，这样即可每隔两个数清空 \(x\)。 如果个数为奇数，那么我们不妨塞上 \(1, 2, 3\)，然后继续放即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; if(n == 4) cout &lt;&lt; "2 1 3 4\n"; else&#123; if(n % 2 == 1) cout &lt;&lt; "1 2 3 "; for(int i=n-2;i>=(n % 2 == 1 ? 4 : 1);i--) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 主打一个差点看错题 C. Digital Logarithm 题意 定义 \(f(x)\) 等于 十进制下 \(x\) 所有位数之和。 给定两个序列 \(a, b\)，定义一次操作为选定任意 \(a_i\) 并将其赋值为 \(f(a_i)\)，或选定任意 \(b_i\) 并将其赋值为 \(f(b_i)\)。 输出最小的操作数，使两个序列升序排序后相等。 思路 我们可以用优先队列实现。 我们先将所有 \(a_i, b_i\) 分别放入两个优先队列中，然后枚举 \(a, b\) 中的头元素。 如果头元素相等，那么把这对数取出，否则，我们对较大的头元素执行一次操作，然后继续遍历，最后一定可以得到答案。 不难证明这样操作得到的答案就是最小的。 时间复杂度：小于\(O(3n \log (3n))\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; priority_queue&lt;int> a, b; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; a.emplace(cur); &#125; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; b.emplace(cur); &#125; int ans = 0; while(!a.empty())&#123; if(a.top() == b.top())&#123; a.pop(); b.pop(); continue; &#125; ans ++; if(a.top() > b.top())&#123; a.emplace(to_string(a.top()).size()); a.pop(); &#125;else&#123; b.emplace(to_string(b.top()).size()); b.pop(); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 我写的更模拟（ D. Letter Picking 题意 给定一个字符串，以及两个玩家 \(Alice, Bob\)。 \(Alice\) 先手。每次操作中，玩家可以选择字符串的第一个或最后一个字符，将其取出并拼接到自己的字符串的前面。 两个人足够聪明，输出最后字典序最小的玩家。 思路 我们不妨换个角度考虑这题： 如果我们从最后的状态向前推，那么就等价于我们将拿出的字符拼接到两个选手的字符串后面。 这就好办了，只要前面没有出现平局，那么后面无论怎么操作都无法改变胜负。 因而，我们考虑从小区间递推到大区间的思路，也就是区间 \(dp\)。 我们定义 \(dp[i][j]\) 为 \([i, j]\) 区间内的胜负情况，\(-1\) 为 \(Alice\) 赢，\(0\) 为平局，\(1\) 为 \(Bob\) 赢，那么 \(dp[0][n]\) 就是答案。 那么，我们只需分讨递推即可。 对于 \(A\) 的不同选择，我们分别取最小值。 对于 \(B\) 的不同选择，我们分别取最大值。 然后，如果前一个状态是平局，我们就判断当前的胜负，否则我们就从上一个状态递推得到答案。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; int calc(char a, char b)&#123; return a == b ? 0 : (a > b ? 1 : -1); &#125; void solve()&#123; string s; cin >> s; int n = s.size(); vector&lt;vector&lt;int>> dp(n + 1, vector&lt;int>(n + 1)); for(int len=2;len&lt;=n;len+=2)&#123; for(int l=0;l+len&lt;=n;l++)&#123; int r = l + len; dp[l][r] = 1; //Alice choose the left int now = -1; if(dp[l + 1][r - 1] != 0) now = max(now, dp[l + 1][r - 1]); else now = max(now, calc(s[l], s[r - 1])); if(dp[l + 2][r] != 0) now = max(now, dp[l + 2][r]); else now = max(now, calc(s[l], s[l + 1])); dp[l][r] = min(dp[l][r], now); //Alice choose the right now = -1; if(dp[l + 1][r - 1] != 0) now = max(now, dp[l + 1][r - 1]); else now = max(now, calc(s[r - 1], s[l])); if(dp[l][r - 2] != 0) now = max(now, dp[l][r - 2]); else now = max(now, calc(s[r - 1], s[r - 2])); dp[l][r] = min(dp[l][r], now); &#125; &#125; cout &lt;&lt; (dp[0][n] == 0 ? "Draw\n" : (dp[0][n] == 1 ? "Bob\n" : "Alice\n")); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 还真没想到倒着搞，该加训了（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 873 Div 2</title>
    <url>/blog/posts/4014169129/</url>
    <content><![CDATA[Contestant'. Rank 1390. Rating +9(+109 -100). A. Divisible Array 题意 给定整数 \(n\)，构造一个长度为 \(n\) 的数组 \(a\)，满足 \(a_i \mod i = 0\)，且总和 \(sum\) 满足 \(sum \mod n = 0\)。 思路 构造一个 \(2, 4, \ldots, 2n\) 的数组，\(sum = \frac{(2 + 2n)n}{2} = n(n + 1)\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10; void solve()&#123; int n; cin >> n; for(int i=1;i&lt;=n;i++) cout &lt;&lt; i * 2 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 倒也有其他思路，这个最好写 B. Permutation Swap 题意 给定一个未排序的排列，输出最大的 \(k\)，满足按照 "\(a_i\) 和 \(a_{i + k}\)" 之间可交换的方式进行排序后，可将排列升序。 思路 如果一个数 \(x\) 位于 \(y\) 位置，他想要到 \(x\) 位置，那么 \(abs(y - x) \mod k = 0\)。 那么，如果所有数都要满足这个条件，我们只需求 \(gcd\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10; void solve()&#123; int n; cin >> n; int ans = -1; for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; cur = abs(cur - i); if(cur == 0) continue; if(ans == -1) ans = cur; else ans = gcd(ans, cur); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 瞎猜就完事了 C. Counting Orders 题意 给定两个长度相等的序列 \(a, b\)，其中 \(a\) 中无重复元素，输出满足所有 \(a_i\) 均大于 \(b_i\) 的 \(a\) 的所有排列的个数。 思路 我们将 \(a, b\) 升序排序，那么，对于每一个 \(a_i\)，我们找出 \(b\) 中满足 \(a_i &gt; b_i\) 的个数 \(cnt\)，这个个数就是 \(a_i\) 能放的位置。 因而，答案就是 \(cnt_1 \cdot(cnt_2 - 1) \cdot(cnt_3 - 2) \cdots (cnt_n - (n - 1))\) （考虑前面几个数已经放了，而且前几个数能放的区间一定在当前能放的区间里面）。 找位置可以线性也可以二分。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7; void solve()&#123; int n; cin >> n; vector&lt;int> a(n), b(n); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;n;i++) cin >> b[i]; sort(all(a)), sort(all(b)); int ans = 0, cnt = 0; for(int i=n-1;i>=0;i--)&#123; int pos = n - (upper_bound(all(a), b[i]) - a.begin()); if(pos &lt;= cnt)&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; if(ans == 0) ans = pos - cnt; else ans = (ans * (pos - cnt)) % mod; cnt ++; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜即可 D1. Range Sorting (Easy Version) 题意 给定一个序列 \(p\)，定义操作为选定一个区间 \([l, r]\)，并将里面的数排序，代价为 \(r - l\)。 输出对于序列的 所有连续子序列，任意次操作后，使其升序所需的最小代价的总和。 思路 首先，我们固定子序列的头，然后依次枚举尾。 不难发现，如果一段区间不需要参与排序，那么他一定是单调的，并且，除去这段区间后，没有比区间内的数小的数。 当然，这个区间内也不能包含比剩余数小的数。 我们维护一个单调栈，在弹出元素的时候，将元素和当前元素取最大值，最后放入栈中的是这个最大值。 这样即可满足上述的所有条件（比较抽象）。 取最大值是为了满足最后一个条件，而单调栈的维护满足了剩下的条件。 对于一段枚举的区间 \([i, j]\)，最小代价就是 \(j - i - size\)，其中 \(size\) 是单调栈的大小。 时间复杂度：\(O(n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; int ans = 0; for(int i=0;i&lt;n;i++)&#123; stack&lt;int> st; for(int j=i;j&lt;n;j++)&#123; int mx = a[j]; while(!st.empty() &amp;&amp; a[j] &lt; st.top())&#123; mx = max(mx, st.top()), st.pop(); &#125; st.emplace(mx); ans += j - i + 1 - st.size(); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 太妙了！]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 148</title>
    <url>/blog/posts/1408955620/</url>
    <content><![CDATA[Contestant'. Rank 1580. Rating +23(+173 -150). A. New Palindrome 题意 给定一个回文串，输出是否可以将其重新排序，变成另一个回文串。 思路 只要回文串中有两种不同的字符，且这两个字符出现次数都大于 \(1\)，那么就可以。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; string s; cin >> s; int cnt = 0; for(int i=0;i&lt;s.size();i++) if(s[i] != s[0]) cnt ++; cout &lt;&lt; (cnt >= 2 ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 什么手速题 B. Maximum Sum 题意 给定一个无重复元素的序列，定义操作为下列操作任选其一： 删除序列中最小的 两 个数； 删除序列中最大的 一 个数 输出一次操作后序列的和的最大值。 思路 枚举所有删除后的序列的和即可，至于求和，可以用前缀和。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, m; cin >> n >> m; vector&lt;int> a(n); vector&lt;int> sum(n + 1); for(int i=0;i&lt;n;i++) &#123; cin >> a[i]; &#125; sort(all(a)); for(int i=0;i&lt;n;i++) sum[i + 1] = sum[i] + a[i]; int ans = 0; for(int l=0;l&lt;=m;l++)&#123; int r = m - l; ans = max(ans, sum[n - r] - sum[2 * l]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 为什么我想着用双指针啊哈哈哈，为什么有人和我想的一样然后觉得样例错了还去问啊哈哈哈 C. Contrast Value 题意 对于一个序列 \(a\)，定义其 "对比度" 为 \(|a_1-a_2|+|a_2-a_3|+\cdots+|a_{n-1}-a_n|\)。 找出一个长度最小的 \(a\) 的子序列，使其和 \(a\) 的对比度一致，输出长度。 思路 显然，对于一段单调的区间，只有区间的头和尾对 "对比度" 有贡献，因此中间的数直接删掉即可。 或者换句话说，拐点的个数就是答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int pre; cin >> pre; int now = -1, cnt = 0; for(int i=2;i&lt;=n;i++)&#123; int cur; cin >> cur; if(cur == pre) continue; if(cur > pre &amp;&amp; now == 0)&#123; cnt ++; now = 1; &#125;else if(cur &lt; pre &amp;&amp; now == 1)&#123; cnt ++; now = 0; &#125; if(now == -1)&#123; cnt ++; now = (cur > pre ? 1 : 0); &#125; pre = cur; &#125; cout &lt;&lt; cnt + 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 怎么三道水题之后都是坐牢题啊！ImbalancedForces（迫真 D1. Red-Blue Operations (Easy Version) 题意 给定 \(n\) 个格子，给定每个格子内的数字，格子一开始都是红色的。 对于 \(k\) 次操作，定义第 \(i\) 次操作如下： 选定一个格子 按格子的颜色进行不同的操作： 如果格子是红色的，那么将格子内的元素 \(+i\)，并将该格子变为蓝色； 如果格子是蓝色的，那么将格子内的元素 \(-i\)，并将该格子变为红色 现在，对于 \(q\) 个独立询问，每个询问给定整数 \(k\)，输出恰好进行 \(k\) 次操作后，所有格子内元素的最小值 的最大值。 思路 简化问题 - 1 首先，如果 \(k\leq n\)，那么我们只需依次对没操作过的格子进行操作即可。 那么，很显然，我们对前 \(k\) 小的格子进行操作即可，且我们自然希望最小的能加上最大的数。 更具体地说，我们将格子对应的序列 \(a\) 升序排序，并将 \(k, k-1,\ldots,1\) 按顺序加到 \(a_i\) 中，最后遍历找出序列中的最小值即可。 简化问题 - 2 其次，我们来考虑 \(k &gt; n\) 的时候，多余操作的如何处理。 对于一个红色的格子，我们可以对其进行两次操作，使其 \(+i\ -(i+1) = -1\)。 那么，我们不难发现，既然这样能让两次操作后对序列的影响最小，我们就可以把 "\(-1\)" 应用到当前最大的数上。 也就是说，我们可以先循环执行 \(-1\) 的操作，直到刚好剩余 \(n\) 个操作，最后按照 \(k \leq n\) 的方法做即可。 当然，上述思路只对 \(k - n\) 是偶数的情况有效，若它为奇数，那么我们有两个选择： 多执行一次减操作 少执行一次加操作 显然，后者能产生更大的最小值。 因此，总结为：先循环执行 \(-1\) 的操作，直到刚好剩余 \(n - (k - n)\mod 2\) 个操作，最后按照 \(k \leq n\) 的方法做即可。 优化复杂度 - 1 如果 \(k\) 不大，那么我们直接用 \(\mathtt{multiset}\) 模拟即可。 但这里的 \(k\) 是 \(1e9\) 级别的，这就迫使我们去找一个 \(O(1)\) 或 \(O(logn)\) 的解法。 后者可以通过二分实现，这边不做解释。 我们不妨模拟一下 \(-1\) 操作的过程：我们找出序列的最大值，拿掉这个数，并将其 \(-1\)，然后将这个新的数塞到序列中并排序序列。 那么，不难发现，除非这个最大值等于最小值，否则无论怎么减，操作后的数一定大于等于原来的最小值。 因此，想要让最小值减小，首先我们需要将整个序列全都减到和最小值相等为止。 这样，我们再依次将每个数 \(-1\)，\(n\) 次 \(-1\) 操作后，最小值就 \(-1\) 了。 总结 考虑到 \(-1\) 操作和 按顺序加的操作 是相互独立的，我们可以先执行 按顺序加的操作。 那么，对于每次询问，我们只需先遍历序列中的所有数，将 \(a_i\) 加上 \(k - i + 1\)（如果 \(k - n\) 是奇数，那么最后一个数不加），统计出总和以及最小值。那么按照优化的思路即可 \(O(1)\) 得到答案。 以上，即可通过 \(D1\)。 时间复杂度：\(O(nq)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, q; cin >> n >> q; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(all(a)); while(q --)&#123; int k; cin >> k; int left = k - n; int mn = inf, sum = 0; for(int i=0;i&lt;n;i++) &#123; int now = (i == n - 1 &amp;&amp; left % 2 == 1) ? a[i] : a[i] + max(0ll, (k - i)); mn = min(mn, now); sum += now; &#125; if(left &lt;= 0)&#123; cout &lt;&lt; mn &lt;&lt; ' '; continue; &#125; left += left % 2; left >>= 1; cout &lt;&lt; min(mn, (sum - left) / n) &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 令人感慨，没看到 \(k\) 的范围，硬模拟 \(t\) 咯！ D2. Red-Blue Operations (Hard Version) 题意 同 \(D1\)，区别是 \(n, q\) 的数据范围更大了。 思路 前面的思路和 \(D1\) 一致。 优化复杂度 - 2 观察 \(D1\) 的代码，我们不难发现，只有统计总和以及最小值的步骤是 \(O(n)\) 的，因而我们考虑优化这个。 我们不妨构造一个 \(pre\) 数组，代表处理前 \(k\) 个数后，整个序列 的最小值。接下来我们来看看如何构造： 首先，对于 \(a_i\)，如果我们处理前 \(i\) 个数，那么，在处理之后，\(a_i\) 会 \(+1\)。 其次，对于上一次处理后的序列，本次处理等价于将前 \(i\) 个数都 \(+1\)。 那么，如果我们不考虑前 \(i\) 个数之外的其他数，前 \(i\) 个数的最小值具有递推性：\(x_i = \min(x_{i - 1} + 1, a_i + 1)\)。 考虑其他数，因为我们排过序，所以 \(a_{i + 1}\) 就是这些数中的最小值。 因此，\(pre_i = \min(x_i, a_{i + 1})\)。 \(ok\)，那么如果 \(k \leq n\)，我们就可以直接输出答案了。 如果 \(k &gt; n\) 呢？ 首先，我们不妨在递推的时候顺便统计一下序列 \(a\) 的总和 \(sum\)，那么最后的 \(sum&#39;\) 就是 \(sum\) 加上 \(k, k - 1,\ldots, k - n + 1\) 的和。 显然，我们可以用等差数列求和公式直接计算。 之前，我们预处理得到的 \(pre_n\) 就是原序列依次加上 \(n, n-1, \ldots,1\) 中的最小值，而现在我们要加上的是 \(k, k - 1,\ldots, k - n + 1\)，显然对于每个元素，加上的数的差值都是 \(n - k\)，因此现在的最小值 \(mn = pre_n + (n - k)\)。 还没有结束，如果 \(k - n\) 为奇数，那么 \(sum&#39;\) 要减去 \((n - k + 1)\)。并且，因为最大数 \(a_n\) 没有加上 \((n - k + 1)\)，所以最后 \(mn\) 还要和 \(a_n\) 取个最小值。 如上，即可线性得到答案。 时间复杂度：\(O(n + q)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, q; cin >> n >> q; vector&lt;int> a(n + 1, inf); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(all(a)); vector&lt;int> pre(n + 1); //处理前k个后序列的最小值 int pre_mn = inf, sum = 0; //前k-1个数的最小值（+1后有可能成为前k个数的最小值，需递推特判 for(int i=0;i&lt;n;i++)&#123; pre_mn = min(pre_mn + 1, a[i] + 1); pre[i + 1] = min(pre_mn, a[i + 1]); sum += a[i]; &#125; while(q --)&#123; int k; cin >> k; int left = k - n; if(left &lt;= 0)&#123; cout &lt;&lt; pre[k] &lt;&lt; ' '; continue; &#125; //从+k到+(k-n+1) int now_sum = sum + (k + left + 1) * n / 2; int mn = pre[n] + left; //+n到+1 -> +k到+(k-n+1) if(left % 2 == 1)&#123; now_sum -= (left + 1); mn = min(mn, a[n - 1]); &#125; left += left % 2; left >>= 1; cout &lt;&lt; min(mn, (now_sum - left) / n) &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 有趣的题捏]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 872 Div 2</title>
    <url>/blog/posts/1228167069/</url>
    <content><![CDATA[Contestant'. Rank 1357. Rating +14 (+264 -250). A. LuoTianyi and the Palindrome String 题意 给定一个字符串，输出最长的非回文子串的长度。 思路 很显然，如果整个字符串是回文串，那么我们拿掉一个字符即可，长度为 \(n - 1\)； 如果不是，那么整个字符串就是非回文串，长度为 \(n\)。 当然，如果整个字符串都是由一个字母组成的，那么无法将其变为非回文，无解输出 \(-1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; string s; cin >> s; bool f = false; int n = s.size(); for(int i=1;i&lt;n;i++)&#123; if(s[0] != s[i]) f = true; &#125; if(!f)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; for(int i=0;i&lt;n/2;i++)&#123; if(s[i] != s[n - i - 1]) f = false; &#125; cout &lt;&lt; (f ? n - 1 : n) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 很签到，虽然要绕一下 B. LuoTianyi and the Table 题意 给定一个 \(n \times m\) 的矩阵，以及 \(n \times m\) 个元素组成的序列。将序列中所有元素填入矩阵中，满足下面的式子最大，并输出这个最大值： \(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}\left(\max\limits_{1 \le x \le i, 1 \le y \le j}a_{x,y}-\min\limits_{1 \le x \le i, 1 \le y \le j}a_{x,y}\right)\) 思路 思维题。 如果要让最大值减最小值的值最大，那么我们一定会用最大的值减去最小的值。 对于上述式子，我们不难发现，只要满足下面的两种情况，即为最大值： 左上角为最大值，其相邻两个元素为最小值和次小值； 左上角为最小值，其相邻两个元素为最大值和次大值 我们取两者的最大值即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, m; cin >> n >> m; vector&lt;int> a(n * m); for(int i=0;i&lt;n*m;i++) cin >> a[i]; sort(all(a)); if(n > m) swap(n, m); int ans1 = (n * (m - 1)) * (a[n * m - 1] - a[0]) + (n - 1) * (a[n * m - 1] - a[1]); int ans2 = (n * (m - 1)) * (a[n * m - 1] - a[0]) + (n - 1) * (a[n * m - 2] - a[0]); cout &lt;&lt; max(ans1, ans2) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 偏思维的题捏 C. LuoTianyi and the Show 题意 给定三种操作如下： 坐在当前最左边的人的左边，如果最左边的人左边无位置，那么坐到最右边； 坐在当前最右边的人的右边，如果最右边的人右边无位置，那么坐到最左边； 坐到指定位置 现在，给定 \(n\) 个人的操作，操作用一个数字表征，其中操作 \(1\) 为 \(-1\)，操作 \(2\) 为 \(-2\)，操作 \(3\) 为一个正整数，代表坐到该位置。 如果不可以坐，那么这个人离场。 输出按任意顺序排座后最多能坐多少人。 思路 首先，重复的正整数我们直接筛去，因为不会重叠。 那么，对于第一个数，我们有两个选择： 执行操作 \(3\)，对此我们可以标记操作 \(3\) 的所有下标，并枚举这些下标。既然我们确定了一个点，那么我们只能从这个点开始向左右拓展。 为计算方便，我们可以用 \(pre, suf\) 数组记录前 \(i\) 个数和后 \(n - i + 1\) 个数去掉操作 \(3\) 后有多少空位置。 那么， \(\min(pre[i], cnt_1) + \min(suf[i], cnt_2) + cnt_{12}\) 就是当前位置的答案。 一直执行操作 \(1\) 或操作 \(2\)，并在经过和结束后执行操作 \(3\)，那么，\(\min(\max(cnt_1, cnt_2) + cnt_{12}, m)\) 就是该选择的答案 最后，我们取最大值即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, m; cin >> n >> m; int cnt1 = 0, cnt2 = 0; vector&lt;bool> st(m + 1); int cnt = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur == -1) cnt1 ++; else if(cur == -2) cnt2 ++; else if(!st[cur]) st[cur] = true, cnt ++; &#125; vector&lt;int> pre(m + 2), suf(m + 2); for(int i=2;i&lt;=m;i++)&#123; pre[i] = pre[i - 1] + (st[i - 1] ? 0 : 1); &#125; for(int i=m-1;i>=1;i--)&#123; suf[i] = suf[i + 1] + (st[i + 1] ? 0 : 1); &#125; int ans = min(max(cnt1, cnt2) + cnt, m); for(int i=1;i&lt;=m;i++)&#123; if(st[i]) ans = max(ans, min(pre[i], cnt1) + min(suf[i], cnt2) + cnt); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 一开始想着确定两个点，想复杂了 D1. LuoTianyi and the Floating Islands (Easy Version) 题意 给定一棵无根树，给定整数 \(n, k\)，其中 \(n\) 为节点个数，\(k\) 为标记点的个数。确定标记点放置位置后，若某些点满足到所有标记点的距离之和为所有点中最小，那么这些点符合条件。输出符合条件的点的数量的期望。 本题中，\(k_{max} = 3\)。 思路 首先，\(k = 1\) 的时候很显然，标记点能确定的位置有 \(n\) 个，当标记点被确定后，距离最小的点只可能是标记点，因此期望为 \(\frac{n}{n} = 1\)。 由此，\(k = 3\) 的时候也是这样，期望为 \(1\)。 有趣的是，当 \(k\) 为奇数时，期望均为 \(1\)，此处不给出证明。 那么，我们来考虑 \(k = 2\) 的情况： 首先，\(n\) 个点中选 \(2\) 个，很明显分母是 \(C_n^2\)。 其次，如果我们 不考虑方向，那么，对于一条边，我们可以很轻松地通过 \(Dfs\) 求出其某一方向的连通块的点的个数 \(x\)。 那么，这条边就被经过了 \(x(n-x)\) 次。 这是很显然的，但有趣的是这么一求，我们的答案偏小了。 不妨对着样例一模拟一遍，我们不难发现缺少了从 \(2, 3, 4\) 节点向 \(1\) 方向的边，这恰好就是 \(C_n^2\)。 或者说，因为距离为 \(d\) 的两点间算上端点总共有 \(d + 1\) 个点，因而这么计算，起点或者终点对应的距离肯定有一个没被计算。 那么，最后的答案就是 \(\displaystyle{\frac{\sum_{i = 1}^n dp_i(n - dp_i) + C_n^2}{C_n^2}}\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; int qp(int a, int b) &#123; int res = 1; while (b > 0) &#123; if (b &amp; 1) res = (res * a) % mod; a = (a * a) % mod; b >>= 1; &#125; return res; &#125; int inv(int n) &#123; return qp(n, mod - 2); &#125; void solve()&#123; int n, k; cin >> n >> k; vector&lt;vector&lt;int>> e(n + 1); for(int i=0;i&lt;n-1;i++)&#123; int u, v; cin >> u >> v; e[u].pb(v), e[v].pb(u); &#125; if(k % 2 == 1)&#123; cout &lt;&lt; 1 &lt;&lt; '\n'; return; &#125; vector&lt;int> dp(n + 1); auto dfs = [&amp;](auto self, int c, int p) -> void&#123; dp[c] = 1; for(auto x : e[c])&#123; if(x == p) continue; self(self, x, c); dp[c] += dp[x]; &#125; &#125;; dfs(dfs, 1, 1); int ans = 0; for(int i=1;i&lt;=n;i++) ans = (ans + (dp[i] * (n - dp[i]) % mod)) % mod; ans = (ans + n * (n - 1) / 2 % mod) % mod; ans = ans * inv(n) % mod; ans = ans * inv(n - 1) % mod; ans = ans * 2 % mod; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 太抽象了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 871 Div 4</title>
    <url>/blog/posts/2445273141/</url>
    <content><![CDATA[Contestant'. Rank 472. Rating +58 (+408 -350). 这场没WA!!! 开心捏 A. Love Story 题意 对于字符串 "codeforces"，给定一个与其长度相等的字符串，按位遍历，输出不同位置的个数。 思路 如题，暴力即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; string s; cin >> s; string cf = "codeforces"; int cnt = 0; for(int i=0;i&lt;s.size();i++)&#123; if(s[i] != cf[i]) cnt ++; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 签到签到 B. Blank Space 题意 给定一个 \(01\) 序列，输出连续 \(0\) 长度的最大值。 思路 不妨绕一下，在开头和末尾加上 \(1\)，那么我们只需枚举 \(1\)，求出间距的最大值 \(-1\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n + 2, 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; int pre = 0, cnt = 0; for(int i=1;i&lt;=n+1;i++)&#123; if(a[i] == 1)&#123; cnt = max(cnt, i - pre - 1); pre = i; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 枚举 \(0\) 怕写错就换了个思路 C. Mr. Perfectly Fine 题意 现在有两个知识点需要修学。 给定 \(n\) 本书，每本书具有时间代价 \(m_i\)，以及对于两个知识点是否可以修学到。后者用两位二进制表示，如 \(01\) 表示可以花费 \(m_i\) 的时间来修学到知识点 \(2\)。同一个时刻只能学习一本书。 输出两个知识点均修学所需的最小时间代价。 思路 我们遍历输入，分别找出 \(10, 01, 11\) 对应的时间代价最小值 \(l, r, lr\)。 那么，\(ans = \min(l + r, lr)\)。 为了方便判断能否均修学，我们可以初始化三个变量的值为 \(inf\)，然后只需判断最后的 \(ans\) 是否大于等于 \(inf\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int l = inf, r = inf, lr = inf; for(int i=0;i&lt;n;i++)&#123; int m; string s; cin >> m >> s; if(s == "10") l = min(l, m); else if(s == "01") r = min(r, m); else if(s == "11") lr = min(lr, m); &#125; int ans = min(l + r, lr); if(ans >= inf) cout &lt;&lt; -1 &lt;&lt; '\n'; else cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 题目有点绕 D. Gold Rush 题意 给定一堆金子，金子数量为 \(n\)，定义一次操作为选定某一堆金子并将其恰好划分为 \(x, 2x\)。输出任意次操作后能否出现一堆金子的个数为 \(m\)。 思路 首先，既然能划分，那么这个数一定是 \(3\) 的倍数。 不难发现，最后的若干堆金子一定是 \(n\) 整除 \(k\) 个 \(3\) 后，再乘上 \(p, p \in [0, k]\) 个 \(2\) 后得到的。 那么，我们只需暴力，在每次整除 \(3\) 后都枚举一遍 \(p\)，判断是否可以相等即可。 时间复杂度：不会算 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; int two[64]; void init()&#123; two[0] = 1; for(int i=1;i&lt;64;i++)&#123; two[i] = two[i - 1] * 2; &#125; &#125; void solve()&#123; int n, m; cin >> n >> m; if(n == m)&#123; cout &lt;&lt; "YES\n"; return; &#125; int k = 0; while(n % 3 == 0)&#123; k ++, n /= 3; if(m % n != 0) continue; for(int i=0;i&lt;=k;i++)&#123; if(n * two[i] == m)&#123; cout &lt;&lt; "YES\n"; return; &#125; &#125; &#125; cout &lt;&lt; "NO\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while (t --) solve(); &#125; 卡了一会儿 E. The Lakes 题意 给定一个 \(n \times m\) 的矩阵，元素为非负数。 对于当前位置，定义移动的限制为： 只能向上下左右移动一位； 不能移动到 \(0\)； 不能越界； 不能移动到之前经过的点 定义一条路径为任选一个不为 \(0\) 的点，并进行符合要求的若干次移动后的最大路径，这条路径的贡献为所有在该路径上的点的值的和。 输出最大的路径贡献。 思路 一道很裸的搜索题。 就这样，手搓一下 \(dfs\) 的板子即可。 至于起点的话，按顺序枚举，跳过已经遍历过的点和为 \(0\) 的点即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; int two[64]; void init()&#123; two[0] = 1; for(int i=1;i&lt;64;i++)&#123; two[i] = two[i - 1] * 2; &#125; &#125; void solve()&#123; int n, m; cin >> n >> m; if(n == m)&#123; cout &lt;&lt; "YES\n"; return; &#125; int k = 0; while(n % 3 == 0)&#123; k ++, n /= 3; if(m % n != 0) continue; for(int i=0;i&lt;=k;i++)&#123; if(n * two[i] == m)&#123; cout &lt;&lt; "YES\n"; return; &#125; &#125; &#125; cout &lt;&lt; "NO\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while (t --) solve(); &#125; 无脑搓板子（ F. Forever Winter 题意 定义雪花图如下： 无向图； 选定一个点为雪花的中心点； 中心点和 \(x\) 个点连接； 对于这 \(x\) 个点，均有 其他 \(y\) 个点和它连接 现在，给定一个雪花图，输出上述定义中的 \(x, y\)。 保证 \(\min(x, y) \geq 2\) 思路 我们遍历所有的叶节点，也就是度为 \(1\) 的点，这些点个数总和就是 \(xy\)。 对于一个叶节点，他一定只有一个点和其相连，也就是定义中那 \(x\) 个点的其中一个。 那么，我们只需统计所有叶节点所连接的不同点的个数，个数即为 \(x\)。 由上，可相除求得 \(y\)。 可以证明，对于题目所给限制，上述算法一定成立。 时间复杂度：\(O(n + m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> e(n + 1); vector&lt;int> in(n + 1); for(int i=0;i&lt;m;i++)&#123; int u, v; cin >> u >> v; e[u].pb(v); e[v].pb(u); in[u] ++, in[v] ++; &#125; vector&lt;bool> st(n + 1); int x = 0, y = 0; for(int i=1;i&lt;=n;i++)&#123; if(in[i] == 1) &#123; y ++; if(!st[e[i][0]]) x ++, st[e[i][0]] = true; &#125; &#125; cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y / x &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 抽象 G. Hits Different 题意 将 \(2023\) 个格子按照下图的规律放置成一个金字塔： 定义一个点的所有顶部的点为 当前层标记的所有点 与上一层相邻的点 并依次递归到最顶部为止 后被标记的所有点。 如上图，对于 \(9\)，除了它本身，其余被标红的点就是它所有顶部的点。 给定 \(n\)，输出其本身以及其所有顶部点的值之和。 题目明示开 \(long\ long\)。 思路 首先，我们不难发现，我们要求和的点就是一个倒三角内的所有点。 这个倒三角很有趣，我们以例图为例，来看看规律如何： 从 \(9\) 开始，向右上角枚举，最后枚举到了 \(6\)，也就是第三行的末尾； 对于 \(9, 6\)，向左上角求和，恰好都有 \(3\) 个数，\(3\) 就是 \(6\) 的行数； 向左上角枚举，扣除 当前行数，向右上角枚举，扣除 (当前行数 \(-1\)) 通过归纳猜想我们可以得出，我们循环从 \(n\) 开始，依次扣除 (当前行数 \(-1\))，直到遍历到第 \(x\) 行的末尾，并记录我们遍历了 \(cnt\) 个数。 那么，最后的答案就是 \(cnt\) 个前缀和长度为 \(x\) 的和。 此处为按照 \(1 =&gt; 3 =&gt; 6\) 为一行，\(1 =&gt; 2 =&gt; 4\) 为一列的方式计算每行的前缀和。 那么，前缀和我们完全可以预处理，枚举即可。 时间复杂度：不大 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int N = 3e3, M = 4e6, inf = 0x3f3f3f3f3f3f3f3f; int sum[N][N]; int line[M]; bool ed[M]; void init()&#123; int start = 1; for(int i=1;i&lt;=2e3;i++)&#123; int cur = start; for(int j=1;j&lt;=2e3-i+1;j++)&#123; sum[i][j] = sum[i][j - 1] + cur * cur; cur += i + j; &#125; start += i; &#125; int now = 0; for(int i=1;i&lt;=2e3;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; now ++; line[now] = i; &#125; ed[now] = true; &#125; &#125; void solve()&#123; int n; cin >> n; int tmp = n, cnt = 1; while(!ed[tmp])&#123; tmp -= line[tmp] - 1; cnt ++; &#125; int to = line[tmp]; int ans = 0; for(int i=1;i&lt;=cnt;i++) ans += sum[i][to]; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while (t --) solve(); &#125; 纯纯找规律（ H. Don't Blame Me 题意 给定序列 \(a\) 以及整数 \(k\)，输出子序列的个数，满足序列中所有数按位与以后得到的数的二进制中有 \(k\) 个 \(1\)。 思路 根据题目所给数据范围，可以推测这道题需要状压枚举。 考虑到非连续子序列，我们可以推测这道题需要 \(dp\)。 下面给出状压 \(dp\) 的解法： 首先，对于当前位置，它既可以作为某些子序列的一部分，也可以不作为任何子序列的一部分，当然也可以作为新序列的开头。 因此，我们定义 \(dp[i][j]\) 为前 \(i\) 个数的所有子序列在 \(i\) 位为值 \(j\) 的个数，进行分讨： 作为某些子序列的一部分，我们枚举 \(msk \in [1, 63]\)，并将 \(dp[i][msk \&amp; a[i]]\) 加上 \(dp[i - 1][msk]\)； 不作为任何子序列的一部分，那么跳过这个元素，\(dp[i][msk]\) 加上 \(dp[i - 1][msk]\)； 作为新序列的开头，\(dp[i][a[i]]\) 加上 \(1\)。 最后，我们枚举所有二进制下 \(1\) 的个数为 \(k\) 的数 \(msk\)，并统计 \(dp[n][msk]\) 的总和即可。 时间复杂度：\(O(2^6n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int N = 3e3, M = 4e6, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; int set_bit(int x)&#123; int cnt = 0; while(x > 0)&#123; if(x % 2 == 1) cnt ++; x /= 2; &#125; return cnt; &#125; void solve()&#123; int n, k; cin >> n >> k; vector&lt;vector&lt;int>> dp(n + 1, vector&lt;int>(1 &lt;&lt; 6, 0)); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; for(int msk = 0; msk &lt; (1 &lt;&lt; 6); msk ++)&#123; //状压枚举 dp[i][msk] = (dp[i][msk] + dp[i - 1][msk]) % mod; //作为某些子序列中不出现的元素 dp[i][msk &amp; cur] = (dp[i][msk &amp; cur] + dp[i - 1][msk]) % mod; //作为某些子序列的一部分 &#125; dp[i][cur] = (dp[i][cur] + 1) % mod; //新开一个子序列 &#125; int ans = 0; for(int msk = 0; msk &lt; (1 &lt;&lt; 6); msk ++)&#123; if(set_bit(msk) == k) ans = (ans + dp[n][msk]) % mod; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 你还真别说，我赛时确实想到了状压 \(dp\)，不会写罢了(x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 870 Div 2</title>
    <url>/blog/posts/3735766708/</url>
    <content><![CDATA[Contestant‘. Rank 1818. Rating +61(+561 -500). A. Trust Nobody 题意 定义一群人中有一定数量的人撒谎。对于每个人 \(i\)，会给出他所说的撒谎的人至少有 \(a_i\) 人。输出撒谎的人的数量。 思路 我们直接遍历撒谎的人的数量 \(x\)，然后枚举 \(a_i &gt; x\) 的数量，从而如果数量和 \(x\) 一致，我们就找到了答案。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() const int N = 2e6, mod = 1e9 + 7; void solve()&#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=0;i&lt;=n;i++)&#123; int cnt = 0; for(int j=1;j&lt;=n;j++)&#123; if(a[j] > i) cnt ++; &#125; if(i == cnt) &#123; cout &lt;&lt; i &lt;&lt; '\n'; return; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 一开始题目看错了，卡了半天（ B. Lunatic Never Content 重题了。原题链接：Abu Tahun Mod problem 题意 给定一个序列，找出最大的 \(x\)，满足将序列中所有元素对 \(x\) 取模后得到的新序列回文。 思路 首先，对于两个数，如果我们希望取模后的值相等，那么这两个数应该可以写成 \(k_1x + p, k_2x + p\)。 想让 \(x\) 尽可能大，那么就需要 \(k_1\) 和 \(k_2\) 尽可能小。 于是，我们不妨将差值的绝对值作为 \(x\)，这样即可让 \(x\) 尽可能大。 那么因此，我们会得到多组限制。 如果对于两个限制 \(x_1 = abs(a_i - a_{n - i + 1}), x_2 = abs(a_j - a_{n - j + 1})\)，要满足这两个限制，新的 \(x&#39; = gcd(x_1, x_2)\)， 为何呢？不难证明如果两个数\(\mod x\) 后的值相等，那么如果 \(y\) 是 \(x\) 的因数，两个数\(\mod y\) 后的值也相等。 当然，如果差值为 \(0\)，就不需要参与计算了。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() const int N = 2e6, mod = 1e9 + 7; void solve()&#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; if(n == 1)&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; int ans = abs(a[1] - a[n]); for(int i=2;i&lt;=n/2;i++)&#123; if(ans) ans = gcd(ans, abs(a[i] - a[n + 1 - i])); else ans = abs(a[i] - a[n + 1 - i]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 好快的签 C. Dreaming of Freedom 题意 给定 \(n\) 个人和 \(m\) 个选择，每轮中每个人可以对任意一个选择投票，每轮结束后将会保留投票数最多的几个选择，并继续下一轮。如果可以无穷继续下去，输出 \(NO\)；否则如果最后可以确定一个选择，输出 \(YES\)。 思路 我们遍历 \(n\) 的所有质因子 \(x\)，如果 \(x \leq m\)，那么我们扔掉 \(m - x\) 个选择，对于剩下的 \(x\) 个选择，只需每个选择都有 \(\frac{n}{x}\) 票即可无穷继续下去。 那么，如果暴力枚举因子，我们会超时。 也许会想到枚举到根号，但如果我们恰好碰到了个质数 \(n\)，我们就寄了。 为何呢？因为质因子 \(n\) 没有被我们枚举到。 为了避免这样，我们直接加一个特判，如果 \(n \leq m\)，输出 \(NO\) 即可。 当然，如果 \(n = 1\)，一定可以确定一个选择（因为只有一个），所以再加一个特判。 时间复杂度：\(O(\log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() void solve()&#123; int n, m; cin >> n >> m; if(m == 1 || n == 1)&#123; cout &lt;&lt; "YES\n"; return; &#125; if(n &lt;= m)&#123; cout &lt;&lt; "NO\n"; return; &#125; for (int i = 2; i * i &lt;= n; i ++) &#123; if(n % i == 0)&#123; if(i &lt;= m)&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 被坑死了 D. Running Miles 题意 给定一个序列，确定一个长度大于等于 \(3\) 的区间 \([l, r]\)，区间的价值为最大的三个数减去 \(r - l\)。 输出最大的价值。 思路 我们不妨直接将 \(-r, +l\) 体现到序列中。 具体地说，我们确定中间的元素 \(a_i\)，那么前 \(i - 1\) 个元素中加上其下标后的最大值和后 \(n - i - 1\) 个元素中减去其下标后的最大值与 \(a_i\) 的和即为当前的最大价值。 对于最大值的初始化，我们可以用 "前缀和"。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; vector&lt;int> l(n + 2, -inf), r(n + 2, -inf); for(int i=1;i&lt;=n;i++) l[i] = max(l[i - 1], a[i] + i); for(int i=n;i>=1;i--) r[i] = max(r[i + 1], a[i] - i); int ans = -inf; for(int i=1;i&lt;=n;i++) ans = max(ans, l[i - 1] + a[i] + r[i + 1]); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 学习了学习了（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 820 Div 3</title>
    <url>/blog/posts/3779885126/</url>
    <content><![CDATA[Practice. A. Two Elevators 题意 给定两个电梯，电梯从一层移动到相邻层需要一秒。当前人位于第一层；第一个电梯位于 \(a\) 层；第二个电梯位于 \(b\) 层，但是该电梯会先前往 \(c\) 层。 输出最先到达第一层的电梯的耗时。 思路 第一个电梯耗时 \(a - 1\)，第二个梯子耗时 \(abs(b - c) + c - 1\)。 取最小值即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pdd pair&lt;double, double> #define fs first #define sc second void solve() &#123; int a, b , c; cin >> a >> b >> c; int p = abs(a - 1), q = abs(c - b) + abs(c - 1); if(p == q) cout &lt;&lt; 3 &lt;&lt; '\n'; else if(p > q) cout &lt;&lt; 2 &lt;&lt; '\n'; else cout &lt;&lt; 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; b不一定小于c，要取绝对值 B. Decode String 题意 对于一个字符串，给定如下的加密方式： 遍历所有字符； 对于一个字符，设 \(x_i\) 为从 \(a\) 开始编号的数值； 如果 \(x_i \geq 10\)，将 \(x_i\) 乘上 \(10\)； 将所有 \(x\) 按顺序拼接起来 现在，给定加密后的结果，输出原字符串。 思路 首先，小于 \(10\) 的数不会出现末尾为 \(0\) 的情况，而出现了末尾是 \(0\)，前面两个数就是原字符对应的编号。 所以，我们直接倒序遍历，若找到 \(0\)，跳过 \(0\) 并读取前两个数并转换，若不是 \(0\)，那么将这个数转换。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pdd pair&lt;double, double> #define fs first #define sc second void solve() &#123; int n; cin >> n; string s; cin >> s; string ans; for(int i = n - 1; i >= 0; i --)&#123; char now = s[i]; if(now == '0')&#123; ans = (char) ((s[i - 2] - '0') * 10 + (s[i - 1] - '0') - 1 + 'a') + ans, i -= 2; &#125;else&#123; ans = (char) (s[i] - '0' - 1 + 'a') + ans; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 通俗 C. Jumping on Tiles 题意 给定一个字符串，规定操作为从该位置跳到另一个位置，代价为两个位置对应字符在字母表中位置的差的绝对值。 输出从字符串左端跳到右端的代价和的最小值，以及该代价下能跳过的最多位置（不可以重复跳到同一个位置）。 思路 显然，我们只需按照字典序跳着走即可，那么我们不妨记录每个字母出现的次数以及对应的下标，然后从起点的字母按顺序遍历到终点的字母，边遍历边将所有下标都加入答案中，最后根据答案序列计算代价即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; string s; cin >> s; int n = s.size(); vector&lt;vector&lt;int>> a(26); for(int i=0;i&lt;n;i++) a[s[i] - 'a'].emplace_back(i); vector&lt;int> ans; int step = s[0] &lt; s[n - 1] ? 1 : -1; for(int i=s[0]-'a';i*step&lt;=((int)(s[n-1]-'a'))*step;i += step)&#123; for(auto e : a[i]) ans.emplace_back(e); &#125; int sum = 0; for(int i=1;i&lt;ans.size();i++) sum += abs((int) (s[ans[i]] - s[ans[i - 1]])); cout &lt;&lt; sum &lt;&lt; ' ' &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto e : ans) cout &lt;&lt; e + 1 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 跳一跳 D. Friends and the Restaurant 题意 给定 \(n\) 个朋友，每个朋友需要花 \(a_i\) 的时间，个人时间预期为 \(b_i\)，由此给定长度为 \(n\) 的两个序列 \(a, b\)。 定义每次可取出至少两个朋友，只要所有人花费的时长小于等于预期时间的总和，那么这些朋友就可以一起去餐馆吃饭。 输出最多可取出多少对满足条件的朋友，且一个人最多只能在一对朋友里。 思路 首先，我们不难会想到构建一个新的数组 \(c\)，满足 \(c_i = b_i - a_i\)，然后将其排个序。 我们不妨直接两两配对，因为既然三个人能配对，那么将其拆开去和其他的人组合一定贡献更大。 其次，如果我们从大到小遍历，并从最小值开始从小到大寻找能进行配对的数，那么我们可以发现我们跳过的数对后续的遍历都没有任何贡献。 具体来说，当我们从小到大遍历的时候，既然这个数不满足要求，那么因为另一个数是递减的，我们一定找不出答案。 因此，我们直接贪心地降序排序，然后枚举左端点，移动右指针即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; a[i] = cur - a[i]; &#125; sort(a.rbegin(), a.rend()); int l = 0, r = n - 1; int cnt = 0; while(l &lt; r)&#123; while(l &lt; r &amp;&amp; a[l] + a[r] &lt; 0) r --; if(l &lt; r &amp;&amp; a[l] + a[r] >= 0) cnt ++; else break; l ++, r --; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 但是升序排序是不可行的哦 E. Guess the Cycle Size 题意 互动游戏。 对于一个由 \(n\) 个节点连接而成的一个无向环，节点的顺序未知。 定义询问为指定两个点，返回值为联结两个点的两条边随机选一，随机是等概率的。如果给定的两个点中至少有一个点超出范围，那么输出 \(-1\)。 对于 \(1e18\) 级别的 \(n\)，在 \(50\) 次询问内，输出 \(n\) 的值。 思路 这是一道很有趣的题。 首先，这道题没有 \(100\%\) 能通过的算法，但 \(99.999851\%\) 的通过概率可以视为正确。 具体来说，因为随机是等概率的，所以我们可以进行 \(25\) 次询问，每次询问 \(1\ i, i\ 1\)，如果两者的返回值不相等，那么我们就找到了答案。 若我们从 \(2\) 开始逐一递增枚举 \(i\)，那么只要我们得到了 \(-1\)，前一个 \(i\) 就是答案。 这样，我们可以以一个很高的概率 "通过" 此题。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; int ask(int l, int r)&#123; cout &lt;&lt; "? " &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; cout.flush(); int x; cin >> x; return x; &#125; void solve()&#123; int ans = 0; for (int i = 2; i &lt;= 26; i++) &#123; long long x = ask(1, i); long long y = ask(i, 1); if (x == -1) &#123; ans = i - 1; break; &#125; if (x != y) &#123; ans = x + y; break; &#125; &#125; cout &lt;&lt; '!' &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; '\n'; cout.flush(); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 真的过了吗？真的没过吗？]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 869 Div 2</title>
    <url>/blog/posts/2274952185/</url>
    <content><![CDATA[Contestant. Rank 474. Rating +86. A. Politics 题意 对于 \(n\) 个人，有 \(m\) 个意见，每个人需要对意见做表率（\(+\)表示同意，\(-\) 表示不同意）。 在对一个意见做完表率后，如果同意的人多，那么不同意的人将会离开；如果不同意的人多，那么同意的人将会离开；如果人数一样多，那么所有人都离开。 规定可以在所有人表率前，拿掉一些人。设第一个人为自己，那么输出自己能留到最后的条件下最后剩余的人数的最大值。 思路 首先，如果有其他人的任意一个意见的表率和自己不一样，那么最后自己或者那个不一样的人会离开，所以，所有意见的表率和自己都相同的人的个数加上 \(1\) 就是答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, k; cin >> n >> k; vector&lt;string> s(n); for(int i=0;i&lt;n;i++) cin >> s[i]; int ans = 0; for(int i=0;i&lt;n;i++) if(s[0] == s[i]) ans ++; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 抽象 B. Indivisible 题意 给定一个整数 \(n\)，构造一个 \(n\) 的排列，满足对于任意 \(1 \leq l &lt; r \leq n\)，\((a_l + a_{l + 1} + \ldots + a_r) \mod (r - l + 1) \neq 0\)。 思路 我们先来考虑两个连续的数，既然它们不能被 \(2\) 整除，那么我们不妨直接用一个奇数和一个偶数拼接。 或者换句话说，排列为奇偶相间的。 对于三个连续的数，不能被 \(3\) 整除，那么这三个数不可以是 \(a - 1, a, a + 1\)。 从这里就已经出现一定的规律了，我们不妨按照 \(2, 1, 4, 3, \ldots, 2n, 2n - 1\) 的方法构造，很巧，其他约束均满足。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; if(n == 1) cout &lt;&lt; 1 &lt;&lt; '\n'; else&#123; int cnt = (1 + n) * n / 2; if(cnt % n == 0) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; for(int i=1;i&lt;=n/2;i++) cout &lt;&lt; i * 2 &lt;&lt; ' ' &lt;&lt; i * 2 - 1 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜即可 C. Almost Increasing Subsequence 题意 如果一个序列中不包含任何 连续的 三元组 \((x, y, z)\) 满足 \(x \geq y \geq z\)，那么定义该序列 几乎递增。 现在，给定一个序列以及若干询问，对于 \([l_i, r_i]\) 的区间询问，输出该区间中几乎递增的序列的最大长度。 思路 因为三元组是连续的，所以我们可以直接计算出前 \(x\) 个数中几乎递增的序列的长度。 或者说，这里采用了一种类似于前缀和的做法： 如果 \(a_{i - 2} \geq a_{i - 1} \geq a_i\)，那么 \(sum_i = sum_{i - 1}\)； 否则，\(sum_i = sum_{i - 1} + 1\)。 但是这样相减是不够的，如果左边界出现了不满足条件的三元组，这时答案会偏小。因为三元组的一部分包含在区间中时，并不会不满足条件。 因此，我们可以顺便记录统计的时候当前位置是否出现了不满足条件的三元组，即标记 \(f_i = true\)，那么如果 \(f_l = true\)，答案 \(+1\)；如果 \(f_{l + 1} = true\)，答案再 \(+1\)（当然，\(l + 1\) 要在区间中）。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, q; cin >> n >> q; vector&lt;int> a(n + 1), ans(n + 1); vector&lt;bool> st(n + 1); for (int i = 1; i &lt;= n; i++) cin >> a[i]; ans[0] = 0; ans[1] = 1; ans[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; ans[i] = ans[i - 1]; if (a[i - 2] >= a[i - 1] &amp;&amp; a[i - 1] >= a[i]) st[i] = true; else ans[i] ++; &#125; while (q --) &#123; int l, r; cin >> l >> r; int w = ans[r] - ans[l - 1]; if (st[l]) w ++; if (r != l &amp;&amp; st[l + 1]) w ++; cout &lt;&lt; w &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 好妙 D. Fish Graph 题意 给定一个无向不完全联通图，找出一个 "鱼"，并输出它的所有边。找不到输出 \(NO\)。 其中，"鱼" 定义为一个环加上其中一个点所多连出的两条边。注意，这两条边不可以和环中的其他点连接。 思路 首先，数据量很小，我们不妨直接枚举两个点 \(u, v\)，并忽略 \(u - v\) 这条边。我们从 \(u\) 节点开始 \(dfs\)，若能到 \(v\)，那么就存在了环。 此时，我们将 \(u\) 作为特殊点，那么在开始 \(dfs\) 前，我们还得满足 \(u\) 的度数大于等于 \(4\)。 设 \(dfs\) 的路径点集为 \(step\)，\(u\) 的所有子节点为 \(extra\)。 首先，我们只需随便选 \(extra\) 中的 \(4\) 个，因为最多只会有两条边在路径中。 那么，我们枚举 \(extra\)，如果 \(extra\) 中的点都不在 \(step\) 中，那么很凑巧，去掉 \(extra\) 中在路径中的两个点，剩余的两个点和这个环就可以构成一个答案。 但如果出现了，因为题目要求多出的两条边不可以和环中的其他点连接，我们就需要另行处理。 显然，我们只需考虑一种情况，也就是当 \(extra\) 中包含了路径中的两个点，但是有一条边和环中的其他点相连的时候。 此时，我们找到了一个更小的环，如果我们将这个更小的环作为答案，那么 \(extra\) 中剩余的一个点和原来在路径中的一个点就可以作为多出来的那两条边了。 因此，按照上述算法，可以保证一定可以找出一条鱼。 最后，我们将 \(step\) 和 \(extra\) 稍做处理即可得到答案。 时间复杂度：\(O(m \cdot (n + m))\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() void solve()&#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> e(n); for(int i=0;i&lt;m;i++)&#123; int u, v; cin >> u >> v; u --, v --; e[u].pb(v), e[v].pb(u); &#125; for(int u=0;u&lt;n;u++)&#123; if(e[u].size() &lt; 4) continue; for(auto v : e[u])&#123; vector&lt;int> now, step; bool ok = false; vector&lt;bool> vis(n); auto dfs = [&amp;](auto self, int p)&#123; vis[p] = true; now.pb(p); if(p == v) &#123; //绕回v了 step = now; ok = true; return; &#125; for(auto to : e[p])&#123; if(vis[to] || (p == u &amp;&amp; to == v)) continue; self(self, to); //lambda递归调用 if(ok) return; &#125; now.pop_back(); &#125;; dfs(dfs, u); if(!ok) continue; vector&lt;int> extra = e[u]; extra.resize(4); //挑4个即可 int mn = step.size(); for(auto x : extra)&#123; //根据这4个来重新调整环（因为环内可能还有小环，我们拿小环更好，可以保证一定满足条件 auto it = find(all(step), x); if(it != step.begin() + 1)&#123; mn = min(mn, (int)(it - step.begin()) + 1); &#125; &#125; step.resize(mn); partition(all(extra), [&amp;](int x)&#123; return count(all(step), x) == 0; &#125;); //删掉在环中的那些点 extra.resize(2); cout &lt;&lt; "YES" &lt;&lt; '\n' &lt;&lt; step.size() + 2 &lt;&lt; '\n'; int pre = step.back(); for(auto x : step)&#123; cout &lt;&lt; x + 1 &lt;&lt; ' ' &lt;&lt; pre + 1 &lt;&lt; '\n'; pre = x; &#125; cout &lt;&lt; u + 1 &lt;&lt; ' ' &lt;&lt; extra[0] + 1 &lt;&lt; '\n' &lt;&lt; u + 1 &lt;&lt; ' ' &lt;&lt; extra[1] + 1 &lt;&lt; '\n'; return; &#125; &#125; cout &lt;&lt; "NO" &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 参考了官方题解对出现 "更小环" 时的处理]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 868 Div 2</title>
    <url>/blog/posts/569247821/</url>
    <content><![CDATA[Contestant. Rank 1585. Rating +7. A. A-characteristic 题意 给定一个由 \(±1\) 组成的数组 \(a\)，定义特征 \(A\) 为数组 \(a\) 中满足 \(a \leq i &lt; j \leq n\) 且 \(a_i \cdot a_j = 1\) 的个数。 给定个数，构造这个数组。 思路 直接暴力枚举 \(-1\) 的个数，因为可以无视顺序，我们直接在输出 \(-1\) 后剩下的全填上 \(1\) 即可。 因为 \((-1) \cdot (-1) = 1, 1 \cdot 1 = 1\)，所以我们不妨初始化 \(p\) 数组，其中 \(p_i = p_{i - 1} + i - 1\)，那么 \(p_i + p_{n - i} = k\) 时就找到了答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> p(110); for(int i=2;i&lt;=100;i++) p[i] = p[i - 1] + i - 1; for(int i=0;i&lt;=n;i++)&#123; if(p[i] + p[n - i] == k)&#123; cout &lt;&lt; "YES\n"; for(int x=1;x&lt;=i;x++) cout &lt;&lt; "-1 "; for(int x=i;x&lt;n;x++) cout &lt;&lt; "1 "; cout &lt;&lt; '\n'; return; &#125; &#125; cout &lt;&lt; "NO\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 傻逼（指出题 B. Sort with Step 题意 给定一个 排列 以及整数 \(k\)，规定 \(a_i\) 可以和 \(a_{i + k}\) 交换。 如果在若干次交换后可以让排列升序，那么输出 \(0\)； 否则，如果在交换之前可以任选两个数交换一次，该条件下可以让排列升序，那么输出 \(1\)； 否则，输出 \(-1\)。 思路 首先，既然这是一个排列，那么如果可以升序，一定满足 \(a_i \mod k = i \mod k\)。 那么，我们直接统计不满足该条件的个数，如果为 \(0\)，输出 \(0\)；如果为 \(2\)，输出 \(1\)，否则输出 \(-1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n + 1); int f = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; if(a[i] % k != i % k) f ++; &#125; if(f == 0) &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; &#125;else if(f == 2)&#123; cout &lt;&lt; 1 &lt;&lt; '\n'; &#125;else cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 如果不是排列那我就似了 C. Strongly Composite 题意 对于一个合数，如果它的所有因子满足质数的个数小于等于合数的个数，那么定义该数为强合数。 现在，给定一个序列 \(a\)，构造一个序列 \(b\)，并输出它的长度： \(a_1 \cdot a_2 \cdot \ldots \cdot a_n = b_1 \cdot b_2 \cdot \ldots \cdot b_m\)； \(b\) 中所有数都是强合数； \(b\) 的长度尽可能最大 思路 首先，我们不妨分解质因数，并统计所有质因数的个数。 因为两个相同的质数相乘后，我们会得到一个因子满足质数个数为 \(1\) 且合数个数也为 \(1\) 的强合数，所以我们在统计之后枚举所有个数 \(cnt_p\)，统计 \(\lfloor \frac{cnt_p}{2} \rfloor\) 的总和，作为答案的一部分。 对于剩余的数的集合，不难发现没有重复数字，而三个不同的质数相乘后，我们会得到一个因子满足质数个数为 \(3\) 且合数个数为 \(4\) 的强合数，此时对于剩余的数的个数 \(sum\)，\(\lfloor \frac{sum}{3} \rfloor\) 就是答案的另一部分。 因此，\(ans = \sum \lfloor \frac{cnt_p}{2} \rfloor + \lfloor \frac{sum}{3} \rfloor\)。 当然，对于分解质因数，我们可以用线性筛。 时间复杂度：不大 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; vector&lt;int> pri; vector&lt;bool> vis(N); void init(int n) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) pri.emplace_back(i); for (auto j : pri) &#123; if (i * j > n) break; vis[i * j] = true; if (i % j == 0) break; &#125; &#125; &#125; void solve() &#123; int n; cin >> n; map&lt;int, int> cnt; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; for (auto x : pri) &#123; if (cur % x == 0) &#123; while (cur % x == 0) cur /= x, cnt[x] ++; &#125; &#125; if (cur != 1) &#123; cnt[cur] ++; &#125; &#125; int ans = 0, sum = 0; for(auto e : cnt)&#123; ans += e.sc / 2; sum += e.sc % 2; &#125; cout &lt;&lt; sum / 3 + ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(1e5); int t = 1; cin >> t; while(t --) solve(); &#125; 有点水，但又有点不水（x D. Unique Palindromes 题意 对于一个至少有三个字符的字符串 \(s\)，定义 \(p(s, m)\) 为 \(s\) 的前 \(m\) 个字符的所有连续子串中 不同回文串 的个数。 现在，给定最多 \(20\) 个限制，一条限制包括 \(m_i\) 和 \(p(s, m_i)\) 的值，输出满足限制的一个字符串。 思路 首先，题目说了回文串不同才计数，那么对于 \(n\) 个连续相同的子串，就有 \(n\) 个不同的回文串（如 \(a, aa, aaa, aaaa, \dots\)）。 很有趣，题目给了限制的最大个数，这让我们不难联想到字母表的个数，\(20 &lt; 26\)。 那么，对于两个相邻的限制，我们可以求出多出的回文串的个数，并填上连续的对应个数的字符。我们不妨从 \(d\) 开始，第一个限制我们都放 \(d\)，第二个限制我们都放 \(e\)，以此类推，字母表是够我们用的。 那么空出来的地方，我们就一定得保证不会多出来回文串了。 可以很简单的观察到，我们只要循环放 \(abc\) 即可，如 \(\color{rgb(149,117,205)}{a}\color{rgb(124,179,66)}{b}\color{rgb(0,172,193)}{c}\)\(dd\)\(\color{rgb(149,117,205)}{a}\color{rgb(124,179,66)}{b}\)\(eee\)\(\color{rgb(0,172,193)}{c}\color{rgb(149,117,205)}{a}\color{rgb(124,179,66)}{b}\)\(ff\)，这样就可以满足我们的需求了。 这样，只要每次多出来的回文数的个数大于等于空出来的位置，我们都可以完成构造。 当然，如果空间不够了，其实可以证明一定无解，这边不给出证明。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, k; cin >> n >> k; vector&lt;int> x(k + 2), c(k + 2); for(int i=1;i&lt;=k;i++) cin >> x[i]; for(int i=1;i&lt;=k;i++) cin >> c[i]; x[++ k] = n, c[k] = c[k - 1]; int pre = 0; for(int i=1;i&lt;=k;i++)&#123; if(x[i] - c[i] &lt; pre)&#123; cout &lt;&lt; "NO\n"; return; &#125; pre = x[i] - c[i]; &#125; string ans = "abc"; int now = 0; c[0] = 3; for(int i=1;i&lt;=k;i++)&#123; for(int j=1;j&lt;=c[i]-c[i-1];j++) ans += (char) ('c' + i); int l = ans.size(); for(int j=1;j&lt;=x[i]-l;j++) ans += (char) ('a' + (now ++ % 3)); &#125; cout &lt;&lt; "YES\n" &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 其实是不会证（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 867 Div 3</title>
    <url>/blog/posts/2694924338/</url>
    <content><![CDATA[Contestant(alt). Rank 1774. Rating +20. A. TubeTube Feed 题意 给定两个序列 \(a, b\)，选择 \(a_i\) 的代价为 \(a_i + i\) (从 \(0\) 开始)，价值为 \(b_i\)。输出代价不超过 \(t\) 的条件下的最大价值。 思路 我们找出所有代价不超过 \(t\) 的价值，并遍历这些价值，找出最大值即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, t; cin >> n >> t; vector&lt;int> p; vector&lt;int> e(n); for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur + i &lt;= t) p.emplace_back(i); &#125; for(int i=0;i&lt;n;i++) cin >> e[i]; if(p.empty())&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; int mx = p[0]; for(auto &amp;x : p) &#123; if(e[mx] &lt; e[x]) mx = x; &#125; cout &lt;&lt; mx + 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 很水 B. Karina and Array 题意 给定一串整数序列，定义序列的美丽值为所有相邻两数乘积的最大值。在可以任意删除元素且最后至少剩余两个元素的条件下，输出最大的美丽值。 思路 很显然，我们直接排个序，对前两个和最后两个分别取乘积，并取最大值即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a.begin(), a.end()); int ans = -inf; ans = max(ans, a[0] * a[1]); ans = max(ans, a[n - 2] * a[n - 1]); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 还是很水 C. Bun Lover 题意 给定一个肉桂卷的大小 \(n\)，输出边长的总和。 具体来说，如下图，棕色线段的长度就是答案： 思路 我们将其拆分成两段，如下图（来自官方题解）： 可以发现粉色和青色段最后都会向里折1格，我们将其展开，那么长度恰好成为了一个等差数列的前 \(n\) 项和。 具体来说，青色的长度为 \(1 + 2 + \dots + n = \frac{n \cdot (n + 1)}{2}\)，粉色的长度为 \(1 + 2 + \dots + (n + 1) = \frac{(n + 1) \cdot (n + 2)}{2}\) 因此，最后的结果为 \(\frac{(n + 1) \cdot (n + 2)}{2} + \frac{n \cdot (n + 1)}{2} + 1 = \frac{(n + 1) \cdot (n + 2) + n \cdot (n + 1)}{2} + 1 = \frac{2 \cdot (n + 1)^2}{2} + 1 = (n + 1)^2 + 1\) 不过当然，像我这样盲猜有规律然后直接乱写也是可以的，这样你可以得到 \(26 + (n + 6)(n - 4)\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; cout &lt;&lt; 26 + (11 + 11 + (n - 5) * 2) * (n - 4) / 2 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 无脑Ocean在线乱猜 D. Super-Permutation 题意 给定排列 \(a\) 的长度，构造一个新序列 \(b\)，其中 \(b_i = ((a_1 + a_2 + \ldots + a_i) \mod n) + 1\)。 若能找出一个排列 \(a\)，满足构造出的新序列 \(b\) 为一个排列，那么输出 \(a\)，否则输出 \(-1\)。 思路 我们先来猜测一下如何构造： 首先，为了方便拿到 \(1\)，我们将第一个数指定为 \(n\)。 那么我们接下来就可以放上 \(n - 1\) 和 \(2\)，此时 \(n + n - 1 = 2n - 1, 2n - 1 + 2 = 2n + 1\)，\((2n - 1) \mod n + 1 = n, (2n + 1) \mod n + 1 = 2\)，此时我们拿到了 \(n, 2\)。 我们继续放上 \(n - 3\) 和 \(4\)，此时 \(2n + 1 + n - 3 = 3n - 2, 3n - 2 + 4 = 3n + 2\)，\((3n - 2) \mod n + 1 = n - 1, (3n + 2) \mod n + 1 = 3\)，此时我们拿到了 \(n - 1, 3\)。 依次类推，我们可以构造出排列 \(\{n, n - 1, 2, n - 3, 4, \ldots \}\)，以此得到序列 \(b = \{1, n, 2, n - 1, 3, \dots \}\)。 不难发现，上述构造方法对 \(1\) 和偶数都一定有解，而除 \(1\) 之外的奇数都无解。 事实上，我们来单独考虑这种无解情况，\(b_n = (a_1 + a_2 + \ldots + a_n) \mod n + 1= (1 + 2 + \ldots + n) \mod n + 1 = \frac{(1 + n)n}{2} \mod n + 1\)。 如果 \(n\) 为 \(1\) 或者偶数，那么分母对 \(n\) 有效，可以写作 \((1 + n) \frac{n}{2} \mod n + 1\)，我们无法在提出 \(n\) 后让式子为整数。 而相反地，当 \(n\) 为除 \(1\) 之外的奇数时，上述式子变成了 \(n \frac{1 + n}{2} \mod n + 1\)，我们可以提出 \(n\)，此时 \(b_n\) 变为了 \(1\)。 猜测的第一句话其实是一定需要满足的，我们假设 \(a_k = n\)，此时 \(b_k = (b_{k - 1} - 1 + a_k) \mod n + 1= b_{k - 1}\)，那么为了防止 \(b\) 元素重复，\(k\) 只能为 \(1\)。 那么，\(b_1\) 只能为 \(1\)。 不难发现，当 \(n\) 为除 \(1\) 之外的奇数时，\(b_1 = b_n\)，因此无解。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;bool> st(n + 1); vector&lt;int> ans(n); ans[0] = n; st[n] = true; bool ok = true; for(int i=1;i&lt;n;i+=2) &#123; ans[i] = n - i; if(st[n - i]) ok = false; st[n - i] = true; &#125; for(int i=2;i&lt;n;i+=2)&#123; ans[i] = i; if(st[i]) ok = false; st[i] = true; &#125; if(!ok) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 根据题意构造（x），根据猜测构造（√） E. Making Anti-Palindromes 题意 定义反回文串为一个长为 \(n\) 的字符串 \(s\)，满足对于任意 \(i \in [1, n]\) 都有 \(s_i \neq s_{n - i + 1}\)。 给定一个字符串，定义操作为选定任意两个不同位置的字符并交换它们，输出将字符串变为反回文串所需的最小的操作数。若无解输出 \(-1\)。 思路 首先，\(n\) 是奇数时，一定无解。 其次，只要有一个字母出现次数大于 \(\frac{n}{2}\)，那么也是无解，毕竟一定会出现至少一对相同的字母。 那么，我们统计 \(s_i = s_{n + 1 - i}\) 的个数为 \(k\)，以及对于所有字符 \(c\)，\(s_i = s_{n + 1 - i}\) 的个数的最大值 \(m\)，借此，我们可以先缩小一下范围： \(ans \geq m\)，因为这 \(m\) 对一定得和其他不同的字符对进行交换； \(ans \geq \lceil \frac{k}{2} \rceil\)，因为我们至少得两两配对。 那么显然，如果满足可以两两配对的条件，\(ans_{min} = \lceil \frac{k}{2} \rceil\)。 但如果不满足，那么我们不难发现，只要我们将数量少的字符对和其他数量少的字符对的进行交换，那么最后一定只会多出数量最多的那个字符对，也就是我们之前统计的数量为 \(m\) 的那个字符。 那么，最后约束就只剩下 \(m\) 了，\(ans_{min} = m\)。 因此，最后答案就是 \(\max(m, \lceil \frac{k}{2} \rceil)\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; string s; cin >> s; if(n % 2 == 1)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; vector&lt;int> cnt(26), oc(26); int m = 0, k = 0; for(int i=0;i&lt;n/2;i++) &#123; oc[s[i] - 'a'] ++, oc[s[n - i - 1] - 'a'] ++; if (s[i] == s[n - i - 1]) cnt[s[i] - 'a']++, k++; &#125; for(int i=0;i&lt;26;i++)&#123; m = max(m, cnt[i]); if(oc[i] > n / 2)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; &#125; cout &lt;&lt; max(m, (k + 1) / 2) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 好绕，好高级，我好若 G1. Magic Triples (Easy Version) 详见G2，区别是G1的数据量更小 G2. Magic Triples (Hard Version) 题意 定义如果一个三元组 \((i, j, k)\) 满足下面的条件，那么这个三元组是有魔力的： \(1 \leq i, j, k \leq n\)； \(i, j, k\) 各不相同； 存在一个正整数 \(b\)，满足 \(a_i \cdot b = a_j, a_j \cdot b = a_k\)。 给定一个序列，输出所有三元组中有魔力的个数。 思路 首先，我们完全可以在确定一个数的条件下，枚举正整数 \(b\) 来计算答案。 那么我们不妨确定 \(j\)，并枚举 \(b\)，那么 \(a_i = \frac{a_j}{b}, a_k = ba_j\)。 很显然，如果我们从小到大枚举，是一定会超时的。 考虑到 \(b\) 一定是整数，所以我们在计算 \(b\) 的时候可以顺便计算 \(\frac{a_j}{b}\)，那么复杂度可以降到 \(\log a_j\)。 当然，考虑到重复问题，我们单独计算 \(b = 1\) 的贡献。 在 \(1e6\) 的范围内，复杂度可行，但对于 \(1e9\) 的数据，我们一定得做优化了。 考虑到 \(a_k = ba_j \leq \max(a)\)，我们可以一定程度复杂度，此时可以 \(AC\)。 时间复杂度：\(小于O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int mx = 0; map&lt;int, int> mp; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; mp[cur] ++; mx = max(mx, cur); &#125; int ans = 0; for(auto [a, cnt] : mp) &#123; ans += max(0ll, cnt * (cnt - 1) * (cnt - 2)); if(a != 1 &amp;&amp; mp.count(1) &amp;&amp; mp.count(a * a)) ans += cnt * mp[1] * mp[a * a]; for (int b = 2; b &lt;= a / b &amp;&amp; a * b &lt;= mx; b ++)&#123; if(a % b != 0) continue; if(mp.count(a / b) &amp;&amp; mp.count(a * b)) ans += cnt * mp[a / b] * mp[a * b]; if(b != a / b &amp;&amp; mp.count(b) &amp;&amp; mp.count(a * a / b)) ans += cnt * mp[b] * mp[a * a / b]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 卡过去力！]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 147</title>
    <url>/blog/posts/3276138869/</url>
    <content><![CDATA[Contestant. Rank 2617. Rating -37. A. Matching 题意 给定一个匹配字符串，包含 \(?\) 和 \([0, 9]\) 内的数字，\(?\) 可用任意数字替换。 输出字符串可以代表的数字的总数，其中数字不可以出现前导 \(0\)。 思路 很显然，难点在最后一句话，但这只和第一个字符是不是 \(?\) 有关。 如果不是 \(?\)，那么显然不会出现前导 \(0\)，最后的答案就是 \(10 ^ x\)，其中 \(x\) 是 \(?\) 的个数。 如果是 \(?\)，那么该位不可以出现 \(0\)，而其余位置是否为 \(0\) 我们无需考虑，所以最后的答案是 \(\frac{9}{10} 10 ^ x\)。 不过当然，如果第一位是 \(0\)，那么一个符合条件的数都没有了。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define psi pair&lt;string, int> #define fs first #define sc second const int N = 1e5 + 10; void solve()&#123; string s; cin >> s; int ans = 1; int n = s.size(); for(int i=0;i&lt;n;i++)&#123; if(s[i] == '?') ans *= 10; &#125; if(s[0] == '?') ans = ans / 10 * 9; if(s[0] == '0') ans = 0; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 很快啊，很简单啊（x B. Sort the Subarray 题意 定义操作为选择一段连续的子区间并将其中的所有元素升序排序。 现在给定操作前后的序列，输出最长的可能操作区间的左右端点。 思路 首先，我们比对两个序列，先找出不相同的起始位置和结束位置，得到区间 \([l_0, r_0]\)。 然后，我们拓展这个区间，其中，左区间向左拓展的条件是 \(a_{l_0 - 1} \leq a_{l_0}\)，右区间同理。 最后得到的区间就是答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define psi pair&lt;string, int> #define fs first #define sc second const int N = 1e5 + 10; void solve()&#123; int n; cin >> n; vector&lt;int> p(n), q(n); for(int i=0;i&lt;n;i++) cin >> p[i]; int b = -1, e = -1; for(int i=0;i&lt;n;i++) &#123; cin >> q[i]; if(p[i] != q[i])&#123; if(b == -1) b = e = i; else e = i; &#125; &#125; if(b == -1)&#123; int mx = 1, pre = p[0], cnt = 1, e = 1; for(int i=1;i&lt;n;i++)&#123; if(p[i] >= pre) cnt ++; else&#123; if(mx &lt; cnt)&#123; mx = cnt; e = i; &#125; cnt = 1; &#125; pre = p[i]; &#125; if(mx &lt; cnt)&#123; mx = cnt; e = n; &#125; cout &lt;&lt; e - mx + 1 &lt;&lt; ' ' &lt;&lt; e &lt;&lt; '\n'; &#125;else&#123; while(b - 1 >= 0 &amp;&amp; q[b] >= q[b - 1]) b --; while(e + 1 &lt; n &amp;&amp; q[e] &lt;= q[e + 1]) e ++; cout &lt;&lt; b + 1 &lt;&lt; ' ' &lt;&lt; e + 1 &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 怎么老打错变量，罚时吃饱力（悲 C. Tear It Apart 题意 给定一个字符串，定义操作为选择任意数量的不相邻的位置并将对应位置的字符删除。 输出最小操作数，使最后的字符串所有字符相同。 思路 首先，我们可以枚举我们要保留的那个字符，并删去其他的字符。 那么，我们只需考虑如何删的问题了。 显然，我们可以将需要删除的字符分成若干段，在第一次删除时，我们只需对每一段从第一个开始隔一位删就可以让能删的字符数最多，这显然成立（如 \(\color{rgb(124,179,66)}{b}\)\(c\)\(\color{rgb(124,179,66)}{d}\)\(a\)\(\color{rgb(124,179,66)}{b}\)\(c\)\(\color{rgb(124,179,66)}{d}\)\(b\)）。 那么，我们可以重复上面的操作，直到删完为止。 我们可以发现，操作数只和数量最多的那一段有关，而且最后的结果有 \(\log_2\) 的关系。 观察发现，\(\lceil \log_2 cnt_{max} \rceil\) 即为答案。 当然，直接用while循环也不是不可以（ 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define psi pair&lt;string, int> #define fs first #define sc second const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; string s; cin >> s; int n = s.size(); bool f = true; for(int i=1;i&lt;n;i++) if(s[i] != s[i - 1]) f = false; if(f) &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; int ans = inf; s = " " + s + " "; for(int w=0;w&lt;=25;w++)&#123; char now = (char) (w + 'a'); s[0] = s[n + 1] = now; int mx = 1, cnt = 0; for(int i=0;i&lt;=n + 1;i++)&#123; if(s[i] == now)&#123; mx = max(mx, cnt); cnt = 0; &#125;else cnt ++; &#125; int cur = 0; while(mx > 0)&#123; cur ++; mx /= 2; &#125; ans = min(ans, cur); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 观察可得，显然易得（x D. Black Cells 题意 给定一个数轴，对于起点 \(0\)，有下面的三个代价均为 \(1\) 的操作： 向右移动一格 按下shift 松开shift，此时按下到松开这段时间内经过的格子都会被染成黑色。 现在，给定数轴上的 \(n\) 段区间，只能将区间内的格子染上黑色，且需要染 \(k\) 个格子。 输出最小代价和。 思路 首先，不跳过区间的做法绝对不是最优的。 那么，我们会希望跳过区间的代价小于不跳过区间的代价。 但是，显然无论跳不跳过，我们都必须经过这个区间，所以问题归结到按下和松开shift的代价。 假设我们跳过了 \([l_i, r_i]\) 区间，此时代价为 \(a\)；如果我们不跳过，那么我们会多出 \(2\) 次按shift的代价，但是最后就不会多出至少 \(len\) 个需要多染的格子了。 那么最后问题归结于 \(a&#39;=a+2-len\) 和 \(a\) 的大小关系了。 显然，当长度为 \(1\) 时，我们能跳就跳；而长度为 \(2\) 时代价一致，长度大于 \(2\) 时我们能不跳就不跳。 我们可以枚举所有区间，然后进行分类讨论。 我们边枚举边记录算上当前区间的话之前有 \(c\) 个长为 \(1\) 的区间，去掉长为 \(1\) 区间后其他区间的和为 \(s\)。 那么，如果 \(s + c &lt; k\)，在这里停下来是不够的。如果 \(s &lt; k\) 但 \(s + c \geq k\)，那么一部分 \(1\) 是需要保留的，我们可以得到当前的最小代价为 \(end + 2((i - c) + (k - s))\)。如果 \(s \geq k\)，那么我们将所有的 \(1\) 都跳过即可，此时最小代价为 \(end - (s - k) + 2(i - c)\)。 当然，我们也可以使用优先队列解这题。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, k; cin >> n >> k; vector&lt;int> l(n), r(n); for(int i=0;i&lt;n;i++) cin >> l[i]; for(int i=0;i&lt;n;i++) cin >> r[i]; int s = 0, c = 0, ans = inf; for(int i=0;i&lt;n;i++)&#123; if(r[i] - l[i] + 1 == 1) c ++; else s += r[i] - l[i] + 1; if(s + c &lt; k) continue; if(s &lt; k &amp;&amp; s + c >= k) ans = min(ans, r[i] + 2 * (i + 1 - c + k - s)); else ans = min(ans, r[i] - (s - k) + 2 * (i + 1 - c)); &#125; cout &lt;&lt; (ans == inf ? -1 : ans) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 有点贪心的感觉]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 821 Div 2</title>
    <url>/blog/posts/809255780/</url>
    <content><![CDATA[Practice. A. Consecutive Sum 题意 给定一个序列 \(a\)，以及整数 \(k\)，定义操作为选择 \(i, j\)，满足 \(i \mod k = j \mod k\)，并将 \(a_i\) 和 \(a_j\) 交换。 输出任意次操作后，所有长为 \(k\) 的连续子序列的和的最大值。 思路 我们直接枚举 \(p \in [0, k - 1]\)，并求出所有 \(i \mod k = p\) 位置上 \(a_i\) 的最大值，并输出总和即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, k; cin >> n >> k; vector&lt;int> a(k); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; a[i % k] = max(a[i % k], cur); &#125; int ans = 0; for(int i=0;i&lt;k;i++) ans += a[i]; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 就好了 B. Rule of League 题意 规定对于 \(n\) 个选手，一共有 \(n - 1\) 场对决，第 \(i\) 场为上一场的赢家和第 \(i + 1\) 号选手之间的对决。 给定三个整数 \(n, a, b\)，其中 \(n\) 为选手数，所有选手要么赢了 \(a\) 场，要么赢了 \(b\) 场。 输出每场的赢家，若有多个方案，任选其一输出。 思路 显然，我们需要满足 \(\min(a,b)=0, (n - 1) \% \max(a,b) = 0\)。 那么，我们完全可以让第 \(2 + ky\) 号选手连续赢 \(y\) 场，这样即可满足条件。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, x, y; cin >> n >> x >> y; if(x > y) swap(x, y); if(x != 0 || y == 0 || (n - 1) % y != 0)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; &#125;else&#123; for(int i=2;i&lt;=n;i+=y)&#123; for(int j=0;j&lt;y;j++) cout &lt;&lt; i &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜即可 C. Parity Shuffle Sorting 题意 给定一个序列，定义操作如下： 选择两个下标 \(l, r\)，其中 \(1 \leq l &lt; r \leq n\)。 如果 \(a_l + a_r\) 为奇数，那么将 \(a_r\) 改为 \(a_l\)，否则相反。 输出将序列变为不递减序列的一种方案，满足方案数不超过序列的长度。 思路 我们不妨将序列全都改成一样的。 首先，我们将左右两个端点变为一样的，这只需选择 \(1, n\)，我们无需考虑端点的奇偶性。 其次，我们枚举剩余的元素，如果它和端点的和为奇数，那么我们选择 \(1, i\)，将 \(a_i\) 改为 \(a_1\)；如果为偶数，那么我们选择 \(i, n\)，将 \(a_i\) 改为 \(a_n\)，最后所有元素都会变为同一个值，且所需操作数为 \(n - 1 &lt; n\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; cout &lt;&lt; n - 1 &lt;&lt; '\n'; if(n > 1) cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; n &lt;&lt; '\n'; int f = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(i > 0 &amp;&amp; i &lt; n - 1)&#123; if((cur + f) % 2 == 1) cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; i + 1 &lt;&lt; '\n'; else cout &lt;&lt; i + 1 &lt;&lt; ' ' &lt;&lt; n &lt;&lt; '\n'; &#125;else f = cur; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 也是乱猜，但是很有道理（x D1. Zero-One (Easy Version) 题意 给定两个长度相等的二进制字符串 \(a, b\)，定义操作如下： 选择两个下标 \(l, r\)，其中 \(l &lt; r\)； 将 \(a_l\) 修改为 \(1 - a_l\)，\(a_r\) 修改为 \(1 - a_r\)； 如果 \(l + 1 = r\)，那么这次操作代价为 \(x\)，否则代价为 \(y\)。 本题满足 \(x \geq y\)。 输出最小的代价和，使 \(a\) 变为 \(b\)。 思路 首先，本题等效于将 \(a\) 和 \(b\) 按位异或后得到的二进制字符串 \(c\) 中所有 \(1\) 变为 \(0\) 的代价和。 其次，修改是成对的，也就是说，如果 \(1\) 的个数是奇数，那么无解。 那么，这里存在两种操作： 选择两个进行一次操作； 选择任意一个其他元素作为跳板，进行两次操作 因为操作相邻元素的代价是大于操作不相邻元素的，所以当个数多于 \(2\) 的时候，我们完全不需要考虑操作相邻的，因为我们一定可以避免取相邻的对。 而当个数为 \(2\) 时，如果相邻，我们就需要考虑执行哪种操作了，操作 \(1\) 的代价为 \(x\)，操作二的代价为 \(2y\)，那么我们取最小值即可。当然，如果不相邻，答案就是 \(y\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, x, y; cin >> n >> x >> y; string a, b; cin >> a >> b; vector&lt;int> dif; for(int i=0;i&lt;n;i++)&#123; if(a[i] != b[i]) dif.emplace_back(i); &#125; int cnt = dif.size(), ans; if(cnt % 2 == 1) ans = -1; else if(cnt == 2) ans = dif[0] + 1 == dif[1] ? min(x, 2 * y) : min(x * (dif[1] - dif[0]), y); else ans = cnt / 2 * y; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 依然还是乱猜（什]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 822 Div 2</title>
    <url>/blog/posts/30693881/</url>
    <content><![CDATA[Practice. A. Select Three Sticks 题意 给定 \(n\) 根火柴，定义操作为选定一根火柴，并将其长度加 \(1\) 或减 \(1\)。输出最小的操作数，使得所有火柴中有至少三根火柴的长度相等。 思路 很显然，我们只需将火柴按长短升序排序，然后枚举所有相邻的三元组，找出 将 左右两个元素 加减 到 与中间的元素相同 所需的操作数 的最小值 即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a.begin(), a.end()); int ans = inf; for(int i=0;i&lt;n-2;i++)&#123; ans = min(ans, a[i + 2] - a[i]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 就乱猜（ B. Bright, Nice, Brilliant 题意 给定一个 \(n\) 层的金字塔，第 \(i\) 层有 \(i\) 个房间，每个房间可选择是否点亮，点亮可以将该房间以及其 "子树" 的亮度 \(+1\)，如下图： 现在，给定金字塔的层数，输出每个房间是否点亮 \((0/1)\)，满足所有房间的亮度相同，且点亮的房间数最大。 思路 显然，我们只能按照下面的方法构造： \(\ \ \ \ \ \ \ \ 1 \\\ \ \ \ \ \ 1\ \ 1\\ \ \ \ \ 1\ \ 0\ \ 1\\\ \ 1\ \ 0\ \ 0\ \ 1\\ 1 \ \ 0\ ...\ 0\ \ 1\) 否则，中间一定会越来越大。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; cout &lt;&lt; 1 &lt;&lt; '\n'; for(int i=2;i&lt;=n;i++)&#123; cout &lt;&lt; 1 &lt;&lt; ' '; for(int j=0;j&lt;i-2;j++) cout &lt;&lt; 0 &lt;&lt; ' '; cout &lt;&lt; 1 &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 别问，问就是猜的 C. Removing Smallest Multiples 题意 给定一个长为 \(n\) 的二进制字符串，代表 \(1 - n\) 中的数字是否在序列中。 对于上述字符串描述的序列，定义操作为选择任意一个 \(k \in [1, n]\)，将序列中最小的 \(k\) 的倍数删去，代价为 \(k\)。 输出最小的代价和，将 \(n\) 的排列变为该序列。 思路 显然，一个数被他的最小因数删去是代价最小的，但我们也需要保证 比这个数更小的 它的最小因数的倍数 不在序列中，否则我们会优先删去不可以删去的元素。 所以我们可以从小到大枚举 \(k\)。 对于 \(k\)，我们枚举 \(k\) 的所有倍数（包括 \(k\) 本身），并将所有倍数的答案和 \(k\) 取最小值。 在枚举倍数的时候，只要这个倍数在字符串中对应位置为 \(1\)，那么我们直接结束枚举，因为我们会删除不必要的元素。 最后，我们直接遍历每个数的代价，求和即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; string s; cin >> s; s = " " + s; vector&lt;int> ans(n + 1, inf); int res = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j += i) &#123; if (s[j] == '1') break; ans[j] = min(ans[j], i); &#125; if (ans[i] != inf) res += ans[i]; &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 挺快的（ D. Slime Escape 题意 给定 \(n\) 个史莱姆，每个史莱姆有对应的血量，血量可以为负。给定目标史莱姆的位置，满足该史莱姆的血量为正。 规定目标史莱姆可以向左右任意移动，但每次只能移动一格，移动到对应格时会吸收该格的史莱姆（不可以重复吸收），吸收后，目标史莱姆的血量将会加上被吸收的史莱姆的血量（吸收负血量史莱姆将会扣除目标史莱姆的血量）。 输出目标史莱姆是否可以以非负的血量来到左端点或右端点。 思路 我们用双指针 \(l, r\) 表征目标史莱姆拓展的区域，显然当 \(l \leq 0\) 或 \(r \geq n\) 时到达了端点。 那么，我们只需模拟史莱姆的移动即可，我们默认向左走，那么如果不可以向左，我们就尝试向右，不能移动就结束。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n + 2), pre(n + 2); for(int i=1;i&lt;=n;i++) cin >> a[i], pre[i] = pre[i - 1] + a[i]; int l = k - 1, r = k; int l_pre = pre[l], r_pre = pre[r]; while(l > 0 &amp;&amp; r &lt; n)&#123; if(r_pre - pre[l - 1] >= 0) l_pre = min(l_pre, pre[-- l]); else if(pre[r + 1] - l_pre >= 0) r_pre = max(r_pre, pre[++ r]); else break; &#125; cout &lt;&lt; (l > 0 &amp;&amp; r &lt; n ? "NO\n" : "YES\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 这就A了？]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 823 Div 2</title>
    <url>/blog/posts/2812498512/</url>
    <content><![CDATA[Practice. A. Planets 题意 对于一个序列，定义操作为下面二选一： 序列的其中一个元素减一，代价为 \(1\)； 将某一个元素改为 \(0\)，代价为 \(c\)。 现在，给定一个序列 \(a\)，根据 \(a_i\) 的值出现的次数构造新的序列 \(c\) (\(c_i\) = \(cnt_i\))，输出将序列 \(c\) 所有元素修改为 \(0\) 所需的最小代价。 思路 判断每个元素的大小与 \(c\) 的关系，答案就是 \(\displaystyle{\sum_{i=1}^n min(cnt_i, c)}\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110; void solve()&#123; int n, c; cin >> n >> c; vector&lt;int> cnt(N); for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; cnt[cur] ++; &#125; int ans = 0; for(int i=0;i&lt;N;i++)&#123; ans += cnt[i] >= c ? c : cnt[i]; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 签到 B. Meeting on the Line 题意 给定 \(n\) 个人在数轴上的位置，以及每个人的等待时间 \(t_i\)，找出一个点 \(x_0\)，满足所有人中 每个人离 \(x_0\) 的距离 \(dist_i\) 与 \(t_i\) 的和 的最大值 最小。 思路 首先，如果没有 \(t\) 数组，那么这道题具有结论：\(x_0 = \frac{x_{max} + x_{min}}{2}\)。 此结论可以用类似递推的方式证明，有关归纳证明参考 这里。 那么，我们先假设 \(x_0\) 已知，来看看单独一个人的情况： 如果这个人位于 \(x_0\) 左侧，那么他需要的总时长为 \(x_0 - (x_i - t_i)\)；反之，他需要 \(- x_0 + (x_i + t_i)\)。 观察上述式子，我们不妨用 \(x_i - t_i\) 和 \(x_i + t_i\) 替换 \(x_i\)。 由于结论 \(x_0 = \frac{x_{max} + x_{min}}{2}\)，也就是 \(- x_0 + x_{max} = x_0 - x_{min}\)， 我们不难发现，因为 \(\max(x_i - t_i, x_i + t_i) = x_i + t_i, \min(x_i - t_i, x_i + t_i) = x_i - t_i\)，所以 取最大值和最小值时 一定可以满足 我们所取的值 就是我们在上述情况 \(1\) 中所提到的每个人需要的总时长。 因而，我们只需按照上述操作计算即可，复杂度是线性的。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> x(n), p(2 * n); for(int i=0;i&lt;n;i++) cin >> x[i]; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; p[i * 2] = x[i] + cur; p[i * 2 + 1] = x[i] - cur; &#125; int mn = inf, mx = -inf; for(int i=0;i&lt;2*n;i++) mn = min(mn, p[i]), mx = max(mx, p[i]); cout &lt;&lt; (mn + mx) / 2 &lt;&lt; ((mn + mx) % 2 == 0 ? "" : ".5") &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 好抽象的做法（ C. Minimum Notation 题意 给定一个由 \(0-9\) 内数字构成的字符串，定义操作为选择任意一个下标 \(i\)，删除 \(s_i\)，并将 \(\min(9, s_i + 1)\) 插入到任意位置。 输出任意次操作后，字符串的最小字典序。 思路 首先，除了 \(8, 9\)，我们不能对他元素操作多于一次。 其次，我们一定需要让最小的元素在开头。 那么，我们找出最小的元素 \(x\) 的初始位置，然后向后遍历，找出最后一个 \(x\) 出现的位置，然后从这个位置开始，继续找第二小的元素的初始位置和结束位置，如此循环直到遍历到字符串末尾。这样，我们可以取出一个子序列，这个子序列内的元素我们都不需要操作。 而对于其他的元素，我们只需将其加 \(1\) 并插入到对应的位置，让最后的字符串 "非降序" 即可。 上述的一个简单做法就是将取出的子序列对应的下标做上标记，然后从前往后遍历，将未标记的值加上 \(1\)。遍历结束后，将字符串升序排序即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; string s; cin >> s; int n = s.size(); vector&lt;vector&lt;int>> pre(10, vector&lt;int>(n + 1)); vector&lt;int> ed(10, -1), cnt(10, 0); for(int i=1;i&lt;=n;i++)&#123; ed[s[i - 1] - '0'] = i; cnt[s[i - 1] - '0'] ++; for(int j=0;j&lt;10;j++)&#123; pre[j][i] = pre[j][i - 1]; if(j == s[i - 1] - '0') pre[j][i] ++; &#125; &#125; int start = 0; string res; for(int i=0;i&lt;10;i++)&#123; if(ed[i] &lt;= start) continue; for(int j=0;j&lt;pre[i][ed[i]] - pre[i][start];j++) res += (char)(i + '0'); cnt[i] -= pre[i][ed[i]] - pre[i][start]; start = ed[i]; &#125; for(int i=0;i&lt;10;i++)&#123; for(int j=0;j&lt;cnt[i];j++) res += (char)(min(9ll, i + 1) + '0'); &#125; sort(res.begin(), res.end()); cout &lt;&lt; res &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 反而比B题简单 D. Prefixes and Suffixes 题意 给定两个长为 \(n\) 的字符串 \(a, b\)，定义操作为选择一个 \(k \in [1, n]\)，将 \(a\) 的前 \(k\) 个字符和 \(b\) 的后 \(k\) 个字符交换。 输出任意次操作后能否将两个字符串变为相同的字符串。 思路 我们先观察样例的操作特点，不难 得到下面的结论： 我们在不断交换 \(\{a_i, b_{n - i - 1}\}\) 的左右顺序，并更改着 \(i\) 的大小。 那么，我们只需统计 \(\{\min(a_i, b_{n - i - 1}), \max(a_i, b_{n - i - 1})\}\) 的个数，如果这个个数是偶数，那么我们一定可以将其安排在类似于 "回文" 的对称位置。 或者更具体地说，我们统计得到了 \(\color{rgb(149,117,205)}{\{a, c\}}\), \(\color{rgb(186,104,200)}{\{a, c\}}\), \(\color{rgb(124,179,66)}{\{b, d\}}\), \(\color{rgb(76,175,80)}{\{b, d\}}\), \(\color{rgb(0,172,193)}{\{b, d\}}\), \(\color{rgb(3,155,229)}{\{b, d\}}\)，那么我们一定能构造其为 \(\color{rgb(149,117,205)}{a} \color{rgb(124,179,66)}{b} \color{rgb(0,172,193)}{b} \color{rgb(3,155,229)}{d} \color{rgb(76,175,80)}{d} \color{rgb(186,104,200)}{c}\), \(\color{rgb(186,104,200)}{a} \color{rgb(76,175,80)}{b} \color{rgb(3,155,229)}{b} \color{rgb(0,172,193)}{d} \color{rgb(124,179,66)}{d} \color{rgb(149,117,205)}{c}\) （不唯一）。 上述例子的 "回文" 性体现在，如果我们将 \(abbddc\) 中 \(c\) 用 \(a\) 替换，\(d\) 用 \(b\) 替换，那么会得到 \(abbbba\)，这是回文的。 如果是奇数的话，显然我们只能把他放在中间，因而奇数个数的对最多只能有一个。 满足上述条件即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; string s1, s2; cin >> s1 >> s2; map&lt;pii, int> cnt; for(int i=0;i&lt;n;i++)&#123; pii now = &#123;s1[i], s2[n - i - 1]&#125;; if(now.fs > now.sc) swap(now.fs, now.sc); cnt[now] ++; &#125; int f = 0; for(auto e : cnt)&#123; if(e.sc % 2 == 1)&#123; f ++; if(e.fs.fs != e.fs.sc) f = -inf; &#125; &#125; cout &lt;&lt; (f >= 0 &amp;&amp; f &lt;= 1 ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 绕，但是有趣]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - 湘潭大学2023新生赛</title>
    <url>/blog/posts/1207844194/</url>
    <content><![CDATA[Practice. A. 签到啦~ 题意 给定一个序列以及一个整数 \(d\)，输出总和大于等于 \(d\) 的元素的数量的最小值。 思路 排序+枚举。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; int n, w; cin >> n >> w; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a.rbegin(), a.rend()); int ans = 0; for(int i=0;i&lt;n;i++)&#123; ans ++; w -= a[i]; if(w &lt;= 0) break; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 打卡打卡（其实后面题目也不比这个难多少 B. 熙巨打票 题意 给定两个机器，机器在操作结束后需要 \(a\) 分钟的冷却时间，每个操作需要 \(b\) 分钟。 给定操作的数量，输出完成最后一个操作的时刻。 思路 首先，如果 \(a \leq b\)，那么我们直接无视冷却时间，因为我们轮换着用机器即可。 如果 \(a &gt; b\)，我们可以画图，不难发现，除了前两个操作不需要加时间，接着每两个操作都需要 \(a + b\) 分钟。 当然，考虑到这个，我们需要分奇偶性做，奇数下会多一个操作时间 \(b\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; int a, b, n; cin >> a >> b >> n; if(a &lt;= b) cout &lt;&lt; b * n &lt;&lt; '\n'; else cout &lt;&lt; b * (2 - n % 2) + (a + b) * ((n - 1) / 2) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 做的时候漏考虑了点（ C. 三元分配 题意 给定三个部门的员工数量，按照下面的要求配对所有的员工，若不能配对输出 \(P\)，否则输出 \(R\)： 单一部门内可配对； 两个部门员工数量之和为质数可配对 思路 首先，如果总和为奇数，那么一定无法将所有员工都配对。 那么，我们来考虑总和为偶数的情况： 全都是偶数，那么一定是可以配对的； 两个奇数，一个偶数，那么很明显，除非奇数的和为 \(2\)，那么我们可以直接把这俩员工配对，否则和一定不是质数。这时，我们就需要用这个唯一的偶数来分配。具体来说，我们只需满足这个唯一的偶数大于等于 \(2\)，那么我们只需分别拿出一个员工和这两个奇数来配对，那么就会剩下三个偶数，此时一定可以分配完。当然，需要满足这个唯一的偶数分别和两个奇数相加的和都是质数。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 4e5 + 10; vector&lt;int> pri; vector&lt;bool> vis(N), is_pri(N); void init() &#123; for(int i=2; i&lt;=4e5; i++) &#123; if(!vis[i]) pri.emplace_back(i), is_pri[i] = true; for(int j=0; j&lt;pri.size(); j++) &#123; if(i * pri[j] > 4e5) break; vis[i * pri[j]] = true; if(i % pri[j] == 0) break; &#125; &#125; &#125; void solve() &#123; int a, b, c; cin >> a >> b >> c; if((a + b + c) % 2 == 1) cout &lt;&lt; "P\n"; else if(a % 2 == 0 &amp;&amp; b % 2 == 0 &amp;&amp; c % 2 == 0) cout &lt;&lt; "R\n"; else if((a + b + c) == 2) cout &lt;&lt; "R\n"; else if(((a + b) == 2 &amp;&amp; c % 2 == 0) || ((a + c) == 2 &amp;&amp; b % 2 == 0) || ((b + c) == 2 &amp;&amp; a % 2 == 0)) cout &lt;&lt; "R\n"; else if((a % 2 == 0 &amp;&amp; is_pri[a + b] &amp;&amp; is_pri[a + c] &amp;&amp; a >= 2) || (b % 2 == 0 &amp;&amp; is_pri[b + a] &amp;&amp; is_pri[b + c] &amp;&amp; b >= 2) || (c % 2 == 0 &amp;&amp; is_pri[c + a] &amp;&amp; is_pri[c + b] &amp;&amp; c >= 2)) cout &lt;&lt; "R\n"; else cout &lt;&lt; "P\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 过于复杂的分类讨论（ D. "逆"天求和 题意 给定一个质数 \(p\)，输出 \([1, p - 1]\) 内所有数在模 \(p\) 的值位于 \([1, p - 1]\) 内的逆元之和。 思路 很有趣，我们直接打表找规律，发现是个等差数列求和，套公式提交直接就过了（ 这边不给出证明，需要费马小定理的逆用。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; int n; cin >> n; cout &lt;&lt; (1 + n - 1) * (n - 1) / 2 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 确实很逆天 E. 读中国数字 题意 给定一个不超过 \(9999\ 9999\ 9999\) 的数，输出它的中文大写按照题给映射后的结果。 思路 我们按照下面的规则模拟即可： 每 \(4\) 位为一个单元，如果这个单元中出现了两个非 \(0\) 数夹了若干个 \(0\)，那么需要在中间加上 "零"。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; string s; cin >> s; while(s.size() % 4 != 0) s = "0" + s; string ans = ""; string l[3] = &#123;"Y", "W", ""&#125;; bool st1 = false, st0 = false; for(int level=0;level&lt;s.size()/4;level++)&#123; string p[4] = &#123;"K", "B", "T", ""&#125;; bool f = false; for(int i=0;i&lt;4;i++)&#123; char now = s[level * 4 + i]; if(st1 &amp;&amp; now == '0' &amp;&amp; i &lt; 3) st0 = true; if(now != '0')&#123; if(st0 &amp;&amp; st1)&#123; ans += "0"; st0 = st1 = false; &#125; ans += now; ans += p[i]; f = st1 = true; &#125; &#125; if(f) ans += l[3 - s.size() / 4 + level]; st0 = false; &#125; cout &lt;&lt; (ans == "" ? "0" : ans) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 这个零太搞人了（ F. 您有一封新邮件待接收 题意 给定一个有向图，输出位于环中的所有元素，按照升序以及给定的映射输出。 思路 因为数据量很小，我们直接暴力 \(Dfs\)，记录经过 \(100\) 次的节点，并在第 \(101\) 次经过时停止搜索即可。 时间复杂度：\(O(不大)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 4e5 + 10; vector&lt;int> e[N]; void dfs(int x, vector&lt;int> &amp;vis, set&lt;int> &amp;ans) &#123; vis[x] ++; if(vis[x] == 100) ans.emplace(x); else if(vis[x] > 100) return; for(auto c : e[x]) dfs(c, vis, ans); &#125; void solve() &#123; int n, m; cin >> n >> m; vector&lt;string> s(n); for(int i=0; i&lt;n; i++) cin >> s[i]; for(int i=1; i&lt;=n; i++) &#123; int k; cin >> k; e[i].clear(); e[i].reserve(k); while(k --) &#123; int x; cin >> x; e[i].emplace_back(x); &#125; &#125; vector&lt;int> vis(n + 1); set&lt;int> ans; dfs(m, vis, ans); if(ans.empty()) cout &lt;&lt; "No one is disturbed!" &lt;&lt; '\n'; else &#123; cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto c : ans) cout &lt;&lt; s[c - 1] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); //init(); int t = 1; cin >> t; while(t --) solve(); &#125; 怎么这么暴力（ H. 我爱XTU 题意 给定一个由 \(X,T,U\) 组成的字符串，输出三个字母数量相同的子串的个数。 思路 我们很容易就想到了前缀和。 那么我们不妨令 \(SX_i, ST_i, SU_i\) 为前 \(i\) 个数中 \(X,T,U\) 出现的个数。 对于区间 \([l, r]\)，需要满足 \(SX_r - SX_{l - 1} = ST_r - ST_{l - 1} = SU_r - SU_{l - 1}\)。 对于左边的等式，化简可得 \(SX_r - ST_r = SX_{l - 1} - ST_{l - 1}\)。 同样的，\(SX_r - SU_r = SX_{l - 1} - SU_{l - 1}\)。 这两个式子同时满足即可。 也就是说，对于二元组 \(&lt;SX_p - ST_p, SX_p - SU_p&gt;\)，我们只需找出有多少个 \(&lt;SX_q - ST_q, SX_q - SU_q&gt;\) 与之相等即可，这里我们可以用到 \(map\)。 当然，对于 \(l - 1 = 0\) 的情况，此时二元组为 \(&lt;0, 0&gt;\)，我们在遍历之前加上这个即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 4e5 + 10; void solve() &#123; map&lt;pii, int> cnt; cnt[&#123;0, 0&#125;] ++; string s; cin >> s; int n = s.size(), ans = 0; int sx = 0, st = 0, su = 0; for(int i=0;i&lt;n;i++)&#123; char now = s[i]; if(now == 'X') sx ++; else if(now == 'T') st ++; else if(now == 'U') su ++; pii cur = &#123;sx - st, st - su&#125;; ans += cnt[cur]; cnt[cur] ++; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); //init(); int t = 1; cin >> t; while(t --) solve(); &#125; 有个一摸一样的题：数据结构]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 298</title>
    <url>/blog/posts/437490184/</url>
    <content><![CDATA[Practice. A. Job Interview 题意 给定一个由 \(o, -, x\) 构成的字符串，判断字符串是否至少含有一个 \(o\)，且不包含 \(x\)。 思路 如题。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; string s; cin >> s; bool ans1 = false, ans2 = false; for(char e : s)&#123; if(e == 'o') ans1 = true; if(e == 'x') ans2 = true; &#125; cout &lt;&lt; (ans1 &amp;&amp; !ans2 ? "Yes\n" : "No\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 打卡打卡 B. Coloring Matrix 题意 给定两个 \(n \times n\) 的矩阵 \(A, B\)，定义操作为将当前矩阵顺时针旋转 \(90°\)。输出对 \(A\) 进行任意次操作后，是否存在一种情况，使得对于所有 \(A_{i, j} = 1\)，满足 \(B_{i, j} = 1\)。 思路 如题，模拟即可。 时间复杂度：\(O(4n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;vector&lt;int>> a(n ,vector&lt;int>(n)), b(n ,vector&lt;int>(n)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin >> a[i][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin >> b[i][j]; bool ans = true; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; if(a[i][j] == 1 &amp;&amp; b[i][j] == 0) ans = false; &#125; if(ans) &#123; cout &lt;&lt; "Yes\n"; return; &#125; ans = true; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; if(a[j][n - i - 1] == 1 &amp;&amp; b[i][j] == 0) ans = false; &#125; if(ans) &#123; cout &lt;&lt; "Yes\n"; return; &#125; ans = true; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; if(a[n - i - 1][n - j - 1] == 1 &amp;&amp; b[i][j] == 0) ans = false; &#125; if(ans) &#123; cout &lt;&lt; "Yes\n"; return; &#125; ans = true; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; if(a[n - j - 1][i] == 1 &amp;&amp; b[i][j] == 0) ans = false; &#125; if(ans) &#123; cout &lt;&lt; "Yes\n"; return; &#125; cout &lt;&lt; "No\n"; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 复制粘贴.jpg C. Cards Query Problem 题意 给定 \(q\) 个询问，询问为下面三者任选一： \(1\ i\ j\)，将 \(i\) 写到一张空白的卡牌上并将其塞到 \(j\) 盒子； \(2\ i\)，升序输出 \(i\) 盒子内所有卡牌的数字； \(3\ i\)，升序输出所有包含数字 \(i\) 的盒子编号，不可以重复； 按照上述条件执行对应操作。 思路 直接模拟即可。 其中，盒子可使用 \(multiset\)，卡牌可使用 \(set\)。 注意对应关系。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, q; cin >> n >> q; map&lt;int, multiset&lt;int>> box; map&lt;int, set&lt;int>> card; while(q --)&#123; int tp; cin >> tp; if(tp == 1)&#123; int i, j; cin >> i >> j; card[i].emplace(j); box[j].emplace(i); &#125;else if(tp == 2)&#123; int i; cin >> i; for(auto e : box[i]) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125;else if(tp == 3)&#123; int i; cin >> i; for(auto e : card[i]) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 别绕晕即可 D. Writing a Numeral 题意 给定一个字符串 \(S\)，初始状态下 \(S\) 为 \(1\)。 现在，给定 \(q\) 个询问，询问为下面三者任选一： \(1\ x\)，将 \(x\) 拼接到 \(S\) 的最后； \(2\)，删除 \(S\) 开头的数字； \(3\)，输出 \(S\) 转换为数字并\(\mod 998244353\) 后的值； 按照上述条件执行对应操作。 思路 我们可以用队列来维护 \(S\) 序列，以此记录开头的数字到底是什么。 这样，我们就可以直接模拟寻问 \(1\) 对应的操作。 而对于询问 \(2\)，我们直接减掉对应的值即可。其中，位数就是队列的长度 \(-1\)，我们可以用快速幂求出 \(10 ^ t\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; int qp(int a, int b)&#123; int ans = 1; while(b > 0)&#123; if(b &amp; 1) ans = ans * a % mod; a = a * a % mod; b >>= 1; &#125; return ans; &#125; void solve() &#123; int q; cin >> q; int ans = 1; queue&lt;int> nums; nums.emplace(1); while(q --)&#123; int t; cin >> t; if(t == 1)&#123; int x; cin >> x; nums.emplace(x); ans = (ans * 10 % mod + x) % mod; &#125;else if(t == 2)&#123; ans = (ans + mod - nums.front() * qp(10, nums.size() - 1) % mod) % mod; nums.pop(); &#125;else if(t == 3)&#123; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 这怎么可以用 \(java\) 的大数爆算啊，对吧（x E. Unfair Sugoroku 待补充 F. Rook Score 题意 给定一个无限大的矩阵以及其中的 \(n\) 个点的值，除此之外，其余点的值全是 \(0\)。对于一个点 \((R, C)\)，对应的总和为 \(sumR_R + sumC_C - val_{R, C}\)，即这个点所在的行和列的元素总和（交点只被计算一次）。找出一个点，满足总和最大，并输出最大总和。 思路 首先，我们固定 \(C\)，那么我们只需找出最大的 \(sumR\) 即可。 如果行和列的交点的元素值为 \(0\)，那么我们就能保证这个总和一定是最大的，因为其他的总和不减掉交点也一定比他小。 然而，如果不为 \(0\)，那么我们需要减掉交点，这时，我们得到的答案并非就是最大的，我们需要继续枚举次大值。 如上，我们循环枚举，直到交点值为 \(0\) 或者枚举完即可。 有趣的是，我们按照上述操作，再枚举 \(C\) 即可，复杂度是可行的。 时间复杂度：\(O(np)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; map&lt;pii, int> v; map&lt;int, int> mc, mr; for(int i=0;i&lt;n;i++)&#123; int R, C, X; cin >> R >> C >> X; v[&#123;R, C&#125;] = X; mr[R] += X; mc[C] += X; &#125; vector&lt;pii> vr; vr.reserve(mr.size()); //有意思的函数（不是reverse捏 for(auto r : mr) vr.emplace_back(r.second, r.first); sort(vr.rbegin(), vr.rend()); int ans = 0; for(auto C : mc)&#123; int c = C.fs, sum = C.sc; for(auto R : vr)&#123; ans = max(ans, sum + R.fs - v[&#123;R.sc, c&#125;]); if(v[&#123;R.sc, c&#125;] == 0) break; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 就离谱]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 866 Div 2</title>
    <url>/blog/posts/1909551888/</url>
    <content><![CDATA[Contestent. Rank 1674. Rating -30. 开局爽翻，越打越坐牢（ A. Yura's New Name 题意 给定一个由 "^" 和 "_" 构成的字符串，输出至少需要插入多少个 "^" 或 "_"，使字符串可被划分为若干个个 "^^" 和 "^_^"。 思路 首先，我们可以确定开头和结尾一定是 "^"，那么如果不是，统计数量。 其次，我们两个两个遍历，如果出现了两个 "_"，那么中间一定要插一个 "^"，连续的 "^" 我们不用管。 当然，我们需要特判一下只有一个 "^" 的情况（不难发现上面的做法恰好只漏了这个条件），这个情况只需补上一个 "^" 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; string s; cin >> s; int n = s.size(); int ans = 0; if(n == 1 &amp;&amp; s[0] == '^') &#123; ans ++; &#125;else &#123; if (s[0] == '_') ans++; for (int i = 1; i &lt; n; i++) &#123; if (s[i - 1] == s[i] &amp;&amp; s[i] == '_') ans++; &#125; if (s[n - 1] == '_') ans++; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜+签到 B. JoJo's Incredible Adventures 题意 给定一个长度为 \(n\) 的二进制字符串，依次循环将字符串右移一位，得到 \(n - 1\) 个新的字符串。 将所有字符串按照右移的位数升序从上往下排列，构成一个 \(n \times n\) 的矩阵。 输出矩阵中一个面积最大的矩形的面积，满足矩形内所有元素都是 \(1\)。 思路 首先，我们无法让断续的 \(1\) 构造出面积很大的矩形，因为中间有 \(0\)，不难发现就算只有一个 \(0\)，也会让面积大打折扣。 因此，我们贪心地认为：只有长度最长的连续 \(1\) 才能构造出面积最大的矩形。 我们通过 打表 找规律可以发现，这个矩形的面积是和上述连续 \(1\) 的长度有关的。 \(S = \frac{len + 1}{2}(\frac{len}{2} + 1)\)。 当然，我们需要特判一下只有 \(0\) 和只有 \(1\) 的情况，前者为 \(0\) 后者为 \(n \times n\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; string s; cin >> s; int n = s.size(); bool have0 = false, have1 = false; for(char e : s) &#123; if(e == '0') have0 = true; else have1 = true; &#125; if(!have0) &#123; cout &lt;&lt; n * n &lt;&lt; '\n'; return; &#125; if(!have1)&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; s += s; n *= 2; int mx = 0, cur = 1; for(int i=1;i&lt;n;i++)&#123; if(s[i] == '1' &amp;&amp; s[i - 1] == '1') cur ++; else&#123; mx = max(mx, cur); cur = 1; &#125; &#125; cout &lt;&lt; ((mx + 1) / 2) * (mx / 2 + 1) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 贪心？其实是乱猜（x C. Constructive Problem 题意 给定一个序列，定义 \(MEX(a)\) 为 \(a\) 中未出现的最小非负整数。定义操作为选定一个连续区间，并将区间内的所有数都更改为同一个数。在操作只能执行一次的条件下，判断是否可以将 \(MEX&#39;(a)\) 变为 \(MEX(a) + 1\)。 思路 首先，如果 \(MEX + 1\) 在原序列中只出现一次，那么直接把他改成 \(MEX\) 即可。 其次，如果 \(MEX + 1\) 未在原序列中出现，那么我们分两种情况考虑： 最大值大于 \(MEX + 1\)，那么我们直接把最大值换成 \(MEX\) 就好了； 最大值小于等于 \(MEX + 1\)，那么 \([0, MEX)\) 中至少得有一个数的数量大于 \(1\)，然后我们将这个多余的数换成 \(MEX\) 即可。 否则，我们就需要将最左边的 \(MEX + 1\) 和最右边的 \(MEX + 1\) 之间的所有数全都替换成 \(MEX\)。 替换需要满足一个条件，即替换后 \([0, MEX)\) 内的所有数仍然至少存在一个在序列内。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n), cnt(n + 10); int mx = 0; for (int i = 0; i &lt; n; i++) &#123; cin >> a[i]; if (a[i] &lt;= n + 1) cnt[a[i]]++; mx = max(mx, a[i]); &#125; int mex = 0; for (int i = 0; i &lt;= n; i++) &#123; if (!cnt[i]) &#123; mex = i; break; &#125; &#125; if (n == 1) &#123; cout &lt;&lt; (a[0] == 1 ? "YES\n" : "NO\n"); return; &#125; if (cnt[mex + 1] == 1) &#123; cout &lt;&lt; "YES\n"; return; &#125;else if (cnt[mex + 1] == 0) &#123; if (mx > mex + 1) cout &lt;&lt; "YES\n"; else &#123; for (int i = 0; i &lt; mex; i++) &#123; if (cnt[i] > 1) &#123; cout &lt;&lt; "YES\n"; return; &#125; &#125; cout &lt;&lt; "NO\n"; &#125; return; &#125; vector&lt;int> del(n + 7); bool pre = false; for (int i = 0; i &lt; n; i++) &#123; if (a[i] == mex + 1) pre = true; if (pre &amp;&amp; a[i] &lt;= n + 1) del[a[i]]++; if (del[mex + 1] == cnt[mex + 1]) break; &#125; for (int i = 0; i &lt; mex; i++) &#123; if (cnt[i] == del[i]) &#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 欠考虑了欠考虑了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 137</title>
    <url>/blog/posts/2349105074/</url>
    <content><![CDATA[Practice. A. Password 题意 给定 \([0, 9]\) 中的几个元素，按照升序排列给出。排除这些元素后，剩余的元素可作为密码的一部分。 其中，密码为 \(4\) 位数，只包含两种数字，且每种数字出现两次。 输出密码可行解的个数。 思路 首先，我们假设只包含数字 \(a, b\)，那么有 \(aabb, abba, bbaa, abab, baba\) 这 \(6\) 种可行解。 其次，我们统计出剩余 \(k\) 种数字，那么选两个的方案数就是 \(C^2_k\)。 因此，答案就是 \(6C^2_k\)。 不过，既然元素个数已经告诉我们了，那么 \(k = 10 - n\)。 因此我们完全不用管元素是什么。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve()&#123; int n; cin >> n; for(int i=0;i&lt;n;i++)&#123; int tmp; cin >> tmp; //啥用没有 &#125; cout &lt;&lt; (10 - n) * (9 - n) / 2 * 6 &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; Happy Happy Happy B. Permutation Value 题意 给定一个整数 \(n\)，构造一个排列，满足其所有连续子序列中排列的个数最少。 思路1 很直接的思路就是让连续的数用其他元素隔开。 并且，为了尽可能不构造出排列，我们就最好先隔一位填按顺序上答案，然后在剩余的位置按顺序填上剩余的数。 如 \(4\ 1\ 5\ 2\ 6\ 3\)。 时间复杂度：\(O(n)\) 思路2 我们可能会想到倒着输出，这样确实可以让前面的那些取法都不是排列，但是我们只要选择右边界为右端点，那么我们会多出 \(n - 1\) 个排列，因为有 \(1\)。 那么，很直接的思路就是把 \(1\) 直接移到第一个，然后倒序输出即可，不难发现和思路 \(1\) 得到的数量是一致的。 如 \(1\ 6\ 5\ 4\ 3\ 2\)。 时间复杂度：\(O(n)\) 对应AC代码（思路1） #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve()&#123; int n; cin >> n; if(n % 2 == 1) cout &lt;&lt; 1 &lt;&lt; ' '; for(int i=0;i&lt;n/2;i++)&#123; cout &lt;&lt; n / 2 + i + 1 + n % 2 &lt;&lt; ' ' &lt;&lt; i + 1 + n % 2 &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 思路2是题解做法（没想到居然这么简单 C. Save the Magazines 题意 给定一个长为 \(n\) 的二进制字符串 \(s\) 以及一个包含 \(n\) 个元素的序列 \(a\)。定义对于所有 \(i \in [2, n]\)，可进行下面的两个操作任选一： 若 \(s_{i - 1} = 0, s_i = 1\)，交换 \(a_{i - 1}\) 和 \(a_i\)（即传递 \(1\) 到前者）； 不进行操作 规定同一个 \(1\) 只能被传递一次。 遍历操作后的 \(s\)，若 \(s_i = 1\)，累计 \(ans += a_i\)。 输出 \(ans\) 的最大值。 思路 我们不妨遍历所有连续的 \(1\)，然后找出其中的最小值，将这个最小值剔除，用前面的 \(0\) 代替。 或者更容易实现地，我们遍历找出连续的 \(1\) 前面相邻的那个 \(0\)，并从这个 \(0\) 开始寻找最小值，并统计总和，最后这一段的价值就是 \(sum - min\)。 为了更加方便，我们不妨在第一个元素前插入 \(0\)，那么 \(0\) 一定是最小的，如果开头是 \(1\) 也不会影响答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; void solve()&#123; int n; cin >> n; string s; cin >> s; s = '0' + s; int ans = 0; for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=0;i&lt;=n;)&#123; int mn = a[i]; int sum = a[i]; int j = i + 1; while(j &lt;= n &amp;&amp; s[j] == '1')&#123; mn = min(mn, a[j]); sum += a[j]; j ++; &#125; i = j; ans += sum - mn; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 有个大蠢比没看到只能向前交换然后一直在想 \(dp\)，我不说是谁（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 865 Div 2</title>
    <url>/blog/posts/1077504397/</url>
    <content><![CDATA[Contestant. Rank 900. Rating +46. A. Ian Visits Mary 题意 给定一个点 \((a, b)\)，最多另找一个点作为支点，满足原点到该点的连线不经过其他点，或者原点到支点、支点到该点的连线都不经过其他点。 输出该点，或者支点和该点。 思路 （怎么解释得这么抽象） \((0, 0) =&gt; (a - 1, 1) =&gt; (a, b)\) 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int a, b; cin >> a >> b; cout &lt;&lt; 2 &lt;&lt; '\n'; cout &lt;&lt; a - 1 &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; '\n'; cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 抽象 B. Grid Reconstruction 题意 给定一个 \(2 \times n\) 的矩阵，将 \([1, 2n]\) 内的数字填入矩阵。 规定可以向下或向右移动，记从原点运动到 \((2, n)\) 经过的所有方格的数字为一个序列 \(a\)，序列 \(a\) 的贡献为 \(a_1 - a_2 + a_3 - a_4 + \ldots = \sum_{i=1}^k a_i \cdot (-1)^{i+1}\)。 输出一种填写方案，满足该方案下贡献的最小值为所有方案中最大。 思路 首先，我们下去后就上不来了，那么只要尽量导引其走向我们期望的最大值即可。 下面是一种构造方法： \(\begin{array}{l}2n &amp; 2 &amp; 2n - 2 &amp; 4 &amp; 2n - 4 \ldots \\ 1 &amp; n + 1 &amp; 3 &amp; n + 3 &amp; 5 \ldots\end{array}\) 很显然，既然要更小，那么从 \(2\) 开始就会向下走，可以证明这种情况是最大的。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;vector&lt;int>> ans(2, vector&lt;int>(n)); for(int i=0;i&lt;n;i+=2) ans[1][i] = i + 1; for(int i=1;i&lt;n;i+=2) ans[1][i] = n + i; for(int i=0;i&lt;n;i+=2) ans[0][i] = n * 2 - i; for(int i=1;i&lt;n;i+=2) ans[0][i] = i + 1; for(int i=0;i&lt;2;i++) &#123; for (int j = 0; j &lt; n; j++) cout &lt;&lt; ans[i][j] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜.jpg C. Ian and Array Sorting 题意 给定一个序列 \(a\)，对于所有相邻的两个元素，定义一次操作为将这两个元素的值均加上或减去 \(1\)。 输出任意次操作后能否将序列变为不递减。 思路 首先，对于三个元素 \(a_{i - 1}, a_i, a_{i + 1}\)，如果 \(a_i &lt; a_{i - 1}\)，我们就可以将 \(a_i, a_{i + 1}\) 加上 \(a_{i - 1} - a_i\)，这样就可以让前 \(i\) 个数不递减。 同理，如果 \(a_{i + 1} &lt; a_i\)，我们就可以将 \(a_i, a_{i - 1}\) 加上 \(a_{i + 1} - a_i\)，这样就可以让后 \(i\) 个数不递减。 前者可以从前向后遍历，但不能保证最后一个数会不会小于倒数第二个数；后者可以从后向前遍历，但不能保证第一个数是否大于第二个数。 如果我们依次进行上面的操作，那么我们就能保证从前向后遍历存在的问题被解决了，并且我们已经在第一次遍历的时候保证第一个数小于等于第二个数了，所以从后往前遍历存在的问题也被解决了。 因此，依次进行上面的两个操作即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=1;i&lt;n-1;i++)&#123; if(a[i] &lt; a[i - 1])&#123; a[i + 1] -= a[i]; a[i] -= a[i]; a[i + 1] += a[i - 1]; a[i] += a[i - 1]; &#125; &#125; for(int i=n-2;i>=1;i--)&#123; if(a[i + 1] &lt; a[i])&#123; a[i - 1] -= a[i]; a[i] -= a[i]; a[i - 1] += a[i + 1]; a[i] += a[i + 1]; &#125; &#125; cout &lt;&lt; (a[0] &lt;= a[1] ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 说是乱猜和贪心，但其实也挺有道理的（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 136</title>
    <url>/blog/posts/4211298084/</url>
    <content><![CDATA[Practice. A. Immobile Knight 题意 规定一个棋子只能沿着 \(1 \times 2\) 矩形的对角线行走。 给定一个棋盘的尺寸，输出让棋子无法行走的点的位置。如果点不存在，输出任意点。 思路 能走的尺寸数量有限，我们直接分类讨论，这边定义较短边为 \(n\)，较长边为 \(m\)。 \(n = 1\)，那么随便哪个点都是答案； \(n = 2或3, m = 3\)，那么中心点就是答案 其余情况，随便输出即可。 注意，输出的点一定要在棋盘内，否则是无效答案。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; bool f = n > m; if(n > m) swap(n , m); if(n == 1) cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; '\n'; else if(n == 2 &amp;&amp; m &lt;= 3 || n == 3 &amp;&amp; m == 3) &#123; if(f) swap(n, m); cout &lt;&lt; (n + 1) / 2 &lt;&lt; ' ' &lt;&lt; (m + 1) / 2 &lt;&lt; '\n'; &#125; else cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 分类讨论即可~ B. Array Recovery 题意 定义 \(d\) 序列为原非负序列 \(a\) 构造而成，构造满足 \(d_1 = a_1, d_i = |a_i - a_{i - 1}|\)。 给定 \(d\)，判断是否能唯一确定 \(a\)，若能，输出 \(a\)。 思路 首先，我们化简右式，得到 \(a_i = a_{i - 1} ± d_i\)。 因为 \(a\) 的所有元素都是非负的，因而 \(a_{i - 1} ± d_i \geq 0\)。 那么很明显了，我们既然要唯一确定 \(a\)，那么我们只能 \(+ d_i\)，而 \(- d_i\) 的条件就是 \(a_{i - 1} \geq d_i\)。 因而，只要 \(a_{i - 1} \geq d_i\)，那么就无法唯一确定，否则我们按顺序构造出原序列 \(a\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; //让它只能递增 int n; cin >> n; vector&lt;int> ans(n); cin >> ans[0]; bool f = true; for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; ans[i] = ans[i - 1] + cur; if(cur != 0 &amp;&amp; ans[i - 1] >= cur) f = false; &#125; if(f)&#123; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125;else cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 简单的构造题捏 C. Card Game 题意 给定 \(n\) 张牌，\(n\) 为偶数，每个牌具有一个数字，所有牌的数字组成的序列是长为 \(n\) 的排列。 现在，给定两个玩家 \(A, B\)，每个玩家拥有 \(\frac{n}{2}\) 张牌，规定奇数局 \(A\) 先手，偶数局 \(B\) 先手。每一局每个玩家要打出一张牌并弃置，规定后手要打出比先手大的牌，否则先手赢。所有回合结束后，若没有玩家赢，那么平局。 在所有牌的分配方案中，统计 \(A, B\) 赢的方案数以及平局的方案数，并输出这三个数\(\mod 998244353\)。 思路 首先，平局只有一种方案，我们约定一个由 \(A, B\) 组成的字符串为从 \(1\) 开始按顺序分牌的方案，那么这个方案就是 \(BAABBAABBA\ldots\) 观察不难得到，只要某个方案有一个位置的字符和上面不一样，那么就可以断定已经有玩家胜利了，并且这个位置之后的元素可以任意分配。 也就是说，我们可以采用递归的方法计算。如果前 \(n\) 个数已经确定，那么我们只需计算组合数 \(C^\frac{n}{2}_{n-1}, C^\frac{n}{2}_{n-2}\)，然后交叉累计即可（即按照 \(BA, AB, BA,\ldots\) 的顺序计算）。 当然会涉及到求组合数，因为本题数据量不大，但是数据范围大，我们不妨用 \(java\) 的大数。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; private static BigInteger fact(int to)&#123; BigInteger ans = BigInteger.ONE; for(int i=2;i&lt;=to;i++) ans = ans.multiply(BigInteger.valueOf(i)); return ans; &#125; private static BigInteger C(int n, int k)&#123; return fact(n).divide(fact(n - k)).divide(fact(k)); &#125; private static BigInteger[] calc(int n)&#123; if(n == 2) return new BigInteger[]&#123;BigInteger.ONE, BigInteger.ZERO, BigInteger.ONE&#125;; else&#123; BigInteger[] pre = calc(n - 2); return new BigInteger[]&#123;C(n - 1, n / 2).add(pre[1]), C(n - 2, n / 2).add(pre[0]), BigInteger.ONE&#125;; &#125; &#125; private static void solve(Console console) throws Exception &#123; BigInteger mod = BigInteger.valueOf(998244353); int n = console.nextInt(); for(BigInteger ans : calc(n)) console.print(ans.mod(mod) + " "); console.println(); &#125; public static void main(String[] args) throws Exception &#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0) solve(console); console.close(); &#125; //快读模板 此处略去 public static class Console implements Closeable &#123;&#125; &#125; 有点暴力.jpg]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 297</title>
    <url>/blog/posts/2326564761/</url>
    <content><![CDATA[Contestant. Rank 1053. Rating +125. A. Double Click 题意 定义两个点击时刻 \(s_1, s_2\) 的差小于等于某个值 \(D\) 时视为在靠后的时间点 \(s_2\) 时触发双击。 给定一个点击时刻的序列，判断哪个时刻触发了第一次双击。无双击输出 \(-1\)。 思路 如题，模拟即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, d; cin >> n >> d; int ans = -1; int pre; cin >> pre; for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur - pre &lt;= d &amp;&amp; ans == -1) ans = cur; pre = cur; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 再点一次返回到主页面 B. chess960 题意 给定一个由 \(KQRRBBNN\) 经过任意排列后的字符串，输出其是否满足下面的要求： \(B\) 的两个下标的奇偶性不同； \(K\) 在两个 \(R\) 中间 思路 如题，模拟即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; string s; cin >> s; int k, q; vector&lt;int> r, b, n; for(int i=0;i&lt;8;i++)&#123; char x = s[i]; if(x == 'K') k = i; else if(x == 'Q') q = i; else if(x == 'R') r.emplace_back(i); else if(x == 'B') b.emplace_back(i); else if(x == 'N') n.emplace_back(i); &#125; bool ans = true; if(b[0] % 2 == b[1] % 2) ans = false; if(k &lt; r[0] || k > r[1]) ans = false; cout &lt;&lt; (ans ?"Yes\n" : "No\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 两面包夹芝士 C. PC on the Table 题意 给定 \(H\) 个由 "." 和 "T" 组成的字符串，规定两个相邻的 \(T\) 可以替换为 \(PC\)，输出替换次数最多的一种方案。 思路 直接暴力枚举替换即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; for(int i=0;i&lt;n;i++)&#123; string s; cin >> s; for(int j=1;j&lt;m;j++)&#123; if(s[j] == s[j - 1] &amp;&amp; s[j] == 'T')&#123; s[j - 1] = 'P'; s[j] = 'C'; j ++; &#125; &#125; cout &lt;&lt; s &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; PC? D. Count Subtractions 题意 给定两个数 \(A, B\)，规定一次操作为将较大的数减去较小的数。 输出让两数相等的最小操作数。 思路 这题可以等价为重复操作直到某一个数变为 \(0\)，那么我们将计算得到的结果 \(-1\) 即可。 若 \(A &gt; B\)，那么在 \(A\) 减到小于等于 \(B\) 后，值恰好为 \(A \mod b\)，此时操作数就是 \(\lfloor\frac{a}{b}\rfloor\)。 如上，我们暴力即可。 时间复杂度：反正还行吧（ 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int a, b; cin >> a >> b; int ans = 0; while(a != 0 &amp;&amp; b != 0) &#123; if(b > a) swap(a, b); ans += a / b; a %= b; &#125; cout &lt;&lt; ans - 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 暴力暴力 E. Kth Takoyaki Set 题意 给定一个序列，通过任选数量、任选元素相加得到新的序列，序列升序且无重复元素，输出序列中第 \(k\) 个数，其中 \(k\) 给定。 思路 我们可以直接暴力。 首先，我们希望可以找到一个与当前最大值最接近的那个数，或者说，将组成最大值的某个数替换，这样通过递推就可以使构造出来的序列的相邻元素差值最小。 所以，我们不妨用 \(set\) 去重并顺便排序，对于查找与当前最大值最接近的那个数，我们可以用二分。 思路具有一定的贪心性，此处暂时不给出证明（ 时间复杂度：\(O(pn \log p)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; set&lt;int> st; st.emplace(0); while(st.size() != k + 1)&#123; int mx = *st.rbegin(), now = inf; for(int i=0;i&lt;n;i++)&#123; now = min(now, *st.upper_bound(mx - a[i]) + a[i]); &#125; st.emplace(now); &#125; cout &lt;&lt; *st.rbegin() &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 其实是不会证（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 824 Div 2</title>
    <url>/blog/posts/1644457156/</url>
    <content><![CDATA[Practice. A. Working Week 题意 给定 \(n\) 个格子，规定第 \(1\) 个格子不能标记，第 \(n\) 个格子一定被标记。按照要求标记三个点后，格子被划分成三段，记长度为 \(l_1, l_2, l_3\)。 输出 \(\min(|l_1 - l_2|, |l_2 - l_3|, |l_3 - l_1|)\) 的最大值。 思路 显然，我们可以在第二个点做上标记，这样就可以让差值尽可能大。 那么，我们来考虑剩下那个点。因为对称性，我们不妨令 \(l_2 \leq l_3\)。 很明显，\(\min(|l_1 - l_2|, |l_2 - l_3|, |l_3 - l_1|) = \min(l_2 - 1, n - 4 - 2l_2)\) 如果前者更小，那就需要满足 \(l_2 \leq \frac{n}{3} - 1\)，那么 \(l_2 - 1\) 的最大值就是 \(\frac{n}{3} - 2\)。 如果后者更小，那就需要满足 \(l_2 \geq \frac{n}{3} - 1\)，那么 \(n - 4 - 2l_2\) 的最大值就是 \(n - 4 - 2(\frac{n}{3} - 1) = \frac{n}{3} - 2\)。 所以，答案就是 \(\frac{n}{3} - 2\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve()&#123; int n; cin >> n; cout &lt;&lt; n / 3 - 2 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 其实也可以猜出来（x B. Tea with Tangerines 题意 给定长度为 \(n\) 的序列 \(a\)，其中 \(a_i\) 可切割为任意段。在切割结束后，需要满足任意两段中 较小的那段的 两倍 严格小于 较长那段。输出需要切割的最小次数。 思路 首先，我们先设最小那段为 \(x\)，在按照同一长度 \(2x-1\) 切割后，我们有可能会多出一小段长度小于 \(x\) 的，但我们显然可以各取前面长为 \(2x - 1\) 的那几段的一部分来填补，而且一定不会让前面的那几段减到比 \(x\) 小。 那么，答案就是 \(\displaystyle{\sum_{i=1}^{n}\left\lceil\frac{a_i}{2 \cdot x - 1}\right\rceil}\) 显然，我们希望尽可能减少切割次数，也就是说至少有一段是不用切的。 那么，升序排序 \(a\) 后，\(\displaystyle{\sum_{i=1}^{n}\left\lceil\frac{a_i}{2 \cdot a_1 - 1}\right\rceil}\) 就是答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve()&#123; int n; cin >> n; int ans = 0, a0; cin >> a0; for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; ans += (cur - 1) / (2 * a0 - 1); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 有点抽象 C. Phase Shift 题意 给定一个由大写字母组成的字符串，构造一个字符串映射，满足映射对应的有向图为一个包含 \(A - Z\) 内所有字母的单环。 输出映射后字典序最小的结果。 思路 我们可以暴力枚举每一位，对于该位，如果我们并没有创建映射，我们就暴力按字母表顺序枚举所有字母，找出第一个没有被创建且和原字母不一样的字母并创建映射；如果创建了映射，我们直接使用该映射即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n; string t; cin >> n >> t; vector&lt;int> e(26, -1), re(26, -1); for(int i=0;i&lt;n;i++)&#123; int cur = t[i] - 'a'; if(e[cur] == -1) &#123; for (int j = 0; j &lt; 26; j++) &#123; if (re[j] == -1) &#123; int last = j, cnt = 0; while (e[last] != -1) last = e[last], cnt++; if (last != cur || cnt == 25) &#123; e[cur] = j, re[j] = cur; break; &#125; &#125; &#125; &#125; t[i] = (char) (e[cur] + 'a'); &#125; cout &lt;&lt; t &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 就很暴力（x D. Meta-set 题意 给定 \(n\) 个长度为 \(m\) 的序列，序列元素由 \(0, 1, 2\) 构成。 若一个 由 \(3\) 个不同序列 组成的三元组 满足 对于 所有序列的 第 \(i\) 个元素组成的 新序列 均为相等的值或为 \(012\) 的排列，那么这个三元组是好的。 输出序列的所有五元组中 有至少两个好三元组 的个数。 思路 （题意还是介绍得有点绕，可以去看原题的样例） 首先，数据量并不大，\(O(n ^ 2)\) 的复杂度是完全可以接受的，那么我们不妨去枚举所有的三元组中的其中两个序列，然后我们就可以按照题意构造出第三个序列，我们直接记录构造出的这个序列可以对应多少个 "两个序列"。 记录完后，我们直接枚举所有序列，对于对应的个数 \(cnt\)，我们就可以得到 \(C^2_{cnt}\) 个满足条件的五元组。 时间复杂度：\(O(n^2 \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, k; cin >> n >> k; vector&lt;vector&lt;int>> a(n, vector&lt;int>(k)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;k;j++) cin >> a[i][j]; map&lt;vector&lt;int>, int> cnt; for(int i=0;i&lt;n;i++) for(int j=i+1;j&lt;n;j++)&#123; vector&lt;int> need(k); for(int t=0;t&lt;k;t++)&#123; need[t] = a[i][t] == a[j][t] ? a[i][t] : 3 - a[i][t] - a[j][t]; &#125; cnt[need] ++; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; if(cnt[a[i]] >= 2) ans += cnt[a[i]] * (cnt[a[i]] - 1) / 2; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 有点像状压]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 825 Div 2</title>
    <url>/blog/posts/3295897463/</url>
    <content><![CDATA[Practice. A. Make A Equal to B 题意 给定两个长度为 \(n\) 的二进制序列 \(a, b\)，定义操作如下： 选择任意 \(i\)，将 \(a_i\) 改为 \(1 - a_i\)； 任意排序 \(a\) 输出操作数的最小值。 思路 很显然，我们直接统计两个序列中 \(0, 1\) 的个数，然后在 将 \(0\) 的个数变为一致需要的操作数 和 将 \(1\) 的个数变为一致需要的操作数 中取最小值即可。此时，答案为最小操作数 \(+ 1\)。 当然，如果只需改一次，我们就不用排序了，所以我们顺便计算一下按原顺序排列的情况下有多少数不一样，最后和答案取最小值即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; int c1 = 0, c2 = 0, d1 = 0, d2 = 0; vector&lt;int> a(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; if(a[i] == 0) c1 ++; else c2 ++; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur != a[i]) ans ++; if(cur == 0) d1 ++; else d2 ++; &#125; ans = min(ans, (abs(c1 - d1) + abs(c2 - d2)) / 2 + 1); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 思路后面那个容易没考虑到捏 B. Playing with GCD 题意 给定一个长度为 \(n\) 的数组 \(a\)，输出是否能构造出一个长度为 \(n + 1\) 的数组 \(b\)，满足 \(a_i = gcd(b_i, b_{i + 1})\)。 思路 首先，只有当 \(gcd(lcm(a_{i - 1}, a_i), lcm(a_i, a_{i + 1})) = a_i\) 的时候才有解，否则我们会很轻松将 \(a_i\) 变为 \(k a_i\)，甚至为 \(1\)。 那么，我们直接计算出所有的 \(b_i\)，然后枚举即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1), b(n + 2); for(int i=1;i&lt;=n;i++) cin >> a[i]; b[1] = a[1], b[n + 1] = a[n]; for(int i=2;i&lt;=n;i++) b[i] = lcm(a[i - 1], a[i]); bool f = true; for(int i=1;i&lt;=n;i++)&#123; if(gcd(b[i], b[i + 1]) != a[i]) f = false; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 但其实我并不会严格证明（x C1. Good Subarrays (Easy Version) 题意 定义 如果一个序列 \(p\) 满足所有 \(p_i \geq i\)，那么这个序列是好的。 给定一个序列 \(a\)，输出它的所有连续子序列中 好序列 的个数。 思路 我们固定左边界来计算右边界能到达哪里，显然，当 \(a_r &lt; r - l + 1\) 时 \(r\) 不满足题意。 因为右边界肯定不会回退（既然 \(p_i \geq i\)，那么 \(p_i &gt; i - 1\)），那么我们可以直接循环，得到一个 \(O(n)\) 复杂度的解法。 这种暴力做法不可以用到 \(C2\) 中，而是需要改进为 \(dp\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++)cin >> a[i]; int ans = 0; int r=1; for(int l = 1;l&lt;=n;l++) &#123; while (r &lt;= n &amp;&amp; a[r] >= r - l + 1) r++; ans += r - l; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 就很无脑]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 864 Div 2</title>
    <url>/blog/posts/3863896633/</url>
    <content><![CDATA[Contestant. Rank 1888. Rating +1. 查重后刚好加了一分（跟白打没区别 A. Li Hua and Maze 题意 给定一个 \(n \times m\) 的矩阵以及两个点 \((x_1, y_1), (x_2, y_2)\)。其中，两点满足 \(|x_1-x_2|+|y_1-y_2|\geq 2\)。在矩阵中插入若干个障碍，使得两点不连通。 输出需要插入的最少障碍数。 思路 很显然，我们把起点或者终点包起来即可。 不要写错就是 \(win\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, m, x1, y1, x2, y2; cin >> n >> m >> x1 >> y1 >> x2 >> y2; int ans = 4; if(x1 == 1 || y1 == 1 || x2 == 1 || y2 == 1 || x1 == n || y1 == m || x2 == n || y2 == m) ans = 3; if(((x1 == 1 || x1 == n) &amp;&amp; (y1 == 1 || y1 == m)) || ((x2 == 1 || x2 == n) &amp;&amp; (y2 == 1 || y2 == m))) ans = 2; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 我为什么会写错啊啊啊啊啊啊（艹 B. Li Hua and Pattern 题意 给定一个 \(n \times n\) 的矩阵，以及矩阵中若干标记点的坐标。定义一次操作可以取消或加上标记，现在给定操作数 \(k\)，在操作数用完的条件下，输出是否可以让整个矩阵旋转 \(180°\) 后和旋转前一样。 思路 首先，\(180°\) 旋转后，如果 \(n\) 为奇数，那么中心点是不会变的，也就是说 \(k\) 多余时可以全都操作在中心点上。 其次，题面等价于“将原矩阵旋转 \(180°\) 后进行操作，使其和原矩阵一致”。 那么，我们旋转后统计不一样的格子的个数 \(cnt\)。 我们不难发现，\(cnt\) 一定是偶数，因为具有对称性。而恰恰因为这个，我们只需 \(\frac{cnt}{2}\) 次操作即可让矩阵满足条件。 那么，如果操作数不够，就直接输出 \(NO\)。 否则，\(n\) 为偶数的时候，我们就需要考虑剩余操作数的奇偶性。因为在同一个点上操作两次等价于没有操作，所以当剩余的数量为偶数时，输出 \(YES\)，否则是 \(NO\)。 \(n\) 是奇数的时候，就和思路的第一句话所说的那样，直接判 \(YES\) 即可。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, k; cin >> n >> k; vector&lt;vector&lt;int>> a(n, vector&lt;int>(n)), b(n, vector&lt;int>(n)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; cin >> a[i][j]; b[n - i - 1][n - j - 1] = a[i][j]; &#125; int dif = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(a[i][j] != b[i][j]) dif ++; dif /= 2; if(dif > k)&#123; cout &lt;&lt; "NO\n"; return; &#125; k -= dif; cout &lt;&lt; (n % 2 == 1 || k % 2 == 0 ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 我怎么就没想到 \(n\) 的奇偶性呢 C. Li Hua and Chess 题意 这是一道互动题。 给定一个 \(n \times m\) 的矩阵，定义一个棋子一次可以从 \(8\) 个方向移动一格或 \(\sqrt 2\) 格。 现在，在最多询问 \(3\) 次的前提下，每次询问给出一个坐标，将会得到目标棋子走到这个坐标的最少次数。 判断目标棋子的位置，并输出坐标。 思路 首先，我们从 \((1, 1)\) 展开我们的询问。 我们会得到一个数 \(t\)，通过画图我们可以看到，同一次数对应的下标集合是 \(L\) 型的，而超出 \(\min(n, m)\) 后对应的集合是一个 长或宽为 \(1\) 的长方形。 对于后者，我们可以根据 \(n, m\) 的大小确定 \(t + 1\) 是所求点的横/纵坐标，那么我们只需将未知的坐标记为 \(1\)，继续询问，所得到的 \(p + 1\) 即为未知的那个坐标，最后输出即可。 对于前者，我们最多还需问两次（不问白不问，我们直接问 \(2\) 次吧）： 询问 \((t + 1, t + 1)\)，我们得到 \(p\)，那么 \((t + 1 - p, t + 1), (t + 1, t + 1 - p)\) 其中之一就是我们需要的答案 我们询问任意一个，如 \((t + 1 - p, t + 1)\)，如果得到 \(0\)，那么这个点就是我们要的，否则另外一个点就是我们要的。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; cout &lt;&lt; "? 1 1\n"; cout.flush(); int t; cin >> t; if(t >= min(n, m))&#123; if(n > m)&#123; cout &lt;&lt; "? " &lt;&lt; t + 1 &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; '\n'; cout.flush(); int p; cin >> p; cout &lt;&lt; "! " &lt;&lt; t + 1 &lt;&lt; ' ' &lt;&lt; p + 1 &lt;&lt; '\n'; cout.flush(); &#125;else&#123; cout &lt;&lt; "? " &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; t + 1 &lt;&lt; '\n'; cout.flush(); int p; cin >> p; cout &lt;&lt; "! " &lt;&lt; p + 1 &lt;&lt; ' ' &lt;&lt; t + 1 &lt;&lt; '\n'; cout.flush(); &#125; &#125;else&#123; cout &lt;&lt; "? " &lt;&lt; t + 1 &lt;&lt; ' ' &lt;&lt; t + 1 &lt;&lt; '\n'; cout.flush(); int p; cin >> p; cout &lt;&lt; "? " &lt;&lt; t + 1 - p &lt;&lt; ' ' &lt;&lt; t + 1 &lt;&lt; '\n'; cout.flush(); int q; cin >> q; if(q == 0) cout &lt;&lt; "! " &lt;&lt; t + 1 - p &lt;&lt; ' ' &lt;&lt; t + 1 &lt;&lt; '\n'; else cout &lt;&lt; "! " &lt;&lt; t + 1 &lt;&lt; ' ' &lt;&lt; t + 1 - p &lt;&lt; '\n'; cout.flush(); &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 是哪个大铸币想着用 \(3\) 个边角去算啊，我不说是谁（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 826 Div 3</title>
    <url>/blog/posts/2191281532/</url>
    <content><![CDATA[Practice. A. Compare T-Shirt Sizes 题意 比较 \(T\) 恤的尺码。 其中，\(XXL &gt; XL, XXS &lt; XS\)。 思路 我们记 \(M = 0\)，其余的按照 \(X\) 的个数计算即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string a, b; cin >> a >> b; int na = a.size(), nb = b.size(); map&lt;char, int> mp = &#123;&#123;'S', -1&#125;, &#123;'M', 0&#125;, &#123;'L', 1&#125;&#125;; int va = mp[a[na - 1]] * na, vb = mp[b[nb - 1]] * nb; cout &lt;&lt; (va == vb ? '=' : (va > vb ? '>' : '&lt;')) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 无脑做即可 B. Funny Permutation 题意 给定整数 \(n\)，构造一个长为 \(n\) 的排列 \(a\)，满足 \(a_i\) 的至少一个相邻元素的值为 \(a_i ±1\)，且 \(a_i \neq i\)。 思路 首先，如果没有第二个条件，我们直接按顺序输出即可。 如果考虑第二个条件，如果 \(n\) 为偶数，那我们直接倒着输出即可。 但 \(n\) 为奇数的时候，我们就需要规避中间那个数不满足条件的情况了。 如何规避呢？我们只需先按顺序构造序列，然后把前 \(\frac{n + 1}{2}\) 个数移到最后就可以了。 可以证明，这种构造对任意长度的排列均满足。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; if (n == 3) cout &lt;&lt; -1 &lt;&lt; '\n'; else &#123; for(int i=n;i>n/2 + n % 2;i--) cout &lt;&lt; i &lt;&lt; ' '; for(int i=1;i&lt;=n/2+n%2;i++) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 很有趣的构造题（x C. Minimize the Thickness 题意 给定一个序列，将其分割为若干段 元素和相等 的片段，输出最长片段的长度最小值。 思路 很暴力。我们直接枚举第一段的长度，然后去分割，找出最长片段。最后我们统计最小值即可。 时间复杂度：\(O(n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> sum(n + 1); for(int i=1;i&lt;=n;i++) &#123; int cur; cin >> cur; sum[i] = sum[i - 1] + cur; &#125; auto check = [n, sum](int cnt)&#123; bool ans = true; int pre = 0, mx = cnt; for(int i=1;i&lt;=n;i++)&#123; if(sum[i] - sum[pre] > sum[cnt])&#123; ans = false; break; &#125;else if(sum[i] - sum[pre] == sum[cnt])&#123; mx = max(mx, i - pre); pre = i; &#125; &#125; return make_pair(mx, ans &amp;&amp; pre == n); &#125;; int ans = n; for(int i=1;i&lt;=n;i++)&#123; auto e = check(i); if(e.sc) ans = min(ans, e.fs); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 无脑暴力.cpp D. Masha and a Beautiful Tree 题意 给定一个满二叉树的所有叶节点的编号，规定编号序列为长度为 \(n\) 的排列。 判断是否可以通过 若干次 交换 任意 左右子树的位置 来让排列升序，若可以，输出最小操作数。 思路 显然，我们不难发现，两个父亲一样的叶节点的值相差 \(1\)。 有趣的是，我们规定这些父亲节点（即第二层叶节点）的值为子节点的最大值除以 \(2\)，那么依然需要满足上面的条件。 也就是说，我们只需从最底层向上合并并判断即可。 在每次判断的时候，我们比较一下左右两个节点的大小，如果左边的大，那么就需要一次操作，统计即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> ori(n); for(int i=0;i&lt;n;i++) cin >> ori[i]; int p = 0, tp = n; while(tp > 0) tp /= 2, p ++; int ans = 0; for(int i=1;i&lt;p;i++)&#123; int cnt = n / pow(2, i); vector&lt;int> now(cnt); for(int j=0;j&lt;cnt;j++)&#123; if(abs(ori[j * 2] - ori[j * 2 + 1]) != 1)&#123; ans = -1; break; &#125; if(ori[j * 2] > ori[j * 2 + 1]) ans ++; now[j] = (ori[j * 2] + 1) / 2; &#125; if(ans == -1) break; ori = now; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 找规律.jpg E. Sending a Sequence Over the Network 题意 给定一种处理方式：将给定序列拆成若干段，在每段的前面或后面插入这一段的长度。 现在，给定一个序列，判断是否为处理后的序列。 思路 我们不妨考虑递推，即 \(dp\)，用递推的方式记录当前位置之前的元素是否满足条件。 那么， 如果这个数是个数： 他是前面序列的个数，那么 \(dp[i]\ |= dp[i - a_i - 1]\) （该序列有效，那么 \(dp_i\) 和跳过这个序列的前一个序列的 \(dp\) 值有关） 他是后面序列的个数，那么 \(dp[i + a_i]\ |= dp[i - 1]\)。 最后，\(dp[n]\) 即为答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> dp(n + 1); dp[0] = true; for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; if(i - cur >= 1) dp[i] |= dp[i - cur - 1]; if(i + cur &lt;= n) dp[i + cur] |= dp[i - 1]; &#125; cout &lt;&lt; (dp[n] ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 嘶，想到了还真不难]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 146</title>
    <url>/blog/posts/3024280035/</url>
    <content><![CDATA[Contestant. Rank 3437. Unrated. A. Coins 题意 给定 \(n, k\)，输出是否可以找到一对整数 \(x, y\)，满足 \(2 \cdot x + k \cdot y = n\)。 思路 移项可得，\(x = \frac{n - ky}{2}\)。 那么，只要分母是偶数即可。 也就是说，我们考虑 \(n, k\) 的奇偶性：当 \(n\) 为奇数，\(k\) 为偶数的时候就无法满足。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, k; cin >> n >> k; if(n % 2 == 0) cout &lt;&lt; "YES\n"; else&#123; if(k % 2 == 0) cout &lt;&lt; "NO\n"; else cout &lt;&lt; "YES\n"; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 移个项就ok力 B. Long Legs 题意 给定坐标 \((x, y)\)，定义操作如下三选一： \((x, y) =&gt; (x + m, y)\) \((x, y) =&gt; (x, y + m)\) \(m = m + 1\) 输出从坐标原点到 \((x, y)\) 需要的最小操作数。 思路 我们先假设最后的 \(m\) 值已知，对于横坐标 \(x\)： 如果 \(x \% m = 0\)，那么走 \(\frac{x}{m}\) 步即可 如果 \(x \% m \neq 0\)，那么我们会多出 \(x - \lfloor \frac{x}{m} \rfloor m\) 步，不难发现多出来的步数小于 \(m\)。 那么，我们直接在 \(m\) 递增到 \(x - \lfloor \frac{x}{m} \rfloor m\) 的时候走一步即可。因此，最后需要 \(\lceil \frac{x}{m} \rceil\) 步。 对于 \(m\)，暴力枚举即可。 有趣的是，我们只需枚举到 \(3e5\)，对于枚举到的 \(i\)，我们分别将 \(m\) 赋为 \(i, \frac{\max(a, b)}{i}\) 计算即可。 时间复杂度：\(O(3e5)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; int cal(int a, int b, int&amp; ans, int i) &#123; int cur = i - 1; if(a % i != 0) cur ++; if(b % i != 0) cur ++; cur += a / i + b / i; ans = min(ans, cur); return ans; &#125; void solve() &#123; int a, b; cin >> a >> b; if(a > b) swap(a, b); int ans = inf; for(int i=0;i&lt;=3e5;i++)&#123; ans = cal(a, b, ans, i + 1); if(i != 0) ans = cal(a, b, ans, b / i + 1); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 笑死，卡半天快速算 \(m\) 的方法，结果只要暴力。暴力没写好还 \(fst\) 了（恼 C. Search in Parallel 题意 给定 \(n\) 中颜色，两个机器人可以按照指定序列按照给定的时间间隔 \(s_1, s_2\) 访问颜色。 现在，给定每个颜色需要访问的次数，输出两个机器人的访问序列，使最后需要的总时长最小。 思路 贪心。 我们先按照需要访问的次数排个序，然后依次遍历。 如果这个数放到第一个机器人的序列中，那么循环一次需要 \(s_1(n_a + 1)\) 个单位时间。同理，第二个需要 \(s_2(n_b + 1)\)。 那么，我们一定希望需要的时间更少，所以我们比较上面的值，然后放到较小的那个对应的序列中即可。 如何证明呢？因为之后放入元素后，会导致循环一次的时间变大，所以尽早放入是最佳选择。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, s1, s2; cin >> n >> s1 >> s2; vector&lt;pii> r(n); for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; r[i] = &#123;cur, i + 1&#125;; &#125; sort(r.rbegin(), r.rend()); vector&lt;int> a, b; for(int i=0;i&lt;n;i++)&#123; if((a.size() + 1) * s1 &lt; (b.size() + 1) * s2) a.emplace_back(r[i].sc); else b.emplace_back(r[i].sc); &#125; cout &lt;&lt; a.size() &lt;&lt; ' '; for(auto e : a) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; cout &lt;&lt; b.size() &lt;&lt; ' '; for(auto e : b) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 无脑乱猜即可（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 863 Div 3</title>
    <url>/blog/posts/1424911393/</url>
    <content><![CDATA[Contestant(alt). Rank 993. Rating +168. A. Insert Digit 题意 给定一个数 \(a\)，以及一个 \([0, 9]\) 的数 \(b\)，将 \(b\) 插入 \(a\)，输出最大的数。 思路 我们从后往前找出最后一个小于 \(b\) 的数，放在这个数前面就可以让结果最大。 当然，如果没有比它小的数，直接放在最后即可。 时间复杂度：\(O(n)\) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n; char d; string w; cin >> n >> d >> w; int idx = n; for(int i=n-1;i>=0;i--)&#123; if(w[i] &lt; d) &#123; idx = i; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(i == idx) cout &lt;&lt; d; cout &lt;&lt; w[i]; if(i == n - 1 &amp;&amp; idx == n) cout &lt;&lt; d; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 很简单的贪心捏（我怎么做了这么久 B. Conveyor Belts 题意 给定一个 \(n \times n\) 的矩阵，\(n\) 为偶数。将矩阵从外向里分层为 \(\frac{n}{2}\) 圈，如下图所示： 给定两个点，输出从一个点走到另一个点需要跨越的边界的最少数量。 思路 首先，这个图是对称的，那么我们只需把点全都对阵到左上角即可。 那么，我们规定最外层是第 \(1\) 层，以此类推，我们可以得到： 对于 \((x, y)\)，它位于第 \(\min(x, y)\) 层。 那么，我们取差值的绝对值即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, x1, y1, x2, y2; cin >> n >> x1 >> y1 >> x2 >> y2; if(x1 > n / 2) x1 = n - x1 + 1; if(y1 > n / 2) y1 = n - y1 + 1; if(x2 > n / 2) x2 = n - x2 + 1; if(y2 > n / 2) y2 = n - y2 + 1; int i1 = min(x1, y1), i2 = min(x2, y2); cout &lt;&lt; abs(i1 - i2) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 我怎么那么蠢，会卡这么久（ C. Restore the Array 题意 定义对于一个数组 \(a\)，循环遍历 \([1, n-1]\)，将所有 \(\max(a_i, a_{i + 1})\) 提取出来作为新的数组。 现在给定操作后的数组，构建出一个可能的原数组，保证一定能构造出。 思路 记原数组为 \(a\)，新数组为 \(b\)。 那么，我们来考虑 \(\max(\min(b_{i - 1}, b_i), \min(b_i, b_{i + 1}))\)，我们可以经过分类讨论得到最后的答案为 \(b_i\)。 也就是说，\(a_i = \min(b_i, b_{i + 1})\)。 对于边界，\(\max(b_1, \min(b_1, b_2)) = b_1, \max(\min(b_{n - 2}, b_{n - 1})) = b_{n - 1}\)。 也就是说，\(a_1 = b_1, a_n = b_{n - 1}\)。 按照上述结论构造即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n - 1); for(int i=0;i&lt;n - 1;i++) cin >> a[i]; for(int i=0;i&lt;n;i++)&#123; if(i == 0) cout &lt;&lt; a[0] &lt;&lt; ' '; else if(i == n - 1) cout &lt;&lt; a[n - 2] &lt;&lt; ' '; else cout &lt;&lt; min(a[i - 1], a[i]) &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 有煞笔，我不说是谁 D. Umka and a Long Flight 题意 记 \(F(x)\) 为第 \(x\) 个斐波那契数。给定长为 \(F(n)\)，宽为 \(F(n + 1)\) 的矩阵，矩阵中 \((x, y)\) 被标记。将矩阵分割为 \(n - 1\) 个子矩阵，满足下面的条件： 被标记的点位于一个长为 \(1\) 或 宽为 \(1\) 的矩阵内 无长宽均重复的矩阵 所有矩阵的边长都是斐波那契数 输出是否可以满足条件。 思路 显然，要变为边长为 \(1\) 的矩阵，我们就需要按斐波那契数的计算方式分割。 我们将宽切割为 \(F(n), F(n - 1)\)，判断点落在哪个区域，为方便计算，我们直接改变点的坐标，让点落在较小的区域即可。 切割之后，我们翻转横纵坐标即可。 这样操作的话，我们可以发现，\(y \in (F(n) - F(n - 1), F(n - 1)]\) 时， 也就是卡在中间的情况，这时最后构造出的分隔方法无法满足条件 \(2\)。 如上，循环判断即可。 斐波那契数可以预先初始化。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; int f[50]; void init()&#123; f[1] = f[2] = 1; for(int i=3;i&lt;=49;i++) f[i] = f[i - 1] + f[i - 2]; &#125; void solve() &#123; int n, x, y; cin >> n >> x >> y; int t = n + 1; while(t > 1)&#123; if(y &lt;= f[t] &amp;&amp; y > f[t + 1] - f[t])&#123; cout &lt;&lt; "NO\n"; return; &#125; if(y >= f[t]) y -= f[t]; t --; swap(x, y); &#125; if(t == 1) cout &lt;&lt; "YES\n"; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 复杂但是很形象之 E. Living Sequence 题意 去掉所有包含 \(4\) 的数字，从大到小排序后，对于所有询问，输出第 \(x\) 个数。 思路 等价于去掉 \(9\)，也就是说，在 \(8\) 的时候就进一了，不难发现就是 \(9\) 进制。 转 \(9\) 进制后，将所有大于等于 \(4\) 的数字加一即可。 时间复杂度：\(O(\log_9n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> ans; while(n > 0)&#123; ans.emplace_back(n % 9); n /= 9; &#125; for(int i=ans.size()-1;i>=0;i--)&#123; if(ans[i] >= 4) cout &lt;&lt; ans[i] + 1; else cout &lt;&lt; ans[i]; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 为什么这题比 A 还简单（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 862 Div 2</title>
    <url>/blog/posts/2241746691/</url>
    <content><![CDATA[Contestant. Rank 2150. Rating -3. A. We Need the Zero 题意 给定序列 \(a\)，判断是否存在一个数 \(x\)，使 \((a_1 \oplus x) \oplus (a_2 \oplus x) \oplus ... \oplus (a_n \oplus x) = 0\)。若存在，输出这个数，否则输出 \(-1\)。 思路 很显然，异或是具有交换律的，也就是说，我们不妨记 \(p = a_1 \oplus a_2 \oplus ... \oplus a_n\)。 因为两个相同的数异或值为 \(0\)，所以我们只需考虑 \(n\) 的奇偶性。 如果 \(n\) 为奇数，那么我们只需让 \(x = p\)，否则就需要 \(p = 0\)，不然无解。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; ans ^= cur; &#125; cout &lt;&lt; (ans != 0 &amp;&amp; n % 2 == 0 ? -1 : ans) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 找找规律~ B. The String Has a Target 题意 给定一个由小写字母组成的字符串，任选一个字母并将其移动到字符串的开头，使整个字符串的字典序最小。输出这个最小的字典序。 思路 显然，我们只需把一个小的字符移上来就好了。 或者，更具体地说，我们只需找出字符串中最小的那个字符，然后将其移动到第一个即可。 当然，如果第一个使最小的，不管即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; string s; cin >> n >> s; int mn = 0; for(int i=1;i&lt;n;i++)&#123; if(s[i] &lt;= s[mn]) mn = i; &#125; cout &lt;&lt; s[mn]; for(int i=0;i&lt;=mn-1;i++) cout &lt;&lt; s[i]; for(int i=mn + 1;i&lt;n;i++) cout &lt;&lt; s[i]; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 《Div. 2 B题》 C. Place for a Selfie 题意 给定若干数量两种函数的系数，函数分别为 \(y = kx, y = a x ^ 2 + b x + c\)。 对于所有的二次函数，找出一条直线，使其与二次函数没有交点。若能找到，输出斜率 \(k\)。 思路 首先，对于直线和二次函数，我们将其联立，可得 \(a x ^ 2 + (b - k) x + c = 0\)。 也就是说，只要满足 \(\Delta = (b - k) ^ 2 - 4 a c &lt; 0\) 即可。 提取出 \(k\)，我们可得 \(b - \sqrt{4ac} &lt; k &lt; b + \sqrt{4ac}\)。 那么，我们只需二分，找出边界即可。 对于二分，我们可以用 原数字和相反数的 \(upperbound\)，这样即可快速求出。 注意，合理使用 \(int\) 类型的强制转换，\(double\) 只会向 \(0\) 的方向取整，而不都是向下取整。 时间复杂度：\(O(n \log m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; vector&lt;int> p(n + 2, inf); p[0] = -inf; vector&lt;int> q(n + 2, -inf); q[0] = inf; for(int i=1;i&lt;=n;i++) &#123; cin >> p[i]; q[i] = -p[i]; &#125; sort(p.begin(), p.end()); sort(q.begin(), q.end()); while(m --)&#123; double a, b, c; cin >> a >> b >> c; if(a * c &lt; 0)&#123; cout &lt;&lt; "NO\n"; continue; &#125; double sq = sqrt(4 * a * c); double lk = b - sq, rk = b + sq; if(rk &lt;= p[1] || lk >= p[n])&#123; cout &lt;&lt; "NO\n"; continue; &#125; int l = upper_bound(p.begin(), p.end(), (int) floor(lk)) - p.begin(), r = n - (upper_bound(q.begin(), q.end(), (int) floor(-rk)) - q.begin()) + 1; if(l > r)&#123; cout &lt;&lt; "NO\n"; &#125;else&#123; cout &lt;&lt; "YES\n"; cout &lt;&lt; p[l] &lt;&lt; '\n'; &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 草，相反数 \(upperbound\) 真好用（x D. A Wide, Wide Graph 题意 给定一个边权为 \(1\) 的无向无环图，对于 \(k \in [1, n]\)，输出以距离 \(k\) 为边连结得到的图中连通块的个数。 如 \(1 -2 -3 -4 -5\)，\(k = 2\) 的时候 \(1 -3, 2 - 4, 3 - 5\)，可以发现连通块个数为 \(1\)。 思路 我们不妨考虑 \(k = 1\) 的情况，然后逐一递增。 首先，对于一个点，若它到所有点的最大距离 \(p &lt; k\)，那么这个点无法被连接上，而反之，就可以被连上。 如果一个点连不上了，那么连通块的个数会增加。有趣的是，既然这个点无法和其他点连接，那么他一定是孤立的单点。 为什么呢？因为我们在逐一减小剔除的时候，已经把它旁边的全都拿掉了，那么自然会成为单点。 那么，我们不妨用 \(Dfs\) 的方法，找出所有点到其他点的最大距离，然后排个序，计算答案即可。 我们可以正反跑两遍，来找出最大的距离。 时间复杂度：不会分析捏 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; vector&lt;int> e[N]; void dfs(int x, int f, int st, int &amp;mx, vector&lt;int> &amp;out)&#123; out[x] = st; if(out[mx] &lt; out[x]) mx = x; for(auto w : e[x])&#123; if(w == f) continue; dfs(w, x, st + 1, mx, out); &#125; &#125; void solve() &#123; int n; cin >> n; for(int i=0;i&lt;n-1;i++)&#123; int u, v; cin >> u >> v; u --, v --; e[u].emplace_back(v); e[v].emplace_back(u); &#125; int a = 0; vector&lt;int> tv(n); dfs(0, -1, 0, a, tv); vector&lt;int> f1(n), f2(n); int b = 0, ti = 0; dfs(a, -1, 0, b, f1); dfs(b, -1, 0, ti, f2); for(int i=0;i&lt;n;i++) f2[i] = max(f1[i], f2[i]); sort(f2.begin(), f2.end()); int ans = 0; for(int i=1;i&lt;=n;i++)&#123; while(ans &lt; n - 1 &amp;&amp; f2[ans] &lt; i) ans ++; cout &lt;&lt; ans + 1 &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 嘶，有点抽象（ F1. Survival of the Weakest (easy version) 题意 定义 \(F(a_1, a_2, \ldots, a_n)\) 为任意两个元素相加得到的新集合的前 \(n - 1\) 小项构成的新集合。给定一个序列，求出 \(n - 1\) 次操作后最终的值的最大值。 思路 首先！我们来试试暴力！ 暴力如何解呢？我们将新集合构造出来，然后排序，最后取前 \(n - 1\) 项覆盖原集合。 排序直接用 \(multiset\) 就好了，会快一点。 不过，这里会有一个问题，因为我们需要排序，所以我们不可以取模，但这样会导致爆 \(int\)。 那么，我们不妨在每次做完后，将所有元素减掉最小值，那么最后我们不难发现最小值被减去了 \(\min \times 2 ^ {n - 1}\) 次，最后的答案加上即可。 很好，这样很简单，但是太慢了。 那么，我们不妨观察一下，如何卡过去 如何优化。 首先，固定第二个元素遍历的时候，\(a_2 \geq a_1\)，那么我们可以贪心地认为 \(\frac{n}{2}\) 后面的元素是不用考虑的，瞎猜即可。 归纳得到结论：遍历到 \(\frac{n}{i}\) 为止。 具体证明我不会（瞎猜的 用了 \(2.5s\) 卡过去的（不建议参考这个思路 时间复杂度：卡过去的（ 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n), p(n + 1, 1); for (int i = 0; i &lt; n; i++) cin >> a[i]; for (int i = 1; i &lt;= n; i++) p[i] = (p[i - 1] * 2) % mod; sort(a.begin(), a.end()); n++; int tot = 0; while (n-- > 2) &#123; multiset&lt;int> ans; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt;= min(n - 1, n / (i + 1)); j++) &#123; ans.insert(a[i] + a[j]); &#125; &#125; int mn = *ans.begin(); auto it = ans.begin(); for (int i = 0; i &lt; n - 1; i++) &#123; a[i] = *it - mn; it++; &#125; tot = (tot + mn * p[n - 2]) % mod; &#125; cout &lt;&lt; (tot + a[0]) % mod &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 卡过去了就离谱]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - CodeTON Round 4 Div 1 plus 2</title>
    <url>/blog/posts/3139923560/</url>
    <content><![CDATA[Contestant(alt). 开摆Rank 5778. Rating -11(+89 -100). A. Beautiful Sequence 题意 给定一个序列，输出是否存在一个子序列，存在一个元素满足 \(a_i = i\)。 思路 显然，我们只需遍历一遍序列，找出一个 \(a_i\)，满足 \(a_i \leq i\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; bool f = false; for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; if(cur &lt;= i) f = true; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 水 B. Candies 题意 对于一个数 \(x\)，定义操作如下： \(x :=2x + 1\) \(x := 2x - 1\) 给定一个若干次操作后的数，判断初始值是否为 \(1\)，并输出方案。 思路 首先，得到的数都是奇数，所以我们从这里下手即可。 我们判断 \(\frac{x-1}{2}\) 的奇偶性，若为奇数，那么 \(x := \frac{x-1}{2}\)，否则 \(x := \frac{x + 1}{2}\) 。 可以断定，只要一开始 \(x\) 不是偶数，最后的结果一定是 \(1\)。 时间复杂度：\(O(\log_2n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; if(n % 2 == 0) &#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; vector&lt;int> ans; while(n > 1)&#123; if((n - 1) / 2 % 2 == 0) n = (n + 1) / 2, ans.emplace_back(1); else n = (n - 1) / 2, ans.emplace_back(2); &#125; reverse(ans.begin(), ans.end()); cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 你说我这脑子怎么就转不过来呢 C. Make It Permutation 题意 给定一个序列，定义操作为下面两者任选其一： 删除一个元素，代价为 \(c\)； 插入一个元素，代价为 \(d\)。 找出代价最小的一种方案，使最后的序列变为任意长度的排列，输出最小代价。 思路 贪心。 我们先记最后的答案为 \(cost\)。 首先，我们不妨先把序列排个序，然后用 \(unique\) 剔除重复元素，毕竟重复元素是一定要删去的，我们记剔除这些元素的总代价为 \(rm\)。 然后，我们从大到小遍历，处理相邻的两个数。对于这两个数，我们定义差值为 \(dist\)，以及右边那个数的后面还有 \(cnt\) 个数字。那么，我们有两种处理： \(dist=1\)，那么不用管之 \(dist &gt; 1\)，我们需要比较一下删除这个元素和补上缺少的数的代价。 需要注意的是，如果我们决定删除这个数，那么后面的数都要一并删去。因为后面的数不删去的话，需要补全的数就更多了，而我们已经判定删除的代价更小。也就是说，删除后总代价更新为 \(rm + c (cnt + 1)\)。 而补全数字的代价为 \(d(dist-1)\)，也就是说，更新后的总价值为 \(cost+d(dist-1)\)。 因此，我们比较 \(cost+d(dist-1)\) 和 \(rm + c (cnt + 1)\) 即可。 需要注意的是，当第一个数不是 \(1\) 的时候，我们不能删完所有数，所以一定会出现补全的代价。 到这里并没有结束，你会发现样例过不去。 这里有个有趣的点，我们为何不直接删掉所有数，然后放一个 \(1\) 进去呢？我们将其和答案取最小值即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, c, d; cin >> n >> c >> d; //反着做，看看删掉和补充哪个赚 vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a.begin(), a.end()); int rm = a.size(), sz = unique(a.begin(), a.end()) - a.begin(); rm -= sz; if(a[0] != 1) a.insert(a.begin(), 0ll), sz ++; int cost = rm * c; for(int i=sz-1;i>0;i--)&#123; int dis = a[i] - a[i - 1] - 1; if(a[i - 1] != 0 &amp;&amp; cost + dis * d > rm * c + c * (sz - i))&#123; cost = rm * c + c * (sz - i); &#125;else cost += dis * d; &#125; cout &lt;&lt; min(d + c * n, cost) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 简单的贪心捏，就是我怎么老搞错（ D. Climbing the Tree 题意 定义一个蜗牛在爬树，每天上升 \(a\)，下降 \(b\)，当某一天距离树的顶部小于等于 \(a - 1\) 时，即可爬到顶。树的高度记为 \(h\)。 定义询问为下者二选一： \(1\ a\ b \ n\)，表示给定一组限制，在 \(a, b\) 的条件下在第 \(n\) 爬到顶。若限制不满足前面得到的范围，输出 \(0\)；否则输出 \(1\)，并更新 \(h\) 的可能范围； \(2\ a\ b\)，判定这个条件下所需天数是否有唯一解，有的话输出，否则输出 \(-1\)。 思路 首先，这是一道数学题。 我们先来考虑第一个： 如果它要在第 \(n\) 天到达，首先前提是第 \(n - 1\) 天不会到达，也就是说，\(h \geq (a - b)(n - 1) + b\)； 其次，爬到顶的条件是距离树的顶部小于等于 \(a - 1\)，也就是说，\(h \leq (a - b)(n - 1) + (a - 1)\)。 所以，若原求得的区间和 \([(a - b)(n - 1) + b, (a - b)(n - 1) + (a - 1)]\) 有交集，那么更新区间为两者交集，否则输出 \(0\)。 我们记得到的 \(h \in [lh, rh]\)。 我们再来看看第二个： 首先，如果能一步登天，即 \(a - 1 \geq rh\)，那么直接输出 \(1\) 即可。 否则，我们只需满足一个不等式：\((a - b)(n - 1) + b \leq h \leq (a - b)(n - 1) + (a - 1)\)。 化简可得： $ \[\begin{cases} n \leq \frac{h - b}{a - b} + 1 \\ n \geq \frac{h - (a - 1)}{a - b} + 1\end{cases}\] $ 那么，我们把 \(rh\) 带入第一个式子，\(lh\) 带入第二个式子，即可求出 \(n\) 的所有可能范围。 那么，我们判断一下左右端点取整后是否相等即可。注意，右端点向下取整，左端点向上取整，因为这样取整后得到的区间是在原区间内的最长区间。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int q; cin >> q; int lh = -1, rh = inf; while(q --)&#123; int tp; cin >> tp; if(tp == 1)&#123; int a, b, n; cin >> a >> b >> n; int now = (a - b) * (n - 1); int now_l = n == 1 ? 0 : now + b, now_r = n == 1 ? a - 1 : now + a - 1; if(a &lt;= b || now_l > rh || now_r &lt; lh) cout &lt;&lt; 0 &lt;&lt; ' '; else&#123; cout &lt;&lt; 1 &lt;&lt; ' '; lh = max(lh, now_l), rh = min(rh, now_r); &#125; &#125;else&#123; int a, b; cin >> a >> b; if(a > rh) &#123; cout &lt;&lt; 1 &lt;&lt; ' '; continue; &#125; int min_x = (int) ceil((double) (lh - (a - 1)) / (double) (a - b)) + 1, max_x = (int) floor((double) (rh - (b)) / (double) (a - b)) + 1; if(min_x != max_x) cout &lt;&lt; -1 &lt;&lt; ' '; else cout &lt;&lt; min_x &lt;&lt; ' '; &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 别用 C++ 64位交即可.]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - 2023愚人节场</title>
    <url>/blog/posts/3616853689/</url>
    <content><![CDATA[Contestant. Rank WASTED. Unrated. A. Are You a Robot? 题意 给定一个图片，输出图片里的单词。 思路 如图，为"\(security\)"。 头脑复杂度：\(O(0)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; cout &lt;&lt; "security\n"; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 人也不一定看得出第一个字母是s（划掉 B. Was it Rated? 题意 给定一个 \([1, 25]\) 内的数字，输出对应的答案。 思路 \(Rated?\)，\(Codeforces\) 前 \(25\) 场只有 \(15, 20, 21\) 场是 \(Unrated\)，因此这三场输出 \(NO\) 即可。 头脑复杂度：\(O(n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; map&lt;int, bool> mp = &#123; &#123;1, true&#125;, &#123;2, true&#125;, &#123;3, true&#125;, &#123;4, true&#125;, &#123;5, true&#125;, &#123;6, true&#125;, &#123;7, true&#125;, &#123;8, true&#125;, &#123;9, true&#125;, &#123;10, true&#125;, &#123;11, true&#125;, &#123;12, true&#125;, &#123;13, true&#125;, &#123;14, true&#125;, &#123;15, false&#125;, &#123;16, true&#125;, &#123;17, true&#125;, &#123;18, true&#125;, &#123;19, true&#125;, &#123;20, false&#125;, &#123;21, false&#125;, &#123;22, true&#125;, &#123;23, true&#125;, &#123;24, true&#125;, &#123;25, true&#125; &#125;; cout &lt;&lt; (mp[n] ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 属于是没想到（x C. Digits 题意 给定 \(t\) 组数据，每组数据有 \(n\) 个数，\(n\) 不给出。观察输入输出，输出答案。 思路 我们可以发现，按照 \(3, 1, 4\) 的方法分隔，每组的数相乘就是输出的值。 我们不妨猜测 \(n\) 为圆周率，按规律做即可。 头脑复杂度：\(O(\inf)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int t; cin >> t; string s = "31415926535897932384626433832795"; for(int i=0;i&lt;t;i++)&#123; int n = s[i] - '0'; int ans = 1; while(n --)&#123; int cur; cin >> cur; ans *= cur; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 这属实没料到 D. Trivial Conjecture 题意 角谷猜想，给定整数 \(k\)，输出一个数，使得进行操作后前 \(k\) 个数不出现 \(1\)。 思路 首先，角谷猜想能告诉我们一个正整数按照题给操作是一定会变为 \(1\) 的，而且操作数远小于原数字。 那么，上面有一个值得注意的点：正整数。 有意思的是，题目又没说一定要输出正整数。 输出 \(0\) 即可。 头脑复杂度：\(O(-1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int tmp; cin >> tmp; cout &lt;&lt; 0 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 我是大蠢比 E. Not a Geometry Problem 题意 给定三个数，计算方法未知。 输出一个数，设这个数为 \(a\)，标准答案为 \(b\)，那么只要满足 \(\frac{|a-b|}{\max(1,|b|)} \le 10^6\)，答案即为正确。 思路 \(a = 0\) 就可以让整个式子变为 \(1\)。 头脑复杂度：\(O(0)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 怎么我赛时的时候题面是俄文（? F. Factorization 题意 给定一个数，输出它的最大质因数。 数为下面两者任选其一： \(4167792762229302596005813\) 或 \(\begin{aligned}&amp;502326648535222453054166634657971818804572580\\&amp;255694785590270206376893052666523759828749572\\ &amp;821869200397402455443130219791674914146276480\\&amp;544216264509037323019703862145022909043607926\\&amp;185591029614599889902115472391135622402044979\\&amp;347133959392884686037208893694733655782993294\\&amp;168167973855585231709683012084723677082273198\\&amp;866111120369101303677409522966567521782715484\\&amp;001992772768993119841291702786496058775824381\\&amp;444079748162416745495656333618343487208147794\\&amp;874337933873576016717726298883519261055062303\\&amp;842274145012056670644839715140659887936321934\\&amp;474824687778512706909988484451300384818197143\\&amp;498259061041 \end{aligned}\) 思路 我们先随便找一个网站分解一下第一个数：\(991999999999 \times 4201403994187\)。 很有趣，第一个数是有规律的。 那么，我们不妨枚举因子的长度和 \(1\) 出现的位置，用大数硬跑，即可得到答案。 第二个数为： \(\begin{aligned}&amp;9999999999999999999999999999999999999999999999\\&amp;9999999999999999999999999999999999999999999999\\&amp;9999999999999999999999999999999999999999999999\\&amp;9999999999999999999999999999999999999999999999\\&amp;9999999999999999999999999999999999999999999999\\&amp;9999999999999999999999999999999999199999999999\\&amp;9999999999999999999999\\&amp;*\\&amp;5023266485352224530541666346579718188045725802\\&amp;5569478559027020637689305266652375982874957282\\&amp;1869200397402455443130219791674914146276480544\\&amp;2162645090373230197038621450229090436079261855\\&amp;9102961459988990211547239113562240204497934713\\&amp;3959392884686037208893694733655783395155486996\\&amp;15181802856501740938959\end{aligned}\) 头脑复杂度：\(O(妈妈生的)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string s; cin >> s; if (s == "4167792762229302596005813") cout &lt;&lt; "4201403994187\n"; else cout &lt;&lt; "50232664853522245305416663465797181880457258025569478559027020637689305266652375982874957282186920039740245544313021979167491414627648054421626450903732301970386214502290904360792618559102961459988990211547239113562240204497934713395939288468603720889369473365578339515548699615181802856501740938959\n"; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 我还真去用网站分解后面的了（x G. Colour Vision 题意 一张绿色的柱状图。 思路 首先，我们可以根据输入输出猜测，每个测试数据的第一行是下面两个字符串的长度。 其次，我们仿照前几个小时做的牛客愚人节\(A\) 题（小学数学必考数一数），把图片下载下来看一看颜色。 我们可以得到色值：\(01722B\)。 有趣，我们来看看比赛 \(id=1722\) 的 \(B\) 题（B. Colorblindness）。 题面告诉我们，大条件是蓝绿色盲，而我们需要把 \(G, B\) 当成一样的字母进行判断。 那么，我们不妨将所有的 \(G\) 替换为 \(B\)，然后比较字符串即可。 当然，不知道 \(n\) 这里会不会真的是字符串长度，但我们反正只需考虑前 \(n\) 个字符即可。 头脑复杂度：\(O(\inf ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; string s1, s2; cin >> s1 >> s2; bool f = true; for(int i=0;i&lt;n;i++)&#123; if(s1[i] == 'G') s1[i] = 'B'; if(s2[i] == 'G') s2[i] = 'B'; if(s1[i] != s2[i]) f = false; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 什么解谜啊 H. Expected Twist 待补充，题解看不懂捏 I. Mountain Climber 题意 给定一个由小写字母组成的字符串，观察输入输出和题目，输出真假。 思路 爬山，爬什么山呢？当然是字母的山咯（x。 参考下面的网站，我们可以得到高的字母和低的字母： Ascender Descender 高的字母为 \(\mathtt{tdfhklb}\)，低的为 \(\mathtt{qypgj}\)。 继续观察，我们可以发现，我们需要从 \(0\) 高度向上爬，在过程中不向下爬到 \(0\) 的条件下，在最后爬回 \(0\)，即为 \(YES\)。 头脑复杂度：\(O(?)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string s; cin >> s; string up = "tdfhklb", down = "qypgj"; int h = 0; bool f = true; for(char e : s)&#123; if(up.find(e) &lt; up.size()) h ++; else if(down.find(e) &lt; down.size())&#123; if(h == 0) f = false; h --; &#125; &#125; cout &lt;&lt; (f &amp;&amp; h == 0 ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 爬不动了（x J. Unmysterious Language 题意 用一个未知语言和评测机对话。 思路 下面给出尝试的过程： 提交一个 \(C++\) 代码，得到回复 "wrong answer I'm sorry, as a language model, I'm not able to compile and execute code." 盲猜为英文对话，提交一句 \(Accepted\)，得到回复 "wrong answer I'm sorry, but I'm not sure what you are asking. If you have any question or need any assistance, feel free to ask and I'll do my best to help you." 推得需要一句话，或者某个关键词，我们随便聊一句 "How can I get an "Accepted" judge?"，得到回复 "wrong answer I can give you AC, but did you forget something important?" 看来关键词不对，尝试疑问句 "You mean what important?"，得到和上面一样的回复. 出于奇怪的礼貌，我们随口问一句 "If there is something important, please give me AC."，得到 \(Accepted.\)，以及回复 "ok I will give you AC, as you wish." 有趣的是，本题的关键字只有 \(Please\)，只要语句不长，就会被判通过。 于是，你可以自娱自乐一下： "Please give me WA." "ok I will give you AC, as you wish." 头脑复杂度：\(O(-\inf)\) 对应AC代码 代码？ please 对没错，就一个单词（什么垃圾关键词AI]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 861 Div 2</title>
    <url>/blog/posts/3027651998/</url>
    <content><![CDATA[Practice. A. Lucky Numbers 题意 此处给出 \(A\) 题和 \(C\) 题的定义： 对于一个数字，将所有位上的数取出，组成一个序列 \(a\)。定义 \(l = a_{\max} - a_{\min}\)。 那么， 给定一个区间 \([l ,r]\)，\(l\) 的最大值对应的数就是最幸运数，最小值对应的数就是最不幸运数。 给定一个区间 \([l, r]\)，输出任意一个最幸运数。 思路 首先，如果考虑幸运数，那么我们不难发现，我们只需关注十位和个位上的数即可，因为在这里就可以搞出最大值。 那么，暴力遍历 \([l, l + 100]\) 即可。 时间复杂度：\(O(100x)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int l, r; cin >> l >> r; pii ans = &#123;0, l&#125;; for(int i=l;i&lt;=min(l + 100, r);i++)&#123; int tmp = i, mn = inf, mx = 0; while(tmp > 0)&#123; int cur = tmp % 10; mn = min(mn, cur); mx = max(mx, cur); tmp /= 10; &#125; if(ans.fs &lt; mx - mn)&#123; ans = &#123;mx - mn, i&#125;; &#125; &#125; cout &lt;&lt; ans.sc &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 为什么我会想着去构造（（ B. Playing in a Casino 题意 给定 \(n\) 个人的 \(m\) 张手牌对应的数字，构成序列 \(a_{i,x}\)。 遍历 \(i \in [2, n], j \in [1, i - 1]\)，统计 \(|a_i[0] - a_j[0]| + |a_i[1] - a_j[1]| + \ldots + |a_i[m] - a_j[m]|\) 的总和。 输出总和。 思路 显然，我们可以直接竖着看，看一下去掉绝对值的情况。 不难发现，我们固定第二维 \(x\)，那么对于竖向构造得到的每一个序列，我们进行排序，可以得到形如下面的序列： \(a, b, c, d, e\)。 最后，这个序列的值为 \(-4a-2b+2d+4e\)。 或者说，我们只需排序后遍历，乘上权重加起来即可。权重首项为 \(n - 1\)，依次递减 \(2\)。 时间复杂度：\(O(mn)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> a(m, vector&lt;int>(n)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin >> a[j][i]; int ans = 0; for(int i=0;i&lt;m;i++)&#123; sort(a[i].begin(), a[i].end()); for(int j=0;j&lt;n/2;j++) ans += (a[i][n - j - 1] - a[i][j]) * (n - 1 - 2 * j); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 简简单单（x C. Unlucky Numbers 题意 给定一个区间 \([l, r]\)，输出任意一个最不幸运数。 思路 我们可以考虑用 \(DFS\) 来实现，用拼接的方式得到答案。 考虑下面的两个剪枝： 当前拼接得到的数可以预测是否一定超出边界，如对于 \(12\)，范围为 \([135, 189]\)，那么由 \(12 \times 10 + 10 = 130 &lt; 135\) 可知一定不在边界内。另一个边界直接判大小即可。 因为深搜，所以能提前得到一些答案，那么如果当前 \(\max - \min\) 已经大于之前求得的答案了，就不用继续了。 时间复杂度：不会分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; string l, r, ans; int val = inf, vl, vr; void init()&#123;&#125; void dfs(int x, int mn, int mx, const string&amp; now)&#123; int vn = stoll(now); if(x == l.size())&#123; if(vn >= vl &amp;&amp; vn &lt;= vr &amp;&amp; mx - mn &lt; val)&#123; val = mx - mn; ans = now; &#125; return; &#125; int exp = vn * pow(10, l.size() - x); //优化一下查找 if(exp + pow(10, l.size() - x) &lt; vl || exp > vr || mx - mn >= val) return; for(int i=0;i&lt;=9;i++) dfs(x + 1, min(mn, i), max(mx, i), now + (char) (i + '0')); &#125; void solve() &#123; cin >> l >> r; vl = stoll(l), vr = stoll(r); if(l.size() &lt; r.size())&#123; for(int i=0;i&lt;l.size();i++) cout &lt;&lt; 9; cout &lt;&lt; '\n'; &#125;else&#123; ans = ""; val = inf; for(int i=l[0]-'0';i&lt;=r[0]-'0';i++)&#123; dfs(1, i, i, to_string(i)); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 就很无脑，不知道dp咋做（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 860 Div 2</title>
    <url>/blog/posts/302073386/</url>
    <content><![CDATA[Contestant. Rank 3058. Rating -35. 坐大牢局 A. Showstopper 题意 给定两个序列 \(a, b\)，规定一次操作为任取 \(i\)，交换 \(a_i, b_i\)。输出任意次操作后，是否可以让 \(a_n = \max(a_i), b_n = \max(b_i)\)。 思路 首先，既然最后方案我们无需考虑，那么我们不妨定义 \(a\) 为最小值的序列，\(b\) 为最大值的序列，那么只要满足上面的条件，就是有解，否则无解。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n), b(n); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;n;i++) cin >> b[i]; if(a[n - 1] > b[n - 1]) swap(a[n - 1], b[n - 1]); bool f = true; for(int i=0;i&lt;n-1;i++) &#123; int mn = min(a[i], b[i]), mx = max(a[i], b[i]); if (mn > a[n - 1] || mx > b[n - 1]) f = false; &#125; cout &lt;&lt; (f ? "Yes\n" : "No\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 猜结论题 x1 B. Three Sevens 题意 给定 \(n\) 局的参赛情况，在前面一局胜利的玩家不会参与下面的比赛。输出任意一种获胜玩家列表排列。 思路 我们不妨反过来考虑，也就是说，在后面出现的玩家一定不是前面的赢家，那么我们直接倒着遍历即可。 首先，我们遍历参加了该局的玩家，若只要有一个没被标记，那么就是有解的，我们随便输出一个即可。 然后，我们标记参加了该局的玩家，这样即可防止其在前面作为赢家。 时间复杂度：\(O(mn)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;vector&lt;int>> a(n, vector&lt;int>()); for(int i=0;i&lt;n;i++)&#123; int cnt; cin >> cnt; a[i] = vector&lt;int>(cnt); for(int j=0;j&lt;cnt;j++) cin >> a[i][j]; &#125; vector&lt;bool> st(50010, false); vector&lt;int> ans(n); for(int i=n-1;i>=0;i--)&#123; bool f = false; for(auto e : a[i])&#123; if(!st[e]) ans[i] = e, f = true; st[e] = true; &#125; if(!f)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; &#125; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 这可比A题好做多了 C. Candy Store 题意 给定 \(n\) 组 \(a_i, b_i\)，定义 \(d_i\) 为 \(a_i\) 的因数，\(c_i = b_id_i\)。 构造一组 \(d\)，将 \(c\) 划分为 \(x\) 段值相等的序列，输出 \(x_{\min}\)。 思路 我们来考虑 \(x = 1\) 的情况： 首先，\(c_i = b_id_i\)，也就是说，\(c_i\) 是 \(b_i\) 的倍数。那么，\(c_1 \times c_2 \times \ldots \times c_n\) 是 \(lcm(b_1, b_2, \ldots, b_n)\) 的倍数。 其次，\(d_i\) 是 \(a_i\) 的因数，那么 \(b_id_i\) 就是 \(a_ib_i\) 的因数，也就是说，\(gcd(a_1b_1, a_2b_2, \ldots, a_nb_n)\) 是 \(c_1 \times c_2 \times \ldots \times c_n\) 的倍数。 所以，\(gcd(a_1b_1, a_2b_2, \ldots, a_nb_n) \% lcm(b_1, b_2, \ldots, b_n)=0\) 就是其能成为一段区间的条件。 显然，如果一个元素能划分到前面的序列中，那么我们完全可以不考虑它，因为就算把他放进来，不影响数量。 因此，我们可以贪心地直接遍历统计个数。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b); &#125; int lcm(int a, int b)&#123; return a * b / gcd(a, b); &#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n), b(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i] >> b[i]; &#125; int g = 0, l = 1, ans = 1; for(int i=0;i&lt;n;i++)&#123; g = gcd(g, a[i] * b[i]); l = lcm(l, b[i]); if(g % l != 0)&#123; ans ++; g = a[i] * b[i]; l = b[i]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 没想到啊没想到... D. Shocking Arrangement 题意 给定一个总和为 \(0\) 的序列，重新排序这个序列，满足 \(\max\limits_{1 \le l \le r \le n} \lvert a_l + a_{l+1} + \ldots + a_r \rvert &lt; \max(a_1, a_2, \ldots, a_n) - \min(a_1, a_2, \ldots, a_n),\) 若不能满足，输出 \(No\)。 思路 首先，我们定义 \(sum_i\) 为前 \(i\) 个数的前缀和，那么 \(\max\limits_{1 \le l \le r \le n} \lvert a_l + a_{l+1} + \ldots + a_r \rvert = sum_{\max} - sum_{\min}\)。 那么，我们让 \(sum_{\max} &lt; \max(a_1, a_2, \ldots, a_n), sum_{\min} &gt; \min(a_1, a_2, \ldots, a_n)\) 即可。 如何实现？我们不妨随便放一个数上去，然后记录当前放入的前 \(i\) 个数的和 \(x\)，若 \(x &gt; 0\)，那么我们加上一个负数，直到 \(x \leq 0\)，反之亦然。 考虑到总和为 \(0\)，所以如果 \(x &gt; 0\)，剩余的数的和一定为 \(-x\)，所以后面一定会有几个负数，让 \(x \leq 0\)。 此时，一定有解，而若要判无解，当且仅当整个序列都是 \(0\)。 对细节的证明 思路的第一句话是贪心的（有乱猜的嫌疑）。 为什么呢？因为，\(sum_{\max}\) 不一定在 \(sum_{\min}\) 右边。 或者说，\(S_x, S_y, S_z, Sx&gt;0, S_y &lt; 0, S_z &gt; 0\)，这样的区间要如何保证 \(|S_y| &lt; \max(a_1, a_2, \ldots, a_n) - \min(a_1, a_2, \ldots, a_n)\) 呢？ 首先，根据思路，\(S_x\) 一定小于等于 \(\max(a_1, a_2, \ldots, a_n)\)，而 \(|S_x| \geq |S_{y-1}|\)，所以 \(|S_y| &lt; \max(a_1, a_2, \ldots, a_n) + abs(\min(a_1, a_2, \ldots, a_n))\)。 因此得证。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; stack&lt;int> p, q; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur >= 0) p.emplace(cur); else if(cur &lt; 0) q.emplace(cur); &#125; if(q.empty())&#123; cout &lt;&lt; "No\n"; return; &#125; cout &lt;&lt; "Yes\n"; int now = 0; for(int i=0;i&lt;n;i++)&#123; if(now &lt;= 0)&#123; now += p.top(); cout &lt;&lt; p.top() &lt;&lt; ' '; p.pop(); &#125;else&#123; now += q.top(); cout &lt;&lt; q.top() &lt;&lt; ' '; q.pop(); &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 猜结论题 x2]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 295</title>
    <url>/blog/posts/1688399541/</url>
    <content><![CDATA[Contestant. Rank 2267. Rating +74. A. Probably English 题意 给定一个字符串序列，输出序列中是否包含下面的 \(5\) 个单词： \(and, not, that, the, you\)。 思路 如题，别打错即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; vector&lt;string> mp = &#123;"and", "not", "that", "the", "you"&#125;; int n; cin >> n; bool f = false; while(n --)&#123; string s; cin >> s; for(auto e : mp) if(s == e) f = true; &#125; cout &lt;&lt; (f ? "Yes\n" : "No\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 打错了草 B. Bombs 题意 给定一个矩阵，矩阵由 ".", "#" 和数字组成。对于任意数字 \(x\)，将其周围所有 曼哈顿距离 小于等于 \(x\) 且为 "#" 的点替换为 "."。输出替换后的矩阵。 其中，对于两个点 \((x_1, y_1), (x_2, y_2)\)，曼哈顿距离为 \(|x_1 - x_2| + |y_1 - y_2|\)。 思路 直接模拟。 当然，不要直接替换，判断一下是不是 "#" 再说。 时间复杂度：\(O(nmp^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; vector&lt;string> s(n); for (int i = 0; i &lt; n; i++) cin >> s[i]; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) &#123; char now = s[i][j]; if (now != '#' &amp;&amp; now != '.') &#123; int cnt = now - '0'; s[i][j] = '.'; for (int x = 1; x &lt;= cnt; x++) for (int p = 0; p &lt;= x; p++) &#123; int q = x - p; if (i + p &lt; n &amp;&amp; j + q &lt; m &amp;&amp; s[i + p][j + q] == '#') s[i + p][j + q] = '.'; if (i + p &lt; n &amp;&amp; j - q >= 0 &amp;&amp; s[i + p][j - q] == '#') s[i + p][j - q] = '.'; if (i - p >= 0 &amp;&amp; j + q &lt; m &amp;&amp; s[i - p][j + q] == '#') s[i - p][j + q] = '.'; if (i - p >= 0 &amp;&amp; j - q >= 0 &amp;&amp; s[i - p][j - q] == '#') s[i - p][j - q] = '.'; &#125; &#125; &#125; for (auto e: s) cout &lt;&lt; e &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 论我debug了半天这道简单题这件事 C. Socks 题意 给定一个序列，在一个元素只能在一对数的条件下，输出可以找出多少对相同的数。 思路 如题，将所有数找出，答案即为各个数量除 \(2\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; map&lt;int, int> cnt; int n; cin >> n; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; cnt[cur] ++; &#125; int ans = 0; for(auto e : cnt) ans += e.second / 2; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 这也太水了（（ D. Three Days Ago 题意 给定一个由 \([0, 9]\) 内数字组成的序列，输出 所有连续子序列中 满足 所有数出现次数均为偶数 的个数。 思路 首先，奇偶性相同的前缀和，它们的差值一定是偶数，那么，我们只需考虑奇偶性。 也就是说，对于一种 \([0, 9]\) 的奇偶性排列，若有 \(x\) 个相同的，那么答案加上 \(\frac{x(x - 1)}{2}\)。 对于这种排列，我们不妨用状压，那么，用 \(map\) 就完事了。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string s; cin >> s; int n = s.size(); map&lt;int, int> cnt; cnt[0] = 1; int cur = 0; for(int i=0;i&lt;n;i++)&#123; int t = s[i] - '0'; cur ^= (1 &lt;&lt; t); cnt[cur] ++; &#125; int ans = 0; for(auto i : cnt) ans += (i.second - 1) * i.second / 2; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 以后写状压还是写简单一点为好（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 145</title>
    <url>/blog/posts/759924825/</url>
    <content><![CDATA[Contestant. Rank 2183. Rating -13. A. Garland 题意 给定 \(4\) 盏灯的颜色，颜色为 \([0, 9]\) 内的任意数字。初始状态所有灯均关闭，打开一盏灯的条件是之前打开的灯的颜色与其不一致，第一次可以打开任意一盏灯。输出将所有灯打开所需最小次数。 思路 首先，这题只有 \(4\) 盏灯。 所以，我们直接分类讨论即可。 我们先将灯按照颜色代码升序排序，那么如果第一个数和最后一个数相等，输出 \(-1\)； 否则，前三个数相等或者后三个数相等时，需要 \(6\) 次； 否则，\(4\) 次足矣。 时间复杂度：\(O(4 \log 4)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string s; cin >> s; sort(s.begin(), s.end()); if(s[0] == s[3]) cout &lt;&lt; -1 &lt;&lt; '\n'; else if(s[0] == s[2] || s[1] == s[3]) cout &lt;&lt; 6 &lt;&lt; '\n'; else cout &lt;&lt; 4 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 我居然没看到只有4个... B. Points on Plane 题意 给定整数 \(n\)，代表当前有 \(n\) 个点。将这些点放入平面直角坐标系，满足坐标均为整数。在限制任意一对点的距离都严格大于 \(1\) 的条件下，输出最小的总代价。其中，对于一个点 \((x, y)\)，单点的代价为 \(|x| + |y|\)，总代价为所有点的代价最大值。 思路 我们来固定 \(x\) 看 \(y\)： \(x = k\)，那么 \(y = 0\)； \(x = k - 1\)，那么 \(y = -1, 0, 1\)； 归纳可得，对于 \(x\) 的所有正数取值，\(y\) 的取值总数为 \(1 + 2 + \ldots + (k + 1) = \frac{(k + 1)(k + 2)}{2}\)； 同理， \(x\) 为负数时，\(y\) 的取值总数为 \(1 + 2 + \ldots + k = \frac{k(k+1)}{2}\)。 那么，我们可以得到总和 \((k + 1) ^ 2\)。 那么，最后的答案即为 \(\lceil \sqrt n \rceil - 1\)。 注意精度问题即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; int ans = sqrt(n); if(ans * ans &lt; n) ans ++; cout &lt;&lt; ans - 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 离谱的是在 C++ 17 下，\(\lfloor \sqrt{n - 1} \rfloor\) 可以作为答案卡过去 C. Sum on Subarrays 题意 构造一个序列，满足所有连续子序列的和均不为 \(0\)，且和为正数的序列数量为给定值 \(k\)。 思路 首先，我们不妨打表，\(s_i\) 为 \(i\) 个数的连续子序列个数，即 \(s_i = \frac{i(i + 1)}{2}\)。 那么，我们不难发现，\(s_{i + 1} - s_i = i + 1\)。 那么，在 \(s_i\) 个数的基础上，我们再添加 \(x \in [0, i]\) 个数，就可以等于 \(k\)。 更具体地说，我们不妨在序列前面放上 \(q\) 个相同的正数 \(x\)，其中 \(s_q\) 为 \(s\) 中第一个不大于 \(k\) 的值。 那么，我们还需 \(cnt = k - s_q\) 个数，我们不妨在后面放一个负数 \(p\)，让 以这个数作为结尾的 子序列的和 为负数 的个数为 \(q - cnt\)。 这样的话，以 \(t \in [1, cnt]\) 为头，负数 \(p\) 为尾的子序列的和就是正数了。 剩下还有一些空位，我们填上负无穷大，也就是最小值 \(-1000\) 即可。 当然，正数 \(x\) 不能为 \(1\)，这样会让某个总和变为 \(0\)，那么我们取 \(2\) 即可。 在取 \(2\) 的条件下，负数 \(p = -2(q - cnt) - 1\)。 当然，我们用递增的序列取代这些相等的正数也是可以的。 时间复杂度：\(O(n \log n)\) 对应AC代码1 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; vector&lt;int> s = &#123;0&#125;; void init()&#123; for(int i=1;i&lt;=1000;i++) s.emplace_back(i * (i + 1) / 2); &#125; void solve() &#123; int n, k; cin >> n >> k; int q = upper_bound(s.begin(), s.end(), k) - s.begin() - 1; int cnt = k - s[q]; for(int i=0;i&lt;q;i++) cout &lt;&lt; 2 &lt;&lt; ' '; if(cnt != 0) cout &lt;&lt; -(q - cnt) * 2 - 1 &lt;&lt; ' ', q ++; for(int i=q;i&lt;n;i++) cout &lt;&lt; -1000 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 对应AC代码2 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; vector&lt;int> s = &#123;0&#125;; void init()&#123; for(int i=1;i&lt;=1000;i++) s.emplace_back(i * (i + 1) / 2); &#125; void solve() &#123; int n, k; cin >> n >> k; int q = 0; while(s[q + 1] &lt;= k) q ++; for(int i=0;i&lt;q;i++) cout &lt;&lt; q - i + 1 &lt;&lt; ' '; k -= s[q]; if(k != 0) &#123; cout &lt;&lt; -1 * (s[q - k] + q - k + 1) &lt;&lt; ' '; q ++; &#125; for(int i=q;i&lt;n;i++) cout &lt;&lt; -1000 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 我怎么就这么蠢.jpg D. Binary String Sorting 题意 给定一个二进制字符串，规定操作为下面两个任选一： 交换两个相邻元素； 删掉一个元素 第一个操作的代价为 \(1e12\)；第二个操作的代价为 \(1e12 + 1\)。 输出让整个字符串变为不递减序列的最小代价。 思路 首先，这题可以 \(dp\)，但是我们不妨来想想怎么贪心。 我们下面有四种方案，取最小值即可： 删掉所有的 \(1\)； 删掉所有的 \(0\)； 遍历所有的 \(0\)，将前面的 \(1\) 删掉，后面的 \(0\) 删掉； 遍历所有的 \(0\)，若前面为 \(1\)，那么把这个 \(1\) 和当前的 \(0\) 交换，然后删去前面剩余的 \(1\)，以及后面的 \(0\)。 前面三者是显然的，而对于第四个，我们不妨考虑其他的移动情况。 显然，\(11\) 和 \(00\) 没必要交换；\(01\) 不用管，因为满足递增；\(10\) 交换即可；剩余的情况，我们都需要移动至少两次，那还不如删掉呢。 因此，贪心是成立的。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int x = 1e12; string s; cin >> s; int n = s.size(); s = " " + s; vector&lt;vector&lt;int>> pre(n + 1, vector&lt;int>(2, 0)); int cnt0 = 0; for(int i=1;i&lt;=n;i++)&#123; int now = s[i] - '0'; if(now == 0) cnt0 ++; pre[i][now] = pre[i - 1][now] + 1; pre[i][1 - now] = pre[i - 1][1 - now]; &#125; int ans = min(cnt0, n - cnt0) * (x + 1); for(int i=1;i&lt;=n;i++)&#123; if(s[i] == '0') &#123; ans = min(ans, (pre[i][1] + cnt0 - pre[i][0]) * (x + 1)); if(s[i - 1] == '1') ans = min(ans, x + (pre[i][1] + cnt0 - pre[i][0] - 1) * (x + 1)); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 赛时一看到dp就溜了（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 859 Div 4</title>
    <url>/blog/posts/3765805359/</url>
    <content><![CDATA[Contestant(alt). Rank 5166. Rating -27(+123 -150). A. Plus or Minus 题意 给定三个数 \(a, b, c\)，判断 \(a+b = c\) 还是 \(a - b = c\)，前者输出 \(+\)，后者输出 \(-\)，保证有解。 思路 如题。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int a, b, c; cin >> a >> b >> c; if(a + b == c) cout &lt;&lt; '+' &lt;&lt; '\n'; else cout &lt;&lt; '-' &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 这才应该是低程的签到题啊（（ B. Grab the Candies 题意 给定一个序列 \(a\)，按次序拿出 \(a_i\)，定义 \(a_i\) 为偶数时 \(A\) 拿走 \(a_i\)，否则 \(B\) 拿走 \(a_i\)。输出是否可以将序列重新排列，使得每次取走后 \(A\) 持有的总和严格大于 \(B\)。 思路 如题。 很显然，我们先全排满偶数，再排奇数即可。 那么，题目转化为偶数的总和和奇数的总和的比较。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int sum1 = 0, sum2 = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur % 2 == 0) sum1 += cur; else sum2 += cur; &#125; cout &lt;&lt; (sum1 > sum2 ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 脑子得稍微动一下的题（ C. Find and Replace 题意 给定一个字符串，规定可将一种字母全部替换为 \(0\) 或 \(1\)，在全部替换后，输出是否可以将字符串变为相邻字符不相同的字符串，即 \(0101\) 相间。 思路 显然，我们只需对每一个字母去考虑，如果任意两个距离最近的相同的字母的距离为奇数，那么就构造不出来，否则一定可以。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> pre(26, -1); string s; cin >> s; bool f = true; for(int i=0;i&lt;n;i++)&#123; int cur = s[i] - 'a'; if(pre[cur] != -1 &amp;&amp; (i - pre[cur]) % 2 == 1)&#123; f = false; break; &#125; pre[cur] = i; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 差点看错题 D. Odd Queries 题意 给定一个序列，对于 \(q\) 次 独立 询问，给定一段区间 \([l, r]\) 以及一个整数 \(k\)，将区间内的数字全都修改为 \(k\) 后，输出序列的总和是否为奇数。 思路 既然询问是独立的，那么我们直接对所有询问单独考虑即可。 也就是说，我们不需要模拟修改，而只需求出值。 那么，很简单，我们求出前缀和，然后用 \(O(1)\) 的复杂度拿出区间前后的元素总和，最后判断加上区间内的值能否变为奇数即可。 时间复杂度：\(O(n + q)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, q; cin >> n >> q; vector&lt;int> sum(n + 1, 0); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; sum[i] = sum[i - 1] + cur; &#125; while(q --)&#123; int l, r, k; cin >> l >> r >> k; cout &lt;&lt; ((sum[l - 1] + (r - l + 1) * k + sum[n] - sum[r]) % 2 == 1 ? "YES\n" : "NO\n"); &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 这题怎么更水了（ E. Interview 题意 互动游戏。 背景：给定几堆石子，每堆石子都由权值为 \(1\) 的石子堆叠得到，特殊地，有一堆石子中有一个石子的权值为 \(2\)。 初始：给定堆数，以及每堆石子的 个数。 互动：输出一段区间的左右端点，返回这段区间内所有石子的 权值和。 限制：最多 \(30\) 次。 目标：输出特殊的石子在哪个堆里。 思路 首先，我们可以跑一遍前缀和，方便后续查询。 其次，如果我们询问了区间 \([1, k]\)，得到的值等于个数，那么我们可以断定特殊的石子在 \([k + 1, n]\) 里，反之就在前者里。 那么，对于 \(k\) 的选择，我们直接用二分的思路做即可。 最后二分的结果就是答案。 次数为 \(\log_2n\)，不超过 \(30\)。 时间复杂度：\(O(t \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> sum(n + 1, 0); for(int i=1;i&lt;=n;i++) &#123; int cur; cin >> cur; sum[i] = sum[i - 1] + cur; &#125; int l = 1, r = n, mid; while(l &lt; r)&#123; mid = (l + r) >> 1; cout &lt;&lt; "? " &lt;&lt; mid - l + 1 &lt;&lt; ' '; for(int i=l;i&lt;=mid;i++) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n'; cout.flush(); int g; cin >> g; if(g == sum[mid] - sum[l - 1]) l = mid + 1; else r = mid; &#125; cout &lt;&lt; "! " &lt;&lt; l &lt;&lt; '\n'; &#125; signed main()&#123; //ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 我怎么会想着去在两边都询问一次呢，我好铸 F. Bouncy Ball 题意 给定一个矩阵，以左上角为原点建立坐标系，给定两个点 \((i_1, j_1), (i_2, j_2)\)，以及初始运动方向 \(s, s \in \{DL, DR, UL, UR\}\)（\(DL\) 表示向左下角走，也就是 \((i, j) =&gt; (i + 1, j - 1)\)，其余同理）。在碰到边界后，会发生反弹，如向左上角走，碰到上边界后会反弹，向左下角继续移动。在碰到边角后，运动方向反转，此处记反弹次数为 \(1\) 次，而不是 \(2\) 次。 输出从 \((i_1, j_1)\) 开始运动，到第一次到达 \((i_2, j_2)\) 后，经历了多少次反弹。 无法到达输出 \(-1\)。 思路 数据量并不大，直接模拟即可。 在模拟的时候，我们记录是否已经从某个方向运动到该格子。那么，只要碰到被我们记录过的格子，只要方向一致，那么就出现了循环，直接打断即可。 时间复杂度：最坏\(O(4nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, m, i, j, si, sj; string ori; cin >> n >> m >> i >> j >> si >> sj >> ori; bool vis[n + 1][m + 1][4] = &#123;&#125;; int d = ((ori[0] == 'D' ? 0 : 1) &lt;&lt; 1) + (ori[1] == 'R' ? 0 : 1); //00 DR, 01: DL, 10: UR, 11: UL int cnt = 0; while (!vis[i][j][d]) &#123; if (i == si &amp;&amp; j == sj) &#123; cout &lt;&lt; cnt &lt;&lt; '\n'; return; &#125; vis[i][j][d] = true; int new_d = d; if ((d == 0 || d == 1) &amp;&amp; i == n) new_d += 2; if ((d == 0 || d == 2) &amp;&amp; j == m) new_d ++; if ((d == 1 || d == 3) &amp;&amp; j == 1) new_d --; if ((d == 2 || d == 3) &amp;&amp; i == 1) new_d -= 2; if (new_d != d) cnt++; d = new_d; if (d % 2 == 1) j--; else j++; if ((d >> 1) == 1) i--; else i++; &#125; cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 居然，居然，居然就是暴力... G1. Subsequence Addition (Easy Version) 详见G2，区别是G1的数据量更小 G2. Subsequence Addition (Hard Version) 题意 给定一个初始只含一个数字 \(1\) 的序列，规定操作为选择序列中的任意元素，将选定元素之和加入序列中。 现在，给定一个序列，输出其是否为上述操作所得。 思路 我们可以贪心地认为，排序之后，较大的数一定小于等于所有比他小的数的和，而且只要满足这个条件，一定有一种方案得到这个数。 至于为什么，我们可以想想二分，序列中的数一定是某些数的和，那么如此拆分下去，就是一群 \(1\) 的和，而且数量的集合覆盖 \([1, sum]\)，所以是成立的。 具体的证明需要用到归纳法。 因此，我们排个序，然后判断所有 \(a_i\) 是否大于等于 \(sum_{i - 1}\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a.begin(), a.end()); int sum = 1; bool f = a[0] == 1; for(int i=1;i&lt;n;i++)&#123; if(!f) break; if(i &lt; 2 &amp;&amp; a[i] != 1 || a[i] > sum) f = false; sum += a[i]; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 很有趣一贪]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 福师大第26届低程</title>
    <url>/blog/posts/1549174805/</url>
    <content><![CDATA[Contestant. Rank 2. Solved 4/8. A. ACM? 你也想打ACM? 题意 对于 \(n\) 道题，给定 \(k\) 个提交记录，规定罚时为 \(20\) 分钟，按照 \(ACM/ICPC\) 赛制计算通过题数和总用时。 思路 首先，没过的题不算罚时，过了的题重复提交无效。 因为题给数据是按照时间排序的，那么，我们不妨从前往后遍历，用数组记录当前的状态。 对于下面的 \(AC\) 代码，其中 \(ok_i\) 表示当前是否过了 \(i\) 题；\(a_i\) 表示第 \(i\) 道题最早是在 \(a_i\) 时刻通过的；\(p_i\) 表示第 \(i\) 道题在通过前 \(WA\) 了几次。 最后，我们遍历所有题，如果过题了，记录过题数，并将总用时加上 \(a_i + 20p_i\)。 时间复杂度：\(O(nk)\) 本题测试点数据量过大，java需要使用快读，cpp若使用cin需要关闭输入输出流同步 对应AC代码 (cpp) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; int a[N], p[N]; bool ok[N]; void solve()&#123; int n, k; cin >> n >> k; for(int i=0;i&lt;k;i++)&#123; string s; cin >> s; int id, h, m, now = 0, st = 0; bool msg = true; for(int i=0;i&lt;s.size();i++)&#123; char e = s[i]; if(e == ':')&#123; if(st == 0)&#123; id = now; now = 0; st = 1; &#125;else if(st == 1)&#123; m = now; now = 0; st = 2; &#125; &#125;else if(e == '-')&#123; h = now; now = 0; &#125;else if(e >= '0' &amp;&amp; e &lt;= '9')&#123; now = now * 10 + (e - '0'); &#125;else if(e == 'u')&#123; //读到u就差不多了 msg = false; break; &#125;else break; &#125; int cal = h * 60 + m; if(!ok[id]) a[id] = cal; if(msg) ok[id] = true; else if(!ok[id]) p[id] ++; &#125; int cnt = 0, tot = 0; for(int i=1;i&lt;=n;i++)&#123; cnt += ok[i] ? 1 : 0; if(ok[i]) tot += a[i] + p[i] * 20; &#125; cout &lt;&lt; cnt &lt;&lt; ' ' &lt;&lt; tot &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 对应AC代码 (java) import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception &#123; Console console = new Console(); int n = console.nextInt(), k = console.nextInt(); boolean[] ok = new boolean[n + 1]; int[] a = new int[n + 1], p = new int[n + 1]; for (int i = 0; i &lt; k; i++) &#123; String[] s = console.next().split(":"); int id = Integer.parseInt(s[0]), cal = Integer.parseInt(s[1].split("-")[0]) * 60 + Integer.parseInt(s[1].split("-")[1]); if (!ok[id]) a[id] = cal; if (s[2].equals("accepted")) ok[id] = true; else if (!ok[id]) p[id]++; &#125; int cnt = 0, tot = 0; for (int i = 1; i &lt;= n; i++) &#123; cnt += ok[i] ? 1 : 0; if (ok[i]) tot += a[i] + p[i] * 20; &#125; console.print(cnt + " " + tot + "\n"); console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; java挂掉后果断切cpp，淦 B. 任何邪恶? 终将绳之以法! 题意 给定一个满二叉树，满足根节点为 \(1\)，节点 \(x\) 的子节点为 \(2x, 2x + 1\)。 定义操作为下面三者任选一： \(1\ x\)，输出 \(x\) 节点到其他被标记节点的最短距离总和； \(2\ x\)，标记 \(x\) 节点； \(3\ x\)，取消标记 \(x\) 节点。 给定 \(q\) 个询问，执行对应操作。 思路 一些废话 首先，节点 \(a, b\) 的最短距离为两者 离 它们的 最近公共祖先 的距离 之和。 也就是说，这个路径一定是先向上找，再从一个节点折返，最后从下找的。 这个节点就像一个跳板，不过当然，跳板可以是起点自己。 当然，讨论到这里，我们也许可以对每个查询，都去跑一遍最近公共祖先（\(LCA\)），但我觉得没这个必要。 不过，有没有一种可能，对于一个跳板，我们可以预处理出它的左右子树各有多少点被标记了，以及这些点距离跳板的距离呢。 这个预处理过程可以放在标记的时候。而且，我们不难发现这个过程是可逆的。因而，在取消标记的时候，我们进行相反的操作就好了。 具体思路 计算 首先，我们先来考虑怎么计算： 我们不妨从查询点 \(x\) 开始向上遍历，并记录当前走了 \(st\) 步。遍历时，我们传递一下当前遍历到的父节点 \(p\) 是由哪个子树来的，这个参数和 \(x\) 的奇偶性有关。这样的话，我们就可以拿出另一个子树中所有被标记点到 \(p\) 的距离和 \(sum\)，以及被标记的节点数 \(cnt\)。画个图易得，\(x\) 到 \(p\) 这段路被反复经过了 \(cnt\) 次，经过这个跳板后，剩余距离的总和就是 \(sum\)，因此，以 \(p\) 为跳板，我们可以得到贡献 \(sum + cnt \times st\)。 上述过程对于 \(p \neq x\) 的情况是成立的，而 \(p = x\) 时，两个子树的值我们都需要考虑（传参时，我们不妨传递一个特殊值，如 \(-1\)），具体的贡献计算方式和上面一致。 特别地，若我们遍历到的 \(p\) 是被标记过的，那么贡献会多出 \(st\)。 预处理 对于加上一个标记 \(x\) 的操作，我们可以从该节点开始向上遍历，直到根节点为止。 同样，在遍历的时候，我们记录步数 \(st\)，并传递 \(p\) 是由哪个子树来的，然后将 \(p\) 对应子树的 \(sum\) 加上 \(st\)，\(cnt\) 加上 \(1\)。 取消标记的做法恰好相反，减去即可。 时间复杂度：反正挺复杂 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; pii dp[N][2]; int ans; bool is[N]; void up_dfs_add(int x, int from, int st)&#123; if(x == 0) return; if(from == -1)&#123; dp[x][0].first += st; dp[x][1].first += st; &#125;else dp[x][from].first += st, dp[x][from].second ++; up_dfs_add(x / 2, x % 2, st + 1); &#125; void up_dfs_del(int x, int from, int st)&#123; if(x == 0) return; if(from == -1)&#123; dp[x][0].first -= st; dp[x][1].first -= st; &#125;else dp[x][from].first -= st, dp[x][from].second --; up_dfs_del(x / 2, x % 2, st + 1); &#125; void up_dfs_cal(int x, int from, int st)&#123; if(x == 0) return; int cur; if(from == -1) cur = dp[x][0].first + dp[x][1].first > 0 ? (dp[x][0].first + dp[x][0].second * st + dp[x][1].first + dp[x][1].second * st) : 0; else cur = dp[x][1 - from].first > 0 ? (dp[x][1 - from].first + dp[x][1 - from].second * st) : 0; ans += cur; if(is[x]) ans += st; up_dfs_cal(x / 2, x % 2, st + 1); &#125; void solve()&#123; int n, q; cin >> n >> q; while(q --)&#123; int tp, x; cin >> tp >> x; if(tp == 1)&#123; ans = 0; up_dfs_cal(x, -1, 0); cout &lt;&lt; ans &lt;&lt; '\n'; &#125;else if(tp == 2) is[x] = true, up_dfs_add(x, -1, 0); else is[x] = false, up_dfs_del(x, -1, 0); &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 复杂之，但类似的题其实做过好几次吧，有点像树型dp C. 蘑菇! 提莫来采蘑菇啦! 没做，待补充 D. 锁屏图案? 当然是第k长的最好看! 题意 对于一个九宫格锁屏图案，规定需要一笔将所有点连起来，且不能重复使用同一个点。 规定连接了两个点的时候，若这个路径经过了一个未被使用的点，那么这个点一定要一起被连上，否则视为不合法，如斜角上的 \(159\)，在没使用过 \(5\) 前，\(195\) 是不合法的。 定义满足条件的全排列中，排序的主关键字为路径长，次要关键字为字典序，按照降序排列。 给定 \(q\) 个询问，对于给定的 \(k\)，输出第 \(k\) 个排列。 思路 首先，数据量很小，\(9!\) 的复杂度完全可以暴力。 那么，我们不妨枚举所有全排列，然后算出可行解的路径长，以及排列的结果，按照这个排个序然后取出来就好了。 唯一麻烦的是码量。 时间复杂度：\(O(8 \cdot 9 \cdot 9! \cdot q)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-7; struct node&#123; string ans; double dist; &#125;; vector&lt;node> ans; vector&lt;int> a = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; vector&lt;pii> pos(10); double cal(int x, int y)&#123; return sqrt(pow(abs(pos[x].fs - pos[y].fs), 2) + pow(abs(pos[x].sc - pos[y].sc), 2)); &#125; bool check(int l, int r, int mid)&#123; int l_pos = -1, r_pos = -1, m_pos = -1; for(int i=0;i&lt;9;i++)&#123; if(a[i] == l) l_pos = i; else if(a[i] == r) r_pos = i; else if(a[i] == mid) m_pos = i; &#125; if(l_pos > r_pos) swap(l_pos, r_pos); return l_pos + 1 != r_pos || m_pos &lt; r_pos; &#125; void init()&#123; for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=3;j++) pos[3 * (i - 1) + j] = &#123;i, j&#125;; do&#123; vector&lt;vector&lt;int>> checker = &#123;&#123;1, 3, 2&#125;, &#123;1, 7, 4&#125;, &#123;3, 9, 6&#125;, &#123;7, 9, 8&#125;, &#123;3, 7, 5&#125;, &#123;1, 9, 5&#125;, &#123;2, 8, 5&#125;, &#123;4, 6, 5&#125;&#125;; bool f = true; for(auto e : checker) f &amp;= check(e[0], e[1], e[2]); if(!f) continue; node now = &#123;&#125;; for(int i=0;i&lt;9;i++)&#123; now.ans += (a[i] + '0'); now.ans += " "; if(i > 0) now.dist += cal(a[i], a[i - 1]); &#125; ans.emplace_back(now); &#125;while(next_permutation(a.begin(), a.end())); //这里学到了，好用的东西 sort(ans.begin(), ans.end(), [](node o1, node o2)&#123; return abs(o1.dist - o2.dist) > eps ? o1.dist > o2.dist : o1.ans > o2.ans; &#125;); &#125; void solve()&#123; int k; cin >> k; cout &lt;&lt; ans[k - 1].ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 草，怎么赛时就没想着去做捏，这么暴力（（（ E. 微积分？低程竟然有微积分？ 题意 给定一个多项式，满足式子中没有重复次幂，项按照次幂降序排序，次幂最小为 \(0\)。项的系数可以为负，但不会为 \(0\)。 输出它的积分。 思路 很清晰的模拟题，坑点在于化简和系数 \(1\)。 化简很简单，除以 \(gcd\) 即可。 系数 \(1\) 不做过多解释，自行体会（ 时间复杂度：\(O(n)\)乘上点常数 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b); &#125; void solve()&#123; string exp; cin >> exp; exp += "#"; //end int now = 0, root = 0; cout &lt;&lt; "y="; bool tp = false; for(int i=3;i&lt;exp.size();i++)&#123; char cur = exp[i]; if(cur == 'x')&#123; root = (now == 0 ? 1 : now); now = 0; if(i >= exp.size() - 2 || exp[i + 1] != '^')&#123; if(root % 2 == 0 &amp;&amp; root / 2 != 1) cout &lt;&lt; root / 2 &lt;&lt; "x^2"; else if(root % 2 == 0) cout &lt;&lt; "x^2"; else cout &lt;&lt; root &lt;&lt; "/" &lt;&lt; 2 &lt;&lt; "x^2"; root = 0; &#125; &#125; else if(cur == '+' || cur == '-' || cur == '#') &#123; if(tp)&#123; int p = now; if(root % (p + 1) == 0 &amp;&amp; root / (p + 1) == 1) cout &lt;&lt; "x^" &lt;&lt; p + 1; else if(root % (p + 1) == 0) cout &lt;&lt; root / (p + 1) &lt;&lt; "x^" &lt;&lt; p + 1; else&#123; int x = gcd(p + 1, root); cout &lt;&lt; root / x &lt;&lt; "/" &lt;&lt; (p + 1) / x &lt;&lt; "x^" &lt;&lt; (p + 1); &#125; &#125;else if(now == 1) cout &lt;&lt; "x"; else if(now != 0) cout &lt;&lt; now &lt;&lt; "x"; tp = false; now = 0; if(cur == '+' || cur == '-') cout &lt;&lt; cur; else cout &lt;&lt; "+C"; &#125; else if(cur == '^') tp = true; else now = now * 10 + (cur - '0'); &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 系数1太坑了捏 F. SCI! 我就是要发SCI! 题意 给定 \(n\) 个字符串，从中选 \(k\) 个字符串并进行任意组合，输出最小的字典序。 思路 首先，"从 \(n\) 个东西中选 \(k\) 个"，很容易让人想到背包问题，或者更具体地，这是一个 \(01\) 背包。 但是，再套上板子之前，我们思考一下怎么递推。 有一个错误的思路（这也是我在赛时想到的奇怪思路），就是用一维的 \(dp\)，\(dp_j\) 表示选了 \(j\) 个后的最小字典序。那么我们直接枚举所有的字符串 \(s_i\)，遍历 \(j\)。对于 \(dp_j\) ，遍历其中的字符串，将 \(si\) 依次插入缝中，最后找出一种插法，使得 \(dp_j\) 的字典序变小即可。 显然，我们不可以随意遍历，但有没有一种无需考虑插入位置的方法呢？ 我们来考虑任意两个字符串 \(s_i, s_j\)，如果 \(s_i + s_j &lt; s_j + s_i\)，那么很显然，前者的字典序更小。 那么，如果有三个呢？如果 \(s_j + s_k &lt; s_k + s_j\)，那么依然是前者的字典序更小。此时，我们联立起两个式子，会发现有趣的事情：\(s_i + s_k &lt; s_k + s_i\)。 也就是说，如果我们按照 \(s_i + s_j\) 的字典序升序排序，就可以直接将取出的任意的 \(k\) 个字符串拼接起来，而无需考虑这 \(k\) 个字符串的顺序，此时字典序一定是最小的。 那么，问题就剩下从 \(n\) 个东西中选 \(k\) 个，代价最小的问题了，也就是求最小代价的 \(01\) 背包。 事情到这里并未结束，我们来看下面的样例： 4 3 bbaba bba b b 不难发现，这组数据的答案为 \(bbababb\)。但如果我们套上板子，直接跑，得到的答案是 \(bbababbab\)。 问题在哪里呢？我们并没有考虑拼接上的答案的后缀，而如果出现了前缀一致的情况，我们无法控制让后缀尽可能短。 那么，很简单的解决方法，就是反着 \(dp\)，反着拼，这样就可以保证所有后缀的情况都被我们遍历过了。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve()&#123; int n, k; cin >> n >> k; vector&lt;string> s(n); for(int i=0;i&lt;n;i++) cin >> s[i]; vector&lt;string> dp(k + 1, "&#123;"); //保证ans原来的字典序为inf dp[0] = ""; sort(s.begin(), s.end(), [](string o1, string o2)&#123; return o1 + o2 > o2 + o1; //倒着做来让所有后缀都被遍历到 &#125;); for(auto e : s) //一维01背包 for(int j=k;j>=1;j--)&#123; dp[j] = min(dp[j], e + dp[j - 1]); &#125; cout &lt;&lt; dp[k] &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 还好赛时没怎么看这题（打完01的板子就突然意识到思路不对了，草 G. 旅行! 我就是想去旅行! 不会，样例都没过.jpg，待补充 H. WF？刚打低程就想着WF？ 题意 定义 \(5\) 种奖牌类型由低到高分别为 \(LowerLevelProgrammingCompetition\)，\(SchoolCompetition\)，\(ProvincialCompetition\)，\(Regional\)，\(ECfinal\)，\(WF\)。奖牌由低到高分为铜 (\(Cu\))，银 (\(Ag\))，金 (\(Au\))。当然还有铁牌，但不计入。 定义三个相同的牌可以合成一个等级更高的牌，输出拿到 \(WF\) 的金牌的最早时刻，不能拿到则输出可以拿到的价值最高的牌，什么牌都拿不到（打铁）输出 \(-1\)。 思路 模拟即可。注意不要打错单词。 对于最后价值最高的牌的记录，不妨用 "类型" $ + $ "奖牌" 的方式存，方便一点（（ 时间复杂度：\(O(n)\) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;vector&lt;int> > cnt(6, vector&lt;int>(3)); map&lt;string, int> mp; mp["LowerLevelProgrammingCompetition"] = 0; mp["SchoolCompetition"] = 1; mp["ProvincialCompetition"] = 2; mp["Regional"] = 3; mp["ECfinal"] = 4; mp["WF"] = 5; mp["Cu"] = 0; mp["Ag"] = 1; mp["Au"] = 2; mp["Fe"] = -1; int hi = -1; int time = -1; for(int i=0;i&lt;n;i++)&#123; string s, a; cin >> s >> a; int id = mp[s], what = mp[a]; if(what == -1) continue; cnt[id][what] ++; if(id == 5 &amp;&amp; what == 2 &amp;&amp; time == -1) time = i + 1; hi = max(hi, id * 10 + what); if(cnt[id][what] == 3)&#123; cnt[id][what] = 0; if(what == 2) &#123; if(id &lt; 5)&#123; cnt[id + 1][0] ++; hi = max(hi, (id + 1) * 10); &#125;else&#123; if(time == -1) time = i + 1; &#125; &#125; else if(what &lt; 2) &#123; cnt[id][what + 1] ++; hi = max(hi, id * 10 + what + 1); if(id == 5 &amp;&amp; what + 1 == 2 &amp;&amp; time == -1) time = i + 1; &#125; &#125; &#125; if(time != -1) cout &lt;&lt; time &lt;&lt; '\n'; else if(hi != -1)&#123; int id = hi / 10, what = hi % 10; string ans; //懒得再写一个map了，累 if(id == 0) ans = "LowerLevelProgrammingCompetition"; else if(id == 1) ans = "SchoolCompetition"; else if(id == 2) ans = "ProvincialCompetition"; else if(id == 3) ans = "Regional"; else if(id == 4) ans = "ECfinal"; else ans = "WF"; cout &lt;&lt; ans &lt;&lt; ' '; if(what == 0) ans = "Cu"; else if(what == 1) ans = "Ag"; else ans = "Au"; cout &lt;&lt; ans &lt;&lt; '\n'; &#125;else cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; Ag == Au]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 858 Div 2</title>
    <url>/blog/posts/2942373806/</url>
    <content><![CDATA[Contestant. Rank 1245. Rating +30. A. Walking Master 题意 给定两个点 \((a, b), (c, d)\)，定义对于点 \((x, y)\) 的操作为下面任选一： \(x + 1, y + 1\)； \(x - 1\) 输出从 \((a, b)\) 走到 \((c, d)\) 需要的最小操作数，无解输出 \(-1\)。 思路 画个图即可。 首先，我们需要向上移动 \(d - b\)，如果 \(d - b &lt; 0\) 就是无解。 此时，横坐标变为 \(a + d - b\)，还需要向左移动 \(a + d - b - c\)，如果 \(a + d - b - c &lt; 0\) 也是无解。 若有解，输出 \(d - b + a + d - b - c\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; void solve()&#123; int a, b, c, d; cin >> a >> b >> c >> d; if(b > d || a + d - b &lt; c) cout &lt;&lt; -1 &lt;&lt; '\n'; else cout &lt;&lt; a + d - b - c + d - b &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 就还是那么签（ B. Mex Master 题意 给定一个序列，定义答案为 由相邻数相加构成的新序列中 不在 这个序列中的 最小自然数。将序列重新排序，输出最小答案。 思路 首先，若 \(0\) 的个数小于等于 \(\frac{n + 1}{2}\)，那么一定可以在连续的两个 \(0\) 里面插入一个数，使最后的序列没有 \(0\)，答案即为 \(0\)； 其次，若整个序列的最大值大于 \(1\)，那么我们只需将 \(1\) 全部放到后面，然后第一个 \(1\) 之前不要放 \(0\) 即可，答案即为 \(1\)； 接着，若整个序列的最大值为 \(1\)，那么一定有一个 \(1\) 会和 \(0\) 去相加，使最后的序列出现 \(1\)，而因为 \(0\) 的个数足够多，我们只需在所有 \(1\) 之间插 \(0\)，就可以避免出现 \(2\)，答案即为 \(2\)； 否则，整个序列都是 \(0\)，答案一定是 \(1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; map&lt;int, int> cnt; int mx = 0; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; mx = max(mx, cur); cnt[cur] ++; &#125; if(cnt[0] &lt;= (n + 1) / 2) cout &lt;&lt; 0 &lt;&lt; '\n'; else if(cnt[0] == n) cout &lt;&lt; 1 &lt;&lt; '\n'; else cout &lt;&lt; (mx == 1 ? 2 : 1) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 一开始想错了（（ C. Sequence Master 题意 若一个长为 \(2n\) 的序列，它的所有长度为 \(n\) 的子序列满足选定的数的 乘积 与剩余数的 和 相等，那么定义其为好序列。 给定一个长为 \(2n\) 的序列 \(p\)，选定一个好序列，定义答案为 \(\sum|p_i - q_i|\)，输出答案的最小值。 思路 猜想 首先，我们来以小见大，看看 \(a, b, c, d\) 如何成为一个好序列： 拿出其中两个式子：\(ab=c+d, ac=b+d\)，我们可以得出 \(b = c\) 或 \(a = -1\)。 同理，那么我们不妨猜测整个序列都是相等的数 \(x\)，或者会有至少一个数 \(t\) 不是 \(-1\)。 讨论1 下面我们来探讨一下第一个条件的局限性： 首先，它是一定成立的，毕竟 \(x=0\) 一定是一个解，但可能出现其他解； 若只有两个数，那么 \(x\) 可以为任意值； 若只有四个数，满足 \(x ^ 2 = 2x\)，\(x = 2\)； 若超过四个数，那么我们不难发现 \(x ^ k = kx\) 对于 \(k\) 为偶数的情况下是无整数解的。 讨论2 下面我们来探讨一下第二个条件的局限性： 我们无法让大于等于 \(2\) 个数不为 \(-1\)，列式可发现无实数解； \(n\) 为奇数的时候，依然无解； 其余情况，我们可以解得 \(t = n\)。 总结 最后，答案即为上面条件所算出的答案的最小值。 时间复杂度：\(O(2n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int ans = inf; vector&lt;int> a(2 * n); for(int i=0;i&lt;2*n;i++) cin >> a[i]; if(n == 1)&#123; if(a[0] > a[1]) swap(a[0], a[1]); ans = a[1] - a[0]; &#125;else if(n == 2)&#123; ans = 0; for(int i=0;i&lt;4;i++) ans += abs(a[i] - 2); &#125; if(n % 2 == 0)&#123; int mn = inf, sum = 0; for(int i=0;i&lt;2*n;i++)&#123; sum += abs(a[i] + 1); mn = min(mn, abs(a[i] - n) - abs(a[i] + 1)); &#125; ans = min(ans, sum + mn); &#125; int sum = 0; for(int i=0;i&lt;2*n;i++) sum += abs(a[i]); ans = min(ans, sum); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 漏了奇数的情况，md 有更直接的做法，这里比较麻烦]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Nebius Welcome Round Div 1 plus 2</title>
    <url>/blog/posts/1381135032/</url>
    <content><![CDATA[Contestant. Rank 1755. Rating +54. A. Lame King 题意 给定一个坐标系，其中 \(x \in [-100, 100], y \in [-100, 100]\)。给定一个坐标 \([s, t]\)，输出按规定从 \([0, 0]\) 走到 \([s, t]\) 需要的最短时间。 规定若需要连续从相同方向移动，需要间隔一秒。 思路 首先，若我们需要一直向右，那么停留一秒绝对比向垂直方向绕路快，所以，我们不妨以折线的方式移动，直到横坐标或纵坐标等于终点时，向同一方向间隔移动。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int a, b; cin >> a >> b; a = abs(a), b = abs(b); cout &lt;&lt; (a + b) + (a != b ? abs(a - b) - 1 : 0) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 画个图的事情（（ B. Vaccination 题意 对于 \(n\) 个病人，每个病人需要在 \([t_i, t_i + w]\) 时间内被扎一针。在某个时间点 \(x\)，可以拿出一个包含 \(k\) 个剂量的包装，这个包装会在 \(x + d + 1\) 时过期。给定整数 \(n, k, d, w\)，输出需要拿出的包装的最小数量。 思路 为了要当前的包装可以包括更多的人，我们不妨在某一个病人的 \(t_i + w\) 时刻拿出包装，并枚举后面有多少个 \(t_j\) 小于 \(t_i + w + d\)，这样即可贪心地求出最小值。 就这样，没了。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, k, d, w; cin >> n >> k >> d >> w; int ans = 0; vector&lt;pii> a(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i].first; a[i].second = a[i].first + w; &#125; int i = 0; while(i &lt; n)&#123; int l = a[i].second, r = l + d; int now = i; for(int j=0;j&lt;k;j++)&#123; if(i + j >= n || a[i + j].first > r) break; now ++; &#125; ans ++; i = now; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 这还需要证明吗，这还需要证明吗（ C. Pull Your Luck 题意 给定一个圆盘，按顺序写好了 \(0, 1, 2, ..., n - 1\)，换言之，\(0, n - 1\) 相邻。规定可以转动 \(p\) 秒，第一秒将当前值增加 \(p\)，第二次增加 \(p - 1\)，以此类推。对于给定的起点，输出是否可以进行一次 \([1, p]\) 秒的转动，使终点为 \(0\)。 思路 首先，我们很容易列出一个式子： \(n - x + kn = \frac{p(p+1)}{2}\) 但这个式子推不了什么。 有趣的是，若我们一直循环加上数的话，在取到 \(n-1\) 之后，所有数均会变小，但值得注意的是这些数因均相邻而出现了周期。 因而，在一个周期内，若出现了 \(0\)，输出即可。能保证最后的复杂度足够小。 时间复杂度：不大就对了 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, x, p; cin >> n >> x >> p; int cur = x; for(int i=1;i&lt;=min(p, 2*n);i++)&#123; cur = (cur + i) % n; if(cur == 0) &#123; cout &lt;&lt; "YES\n"; return; &#125; &#125; cout &lt;&lt; "NO\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 捏吗，一直在想怎么搞式子 D. Accommodation 题意 给定 \(n\) 个长度为 \(m\) 的二进制串，满足 \(m\ \%\ 4 = 0\)，将字符串分割为 \(\frac{m}{4}\) 个长度为 \(2\) 的子串和 \(\frac{m}{2}\) 个长度为 \(1\) 的子串。输出所有含 \(1\) 子串个数总和的最大值和最小值。 思路 若我们需要让个数尽可能大，我们当然希望将 \(11\) 分割开，也就是构造非 \(11\) 的大窗，那么，我们不妨枚举所有含有 \(0\) 的可能的大窗，拿掉这些后，剩余的作为小窗，即可让个数尽可能大。 相反地，要让个数尽可能小，我们就希望尽可能不将 \(11\) 分割开，也就是主动构造为 \(11\) 的大窗，这时，能构造多少个，\(1\) 的个数就能减少多少。 有趣的是，只要分割出 \(\frac{m}{4}\) 个长度为 \(2\) 的子串，剩余的一定长度均为 \(1\)，且恰好 \(\frac{m}{2}\) 个；反之亦然。 当然，如果这题数据量小的话，可以 \(dp\)。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; int mn = 0, mx = 0; while (n--) &#123; string s; cin >> s; int c1 = 0, c2 = 0, tot = 0; for (int i = 0; i &lt; m; i++) tot += s[i] - '0'; for (int i = 0; i &lt; m - 1; i ++) if (s[i] == '1' &amp;&amp; s[i + 1] == '1') c1 ++, i ++; for (int i = 0; i &lt; m - 1; i ++) if (s[i] == '0' || s[i + 1] == '0') c2 ++, i ++; mn += tot - min(c1, m / 4); mx += tot - max(0ll, m / 4 - c2); &#125; cout &lt;&lt; mn &lt;&lt; ' ' &lt;&lt; mx &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 似了，在想怎么dp，贪心还没贪对（一直想着拆]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 857 Div 2</title>
    <url>/blog/posts/1495891783/</url>
    <content><![CDATA[Virtual Participant. Unofficial Rank 382. Solved 4/7. A. Likes 题意 定义 \(a_i\) 为一个人对 \(|a_i|\) 的"喜欢"状态，当 \(a_i &gt; 0\) 时，该人对 \(|a_i|\) 点了"喜欢"，否则将其撤回了"喜欢"。规定未点喜欢就不能撤回"喜欢"。 给定打乱顺序后的若干人的"喜欢"操作，定义 \(b_i\) 为进行第 \(i\) 次操作后得到的"喜欢"数量。将操作按一定方案排序，输出让每次操作得到的数量最大和最小的序列 \(b\)。 思路 首先，若要让数量最少，我们直接在点了"喜欢"后立刻取消即可，那么最后得到的答案会有 \(x\) 个 \(0\ 1\)，\(x\) 即为负数的个数。剩余的数只能让 \(b\) 严格递增 \(1\)。 若要让数量最多，那么我们只需在全部点完后再取消。这时得到一个先递增后递减的序列。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; int cur; cin >> cur; if(cur &lt; 0) cnt ++; &#125; for(int i=1;i&lt;=n-cnt;i++) cout &lt;&lt; i &lt;&lt; ' '; for(int i=1;i&lt;=cnt;i++) cout &lt;&lt; n - cnt - i &lt;&lt; ' '; cout &lt;&lt; '\n'; for(int i=0;i&lt;cnt;i++) cout &lt;&lt; "1 0 "; for(int i=1;i&lt;=n-2*cnt;i++) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 瞎模拟即可 B. Settlement of Guinea Pigs 题意 给定一个操作序列，定义操作为下面任选一： "1"表示引入一个未知性别的猪，按规则放入一个栅栏内； "2"表示确定所有已经引入的猪的性别，按照规则重新排列。 定义一个栅栏内的猪性别需一致，且最多有两个猪。 输出最后需要至少多少个不同的栅栏。 思路 首先，在不知道性别的时候，新引入的猪只能单独放到一个栅栏内。 其次，若知道了性别，那么我们需要对奇偶性分类讨论： 若为奇数，那么母猪和公猪的数量一定为一个偶一个奇，那么当前就需要 \((\)总数量\(+1)/2\) 个栅栏 若为偶数，那么会出现两个偶数或两个奇数的可能，但我们不能确定为哪一种情况，所以我们考虑大的那个数量，也就是两个奇数的情况。这个时候，我们需要 总数量\(/2+1\) 个栅栏。 最后，对于每次操作，计算并统计最大值即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123; &#125; void solve() &#123; int n; cin >> n; int sum = 0, num = 0; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur == 1)&#123; sum ++, num ++; ans = max(ans, num); &#125;else&#123; if(sum == 0) num = 0; else num = (sum + 1 + (1 - sum % 2)) / 2; ans = max(ans, num); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 怎么奇数的情况搞错了（（ C. The Very Beautiful Blanket 题意 定义美丽矩阵满足下面的要求： 规模 \(4 \times 4\)； \(A_{11} \oplus A_{12} \oplus A_{21} \oplus A_{22} = A_{33} \oplus A_{34} \oplus A_{43} \oplus A_{44}\)； \(A_{13} \oplus A_{14} \oplus A_{23} \oplus A_{24} = A_{31} \oplus A_{32} \oplus A_{41} \oplus A_{42}\) 给定一个矩阵的规模，规模大于等于 \(4 \times 4\)，构造一个矩阵，使得所有 \(4 \times 4\) 的子矩阵均为美丽矩阵，且不同元素的数量最大。输出不同数字的数量，以及对应的一个矩阵。 思路 首先，值得留意的是：\(4x \oplus (4x+1) \oplus (4x + 2) \oplus (4x + 3) = 0\)。那么，我们不妨构造这样的子矩阵： \(\left[ {\begin{array}{cccc} 4x &amp; 4x + 1 \\ 4x + 2 &amp; 4x + 3 \end{array} } \right]\) 有趣的是，\(4x \oplus (4x + t) \oplus 4y \oplus (4y + t) = 0\) （巧了我不会证），那么我们不妨按照上面的矩阵依次排满第一行，然后找到大于所用过的数的第一个为 \(4\) 的倍数的数，继续按照上面的矩阵排列即可。那么，任意找出一个子矩阵，结果都为 \(0\)。 考虑到数据量，我们不妨让第 \(i\) 行的起始数字为 \(256(i - 1)\)，会让程序更好写。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123; &#125; void solve() &#123; int n, m; cin >> n >> m; cout &lt;&lt; n * m &lt;&lt; '\n'; for(int i=0;i&lt;n/2;i++)&#123; int offset = i * 512; for(int j=0;j&lt;m/2;j++) &#123; cout &lt;&lt; offset &lt;&lt; ' ' &lt;&lt; (offset + 1) &lt;&lt; ' '; offset += 4; &#125; if(m % 2 == 1) cout &lt;&lt; offset &lt;&lt; ' '; cout &lt;&lt; '\n'; offset = i * 512 + 2; for(int j=0;j&lt;m/2;j++) &#123; cout &lt;&lt; offset &lt;&lt; ' ' &lt;&lt; (offset + 1) &lt;&lt; ' '; offset += 4; &#125; if(m % 2 == 1) cout &lt;&lt; offset &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; if(n % 2 == 1)&#123; int offset = n / 2 * 512; for(int j=0;j&lt;m/2;j++) &#123; cout &lt;&lt; offset &lt;&lt; ' ' &lt;&lt; (offset + 1) &lt;&lt; ' '; offset += 4; &#125; if(m % 2 == 1) cout &lt;&lt; offset &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 不会证，但会猜（（（ D. Buying gifts 题意 给定 \(n\) 个商店，第 \(i\) 个商店具有 \(a_i, b_i\) 两个价格。规定每个商店均需要买一个商品，为 \(A\) 买第 \(i\) 个商店的物品花费 \(a_i\) 元，为 \(B\) 买第 \(i\) 个商店的物品花费 \(b_i\) 元。输出所有方案中为 \(A\) 买的商品的最大价格 \(\max_A\) 和为 \(B\) 买的商品的最大价格 \(\max_B\) 的差值的绝对值的最小值，即 \(\min\{|\max_A - \max_B|\}\)。 思路 首先，我们不可能去枚举所有的方案，那么我们至少需要一个 \(O(n \log n)\) 复杂度的解法。 我们可以枚举为 \(A\) 买的商品的最大值，也就是枚举所有的 \(a_i\)，将其作为当前的最大值，那么大于 \(a_i\) 数对应的商品只能给 \(B\)。 接着，我们可以二分查找 去除第 \(i\) 个商店后 剩余商店中的 所有 \(b_i\) 中 和 \(a_i\) 最近的两个数。若我们可以将这个数作为 \(B\) 的最大值，也就是说，所有大于 \(b_j\) 的数对应的 \(a_j\) 不能大于 \(a_i\)，那么更新差值的最小值。当然，有可能两个数都不满足，但是当前 \(B\) 中可以用的最大值依然可以和 \(a_i\) 减，他是有可能作为答案的。 对数复杂度的删除和查询，最佳之选就是 \(multiset\)。 而为了让上述操作更方便，我们不妨按 \(a_i\) 降序排序，那么，之前遍历过的 \(a_i\) 一定是要放到 \(B\) 里去的，而这些数也肯定不能在二分查找的范围内的，因而我们在遍历的时候，顺便记录前 \(i\) 个商店中 \(b_i\) 的最大值 \(mx\)，按照上面的分析执行即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123; &#125; void solve() &#123; int n; cin >> n; multiset&lt;int> a; vector&lt;pii> q(n); for(int i=0;i&lt;n;i++) cin >> q[i].first >> q[i].second; sort(q.begin(), q.end()); for(auto e : q) a.emplace(e.second); a.emplace(inf); int ans = inf, mx = -inf; for(int i=n-1;i>=0;i--)&#123; ans = min(ans, abs(q[i].first - mx)); a.erase(a.find(q[i].second)); auto it = a.lower_bound(q[i].first); if(*it != inf) &#123; if (q[i].first >= mx) ans = min(ans, abs(*it - q[i].first)); &#125; if (it != a.begin() &amp;&amp; q[i].first > mx) ans = min(ans, abs(*(--it) - q[i].first)); mx = max(mx, q[i].second); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 整个人升华了（划掉]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 827 Div 4</title>
    <url>/blog/posts/3129987947/</url>
    <content><![CDATA[Practice. A. Sum 题意 给定三个数，输出是否可以找出一个数，满足其为另外两个数的和。 思路 如题。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; int a, b, c; cin >> a >> b >> c; cout &lt;&lt; (a + b == c || a + c == b || b + c == a ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 如题 B. Increasing 题意 给定一个序列，满足是否可以重新排列序列，使序列严格单调递增。 思路 没有重复元素即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; int n; cin >> n; map&lt;int, bool> mp; bool f = true; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(mp[cur]) &#123; f = false; &#125; mp[cur] = true; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 说那么复杂干嘛（ C. Stripes 题意 给定一个 \(8 \times 8\) 的矩阵，定义操作为将某一行全部涂成红色，或将某一列全部涂成蓝色，后面的颜色会覆盖前面的颜色。给定任意次操作后的矩阵，输出最后涂上的是什么颜色。 思路 首先，既然存在覆盖，那么被覆盖的某行或某列一定不是在最后操作的。 那么，我们可以找出全为红色的行，或者全为蓝色的列，若能找到就为答案。不然，一定存在覆盖。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; vector&lt;string> s(8); for(int i=0;i&lt;8;i++) cin >> s[i]; bool f = false; for(int i=0;i&lt;8;i++)&#123; bool now = true; for(int j=0;j&lt;8;j++)&#123; if(s[i][j] == 'B') now = false; &#125; if(now)&#123; f = true; cout &lt;&lt; "R\n"; break; &#125; &#125; if(!f) for(int j=0;j&lt;8;j++)&#123; bool now = true; for(int i=0;i&lt;8;i++)&#123; if(s[i][j] == 'R') now = false; &#125; if(now)&#123; f = true; cout &lt;&lt; "B\n"; break; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 略微有点小思维 D. Coprime 题意 给定一个序列 \(a\)，找出 \(i, j, i \neq j\)，满足 \(a_i, a_j\) 互质。输出满足条件的 \(i + j\) 的最大值。 思路 虽然整体数据量很大，但是需要留意的是 \(a_i \leq 1000\)。 因而，我们不妨记录出现过的数对应的下标最大值。然后，我们直接对 \(1000\) 中出现过的数字遍历，统计出最大值即可。 时间复杂度：\(O(1000 ^ 2 \log x)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> int gcd(int a, int b)&#123; return a == 0 ? b : gcd(b % a, a); &#125; void solve()&#123; int n; cin >> n; vector&lt;int> a(1001); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; a[cur] = max(a[cur], i); &#125; int ans = -1; for(int i=1;i&lt;=1000;i++) for(int j=i;j&lt;=1000;j++)&#123; if(gcd(i, j) == 1 &amp;&amp; a[i] > 0 &amp;&amp; a[j] > 0) ans = max(ans, a[i] + a[j]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 来绕一个弯（（ E. Scuza 题意 给定一个上升台阶的所有相邻两层的高度差，对于 \(q\) 个询问给定的腿长 \(k_i\)，输出能登上的台阶距离地面的最大高度。 思路 首先，台阶上升，所以台阶距离地面的高度具有单调性。 那么，二分不就好了么。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, q; cin >> n >> q; vector&lt;int> a(n + 1), s(n + 2); for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; a[i] += a[i - 1]; s[i] = max(s[i - 1], a[i] - a[i - 1]); &#125; s[n + 1] = inf; while(q--)&#123; int x; cin >> x; cout &lt;&lt; a[upper_bound(s.begin(), s.end(), x) - s.begin() - 1] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 考虑到lower_bound找不到会指向最后一个点，那么我们不妨在最后插一个无穷大 F. Smaller 题意 给定两个初始均为 \(&#39;a&#39;\) 的字符串 \(s, t\)，定义操作为下面两种任选一： \(1\ k\ x\)，在 \(s\) 后面循环拼接上 \(k\) 个 \(x\)； \(2\ k\ x\)，在 \(t\) 后面循环拼接上 \(k\) 个 \(x\)。 对于每次操作，输出是否可以重新排列两个字符串，使 \(s\) 的字典序小于 \(t\)。 思路 我们不妨直接考虑怎么样才能让字典序较小： 既然可以重新排序，而且一开始两个字符串是一样的，且只有一种字母，那么，只要 \(t\) 中出现了不是 \(a\) 的字符，我们直接把他放到第一个，而 \(s\) 的第一个直接放上 \(a\)，就一定可以满足 \(s &lt; t\)； 但是，若没有非 \(a\) 字符，我们就只能统计有多少个 \(a\)，个数少的字典序自然小。 那么，我们只要按照上述思路，统计 \(s, t\) 中是否出现了非 \(a\) 字符，以及 \(a\) 出现的次数即可。 最后，若 \(s\) 出现了非 \(a\) 字符而 \(t\) 中没有出现，或者都没出现但 \(s\) 的 \(a\) 数量更多，那么输出 \(NO\)，否则为 \(YES\)。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int cnt1 = 1, cnt2 = 1; bool h1 = false, h2 = false; int q; cin >> q; while(q --)&#123; int d, k; cin >> d >> k; string s; cin >> s; for(char e : s)&#123; if(d == 1)&#123; if(e == 'a') cnt1 += k; else h1 = true; &#125; if(d == 2)&#123; if(e == 'a') cnt2 += k; else h2 = true; &#125; &#125; cout &lt;&lt; ((!h1 &amp;&amp; !h2 &amp;&amp; cnt1 >= cnt2) || (h1 &amp;&amp; !h2) ? "NO\n" : "YES\n"); &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 略微绕了一下（ G. Orray 题意 给定一个序列 \(a\)，定义 \(b_i\) 为 \(a\) 前 \(i\) 个数按位或的值。将序列重新排序，满足 \(b\) 的字典序最大。输出任意一种满足条件的方案。 思路 首先，按位或一定是越或越大的，因而我们一定会把最大的数放在第一个。 接着，要让下个数尽可能大，我们当然希望找到一个数，对于当前的数的最高位 \(0\)，这个数的该位为 \(1\)。 我们可能找不到这个数，但是有趣的是，既然数据范围为 \(1e9\)，那么我们一定可以找出 \(32\) 个以内的数，让按位或的值递增。 因而，我们不妨直接遍历 \(32\) 次，找出剩下的让按位或的结果最大的数，输出该数即可。 而，当我们拿不出数字使按位或的结果变大时，就结束了。剩余的数随便输出即可。 时间复杂度：\(O(32 n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; vector&lt;int> ans; vector&lt;bool> vis(n); int tot = 0; for(int i=31; i>=0;i--)&#123; int idx = -1, now = 0; for(int j=0;j&lt;n;j++)&#123; if(vis[j]) continue; if((tot | a[j]) > now)&#123; now = tot | a[j]; idx = j; &#125; &#125; if(idx == -1) break; vis[idx] = true; ans.emplace_back(a[idx]); tot |= a[idx]; &#125; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; for(int i=0;i&lt;n;i++) if(!vis[i]) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 想不到就绕死了（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 293</title>
    <url>/blog/posts/2378255232/</url>
    <content><![CDATA[Contestant. Rank 2467. Rating +89. A. Swap Odd and Even 题意 给定一个字符串，将所有 \(2x\) 和 \(2x+1\) 位字符交换位置，输出操作后的字符串。 思路 模拟即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; string s; cin >> s; for(int i=0;i&lt;s.size()/2;i++)&#123; char t = s[2 * i]; s[2 * i ] = s[2 * i + 1]; s[2 * i + 1] = t; &#125; cout &lt;&lt; s; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 快速签到 B. Call the ID Number 题意 给定一个序列 \(a\)，对于第 \(i\) 个元素，若 \(i\) 没被标记，那么将 \(a_i\) 标记。遍历序列后，输出剩余未标记的数。 思路 模拟即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;bool> vis(n + 1); int cnt = n; for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; if(vis[i] || vis[cur]) continue; cnt --; vis[cur] = true; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i]) cout &lt;&lt; i &lt;&lt; ' '; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 依然快速签到 C. Make Takahashi Happy 题意 给定一个 \(H \times W\) 的加权矩阵，规定一次移动只能向下或向右走，且不能超出矩阵范围。对于起点 \((1,1)\) 和终点 \((H, W)\)，输出满足路径中无重复元素的路径数。 思路 考虑到题给范围特别小，我们不妨直接 \(Dfs\)，用回溯搜索的方式记录当前元素出现了几次，若出现两次跳出搜索即可。 时间复杂度：\(O(n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[20][20], h, w, ans; map&lt;int, int> cnt; void init()&#123;&#125; void dfs(int x, int y)&#123; if(x == h &amp;&amp; y == w)&#123; ans ++; return; &#125; if(x + 1 &lt;= h &amp;&amp; cnt[a[x + 1][y]] == 0) &#123; cnt[a[x + 1][y]] ++; dfs(x + 1, y); cnt[a[x + 1][y]] --; &#125; if(y + 1 &lt;= w &amp;&amp; cnt[a[x][y + 1]] == 0) &#123; cnt[a[x][y + 1]] ++; dfs(x, y + 1); cnt[a[x][y + 1]] --; &#125; &#125; void solve() &#123; cin >> h >> w; for(int i=1;i&lt;=h;i++) for(int j=1;j&lt;=w;j++) cin >> a[i][j]; cnt[a[1][1]] ++; dfs(1, 1); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 就很暴力 D. Tying Rope 题意 定义一段绳子有两个端点，一端为红色，另一端为蓝色。对于 \(k\) 次操作，将第 \(A\) 个绳子颜色为 \(B\) 的一端和第 \(C\) 个绳子颜色为 \(D\) 的一端连接。 特别地，满足一端绳子不会和两条及以上绳子连起来。 输出连通块中环和链的个数。 思路1 首先，既然考虑到这个特别的条件，我们完全可以不管颜色，因为题目一定有解，对于一段绳子，它的一个端点只会出现在最多一次操作里。所以，在本次操作后，下一次再访问到这个绳子，一定是另一个点了。 为了读入数据方便，我们定义绳子左端点是红色的、右端点是蓝色的。 那么，按照上述方法，我们可以很简单地得到一条绳子它的左端点和右端点分别和哪条绳子连起来了。 接着，我们只需遍历所有绳子，对于第 \(i\) 个绳子，若它未被访问到，那么他一定是新的连通块的一部分，我们向左和向右找寻边界。当我们遍历到端点未和其他点连接时，结束寻找，此时枚举到的所有点都是这个连通块的一部分。但，若我们遍历到了之前遍历过的绳子，那么很显然存在了环，所以我们直接统计个数并跳过这个连通块继续寻找。 在找寻边界的时候，因为读入数据的特殊性，对于 \(A =&gt; B =&gt; C\)，若 \(B\) 的右端点和 \(A\) 的右端点连接，那么会出现死循环，但是此时会出现回到上一个相邻点的情况，而且我们不难发现，只有这种特殊情况才会出现"回溯"。所以，我们只需记录前一个绳子 \(A\)，找到 \(B\) 的左右端点中不是 \(A\) 的那个点所连接的绳子 \(C\) 即可。 时间复杂度：\(O(m + n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; //规定左红右蓝 vector&lt;vector&lt;int>> ac(n + 1, vector&lt;int>(2, -1)); for(int i=1;i&lt;=m;i++)&#123; int a, b, c, d; char bc, dc; cin >> a >> bc >> c >> dc; b = bc == 'R' ? 0 : 1; d = dc == 'R' ? 0 : 1; ac[a][b] = c; ac[c][d] = a; &#125; vector&lt;bool> vis(n + 1); int ans1 = 0, ans2 = 0; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]) continue; int now, pre; vis[i] = true; pre = i, now = ac[i][0]; bool ok = false; if(now != -1)&#123; vis[now] = true; while(true)&#123; int tmp = now; now = ac[now][0] == pre ? ac[now][1] : ac[now][0]; pre = tmp; if(now == -1) break; if(vis[now])&#123; ans1 ++; ok = true; break; &#125; vis[now] = true; &#125; &#125; pre = i, now = ac[i][1]; if(!ok &amp;&amp; now != -1) &#123; vis[now] = true; while (true) &#123; int tmp = now; now = ac[now][1] == pre ? ac[now][0] : ac[now][1]; pre = tmp; if (now == -1) break; if (vis[now]) &#123; ans1++; ok = true; break; &#125; vis[now] = true; &#125; &#125; if(!ok) ans2 ++; &#125; cout &lt;&lt; ans1 &lt;&lt; ' ' &lt;&lt; ans2 &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 无脑模拟（（ 思路2 本题也可以用并查集完成。 待补充 磕了半天居然磕出来了 E. Geometric Progression 题意 给定三个整数 \(A, X, M\)，输出 \((\displaystyle{\sum^{X-1}_{i=0} A ^ i)\ \%\ M}\)。 思路 首先，很明显这是等比数列求和公式，最后的答案就是 \(\frac{A ^ X - 1}{A-1}\ \%\ M\)。 但是，问题在于这个除法取模。 一般除法取模需要求逆元，但是本题的 \(A, M\) 是任意的，所以 \(M\) 不是质数并且 \(A, M\) 不互质的时候，无法求出逆元。 但是，若我们对 \(A^X - 1\) 因式分解，当 \(A = 1\) 时一定是一个让式子为 \(0\) 的根，也就是说可以提出 \(A - 1\)。 那么，\(A - 1\) 就可以消掉了。 为了取模计算方便，我们不妨在求快速幂的时候，对 \(M(A - 1)\) 取模，最后除掉 \(A - 1\) 即可。 因而，最后我们可以得到一个式子：\(\frac{A ^ X\ \%\ (M(A - 1)) - 1}{A-1}\)。 当然，当 \(A = 1\) 的时候需要特判，这只和 \(X\ \%\ M\) 的奇偶性有关。 时间复杂度：有点复杂 注意M(A-1)会爆long long，需要用__int_128 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int __int128_t #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; int qp(int a, int b, int m) &#123; a %= m; int res = 1; while (b > 0) &#123; if (b &amp; 1) res = res * a % m; a = a * a % m; b >>= 1; &#125; return res; &#125; void solve() &#123; long long a, x, m; cin >> a >> x >> m; cout &lt;&lt; (a == 1 ? x % m : (((long long) qp(a, x, m * (a - 1)) - 1) / (a - 1)) % m) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 麻了，被逆元坑了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 828 Div 3</title>
    <url>/blog/posts/3533911585/</url>
    <content><![CDATA[Practice. A. Number Replacement 题意 给定一个序列，一个字母可以映射到任意一个数字，但要求一个字母只能映射到一个数字，一个数字可以映射到多个字母。输出是否合法。 思路 简单，我们用哈希即可。用 \(map\) 即可解决本题。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve() &#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; string s; cin >> s; map&lt;int, char> mp; bool f = true; for(int i=0;i&lt;n;i++)&#123; if(mp[a[i]] > 0 &amp;&amp; mp[a[i]] != s[i]) f = false; mp[a[i]] = s[i]; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while(t --) solve(); &#125; 水.jpg B. Even-Odd Increments 题意 给定一个序列，含有奇数和偶数，定义操作如下： \(0\ x\) 表示将 \(x\) 添加到所有偶数上； \(1\ x\) 表示将 \(x\) 添加到所有奇数上。 在每次操作后，输出总和。前面的操作会影响后面的值。 思路 显然，我们只需统计当前序列有多少偶数即可。 设偶数的个数为 \(cnt\)，那么第一个操作即为将 \(sum\) 加上 \(even \times x\)，第二个操作即为将 \(sum\) 加上 \((n - even) \times x\)。 显然，我们不需要在每次操作后遍历找偶数个数，而是考虑下面的规律： 偶数加奇数为奇数； 奇数加奇数为偶数。 因而，若出现将奇数加在奇数上的情况，那么 \(even = n\)，若出现将奇数加在偶数上的情况，那么 \(even = 0\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve() &#123; int n, q; cin >> n >> q; vector&lt;int> a(n); //注意一下偶数和奇数的相加即可 int even = 0, sum = 0; for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; sum += a[i]; if(a[i] % 2 == 0) even ++; &#125; while(q --)&#123; int t, v; cin >> t >> v; if(t % 2 == 0)&#123; //加到偶数上 sum += even * v; cout &lt;&lt; sum &lt;&lt; '\n'; if(v % 2 == 1) even = 0; //偶加奇 &#125;else&#123; //加到奇数上 sum += (n - even) * v; cout &lt;&lt; sum &lt;&lt; '\n'; if(v % 2 == 1) even = n; //奇加奇 &#125; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while(t --) solve(); &#125; 偏模拟的思维题 C. Traffic Light 题意 定义三种交通信号灯：\(R,H,G\)，只有位于 \(G\) 的时间下才可过马路。交通信号灯的切换具有周期性，因而给定一个周期的信号灯切换情况 \(s\)，如 \(s = RBRGG\)，那么在执行五秒后，将会重新执行一次，构成 \(RBRGGRBRGGRB...\)。给定当前的信号灯种类 \(c\)，输出遇到下一个 \(G\) 所间隔的最长时间。 思路 如上，我们只需遍历所有 \(c\)，找出其和下一个 \(G\) 的距离即可。 至于距离，数据范围貌似可以允许我们暴力往后搜，但后缀数组会出手。 我们维护后缀数组，\(suf_i\) 表示 \(i\) 及以后第一个出现的 \(G\) 的位置。 那么，查询的复杂度即为 \(O(1)\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve() &#123; int n; char c; cin >> n >> c; string s; cin >> s; s = " " + s + s; n *= 2; vector&lt;int> suf(n + 1); suf[n] = -1; for(int i=n - 1;i>=1;i--)&#123; if(s[i] == 'g') suf[i] = i; else suf[i] = suf[i + 1]; &#125; int mx = 0; for(int i=0;i&lt;n;i++)&#123; if(s[i] == c) mx = max(mx, suf[i] - i); &#125; cout &lt;&lt; mx &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while(t --) solve(); &#125; 可能就真的能暴力（（ D. Divisibility by 2^n 题意 给定一个长度为 \(n\) 的序列，定义一次操作为选取一个 \(a_i\) 并将其改为 \(a_i \times i\)。输出最少的操作数，使最后的序列的乘积为 \(2 ^ n\) 的倍数。 思路 首先，乘上奇数绝对没什么用，所以我们只需考虑偶数。 观察偶数的递推性以及二进制下的规律，我们不难发现所有的偶数都是一个 \(2 ^ t\) 乘上一个奇数得到的。 上述没必要乘上偶数，毕竟那就是 \(2 ^ {t + 1}\) 的事情了，为何要考虑重复呢。 因而，我们自然希望我们能在一次操作中乘上尽可能多的 \(2\)，也就是让 \(t\) 尽可能大。 这个 \(t_{\max}\) 是很容易求的，我们只需循环乘二直到不超过 \(n\) 的最大值即可。 那么，我们不妨去枚举 \(2 ^ t\) 的奇数倍，然后在超过 \(n\) 后将 \(t\) 递减，这样即可满足条件。 在加之前，我们判断一下当前能除多少个 \(2\)，和 \(n\) 比较即可。 时间复杂度：\(O(nt)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve() &#123; int n; cin >> n; int cnt = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; while(cur % 2 == 0)&#123; cur /= 2; cnt ++; &#125; &#125; int mx = 1, cur = 2; while(true)&#123; if(cur * 2 > n) break; mx ++; cur *= 2; &#125; int ans = 0; for(int i=mx;i>=1;i--)&#123; for(int j=1;pow(2, i)*j&lt;=n;j+=2)&#123; //奇数倍 if(cnt >= n) break; cnt += i; ans ++; &#125; if(cnt >= n) break; &#125; cout &lt;&lt; (cnt >= n ? ans : -1) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while(t --) solve(); &#125; 奇怪的清晰思路增加了 E1. Divisible Numbers (easy version) 详见E2，区别是本题的数据范围小 E2. Divisible Numbers (hard version) 题意 给定 \(4\) 个整数 \(a, b, c, d\)，找出一对 \(x, y\)，满足 \(x \in (a, c], y \in (b, d], xy\) 可以被 \(ab\) 整除。 思路 首先，我们不难发现，\(y = k \times \frac{ab}{gcd(ab, x)}\)，其中 \(k\) 为常数，那么，我们可以很简单的用 \(O(1)\) 的复杂度算出 \(y\)。 那么我们来考虑 \(x\)。显然，\(x \neq 1\)，所以 \(x\) 就是 \(gcd(ab, x)\) 的倍数，或者说，是 \(ab\) 的因数的倍数。 那么，我们只需枚举所有的因数，然后，我们也可以用 \(O(1)\) 的方法算出 \(x\)，和求 \(y\) 的方法类似。 但是，枚举 \(ab\) 的因数是不现实的，因为 \(\sqrt{ab}\) 太大了。但是，既然我们可以将这个数分解为 \(a, b\)，那么它的所有因数就是 \(a\) 的所有因数和 \(b\) 的所有因数配对相乘。 因而，\(\sqrt a\) 可以减到 \(1e5\) 的复杂度，足以。 时间复杂度：\(O(\sqrt a + \sqrt b + t ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; vector&lt;int> fact(int x) &#123; vector&lt;int> facts; int sq = (int) sqrt(x); for (int i = 1; i &lt; sqrt(x); i++) &#123; if (x % i == 0) facts.emplace_back(i), facts.emplace_back(x / i); &#125; if (sq * sq == x) facts.emplace_back(sq); return facts; &#125; void solve() &#123; int a, b, c, d; cin >> a >> b >> c >> d; vector&lt;int> factA = fact(a), factB = fact(b); bool f = false; for (int i: factA) &#123; for (int j: factB) &#123; int bx = i * j, by = a * b / (i * j); int x = ((int) ceil((double) a / (double) bx) + (a % bx == 0 ? 1 : 0)) * bx, y = ((int) ceil((double) b / (double) by) + (b % by == 0 ? 1 : 0)) * by; if (x &lt;= c &amp;&amp; y &lt;= d) &#123; cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n'; f = true; break; &#125; &#125; if (f) break; &#125; if (!f) cout &lt;&lt; -1 &lt;&lt; ' ' &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while (t --) solve(); &#125; 一开始还想着贪心，似也做不出来，淦]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 856 Div 2</title>
    <url>/blog/posts/4284380403/</url>
    <content><![CDATA[Contestant. Rank 1866. Rating -16. A. Prefix and Suffix Array 题意 给定一个字符串的所有前缀和后缀，如 \(a, ab, abc, bca, ca, a\)，不包含其本身，判断原字符串是否是回文字符串。 思路 既然是前后缀，并且回文字符串的判断只需比较 \([0, \frac{n}{2}]\) 和 \([n - \frac{n}{2} - 1, n - 1]\) 区间对应的子串即可，所以我们只需拿出长度为 \(\frac{n}{2}\) 的两个字符串，将一个字符串反转后和另一个比较，相等即回文。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve()&#123; int n; cin >> n; vector&lt;string> s; for(int i=0;i&lt;2 * (n - 1); i++)&#123; string now; cin >> now; if(now.size() == n / 2) s.emplace_back(now); &#125; std::reverse(s[0].begin(), s[0].end()); cout &lt;&lt; (s[0] == s[1] ? "YES\n" : "NO\n"); &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 真是阴间时间下猪脑转不动了（ B. Not Dividing 题意 给定一个长度为 \(n\) 的数组 \(a\)，定义操作为选择任意一个数字并将其加减 \(1\)，操作最多执行 \(2n\) 次。输出一种方案操作后得到的数组，满足 \(a_{i + 1}\) 不能被 \(a_i\) 整除。 思路 首先，不能出现 \(1\)，因为无论前面的数怎么改变，最后都会被 \(1\) 整除，所以遇到 \(1\) 改成 \(2\)。 其次，奇数不能被偶数整除，而偶数可以被奇数整除，但该偶数 \(+1\) 就不会被该奇数整除了（具体证明不清楚）。 最后，我们得到下面的结论：遇到整除，将后者加一，除非遇到 \(1\)，此时将前者加一。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve()&#123; int n; cin >> n; int pre; cin >> pre; if(pre == 1) pre ++; cout &lt;&lt; pre &lt;&lt; ' '; for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur == 1) cur ++; if(cur % pre == 0)&#123; pre = cur + 1; &#125;else pre = cur; cout &lt;&lt; pre &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 当然不是简简单单的判奇偶啊... C. Scoring Subsequences 题意 定义一个不递减序列 \(s\) 的 \(cost\) 为 \(\frac{s_1\cdot s_2\cdot \ldots \cdot s_d}{d!}\)。给定一个长度为 \(n\) 的序列，对于所有 \(k \in [1, n]\)，输出前 \(k\) 个数的所有子序列的最大 \(cost\) 对应的最大子序列长度。 思路 首先，第一个数对应的答案一定是 \(1\)，这是毋庸置疑的。 那么，遍历到第二个数的时候，我们可以继续保持答案 \(1\)，也可以把答案更新为 \(2\)，此时对应为选第二个数或者都选，因为序列是不递减的。 那么，假设我们选了两个数，那么继续遍历到第三个数的时候，由于第二三两个数的乘积大于等于前两个数的乘积，所以答案是肯定大于等于 \(2\) 的，我们唯一需要判断的就是前一个数能不能放进来。 为什么不用再往前考虑呢？因为之前我们已经判断过了，比如说第二次只选了一个数，那么 \(a_2 \geq \frac{a_1 \times a_2}{2} =&gt; a_1 \leq 2\)，也必定满足 \(\frac{a_2 \times a_3}{2} \geq \frac{a_1 \times a_2 \times a_3}{2 \times 3} =&gt; a_1 \leq 3\)。 因此，这道题就变得很好写了（ 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; void solve()&#123; int n; cin >> n; for(int i=1;i&lt;=n;i++) cin >> a[i]; vector&lt;int> ans(n + 1); ans[1] = 1; for(int i=2;i&lt;=n;i++)&#123; ans[i] = ans[i - 1]; if(a[i - ans[i]] > ans[i]) ans[i] ++; &#125; for(int i=1;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 想个半天，差点没看到给的序列不递减，淦 D. Counting Factorizations 题意 对于一个数 \(m\)，由算术基本定理可知，它可以分解为 \(m=p_1^{e_1}\cdot p_2^{e_2}\cdot \ldots \cdot p_k^{e_k}\)，现将所有底数和指数拿出来作为一个序列 \(f(m) = \{p_1, e_1, p_2, e_2, \ldots \}\)，定义如上。 现在，给定上述序列，长度为 \(2n\)，序列的顺序未知，输出所有可能的排序中，\(m\) 的个数总和，\(\mod 998244353\)。 思路 特判 首先，底数一定为不同的 \(n\) 个质数，所以拿到数据后，我们应该先将所有不同的质数找出，若数量不够，直接输出 \(0\)。 指数的全排列问题 否则，我们假设已经选好了 \(n\) 个质数，来考虑一下指数怎么排。 这是一个含有重复数字的全排列问题，它有一个公式，套用在本题即为下面的称述： 我们定义 \(b\) 为所有合数的数量的序列，遍历得到长度为 \(s\)，如 \(2, 3, 4, 4\) 中，\(s = 1, b_1 = 2\)； 同理，\(c\) 为所有质数的数量的序列，长度为 \(t\)； 考虑到有部分质数被拿走，作为了底数，所以部分 \(c_i\) 会减少一定的值。因为底数不能重复，所以最多减少 \(1\)，我们定义 \(c&#39;\) 为所有质数扣去底数后的数量的序列； \(ans = \frac{n!}{b_1!\:\:b_2!\ldots b_s!\:\:c&#39;_1!\:\:c&#39;_2!\ldots c&#39;_t!}\) 那么，最后的答案即为所有 \(ans\) 的和。 简化问题 显然，\(\frac{n!}{b_1!\:\:b_2!\ldots b_s!}\) 可以作为公因子提出，而剩余的数可以进行通分，提出 \(\frac{1}{c_1!\:\:c_2!\ldots c_t!}\)（注意这里是 \(c\)，不是 \(c&#39;\)，能提出的原因是 \(x! = x * (x - 1)!\)），剩余的分子即为 \(t\) 个数里面选 \(n\) 个的所有组合的和，每个组合的值为其包含的元素的乘积。 因此，我们只需要在所有不同质数中挑选 \(n\) 个，求出所选数字的乘积，最后所有不同选择算得的乘积总和乘上之前提出的公因子即为答案。 当然，我们可以递归枚举，但是这样复杂度未免太高了。 如何递推 所有乘积的式子的元素顺序是不影响答案的，所以我们不妨按照序列的顺序将每个式子的元素排序。 如对于下面的序列，我们希望从这 \(5\) 个元素中选 \(3\) 个： 1 2 3 5 4 因为我们确定了元素的顺序，所以我们不妨来考虑一个特定的元素：\(5\)。 对于一个乘积式子 \(? \times ? \times ?\)，我们将第三位填上 \(5\)，那么可以得到这些式子：\(1 \times 2 \times 5 + 1 \times 3 \times 5 + 2 \times 3 \times 5\)， 也就是 \((1 \times 2 + 1 \times 3 + 2 \times 3) \times 5\)。 也就是说，前面两项的选择只和 \(5\) 前面的数有关。 我们还可以将上面的式子提取一下：\((1 \times 2 + (1 + 2) \times 3) \times 5\)。 这时，\(3\) 来到了第二位，它的结果和 \(5\) 的运算大同小异。 而对于类似于 \(1\) 在第 \(3\) 项的情况，我们可以假想地在序列前加上几个 \(0\)，这样对结果毫无影响，但却让 \(1\) 出现在了 \([1, n]\) 的每一位。 事实上，我们可以加上含 \(0\) 的若干项，使所有数字均在 \([1, n]\) 的每一位出现，而如果这样，那么我们可以枚举每一个数字位于哪一位，然后将 上一位 的 前 \(x - 1\) 个选择 所得的答案乘上这个数字，得到 前 \(x\) 位的 前 \(x\) 个选择的乘积。 显然，我们还需要加上不选这个数字的情况，也就是前一个数字的前 \(x\) 个选择所推得的答案。 因而，上述思路可以用二维 \(dp\) 实现，\(dp[i][j]\) 表示前 \(i\) 个数的前 \(j\) 个选择的推算结果。 关于 \(dp\) 部分，本思路正反递推都是可行的，下面给出正向递推的状态转移方程： \(dp[i][j] = dp[i][j] + dp[i - 1][j - 1] \times c[i]\) 其中，\(c\) 为所有不同的质数的数量的序列，下标从 \(1\) 开始。 优化复杂度 阶乘和阶乘逆元可以预处理得到，而质数的判断可以使用线性筛（欧拉筛），求逆元的话可以线性递推也可以快速幂。 时间复杂度：常数有点大的\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; bool vis[N], is[N]; int pri[N], cnt; int fact[N], fact_inv[N]; int qp(int a, int b)&#123; int ans = 1; while(b > 0)&#123; if(b &amp; 1) ans = ((ans % mod) * (a % mod)) % mod; a = ((a % mod) * (a % mod)) % mod; b >>= 1; &#125; return ans; &#125; void init() &#123; for (int i = 2; i &lt;= 1e6; ++i) &#123; if (!vis[i]) &#123; pri[cnt++] = i; is[i] = true; &#125; for (int j = 0; j &lt; cnt; ++j) &#123; if (1ll * i * pri[j] > 1e6) break; vis[i * pri[j]] = true; if (i % pri[j] == 0) break; &#125; &#125; fact[0] = fact_inv[0] = 1; for(int i=1;i&lt;=1e6;i++)&#123; fact[i] = ((fact[i - 1] % mod) * (i % mod)) % mod; fact_inv[i] = qp(fact[i], mod - 2); &#125; &#125; void solve() &#123; int n; cin >> n; vector&lt;int> in(2 * n); map&lt;int, int> tot; for (int i = 0; i &lt; 2 * n; i++) &#123; cin >> in[i]; tot[in[i]]++; &#125; vector&lt;int> c; int el = fact[n]; for(auto e : tot)&#123; if (is[e.first]) c.emplace_back(e.second); el = ((el % mod) * (fact_inv[e.second] % mod)) % mod; &#125; if (c.size() &lt; n) &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; vector&lt;vector&lt;int>> dp(c.size() + 1, vector&lt;int>(n + 1, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= c.size(); i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; dp[i][j] = dp[i - 1][j]; if (j > 0) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * c[i - 1]) % mod; //这里的c初始下标是0 &#125; &#125; cout &lt;&lt; (el * dp[c.size()][n]) % mod &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 我人似了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 855 Div 3</title>
    <url>/blog/posts/3115409144/</url>
    <content><![CDATA[Contestant(alt). Rank 3678. Rating +62(+262 -200). A. Is It a Cat? 题意 给定一个字符串，转化为小写字母后，判断其是否由 \(m, e, o, w\) 组成，四个字母可以出现重复多个，但顺序不能改变，且每一个字母必须出现至少一次。如 \(MeOooOW\)。 思路 如题，我们只需用一个变量存储当前遍历到了哪个字母，若比较到某一个字母的时候，遍历的下标越界，那么输出 \(NO\)。否则，在最后判断一下四个字母是否都出现了至少一次，若满足那么 \(YES\)，否则 \(NO\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int tp = 0; char up[4] = &#123;'M', 'E', 'O', 'W'&#125;, lo[4] = &#123;'m', 'e', 'o', 'w'&#125;; bool ok[4] = &#123;false&#125;; bool f = true; for(int i=0;i&lt;n;i++)&#123; while(tp &lt; 4 &amp;&amp; s[i] != up[tp] &amp;&amp; s[i] != lo[tp]) tp ++; if(tp >= 4)&#123; f = false; break; &#125; ok[tp] = true; &#125; cout &lt;&lt; (ok[0] &amp;&amp; ok[1] &amp;&amp; ok[2] &amp;&amp; ok[3] &amp;&amp; f ? "YES\n" : "NO\n"); &#125; &#125; 瞎模拟即可 B. Count the Number of Pairs 题意 给定一个字符串以及一个整数 \(k\)，规定同一个字母的大写和小写可以进行配对，一个字符只能出现在一对数中。定义一次操作为选择一个字符改变它的大小写，输出在小于等于 \(k\) 次的操作后，最多有多少对数。 思路 我们用两个数组解决这个问题： 令小写字母对应权值为 \(1\)，大写字母对应权值为 \(-1\)，那么加权后每种字母的总和的绝对值可以表征配对了多少对。我们记它为 \(abs(ans[i])\)。 统计每一种数出现的次数 \(cnt[i]\)。 那么，在不进行操作的前提下，我们易得最后的答案为 \(\sum \frac{(cnt[i] - abs(ans[i])}{2}\)。 若可以进行操作，那么对于一个字母剩余的数 \(ans[i]\)，我们可以配对 \(\frac{ans[i]}{2}\) 个。 因此，最后的答案即为 \(\sum \frac{(cnt[i] - abs(ans[i])}{2} + min(k, \sum \frac{ans[i]}{2})\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n, k; cin >> n >> k; string s; cin >> s; int cnt[26]&#123;&#125;, ans[26]&#123;&#125;; for(int i=0;i&lt;n;i++)&#123; if(s[i] >= 'a' &amp;&amp; s[i] &lt;= 'z') &#123; cnt[s[i] - 'a'] ++; ans[s[i] - 'a'] ++; &#125;else&#123; cnt[s[i] - 'A'] ++; ans[s[i] - 'A'] --; &#125; &#125; int res = 0, left = 0; for(int i=0;i&lt;26;i++)&#123; res += (cnt[i] - abs(ans[i])) / 2; left += abs(ans[i]) / 2; &#125; cout &lt;&lt; res + min(k, left) &lt;&lt; '\n'; &#125; &#125; 总感觉类似的题哪里做过 C1. Powering the Hero (easy version) 详见C2，区别是C1的数据量更小一点 C2. Powering the Hero (hard version) 题意 给定 \(n\) 个卡牌对应的数字，从前向后遍历，若数字不为 \(0\)，那么可以选择是否将该数放在堆顶，或者将其丢弃。对于所有为 \(0\) 的数字，从堆顶拿出一个牌作为这个 \(0\) 的加分值，并将这两个牌丢弃，若堆为空则不考虑。输出最后加分的最大值。 思路 既然可以选择放或不放，那么我们一定可以让后面的 \(cnt\) 个 \(0\) 拿到前面的前 \(cnt\) 大的数。 因而，我们直接用优先队列即可。 有趣的是，困难版的数据量也无碍。 时间复杂度：最坏\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; priority_queue&lt;int> q; int ans = 0; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; if(cur != 0) q.push(cur); else if(!q.empty()) ans += q.top(), q.pop(); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 赛时贪错了，吃了WA D. Remove Two Letters 题意 给定一个字符串，输出去掉连续的两个字母后，得到的所有字符串中不同的字符串的个数。 思路 我们不妨取补集： 对于一个序列，若要出现重复的子串，那么需要满足 \(s[i] == s[i + 2]\)，这样的话，去掉 \(s[i], s[i + 1]\) 和去掉 \(s[i + 1], s[i + 2]\) 就是等价的了。 因而，我们统计出对数，用 \(n - 1\) 减去即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int ans = 0, cnt = 1; char pre0 = s[0], pre1 = s[1]; for(int i=1;i&lt;n-1;i++)&#123; char cur0 = s[i], cur1 = s[i + 1]; if((pre0 == cur0 &amp;&amp; pre1 == cur1) || pre0 == cur1 &amp;&amp; pre1 == cur0)&#123; cnt ++; &#125;else&#123; ans += cnt - 1; cnt = 1; pre0 = cur0, pre1 = cur1; &#125; &#125; cout &lt;&lt; n - (ans + cnt - 1) - 1 &lt;&lt; '\n'; &#125; &#125; 赛时的代码居然还写的麻烦了一点（（ E1. Unforgivable Curse (easy version) 详见E2，区别是本题k=3 E2. Unforgivable Curse (hard version) 题意 给定两个长度相等的字符串 \(s, t\)，定义操作为交换 \(i, i + k\) 或 \(i, i + k + 1\) 上的数，在任意数量的操作后，输出是否可以将 \(s\) 更改为 \(t\)。 思路 首先，我们只需进行下面的操作即可将相邻数交换： \(i, i + k + 1\) \(i + k + 1, i + 1\) \(i, i + k + 1\) 因而，只要可以进行上面的操作（或者向左），那么我们只需进行一定的操作，肯定可以将其换到我们需要的为止。 那么，我们也不难发现，若要向右交换，那么 \(i &gt; k - n\)，若要想左交换，那么 \(i &lt; k\)。 因而，只要 \([k, k - n]\) 内的字符相等，就一定有解。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; void solve()&#123; int n, k; cin >> n >> k; string s, t; cin >> s >> t; if(n &lt;= k) cout &lt;&lt; (s == t ? "YES\n" : "NO\n"); else&#123; bool f = true; if(2 * k > n)&#123; for(int i=n-k;i&lt;k;i++) if(s[i] != t[i]) f = false; &#125; if(f)&#123; sort(s.begin(), s.end()); sort(t.begin(), t.end()); f = s == t; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 比赛快结束的时候就懒得写了（其实还挺好写的 F. Dasha and Nightmares 题意 给定 \(n\) 个字符串，输出有多少对字符串，满足下面的条件： 两个字符串的长度总和为奇数； 不同字母的个数为 \(25\)； 每种字母出现的次数为奇数。 思路 首先，第一个条件可以忽略，因为偶数个奇数相加，一定是奇数。 其次，第二个条件即为排除掉一个字母，需要其余的字母均出现。 考虑到 \(25\) 足够小，我们不妨用状压。 更具体地说，我们枚举不出现的字母 \(x\)，然后枚举所有字符串，对于字符串 \(s_i\)，它的所有字母的出现次数均可以预处理。但，因为我们只需考虑奇偶性，所以我们不妨令奇数状态为 \(1\)，偶数状态为 \(0\)，按照字母表顺序构建一个 \(26\) 位二进制字符串，便可以得到这个字符串的"哈希"值。 那么，考虑到异或的可逆性，对于一个排除掉 \(x\) 的拼接后的字符串，它的哈希值一定为形如 \(111...0...111\)，\(0\) 位即为 \(x\)。那么，对于这个 \(p = (1 &lt;&lt; 26)\ XOR\ (1 &lt;&lt; x)\)，我们可以将其和 \(s_i\) 的哈希值进行异或，得到需要和其配对的字符串的哈希值。 显然，对于第 \(i\) 个字符串，我们只需遍历前 \(i - 1\) 个字符串是否可以与其配对即可。那么，我们可以用 \(map\) 存储一个哈希值对应的字符串有多少个，最后统计总和即可。 时间复杂度：\(O(25n + m) = 1e7\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int odd[N], num[N]; void solve()&#123; int n; cin >> n; for(int i=0;i&lt;n;i++)&#123; string cur; cin >> cur; for(char e : cur)&#123; odd[i] ^= (1 &lt;&lt; (e - 'a')); num[i] |= (1 &lt;&lt; (e - 'a')); &#125; &#125; int ans = 0; for(int i=0;i&lt;26;i++)&#123; //不选i map&lt;int, int> cnt; int tot = ((1 &lt;&lt; 26) - 1) ^ (1 &lt;&lt; i); for(int j=0;j&lt;n;j++)&#123; if(!(num[j] &amp; (1 &lt;&lt; i)))&#123; ans += cnt[tot ^ odd[j]]; cnt[odd[j]] ++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t = 1; //cin >> t; while(t --) solve(); &#125; 我好若，居然想不到状压]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 144</title>
    <url>/blog/posts/1514977487/</url>
    <content><![CDATA[Contestant. Rank 1837. Rating +17. 开局天崩场 A. Typical Interview Problem 题意 对于一个数字，如果它是 \(3\) 的倍数，那么它映射到字符串 \(F\)，如果它是 \(5\) 的倍数，那么映射到 \(B\)，如果是 \(15\) 的倍数，那么映射到 \(FB\)，否则映射到空字符串。给定一个字符串，输出它是否是一段连续区间内对应数字映射后拼接而成的。 思路 显然，\(15\) 一循环，且给定的字符串长度只有 \(10\)，所以我们只需暴力匹配即可。 有趣的是，\(FB\) 拆开不影响答案。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0) &#123; int n = console.nextInt(); String s = "FBFFFBFFBFFBFBFFBFFBBFFBFBFFBFFB"; String x = console.next(); console.print(s.contains(x) ? "YES\n" : "NO\n"); &#125; console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; s开小了，倒大霉了属于是 B. Asterisk-Minor Template 题意 给定两个字符串，构造出一个模板，模板由 '*' 和字母组成，通配符 '*' 可以匹配自然数个任意字母。输出是否存在一种模板，使通配符的数量小于等于字母的数量。若存在，输出这个模板。 思路 要满足题给条件，那么模板一定需要存在两个连续的字母。考虑到可以任意匹配，我们不妨只找出一对字母，在两个字符串中均出现，如 \(ab\) 在 \(aabc, xxxabz\) 中均出现，那么就可以在两边加上通配符，如构建为 *\(ab\)*。 当然，只要开头或结尾一样，一个字母加上一个通配符即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; string a, b; cin >> a >> b; if(a[0] == b[0]) cout &lt;&lt; "YES\n" &lt;&lt; a[0] &lt;&lt; '*' &lt;&lt; '\n'; else if(a[a.size() - 1] == b[b.size() - 1]) cout &lt;&lt; "YES\n" &lt;&lt; '*' &lt;&lt; a[a.size() - 1] &lt;&lt; '\n'; else&#123; bool f = false; for(int i=0;i&lt;a.size() - 1;i++)&#123; for(int j=0;j&lt;b.size() - 1;j++)&#123; if(a[i] == b[j] &amp;&amp; a[i + 1] == b[j + 1])&#123; cout &lt;&lt; "YES\n" &lt;&lt; '*' &lt;&lt; a[i] &lt;&lt; a[i + 1] &lt;&lt; '*' &lt;&lt; '\n'; f = true; break; &#125; &#125; if(f) break; &#125; if(!f) cout &lt;&lt; "NO\n"; &#125; &#125; &#125; 贪心一下~ C. Maximum Set 题意 给定两个整数 \(l, r\)，在 \([l, r]\) 内找一个递增不重复序列，满足相邻数可整除。输出序列的最大数量，以及该数量的方案数。方案数 \(\mod 998244353\)。 思路 首先，要让数量最多，且能整除，那么我们不妨将左端点循环乘二，得到一个不超过右端点的最大数，此时乘二的数量就是序列的最大数量 \(- 1\)。 更简洁地看，我们将上述过程转化为一个表达式：\(l \times 2 \times 2 \times \ldots \times 2 = x\leq r\)。 那么，显然 \(\frac{r}{x}\) 是小于 \(2\) 的，所以若要让某个倍数变大，即选择一个 \(2\) 将其变大，那么我们只能将其改成 \(3\)。 那么，整道题就可以变为遍历所有满足上述表达式的 \(l\)，判断 \(\frac{r}{x}\) 和 \(1.5\) 的大小关系，若前者大，那么对于这个左边界，我们可以得到 \(cnt_2\) 个方案，否则只有一个方案。 上述思路的复杂度较高，考虑到推算较为简单，我们不妨直接推导式子： 设 \(\frac{x}{l} = p\)，那么 \(l&#39;p \leq r\) 即 \(l \leq l&#39; \leq \frac{r}{p}\)。 同理，\(l \leq l&#39;&#39; \leq \frac{2r}{3p}\) 那么，答案即为 \((l&#39;&#39; - l + 1) \times cnt + (l&#39; - l&#39;&#39;)\) 当然，我们也可以二分，问题不大（（ 时间复杂度：一般般 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); long mod = 998244353; long t = console.nextInt(); nxt: while(t -- > 0) &#123; long n = console.nextInt(), m = console.nextInt(); long x = n, ans1 = 1, p = 1; while(true)&#123; if(x * 2 > m) break; x *= 2; ans1 ++; p = (p * 2) % mod; &#125; boolean ok = false; long l1 = (long) Math.max(n - 1, (double) m * 2 / 3 / p), l2 = Math.max(l1 - 1, m / p); long ans2 = (((l1 - n + 1) * ans1 % mod) + (l2 - l1) % mod) % mod; console.print(ans1 + " " + ans2 + "\n"); &#125; console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; 暴力枚举左端点的铸币竟是我自己]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 854 Div 1 plus 2</title>
    <url>/blog/posts/2715179373/</url>
    <content><![CDATA[Contestant(alt). Rank 4431. Rating -40 (+310 -350). A. Recent Actions 题意 给定一个整数 \(n\)，以及 \(n\) 的排列，给定 \(m\) 个大于 \(n\) 的数，若这个数不在序列里，那么将整个序列右移一位，删去多出的元素，并将第一个空位放入该数。输出原排列的每一个数在第几个数放入的时候被移除。 思路 直接用 \(map\) 或者数组存一下是否在序列里即可，然后统计即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n, m; cin >> n >> m; map&lt;int, bool> st; vector&lt;int> ans(n, -1); int r = n - 1; for(int i=0;i&lt;m;i++)&#123; int cur; cin >> cur; if(!st[cur] &amp;&amp; r >= 0)&#123; ans[r] = i + 1; r --; &#125; st[cur] = true; &#125; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; 题目怎么那么绕 B. Equalize by Divide 题意 给定一个数组 \(a\)，所有数均为正数，定义操作为选择两个不同的下标 \(i, j\)，将 \(a_i\) 改为 \(\lceil \frac{a_i}{a_j} \rceil\)。输出一种方案，使所有数相等。若无方案输出无解。 思路 首先，我们不可能将所有数都变为 \(1\)，除非原来就全是 \(1\)。所以我们不妨先特判是否所有数都相等，若都相等那么无需操作，否则，若数组中含有 \(1\)，就为无解。 否则，我们只需避免产生 \(1\) 即可，也就是用当前序列的最小值将所有数除到比最小值小或者等于为止。 上述做法可以保证最后的答案一定是有解的，若第一次操作可以构建出一个 \([\min, \min, ..., \min]\) 的数组，那么就无需操作，否则最后的结果一定是 \([2, 2, ..., 2]\)。 时间复杂度：有点复杂 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++)cin >> a[i]; vector&lt;pii> ans(30 * n); int size = 0; bool h = true; while(true)&#123; bool f = false, have1 = false; int pre = -1, mn = 0; for(int i=0;i&lt;n;i++)&#123; if(pre == -1) pre = a[i]; if(pre != a[i]) f = true; if(a[i] == 1) have1 = true; if(a[mn] > a[i]) mn = i; &#125; if(!f) break; if(have1)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; h = false; break; &#125; for(int i=0;i&lt;n;i++)&#123; while(a[i] != a[mn])&#123; if(a[i] > a[mn])&#123; ans[size ++] = &#123;i, mn&#125;; a[i] = ceil((double) a[i] / (double) a[mn]); &#125;else&#123; ans[size ++] = &#123;mn, i&#125;; a[mn] = ceil((double) a[mn] / (double) a[i]); &#125; &#125; &#125; &#125; if(h) &#123; cout &lt;&lt; size &lt;&lt; '\n'; for (int i = 0; i &lt; size; i++) &#123; auto e = ans[i]; cout &lt;&lt; e.first + 1 &lt;&lt; ' ' &lt;&lt; e.second + 1 &lt;&lt; '\n'; &#125; &#125; &#125; &#125; 想到了一半，没想到这么暴力（（ C. Double Lexicographically Minimum 待补充 D1. Hot Start Up (easy version) 题意 给定两个 \(CPU\)，以及 \(n\) 个程序的热启动和冷启动时间，当同一种程序连续运行的时候，第二次启动称为热启动，热启动时间低于冷启动。找出一种方案，使最后运行结束每个程序所用时间总和最短，并输出最短时间。 思路 首先，考虑到递推关系，我们不妨考虑用 \(dp\) 的方式。 最朴素的做法 我们不妨建立一个二维 \(dp\)，\(dp[i][j]\) 表示最后一次操作后第一个 \(CPU\) 运行了程序 \(i\)，第二个 \(CPU\) 运行了程序 \(j\)。 那么显然，最后的答案就是 \(\min(dp[i][a[n]])\) 或者 \(\min(dp[a[n]][j])\)。 如何递推呢？对于一个新元素 \(x\)，以及任意一个 \(CPU\)（如第一块），它可以由两种情况推得： 上一个数和它不同，那么它将成为冷启动，我们遍历所有 \(i \neq x\) 和 \(j\)，将 \(dp[x][j]\) 更新为 \(\min(dp[i][j] + c[x])\)。 上一个数和它相同，他么它将成为热启动，我们遍历所有 \(j\)，将 \(dp[x][j]\) 更新为 \(\min(dp[x][j] + h[x])\)。 时间复杂度：\(O(n k ^ 2)\) 对应TLE代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e3 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; int a[N], h[N], c[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n, k; cin >> n >> k; for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=1;i&lt;=k;i++) cin >> c[i]; for(int i=1;i&lt;=k;i++) cin >> h[i]; vector&lt;vector&lt;int>> dp(k + 1, vector&lt;int>(k + 1)); for(int i=0;i&lt;=k;i++) for(int j=0;j&lt;=k;j++) dp[i][j] = inf; dp[0][0] = 0; for(int x=1;x&lt;=n;x++)&#123; vector&lt;vector&lt;int>> tmp(k + 1, vector&lt;int>(k + 1, inf)); for(int i=0;i&lt;=k;i++)&#123; if(i == a[x]) continue; for(int j=0;j&lt;=k;j++) tmp[a[x]][j] = min(tmp[a[x]][j], dp[i][j] + c[a[x]]); &#125; for(int j=0;j&lt;=k;j++) tmp[a[x]][j] = min(tmp[a[x]][j], dp[a[x]][j] + h[a[x]]); for(int j=0;j&lt;=k;j++)&#123; if(j == a[x]) continue; for(int i=0;i&lt;=k;i++) tmp[i][a[x]] = min(tmp[i][a[x]], dp[i][j] + c[a[x]]); &#125; for(int i=0;i&lt;=k;i++) tmp[i][a[x]] = min(tmp[i][a[x]], dp[i][a[x]] + h[a[x]]); dp = tmp; &#125; int ans = inf; for(int j=0;j&lt;=k;j++)&#123; if(j == a[n]) continue; ans = min(ans, dp[j][a[n]]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; Time limit exceed on test 3. 对朴素的优化 显然，上述复杂度过高，我们希望能找出一种 \(O(n)\) 的递推方法。 对于上述操作，我们并没有考虑哪个元素一定要放到哪个 \(CPU\) 上去，也就是说它和 \(CPU\) 并不绑定。 那么，我们不妨用下标记录一个 \(CPU\) 的情况，另一个用 \(dp\) 来递推。 更具体地说，我们可以记录一下上一次上个 \(CPU\) 放了什么 (\(pre\))，然后对于新加入的数 \(x\)，它可以由下面两种情况推算： \(pre \neq x\)，那么作为冷启动，它的状态可以由所有 \(i \neq x, dp[i] + c[x]\) 推得，当然，我们需要顺便更新 \(dp[i]\) 的值，这和朴素的做法一致。考虑到可以放置在不同的 \(CPU\) 上，所以热启动依然可行，我们将 \(dp[pre]\) 更新为其与 \(dp[x] + h[x]\) 的最小值。最后，我们将 \(pre\) 改为 \(x\)。 \(pre = x\)，那么和上述相同的是，依然存在冷热启动，只是在更新 \(dp[i]\) 的时候，它可以热启动罢了。 时间复杂度：\(O(nk)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e3 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; int a[N], h[N], c[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n, k; cin >> n >> k; for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=1;i&lt;=k;i++) cin >> c[i]; for(int i=1;i&lt;=k;i++) cin >> h[i]; vector&lt;int> dp(k + 1); for(int i=1;i&lt;=k;i++) dp[i] = inf; int pre = 0; for(int p=1;p&lt;=n;p++)&#123; int x = a[p]; vector&lt;int> tmp(k + 1, inf); if(x == pre)&#123; for(int i=0;i&lt;=k;i++)&#123; tmp[i] = min(tmp[i], dp[i] + h[x]); if(i != x) tmp[x] = min(tmp[x], dp[i] + c[x]); &#125; tmp[x] = min(tmp[x], dp[x] + h[x]); &#125;else&#123; for(int i=0;i&lt;=k;i++)&#123; tmp[i] = min(tmp[i], dp[i] + c[x]); if(i != x) tmp[pre] = min(tmp[pre], dp[i] + c[x]); &#125; tmp[pre] = min(tmp[pre], dp[x] + h[x]); pre = x; &#125; dp = tmp; &#125; int ans = inf; for(int i=0;i&lt;=k;i++) ans = min(ans, dp[i]); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 好难解释....]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 138</title>
    <url>/blog/posts/482042403/</url>
    <content><![CDATA[Practice. A. Cowardly Rooks 题意 给定 \(n\) 个点的横纵坐标，输出是否可以将任意一个点移动，使每一行每一列都只有最多一个点。 思路 我们可以先将原来的所有点对应的横坐标和纵坐标对应的行和列进行统计，之后若能找出任意一行或者任意一列没有点，那么就可以移动到那里去。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e3 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n, m; cin >> n >> m; int r[10]&#123;&#125;, c[10]&#123;&#125;; bool f = false; for(int i=0;i&lt;m;i++) &#123; int a, b; cin >> a >> b; r[a]++, c[b]++; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(r[i] == 0 || c[j] == 0)&#123; f = true; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; 给的代码写得略微麻烦了点（ B. Death's Blessing 题意 给定 \(n\) 个怪物的血量和能力 \(a_i, b_i\)，在干掉一个怪物的时候，该怪物将会把相邻的怪物的血量加上它的能力，怪物死亡后从序列中移除，第一个和最后一个怪物只有一个相邻的怪物。输出将所有怪物干掉需要扣除的血量最大值。 思路 首先，答案可以拆分成原来所有怪物的血量和加上外加的血量，外加的血量只和操作顺序有关，所以我们可以试试贪心： 既然两侧的怪物能附加的血量只会影响到一个怪物，那么我们可以贪心地从两侧开始打，但这不够，考虑到只剩一个怪物的时候，这个怪物无法再将自己的能力附加到其他怪物上，所以我们可以将能力值最大的怪物放到最后。 可以很容易证明上述贪心思想成立。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e3 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; int ans = 0; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; ans += cur; &#125; vector&lt;int> b(n); for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; b[i] = cur; ans += b[i]; &#125; sort(b.begin(), b.end()); cout &lt;&lt; ans - b[n - 1] &lt;&lt; '\n'; &#125; &#125; 简单的贪心捏 C. Number Game 题意 给定一个数组 \(a\)，选择任意回合数 \(k\)，在第 \(i\) 个回合，\(A\) 需要找出一个小于等于 \(k - i + 1\) 的数，并将其删去，之后 \(B\) 选择任意一个数，将其加上 \(k - i + 1\)。在两个人足够聪明的条件下，输出最大的 \(k\)，满足不存在某一个回合，数组不为空但 \(A\) 无法删除。 思路 显然，既然要让 \(A\) 寄，那么 \(B\) 一定会将当前的最小值加上 \(k - i + 1\)，因为所加的值是递减的。 考虑到数据范围特别小，我们不妨在每一局结束的时候将整个新数组排个序。 对于一个回合，我们可以用二分的方法，快速找出第一个大于 \(k - i + 1\) 的数并将其前面一个数删去，也就是在每次操作时删去最大数，这样可以尽可能删除多一点的数。然后，将第一个数加上 \(k - i + 1\) 即可。 数据量太小了，可以二分答案 \(k\)，也可以直接暴力枚举。 时间复杂度：\(O(n^2 + n^2 \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int k=n;k>=0;k--)&#123; vector&lt;int> tmp(a); sort(tmp.begin(), tmp.end()); bool f = true; for(int i=1;i&lt;=k;i++)&#123; int p = upper_bound(tmp.begin(), tmp.end(), k - i + 1) - tmp.begin(); if(p == 0) &#123; f = false; break; &#125; tmp[p - 1] = inf; tmp[0] += k - i + 1; sort(tmp.begin(), tmp.end()); &#125; if(f)&#123; cout &lt;&lt; k &lt;&lt; '\n'; break; &#125; &#125; &#125; &#125; 无脑暴力.jpg]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 829 Div 2</title>
    <url>/blog/posts/64163075/</url>
    <content><![CDATA[Practice. A. Technical Support 题意 给定一个由 \(Q, A\) 组成的字符串，对于所有 \(Q\)，判断在下一次 \(Q\) 出现或遍历到结束前，是否有至少一个 \(A\) 与之对应。 思路 如题，配对即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; string s; cin >> s; int cnt = 0; for(char e : s) &#123; cnt += e == 'Q' ? 1 : -1; if(cnt &lt; 0) cnt = 0; &#125; cout &lt;&lt; (cnt == 0 ? "Yes\n" : "No\n"); &#125; &#125; 别看错题（（ B. Kevin and Permutation 题意 给定整数 \(n\)，构建一个 \(n\) 的排列，使相邻数的差值的最小值最大。 思路 想要尽量让差值最大，那么我们只有相间地输出，或者说，若我们按 \(\frac{n}{2} + i, i\) 的规律输出，就可以让所有差值尽量相等。 可以贪心地认为上述的思路是正确的，解法不唯一。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; for(int i=1;i&lt;=n/2;i++)&#123; cout &lt;&lt; n / 2 + i &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' '; &#125; if(n % 2 == 1) cout &lt;&lt; n; cout &lt;&lt; '\n'; &#125; &#125; 找规律+乱贪.jpg C1. Make Nonzero Sum (easy version) 详见C2，区别是C1给定的数组没有0 C2. Make Nonzero Sum (hard version) 题意 给定一个由 \(-1, 0, 1\) 构成的数组，将数组分为任意若干段，相邻两段的左段右边界和右段左边界相差 \(1\)。输出是否存在一种分段，将所有段相间赋上运算符号 \(+, -, +, - ,...\) 后，所有段的运算总和为 \(0\)。若存在，输出方案。 思路 首先，我们不考虑运算符号的时候，将所有数加起来会得到一个结果 \(ans\)，若 \(ans = 0\)，那么我们只需将所有单个元素单独成段就可以无视运算符号了。否则，因为考虑到加减是一样的，我们不妨来考虑 \(ans &gt; 0\) 的情况： 显然，若要让 \(ans\) 减小，我们就只能让某一个 \(1\) 和左相邻的数组合为一段，那么，整个 \(ans\) 将会减少 \(2\)。可以发现，我们无法将 \(ans\) 减少奇数值，所以我们可以先判断 \(ans\) 的奇偶性。在运算的时候，需要变号的时候，变号的数一定但也只要让这个数位于某一段的偶数下标，所以，我们只需找两个相邻数，其中第一个数不需要变号，第二个数需要变号，那么将这两个数作为一段即可。 所以我们只需将 \(1\) 全部找出，判断能找出多少对上述相邻数，和 \(ans / 2\) 比较即可。 有趣的是，这种解法不用考虑是否包含 \(0\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; int ans = 0; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; ans += a[i]; &#125; if(abs(ans) % 2 == 1) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; int r = 0; vector&lt;pii> out; int left = ans / 2; if(left != 0) &#123; int x = left / abs(left); r = 1; for (int i = 1; i &lt; n; i++) &#123; if (a[i + 1] == x) &#123; out.emplace_back(i, i + 1); r = i + 1; i++; left -= x; if (left == 0) break; &#125; else &#123; out.emplace_back(i, i); r = i; &#125; &#125; &#125; for(int i=r+1;i&lt;=n;i++) out.emplace_back(i, i); if(left != 0) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; cout &lt;&lt; out.size() &lt;&lt; '\n'; for(auto e : out) cout &lt;&lt; e.first &lt;&lt; ' ' &lt;&lt; e.second &lt;&lt; '\n'; &#125; &#125; &#125; &#125; 想了半天不小心把两个难度一起做了（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 830 Div 2</title>
    <url>/blog/posts/1524713550/</url>
    <content><![CDATA[Practice. A. Bestie 题意 给定一个数组 \(a\)，定义操作为将 \(a_i\) 改为 \(gcd(a_i, i)\)，代价为 \(n - i + 1\)，输出最小的操作代价总和，使所有数的最大公约数为 \(1\)。 思路 首先，这里有一个结论：相邻数字的最大公约数一定为 \(1\)。 所以，最多只需两次操作，即可满足题意。 所以，我们只需考虑 \(n\) 和 \(n - 1\) 对应的元素是否需要进行操作，以及对应的代价总和的最小值。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], b[N]; int gcd(int x, int y) &#123; while (y != 0) &#123; int tmp = x; x = y; y = tmp % y; &#125; return x; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) &#123; int n; cin >> n; int g = 0; for (int i = 1; i &lt;= n; i++) &#123; cin >> a[i]; g = gcd(g, a[i]); &#125; if (g == 1) cout &lt;&lt; 0 &lt;&lt; '\n'; else if (gcd(g, n) == 1) cout &lt;&lt; 1 &lt;&lt; '\n'; else if (gcd(g, n - 1) == 1) cout &lt;&lt; 2 &lt;&lt; '\n'; else cout &lt;&lt; 3 &lt;&lt; '\n'; &#125; &#125; 这结论一开始还真没想到... B. Ugu 题意 给定一个二进制字符串，定义操作为选定一个整数 \(i\)，将 \([i, n]\) 内的数全都取反，输出让整个字符串变为不递减的操作数的最小值。 思路 考虑下面的模拟： \(\begin{array}{l}&gt;&gt;01011001011 \\ =&gt; 01100110100 \\ =&gt; 01111001011 \\ =&gt; 01111110100 \\ =&gt; 01111111011 \\ =&gt; 01111111100 \\ =&gt; 01111111111\end{array}\) 也就是说，我们只考虑拐点，统计拐点个数即可。 当然，需要根据第一个数的情况来扣去 \(1\) 或 \(2\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], b[N]; int gcd(int x, int y) &#123; while (y != 0) &#123; int tmp = x; x = y; y = tmp % y; &#125; return x; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) &#123; int n; cin >> n; string s; cin >> s; char pre = -1; int dif = 0; for(int i=0;i&lt;n;i++)&#123; if(pre == -1) pre = s[i]; else&#123; if(pre != s[i]) dif ++; pre = s[i]; &#125; &#125; dif ++; cout &lt;&lt; max(0ll, dif - (s[0] == '1' ? 1 : 2)) &lt;&lt; '\n'; &#125; &#125; 就这么模拟嘞 C1. Sheikh (Easy version) 题意 给定一个数组 \(a\)，定义子区间 \([l, r]\) 的代价 \(f(l, r)\) 为总和和所有数异或值的差。对于 \(q = 1\) 个询问，输出询问的 \([L, R]\) 内的子区间的代价最大值，以及对应的最短区间。 思路 首先，对于一段区间，我们加上一个值 \(x\)，那么总和会改变 \(x\)，而异或值改变量不会超过 \(x\)，也就是说，\(f(l, r) \leq f(l, r + 1)\)。 因而，代价最大值一定是 \(f(L, R)\)，我们只需找出最短区间即可。 因为本题 \(easy\) 难度的数据量低，所以我们不妨直接二分长度，然后枚举所有可行解即可。 使用前缀和和前缀异或优化复杂度。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], sum[N], xo[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) &#123; int n, q; cin >> n >> q; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; sum[i] = sum[i - 1] + a[i]; xo[i] = xo[i - 1] ^ a[i]; &#125; while(q --)&#123; int l, r; cin >> l >> r; int ans = (sum[r] - sum[l - 1]) - (xo[r] ^ xo[l - 1]); int L = 1, R = r - l + 1, mid; int ansL = l, ansR = r; while(L &lt; R)&#123; mid = (L + R) >> 1; bool f = false; for(int i=l;i+mid-1&lt;=r;i++)&#123; if((sum[i+mid-1] - sum[i - 1]) - (xo[i+mid-1] ^ xo[i - 1]) == ans) &#123; if(mid &lt; ansR - ansL + 1)&#123; ansL = i, ansR = i + mid - 1; f = true; &#125; &#125; &#125; if(f) R = mid; else L = mid + 1; &#125; cout &lt;&lt; ansL &lt;&lt; ' ' &lt;&lt; ansR &lt;&lt; '\n'; &#125; &#125; &#125; 想不到结论就寄 C2. Sheikh (Hard Version) 待补充 D. Balance (Easy version) 题意 给定一个初始情况下只有一个元素 \(0\) 的序列，对于下述两种询问，进行对应的操作： \(+\ x\)：将 \(x\) 加入序列，满足 \(x\) 原先不在序列里； \(?\ x\)：输出第一个能被 \(x\) 整除且不在序列里的数。 思路 我们先来考虑纯暴力：对于加上某个数，标记一下这个数已加入；对于查询，暴力枚举其倍数，第一个未被标记的数即为答案。 因为数据量过大，我们考虑用 \(map\)。 纯暴力是不可行的，但我们可以略微优化一下：另开一个 \(map\)，记录这个数的下一个没有被标记的数是什么，若这个数是 \(0\)，那么就是这个数本身，输出即可。 因而，在每次输出的时候，我们可以预处理之后的查询，从而降低复杂度。 对于 \(easy\) 难度，到此即可过。 时间复杂度：不好说 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; map&lt;int, bool> mp; map&lt;int, int> to; while(q --)&#123; char op; int num; cin >> op >> num; mp[0] = true; if(op == '+') &#123; mp[num] = true; &#125;else &#123; while(mp[to[num]]) to[num] += num; cout &lt;&lt; to[num] &lt;&lt; '\n'; &#125; &#125; &#125; 数据结构题挺少见 D2. Balance (Hard version) 题意 给定一个初始情况下只有一个元素 \(0\) 的序列，对于下述两种询问，进行对应的操作： \(+\ x\)：将 \(x\) 加入序列，满足 \(x\) 原先不在序列里； \(-\ x\)：将 \(x\) 从序列中删除，满足 \(x\) 原先在序列里； \(?\ x\)：输出第一个能被 \(x\) 整除且不在序列里的数。 思路 我们可以继续之前的优化，但这里需要考虑删除数以后，该数的因数 是否已经将 其 下一个未被标记的数 标为大于等于 这个数 的值了。 也就是说，删除以后，我们需要更新这些因数。 暴力枚举因数是不可行的，但考虑到这些因数都是后来加进来的，所以我们可以在上一题输出优化部分，加上 下一个未被标记的数的原数字是什么（也就是它的因子）。然后，在加减操作的时候，我们不妨遍历我们之前记录下来的因子，标记一下这个因子对应原数字有没有被删去。 最后，我们只需按之前的操作，找出该数字下一个未被标记的数，然后判断这个数的倍数有没有已被删去的数，有的话两个数取最小值即可。 时间复杂度：有点小复杂 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; map&lt;int, bool> mp; map&lt;int, int> to; map&lt;int, set&lt;int>> vis, del; mp[0] = true; while(q --)&#123; char op; int num; cin >> op >> num; if(op == '+') &#123; for(auto &amp;i : vis[num]) del[i].erase(num); mp[num] = true; &#125;else if(op == '-')&#123; for(auto &amp;i : vis[num]) del[i].insert(num); mp[num] = false; &#125;else&#123; while(mp[to[num]]) vis[to[num]].insert(num), to[num] += num; cout &lt;&lt; min(to[num], del[num].empty() ? inf : *del[num].begin()) &lt;&lt; '\n'; &#125; &#125; &#125; 数据结构题挺少见，这种简短的题更少见（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 291</title>
    <url>/blog/posts/1674521260/</url>
    <content><![CDATA[Contestant. Rank 1877. Rating +196. A. camel Case 题意 给定一个由一个大写字母和若干个小写字母组成的字符串，输出大写字母的位置。 思路 如题，很签到。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); string s; cin >> s; for(int i=0;i&lt;s.size();i++)&#123; if(s[0] >= 'A' &amp;&amp; s[i] &lt;= 'Z')&#123; cout &lt;&lt; i + 1 &lt;&lt; '\n'; break; &#125; &#125; &#125; 无聊的签到题 B. Trimmed Mean 题意 给定 \(5N\) 个评委的分数，去掉最大 \(N\) 个和最小 \(N\) 个评委的分数，输出剩余分数的平均数。 思路 如题，排个序即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n; cin >> n; for(int i=0;i&lt;5 * n;i++) cin >> a[i]; sort(a, a + 5 * n); double ans = 0; for(int i=n;i&lt;5*n-n;i++) ans += (double) a[i]; cout &lt;&lt; (ans / ((double) 3 * n)) &lt;&lt; '\n'; &#125; 差点看成只各去掉一个（（ C. LRUD Instructions 2 题意 给定一个由 \(L,R,U,D\) 组成的字符串，模拟点的移动，\(L\) 表示横坐标减一，\(R\) 表示横坐标加一，\(D\) 表示纵坐标减一，\(U\) 表示纵坐标加一。输出有多少点被经过了至少两遍。 思路 如题，模拟即可。 可以用 \(map\) 存有没有经过，或者开一个布尔数组。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); map&lt;pii, bool> mp; int n; cin >> n; string s; cin >> s; pii p = &#123;0, 0&#125;; mp[p] = true; bool f = false; for(int i=0;i&lt;n;i++)&#123; char now = s[i]; if(now == 'L')&#123; p.first --; &#125;else if(now == 'R')&#123; p.first ++; &#125;else if(now == 'U')&#123; p.second ++; &#125;else p.second --; if(mp[p])&#123; f = true; break; &#125; mp[p] = true; &#125; cout &lt;&lt; (f ? "Yes\n" : "No\n"); &#125; 捏马的，忘了在走过以后设标记了（（ D. Flip Cards 题意 给定 \(n\) 张牌，牌的正反两面各印有一个数字，输出整个牌组满足条件的正反情况，满足相邻牌值不相等。 思路 考虑到只需满足相邻牌值不相等，所以我们不妨采用 \(dp\) 的方式，定义一个 \(dp[i][j]\) 表示第 \(i\) 位及以前的牌满足第 \(i\) 张牌的正反情况满足 \(j\) 的情况总数，\(j=0\) 表示向上，否则向下。 那么，对于一个位置，它有两种递推的方式——从上一个为正面的牌的情况数和从上一个为反面的牌的情况数。两个递推的方式的和即为当前位置的值。 如，如果不考虑相邻牌不相等，那么 \(dp[i][0] = dp[i - 1][0] + dp[i - 1]][1], dp[i][1] = dp[i - 1][0] + dp[i - 1][1]\)。 考虑条件的话，我们用 \(if\) 判断即可。 当然，初始情况下 \(dp[1][0] = dp[1][1] = 1\)。 时间复杂度：\(O(2n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int dp[N][2]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n; cin >> n; int lastA, lastB; cin >> lastA >> lastB; dp[1][0] = 1, dp[1][1] = 1; for(int i=2;i&lt;=n;i++)&#123; int nowA, nowB; cin >> nowA >> nowB; if(nowA != lastA) dp[i][0] = (dp[i][0] + dp[i - 1][0]) % mod; if(nowA != lastB) dp[i][0] = (dp[i][0] + dp[i - 1][1]) % mod; if(nowB != lastA) dp[i][1] = (dp[i][1] + dp[i - 1][0]) % mod; if(nowB != lastB) dp[i][1] = (dp[i][1] + dp[i - 1][1]) % mod; lastA = nowA, lastB = nowB; &#125; cout &lt;&lt; (dp[n][0] + dp[n][1]) % mod &lt;&lt; '\n'; &#125; 其实只有两个的话完全可以用两个变量来存，使空间复杂度降低很多 E. Find Permutation 题意 给定 \(n\) 个点以及 \(m\) 组可重复的大小关系 \(A_i, B_i\)，构建一个排列 \(p\)，对于所有条件，均满足 \(p_{A_i} &lt; p_{B_i}\)。输出是否能唯一确定这个排列，若能唯一确定，输出这个排列。 思路 首先，我们可以一眼看出这是求拓扑序。那么，这道题唯一的障碍就是怎么排除无法唯一确定的点，因为如果成环了，拓扑排序会自动找出。 那么，我们来考虑每次读取队列的时候的情况： 考虑到拓扑排序的算法，我们会将每次遍历的时候，将入度为 \(0\) 的点全都放入队列，那么只要出现多个入度为 \(0\) 的点，那么就一定会出现如 \(a =&gt; b, a =&gt; c, b\ ?\ c\) 的情况，此时直接判 \(No\) 即可。 时间复杂度：\(O(m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int n, m; vector&lt;int> G[N]; int in[N]; // 存储每个结点的入度 void topSort() &#123; vector&lt;int> L; queue&lt;int> q; for (int i = 1; i &lt;= n; i++) if (in[i] == 0) q.push(i); if(q.size() > 1)&#123; cout &lt;&lt; "No\n"; return; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); L.push_back(u); for (auto v : G[u]) &#123; if (--in[v] == 0) &#123; q.push(v); &#125; &#125; if(q.size() > 1) &#123; cout &lt;&lt; "No\n"; return; &#125; &#125; if (L.size() == n) &#123; cout &lt;&lt; "Yes\n"; vector&lt;int> ans(n); for(int i=0;i&lt;n;i++)&#123; ans[L[i] - 1] = i + 1; &#125; for (auto i : ans) cout &lt;&lt; i &lt;&lt; ' '; &#125; else &#123; cout &lt;&lt; "No\n"; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); cin >> n >> m; map&lt;pii, bool> mp; for(int i=0;i&lt;m;i++)&#123; int x, y; cin >> x >> y; if(mp[&#123;x, y&#125;]) continue; G[x].emplace_back(y); in[y] ++; mp[&#123;x, y&#125;] = true; &#125; topSort(); &#125; 有一说一，为什么入读和出度的配对不可以用来判呢？ F. Teleporter and Closed off 题意 给定 \(n\) 个长度为 \(m\) 的字符串 \(s\)，若 \(s_{i,j} = 1\)，那么可以使用这个传送点，从第 \(i\) 个城市传送到第 \(i+j\) 个城市。输出对于第 \([2, n - 2]\) 个城市，从第一个城市到最后一个城市，满足跳过这个城市的路径使用的传送点的最少数量。 思路 首先，对于第 \(i\) 个城市，它的状态是从前一个传送点推过来的，存在递推性，所以我们可以用 \(dp\) 来实现。 对于第 \(k\) 个城市，若要跳过它，那么我们一定得从 \(i=k-x+1\) 个城市传送到 \(j = i + x\) 个城市，所以我们可以枚举 \(i \in [k - m + 1, k - 1], j \in [k + 1, i + m]\)，找出对于所有城市 \(i\) 前面用了多少传送点，城市 \(j\) 后面用了多少传送点，最后的答案即为传送点数量之和 \(+1\)。 那么，我们可以从前往后 \(dp\)，再从后往前 \(dp\)，最后的值即为 \(dp_0[i] + dp_1[j] + 1\)。 而对于 \(dp\)，从前向后的时候，对于第 \(i\) 个城市，我们可以枚举所有 \(j \in [1, m]\)，那么我们可以传送到所有满足条件的 \(i + j\) 个城市。因而，这些城市的传送点数量即可用当前城市来更新。 从后往前是类似的。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 4e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int dp[N][2]; string a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, m; cin >> n >> m; for(int i=0;i&lt;n;i++)cin >> a[i]; memset(dp, 0x3f, sizeof dp); dp[0][0] = dp[n - 1][1] = 0; for(int i=0;i&lt;n;i++)&#123; for(int j=1;j&lt;=min(m, n - i);j++)&#123; if(a[i][j - 1] == '1') dp[i + j][0] = min(dp[i + j][0], dp[i][0] + 1); &#125; &#125; for(int i=n-1;i>=0;i--)&#123; for(int j=1;j&lt;=min(m, i - 1);j++)&#123; if(a[i - j][j - 1] == '1') dp[i - j][1] = min(dp[i - j][1], dp[i][1] + 1); &#125; &#125; for(int k=1;k&lt;n-1;k++)&#123; int ans = inf; for(int i=max(k - m + 1, 0ll);i&lt;k;i++)&#123; for(int j=k+1;j&lt;min(n, i+m+1);j++)&#123; if(a[i][j - i - 1] == '1') ans = min(ans, dp[i][0] + dp[j][1] + 1); &#125; &#125; cout &lt;&lt; (ans >= inf ? -1 : ans) &lt;&lt; ' '; &#125; &#125; dp老写错状态，淦]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 853 Div 2</title>
    <url>/blog/posts/2909166420/</url>
    <content><![CDATA[Contestant. Rank 1936. Rating +9. A. Serval and Mocha's Array 题意 给定一个数组 \(a\)，将其重新排序，满足对于所有前缀，如前 \(i\) 个数，满足它们的 \(gcd \leq i\)。 思路 首先，最优的方法当然是互质，只要把互质的两个数放到第一个，那么后面的 \(gcd\) 全都是 \(1\) 了。 其次，前两个数可以有公约数 \(2\)，这是毋庸置疑的。但是，若我们继续下去，前 \(3\) 个数可以有公约数 \(3\)，...，前 \(6\) 个数可以有公约数 \(6\)。停，不对劲：既然有公约数 \(2,3\)，那么一定能被 \(6\) 整除，那么前两个数的 \(gcd\) 一定至少是 \(6\) 了，产生了矛盾。 所以，我们只需找出一对数，满足 \(gcd \leq 2\) 即可。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; int gcd(int x, int y) &#123; while (y != 0) &#123; int tmp = x; x = y; y = tmp % y; &#125; return x; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; bool f = false; for(int i=0;i&lt;n;i++) for(int j=i;j&lt;n;j++)&#123; if(gcd(a[i], a[j]) &lt;= 2) &#123; f = true; break; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; 为什么赛后反而思路这么清晰了（（ B. Serval and Inversion Magic 题意 给定一个二进制字符串，任选一个区间，将区间内的所有数取反，输出是否可以将整个字符串变为回文字符串。 思路 考虑到回文串的对称性，我们只需修改 \([0, \frac{n}{2}]\) 内的数即可。 下面是一种模拟思路： 我们不妨从外向里遍历，比较 \(i\) 和 \(n - i - 1\) 对应的数，若出现了不同的数，记录当前下标开始需要取反，然后一直找到结束，或者出现相同的数。出现相同数后，我们标记一下已经进行过取反操作，当我们再次遇到不同数的时候，考虑到只能选一个区间，所以直接返回 \(NO\)。 否则，一定是有解的。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; string a; cin >> a; bool f = true, have = false, now = false; for(int i=0;i&lt;n/2;i++)&#123; if(a[i] == a[n - i - 1])&#123; if(now)&#123; now = false; have = true; &#125; &#125;else&#123; if(have)&#123; f = false; break; &#125; now = true; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; 我的评价是：比A题简单 C. Serval and Toxel's Arrays 题意 给定一个无重复元素的数组 \(a\)，对于 \(q\) 个操作给定的 \(p_i, v_i\)，将 \(a_{p_i}\) 改为 \(v_i\)。每次操作后，将会得到一个新数组，新数组满足无重复元素。每次操作的对象为上次操作后的数组。对于所有数组（原数组 + 所有新数组），输出所有任意两个数组拼接后不同数字的个数的和。 思路 显然，我们不可能去暴力计算，而相反地，我们可以将问题拆分为所有单个数字的贡献和。 具体地说，对于一个数字，若它自始至终未被修改，那么任意两个数组组合，都会留下它，那么它的贡献即为 \(C_{m + 1}^2\)。 若它被修改了，那么在它未出现的时候，它将毫无贡献。因此，我们需要减去这些无贡献的数组组合，也就是 \(C_{m - cnt + 1}^2\)。因而，得到该条件下的总贡献：\(C_{m + 1}^2 - C_{m - cnt + 1}^2\)。 当然，我们还需算出一个数的出现次数 \(cnt\)，考虑到无重复，所以我们只需模拟即可。 时间复杂度：\(O(m+n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 4e5 + 10, inf = 0x3f3f3f3f; int cnt[N]; pii a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n, m; cin >> n >> m; for(int i=1;i&lt;=n+m;i++) cnt[i] = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i].first; a[i].second = 0; &#125; for(int i=1;i&lt;=m;i++)&#123; int p, v; cin >> p >> v; cnt[a[p].first] += i - a[p].second; a[p] = &#123;v, i&#125;; &#125; for(int i=1;i&lt;=n;i++) cnt[a[i].first] += m + 1 - a[i].second; int ans = 0; for(int i=1;i&lt;=n+m;i++)&#123; if(cnt[i] == 0) continue; if(cnt[i] > m) ans += m * (m + 1) / 2; else ans += (m * (m + 1) - (m - cnt[i]) * (m - cnt[i] + 1)) / 2; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 我蠢了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 831 Div 1 plus 2</title>
    <url>/blog/posts/126870515/</url>
    <content><![CDATA[Practice. A. Factorise N+M 题意 给定一个质数，输出一个质数，使两者相加不是质数。 思路 除 \(2\) 之外，偶数都不是质数，所以直接加上 \(3\) 即可。 若为 \(2\)，那么加上 \(2\) 即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; cout &lt;&lt; (n % 2 == 0 ? 2 : 3) &lt;&lt; '\n'; &#125; &#125; 水 B. Jumbo Extra Cheese 2 题意 给定 \(n\) 个长方形，所有长方形必须有一条边在 \(x\) 轴上，每个长方形至少需要和另一个长方形有公共边，输出周长最小值。 思路 首先，贴靠在一起后，周长只和最高的高度和所有长方形贴靠在 \(x\) 轴上的长度有关，所以我们希望让最高的高度降低，同时尽量将所有的长方形的短边贴靠在 \(x\) 轴。 因此，我们可以贪心地直接将最高的方块横着放，其余竖着放即可。 但是我不会证 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; pii p[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++) &#123; int a, b; cin >> a >> b; p[i] = &#123;max(a, b), min(a, b)&#125;; &#125; sort(p, p + n, greater&lt;>()); int cnt = p[0].first; for(int i=1;i&lt;n;i++) cnt += p[i].second; cout &lt;&lt; 2 * (p[0].second + cnt) &lt;&lt; '\n'; &#125; &#125; 怎么证捏 C. Bricks and Bags 题意 给定一个数组 \(a\)，将所有数字任意分成 \(3\) 组，不能出现空组。从三组中各拿出一个数字，使 \(|w_1 - w_2| + |w_2 - w_3|\) 最小。将数字合理分配，使 \(|w_1 - w_2| + |w_2 - w_3|\) 的最小值最大。 思路 首先，假设我们确定了一个数，那么我们能决定的是将一个组合全部放入最小值或最大值，让这一部分的最小值固定，那么我们只要在一个组合里只放另一个数，要让其最小，肯定会拿出最靠近这个数的数字，因而我们也希望找出数值上相邻的两数，它们的差值最大。 所以，我们可以排序然后枚举这个数字，然后计算出最大值即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a, a + n); int ans = 0; for(int i=1;i&lt;n;i++) ans = max(ans, max(2 * a[i] - a[i - 1] - a[0], a[i] + a[n - 1] - 2 * a[i - 1])); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 怎么就WA了那么多遍呢（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 344 Div 2</title>
    <url>/blog/posts/641661849/</url>
    <content><![CDATA[Practice. 什么陈年老题目（（ A. Interview 题意 给定两个长度相等的序列，任选一段区间，输出区间内各序列值进行按位或之后的和。 思路 考虑到数据范围，直接暴力即可。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], b[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;n;i++) cin >> b[i]; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int ca = 0, cb = 0; for(int j=i;j&lt;n;j++)&#123; ca |= a[j]; cb |= b[j]; ans = max(ans, ca + cb); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; 过于打卡 B. Print Check 中文版：题目详情 - 简单题 - FJNU (fjnuacm.top) 题意 给定一个 \(n \times m\) 的矩阵，对于 \(q\) 个操作，输出操作后的矩阵。 定义操作为选择一行或一列，将该行或该列的值改为指定值，存在覆盖的情况。 思路 首先，不可以模拟，只要 \(n, m, q\) 够大，一定会 \(tle\)。 其次，对于一个点，它最后的值只和最后一次对它所在的行或列的操作有关。 因而，我们不妨记录每行的操作，以及操作时间，在最后输出的时候，判断涉及到该点的行操作和列操作的时间，并输出最后操作后的值。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; pii r[N], c[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, m, k; cin >> n >> m >> k; for(int i=1;i&lt;=k;i++)&#123; int x, p, a; cin >> x >> p >> a; if(x == 1) r[p] = &#123;i, a&#125;; else c[p] = &#123;i, a&#125;; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cout &lt;&lt; (r[i].first > c[j].first ? r[i].second : c[j].second) &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; &#125; 怎么就做到原题了（（ C. Report 题意 给定一个数组 \(a\)，输出操作后数组的结果。 定义一次操作为选择一个右端点 \(r\)，将 \([1, r]\) 内的数升序或降序排列，排列方式取决于输入，\(1\) 为非降序，\(0\) 为非升序。 思路 剪枝 首先，这些操作存在覆盖，也就是说，后面的操作可以使前面的操作无效。 对于最后一个操作，若前面的操作的区间比它小，那么这些操作均无效。推广可得，我们只需从后往前拿出包含最后一个操作且操作区间递增的操作，其余不考虑即可。 输出 考虑到直接暴力排序的时间复杂度过大，我们不妨观察一下每次操作的特点： 当我们对大区间操作后，其与次大值区间的补集就唯一确定了，不会随着后续操作而改变，所以我们不妨直接从后往前放数字。 对于一个区间内的数，我们不妨直接将其升序排序，若这个补集需要非降序，那么把右端点的数字取出，否则把左端点的数字取出，依次放入这个补集所在的区域即可。 当然，最大的操作之后的数直接输出，不参与排序。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; pii op[N], opt[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, tm, m = 0; cin >> n >> tm; for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;tm;i++) cin >> opt[i].second >> opt[i].first; int st = -1; for(int i=tm-1;i>=0;i--)&#123; if(st != -1 &amp;&amp; opt[i].first &lt;= st) continue; st = opt[i].first; op[m ++] = opt[i]; &#125; sort(op, op + m, greater&lt;>()); vector&lt;int> ans(n); for(int i=n-1;i>=op[0].first;i--) ans[i] = a[i]; sort(a, a + op[0].first); int l = 0, r = op[0].first - 1; for(int i=0;i&lt;m-1;i++)&#123; for(int j=op[i].first-1;j>=op[i+1].first;j--)&#123; if(op[i].second == 2) ans[j] = a[l ++]; else ans[j] = a[r --]; &#125; &#125; for(int j=op[m - 1].first-1;j>=0;j--)&#123; if(op[m - 1].second == 2) ans[j] = a[l ++]; else ans[j] = a[r --]; &#125; for(int i=0;i&lt;n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125; 能用数据结构么 D. Messenger 题意 定义对只有小写字母的字符串的一种压缩方式为选取任意连续相等的子序列，将其替换为 \(个数 - 字母\)。 如 \(aaa\) 可替换为 \(3-a\) ，也可以替换为 \(1-a\ 2-a\)。 给定两个压缩后的字符串 \(s, t\)，对于两者的原字符串，输出 \(t\) 在 \(s\) 中出现了几次。 思路 首先，若要在 \(O(n)\) 的复杂度内解出字符串的查找，我们需要用到 \(KMP\) 算法。 其次，我们不能直接调用 \(KMP\)，因为可能出现开头或结尾的字母数量小于 \(s\) 对应字母的数量的情况。如 \(1 - a\) 和 \(2 - a\)。 但是，我们可以确定的是，去掉两端的字母，中间的序列是一定相同的，所以我们不妨去掉两端的字母后调用 \(KMP\) 算法，找出所有满足条件的区间 \([l, r]\)。 当然，考虑到字符串并未彻底压缩，会影响到查找，所以我们需要预处理，将 \(1 - a\ 2 - a\) 之类压缩到最小。 不过，此时还有一个问题没有解决：类似于 \(1 - a\) 和 \(11 - a\) 的子串会被意外匹配，而它们的数量是不相同的。这时我们不妨在所有数字的起始处加一个特殊字符（如 \(.\)）。此时，形如 \(1a12b3c\) 的字符串将会变为 \(.1a.12b.3c\)，即可避免意外匹配。 考虑到对于求得的区间，我们需要快速定位其左右端点对应的内容，所以我们需要用类似于 \(map\) 的容器记录每个元素的起始位置对应的元素。此时，对于 \(l\) 对应的元素的前一个元素和 \(r + 1\) 对应的元素，我们只需比对其与 \(t\) 字符串的两端的元素的字母是否相同、以及数量是否符合条件即可。 当然，上述操作针对的是预处理后 \(t\) 只剩三个元素的情况，其余情况都可以暴力，只是元素为一个的时候，元素是可以在一个大区间内移动的，它的左右端点不像元素多的时候那样是固定的。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> class KMP &#123; //交一个套板子的（（ public: static vector&lt;int> prefix_function(string s) &#123; int n = (int) s.length(); vector&lt;int> pi(n); for (int i = 1; i &lt; n; i++) &#123; int j = pi[i - 1]; while (j > 0 &amp;&amp; s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; &#125; return pi; &#125; static vector&lt;pii > find_occurrences(const string &amp;text, const string &amp;pattern) &#123; string cur = pattern + '#' + text; int sz1 = text.size(), sz2 = pattern.size(); vector&lt;pii > v; vector&lt;int> lps = prefix_function(cur); for (int i = sz2 + 1; i &lt;= sz1 + sz2; i++) &#123; if (lps[i] == sz2) v.emplace_back(i - 2 * sz2, i - sz2 - 1); &#125; return v; &#125; &#125;; vector&lt;pair&lt;int, char>> merge(int tn, int &amp;n) &#123; vector&lt;pair&lt;int, char>> a; char pre = -1; int cnt = 0; while (tn--) &#123; string cur; cin >> cur; int x = 0, i = 0; while (cur[i] != '-') &#123; x = x * 10 + (cur[i] - '0'); i++; &#125; if (pre == -1) pre = cur[i + 1]; if (pre != cur[i + 1]) &#123; a.emplace_back(cnt, pre); n++; pre = cur[i + 1]; cnt = x; &#125; else cnt += x; &#125; a.emplace_back(cnt, pre); n++; return a; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int tn, tm, n = 0, m = 0; cin >> tn >> tm; vector&lt;pair&lt;int, char>> a = merge(tn, n), b = merge(tm, m); int cnt = 0; if (m >= 3) &#123; string origin, dest; map&lt;int, int> ind; for (int i = 0; i &lt; n; i++) &#123; ind[origin.size()] = i; origin += "$" + to_string(a[i].first); origin += a[i].second; &#125; for (int i = 1; i &lt; m - 1; i++) &#123; dest += "$" + to_string(b[i].first); dest += b[i].second; &#125; vector&lt;pii > oc = KMP::find_occurrences(origin, dest); for (auto e: oc) &#123; if (e.second + 1 >= origin.size()) continue; int x1 = ind[e.first], x2 = ind[e.second + 1]; if (x1 == 0) continue; if (a[x1 - 1].second == b[0].second &amp;&amp; a[x2].second == b[m - 1].second &amp;&amp; a[x1 - 1].first >= b[0].first &amp;&amp; a[x2].first >= b[m - 1].first) cnt++; &#125; &#125; else if (m == 2) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; if (a[i].second != b[0].second || a[i + 1].second != b[1].second) continue; if (a[i].first >= b[0].first &amp;&amp; a[i + 1].first >= b[1].first) cnt++; &#125; &#125; else &#123; for (int i = 0; i &lt; n; i++) &#123; if (a[i].second != b[0].second) continue; if (a[i].first >= b[0].first) cnt += a[i].first - b[0].first + 1; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; 有点难解释，反正大概做法是这样（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 832 Div 2</title>
    <url>/blog/posts/3447609703/</url>
    <content><![CDATA[Practice. A. Two Groups 题意 给定一个数组 \(a\)，可以为负数，从数组 \(a\) 中取出某些数作为序列 \(s_1\)，剩余作为序列 \(s_2\)，输出 \(|sum(s_1)| - |sum(s2)|\) 的最大值。序列可以为空。 思路 考虑到 \(|sum(s_1)| - |sum(s2)| \leq |sum(s_1) + sum(s2)| = |sum(a_i)|\)，我们可以发现原数组的总和的绝对值即为最大值。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5+10; signed main()&#123; ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); int t; cin >> t; while(t --)&#123; int n; cin >> n; int ans = 0; for(int i=1;i&lt;=n;i++) &#123; int cur; cin >> cur; ans += cur; &#125; cout &lt;&lt; abs(ans) &lt;&lt; '\n'; &#125; &#125; 暴力枚举碰运气过了可还行 B. BAN BAN 题意 给定一个整数 \(n\)，对于由 \(n\) 个 \(BAN\) 组成的字符串，输出至少交换几次，使所有长度为 \(3\) 的可不连续子序列不包含 \(BAN\)。 思路 显然，我们希望 \(B\) 能移到后面，\(N\) 能移到前面，那么我们不妨将第 \(i\) 个 \(B\) 和第 \(n - i + 1\) 个 \(N\) 交换。 当然，若 \(n\) 为奇数，中间的那个字符串直接反转即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5+10; signed main()&#123; ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); int t; cin >> t; while(t --)&#123; int n; cin >> n; cout &lt;&lt; n / 2 + n % 2 &lt;&lt; '\n'; for(int i=0;i&lt;n/2;i++) cout &lt;&lt; 1 + i * 3 &lt;&lt; ' ' &lt;&lt; 3 * n - (i * 3) &lt;&lt; '\n'; if(n % 2 == 1) cout &lt;&lt; 3 * (n / 2) + 1 &lt;&lt; ' ' &lt;&lt; 3 * (n / 2) + 3 &lt;&lt; '\n'; &#125; &#125; 纯纯找规律（（ C. Swap Game 题意 给定一个序列，规定每个玩家可以选择一个数，将其与第一个数交换，并将第一个数扣去 \(1\)。定义最后将 \(0\) 交换到第一个位置上的玩家输，在 \(Alice\) 先手的条件下，输出最后的赢家。 思路 首先，若最小的数是第一个数，那么先手就会将最小的数放到后面，从而使后手具有必胜策略：我只需每次都挑大的数，那么对方就只能挑小的数，从而让对方最后只能取 \(0\)。反之同理。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f; signed main()&#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; int minn = inf, a0; cin >> a0; minn = min(minn, a0); for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; minn = min(minn, cur); &#125; cout &lt;&lt; (minn == a0 ? "Bob" : "Alice") &lt;&lt; '\n'; &#125; &#125; 当然和总和的奇偶性没关系 D. Yet Another Problem 题意 给定一个序列 \(a\)，定义一次操作为选定任意长度为奇数的区间，将区间内的数全都改为整个区间的异或值。对于每个区间询问，输出最小操作数，使区间的数都变为 \(0\)。无解输出 \(-1\)。 思路 首先，若没有区间奇偶性的限制，我们直接预处理出前缀异或，然后用类似于前缀和的方式计算即可。 当然，也可以用一下前缀和，毕竟我们需要知道这个区间是否已经全为 \(0\)。 若查询的区间长度为偶数，那么我们只能挑选两个长度为奇数的区间。考虑到对一个子区间操作后，剩余的区间的异或值一定为 \(0\)，所以我们只需枚举所有长度为奇数的右端的子区间即可（左端也行）。 不过，我们不可以枚举，因为数据量实在太大了。所以，我们需要进行预处理。对于一个右端点，若它为偶数，那么以它为右端点的区间的左端点一定是奇数，从而我们可以进行递推，找到两个异或值相等且奇偶性不同的点即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; int a[N], xo[N], sum[N], pre[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, q; cin >> n >> q; vector&lt;map&lt;int, int>> mp(2); for (int i = 1; i &lt;= n; i++) &#123; cin >> a[i]; xo[i] = xo[i - 1] ^ a[i]; sum[i] = sum[i - 1] + a[i]; if(mp[1 - i % 2].count(xo[i])) pre[i] = mp[1 - i % 2][xo[i]]; mp[i % 2][xo[i]] = i; &#125; while (q--) &#123; int l, r; cin >> l >> r; if ((xo[r] ^ xo[l - 1]) != 0) &#123; cout &lt;&lt; -1 &lt;&lt; '\n'; continue; &#125; if (sum[r] - sum[l - 1] == 0) &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; &#125; else if ((r - l + 1) % 2 == 1) &#123; cout &lt;&lt; 1 &lt;&lt; '\n'; &#125; else &#123; if (a[r] == 0 || a[l] == 0) &#123; cout &lt;&lt; 1 &lt;&lt; '\n'; continue; &#125; cout &lt;&lt; (pre[r] >= l ? 2 : -1) &lt;&lt; '\n'; &#125; &#125; &#125; 二分半天不过...]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - CodeTON Round 3 Div 1 plus 2</title>
    <url>/blog/posts/3739927720/</url>
    <content><![CDATA[Practice. A. Indirect Sort 题意 给定一个排列 \(a\)，定义操作如下： 选择三个下标 \(i, j, k\)，满足 \(1 \leq i &lt; j &lt; k \leq n\)； 若 \(a_i &gt; a_k\)，将 \(a_i\) 替换为 \(a_i + a_j\)，否则将 \(a_j\) 和 \(a_k\) 交换。 输出是否可以将排列变为一个不递减序列。 思路 显然，当第一位不为 \(1\) 的时候，第一位无法减小，而由于 \(1\) 在序列的后面，所以一定存在一个递减的组合，而操作无法将选定的递减组合变为递增，所以无解。 相反地，当第一位为 \(1\) 时，我们只需选 \(i = 1\)，那么每次均可实现交换，从而交换成为一个不递减序列。 时间复杂度：\(O(1)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int a, tmp; cin >> a; for(int i=1;i&lt;n;i++) cin >> tmp; cout &lt;&lt; (a == 1 ? "YES\n" : "No\n"); &#125; &#125; 怎么会是呢，怎么想了那么久呢？ B. Maximum Substring 题意 给定一个二进制字符串，对于它的连续子串，统计 \(0, 1\) 的个数为 \(x, y\)，那么代价 \(t\) 满足： \(x \cdot y\)，如果 \(x &gt; 0\) 并且 \(y &gt; 0\)； \(x ^ 2\)，如果 \(x &gt; 0\) 并且 \(y = 0\)； \(y ^ 2\)，如果 \(x = 0\) 并且 \(y &gt; 0\)。 输出所有子串中最大的代价。 思路 显然，若我们想让代价最大，那么我们希望子串中 \(0\) 或 \(1\) 的个数尽量多，如果个数差不多，那么考虑两者的乘积。 所以，我们不妨找出所有连续相等的子串，然后计算个数的平方，记录该条件的最大值。 而假设不满足上述条件，那么我们就希望 \(x\) 和 \(y\) 的值足够大，也就是原字符串对应的代价。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int num = 0; for(char e : s) if(e == '1') num ++; int cnt = 0, pre = 0; for(int i=0;i&lt;n;i++)&#123; if(s[i] == s[pre]) continue; else&#123; cnt = max(cnt, i - pre); pre = i; &#125; &#125; cnt = max(cnt, n - pre); cout &lt;&lt; max(cnt * cnt, num * (n - num)) &lt;&lt; '\n'; &#125; &#125; 简单思维题 C. Complementary XOR 题意 给定两个长度相等的二进制字符串 \(a, b\)，定义操作为选择一段连续的区间，并将区间内的 \(a\) 字符串的值取反，将区间外的 \(b\) 字符串的值取反。输出一种操作数低于 \(n + 5\) 的流程，使两个字符串所有位都变为 \(0\)。 思路 显然，若 \(a\) 与 \(b\) 异或值为 \(0\) 或者两者相等的时候才有解，否则考虑到操作的对称性，我们无法将它们变为 \(0\)。 其次，若 \(a\) 与 \(b\) 异或值为 \(0\)，那么我们只需选择整个区间进行一次操作，即可将 \(a\) 变为 \(b\)。 那么，我们来考虑 \(a = b\) 的情况。 不难发现，若我们遍历到了 \(a_i\)，满足 \(a_i = 1\)，那么我们只需选择 \([1, i]\) 和 \([1, i - 1]\) 进行操作，即可在将其余位的操作抵消的前提下，将 \(1\) 变为 \(0\) 了。 当然，右边界 \(i - 1\) 要求 \(i \geq 2\)，若第一位有 \(1\)，那么我们考虑对 \([1, 1]\) 和 \([2, n]\) 进行操作，从而将整个 \(a\) 取反。 按照上述输出，我们将会得到最多 \(2n + 1\) 个操作，要使其降低一倍，我们不妨留意异或的性质，在同一个区间内进行两次操作后操作是无效的。所以，我们只需统计操作数的奇偶性，从而避免无效操作。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; int cnt[N]; signed main()&#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t, n; cin >> t; vector&lt;pii> ans; while(t --)&#123; ans.clear(); cin >> n; for(int i=0;i&lt;n;i++) cnt[i] = 0; string a, b; cin >> a >> b; bool ok = true; for(int i=0;i&lt;n;i++)&#123; if(a[i] != ('1' - b[i] + '0'))&#123; ok = false; break; &#125; &#125; if(a != b &amp;&amp; !ok)&#123; cout &lt;&lt; "NO\n"; &#125;else&#123; cout &lt;&lt; "YES\n"; if(a != b)&#123; ans.emplace_back(1, n); a = b; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i] == '1')&#123; if(i == 0)&#123; ans.emplace_back(1, n); ans.emplace_back(2, n); &#125;else&#123; cnt[i] ++; cnt[i - 1] ++; &#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(cnt[i] % 2 == 1) ans.emplace_back(1, i + 1); &#125; cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto x : ans) cout &lt;&lt; x.first &lt;&lt; ' ' &lt;&lt; x.second &lt;&lt; '\n'; &#125; &#125; &#125; 构造题有时候想到就感觉很妙啊（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Pinely Round 1 Div 1 plus 2</title>
    <url>/blog/posts/760099833/</url>
    <content><![CDATA[Practice. 代码略去了快读模板 A. Two Permutations 题意 给定三个整数 \(n, a, b\)，构建两个长为 \(n\) 的排列，满足前 \(a\) 个数和后 \(b\) 个数一致。输出是否能构建出两个不同的排列。 特别地，当 \(n = a = b\) 时，输出 \(YES\)。 思路 如题。 时间复杂度：\(O(1)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; int n = console.nextInt(), a = console.nextInt(), b = console.nextInt(); if(n == a &amp;&amp; b == a)&#123; console.println("YES"); continue; &#125; console.println(n - a - b >= 2 ? "YES" : "NO"); &#125; console.close(); &#125; &#125; 什么离谱的特判啊 B. Elimination of a Ring 题意 给定一个首尾相连的序列，序列中的相邻元素不相等。定义一次操作为删去任意元素，在每次删去后，若出现相邻元素相等，那么删去任意重复元素，直到没有相邻元素相等。 思路 我们不妨来考虑下面的一种情况： 1 6 1 2 1 2 1 2 显然，对于这类相间的数，在剩余两个数之前，我们都是成对删除的（如删除 \(1\) 后左边或右边的 \(2\) 也将被删去）。 而若我们在里面添加任意数字，那么相间的环将会被打破，我们不难发现，我们只需删去添加的任意数的相邻数，即可避免删除数以后出现重复数字。 更具体地说，除了两个数字相间成环的情况，我们应该输出 \(\frac{n}{2} + 1\) 外，其余情况均输出 \(n\)。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); if(n &lt;= 2 || n % 2 == 1) &#123; for(int i=0;i&lt;n;i++) console.nextInt(); console.println(n); &#125; else&#123; int a = console.nextInt(), b = console.nextInt(); boolean f = false; for(int i = 1;i&lt;n / 2;i++)&#123; if(console.nextInt() != a | console.nextInt() != b)&#123; if(f) continue; console.println(n); f = true; &#125; &#125; if(!f) console.println(n / 2 + 1); &#125; &#125; console.close(); &#125; &#125; 硬猜就完事了（ C. Set Construction 题意 给定一个二进制矩阵 \(b\)，构造 \(n\) 个无重复数字的序列 \(A\)，满足矩阵对应的限制： \(b_{i, j} = 1\) 表示 \(A_i\subsetneq A_j\)，\(b_{i, j} = 0\) 则相反。 思路 显然，序列是不唯一的，那么我们不妨来初始化 \(A\)，满足 \(A_i\) 中一定包含 \(i\)。 那么，显然地，若 \(A_i\subsetneq A_j\)，那么 \(A_j\) 中就一定有 \(i\)。 更简单地说，我们只需遍历输出的矩阵，若 \(b_{i, j} = 1\)，那么我们在 \(A_j\) 里添加 \(i\)。 输出满足上述条件的序列即可。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0) &#123; int n = console.nextInt(); List&lt;List&lt;Integer>> ans = new ArrayList&lt;>(); for (int i = 0; i &lt; n; i++) &#123; List&lt;Integer> e = new ArrayList&lt;>(); e.add(i + 1); ans.add(e); &#125; for (int i = 1; i &lt;= n; i++) &#123; String s = console.next(); for (int j = 0; j &lt; n; j++) &#123; if(s.charAt(j) == '1') ans.get(j).add(i); &#125; &#125; for(int i=0;i&lt;n;i++)&#123; console.print(ans.get(i).size()); for(int j : ans.get(i)) console.print(" " + j); console.println(); &#125; &#125; console.close(); &#125; &#125; 好一个思维题...]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - SWERC 2022-2023 - Online Mirror</title>
    <url>/blog/posts/2576267679/</url>
    <content><![CDATA[Contestant. Rank 720. Unrated. 划水，打卡，三题，结束（（ A. Walking Boy 题意 给定一个升序排序的数组 \(a\)，\(a_i \in [0, 1440]\)，在数组第一位插入 \(0\)，最后一位插入 \(1440\)，输出是否有两个相邻数的差值大于等于 \(120\)。 思路 如题。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; a[i] = min(a[i], 1440ll); &#125; int cnt = 0; a[n + 1] = 1440; for(int i=1;i&lt;=n + 1;i++) cnt += (a[i] - a[i - 1]) / 120; cout &lt;&lt; (cnt >= 2 ? "YES\n" : "NO\n"); &#125; &#125; 你怕是不想让我看懂（ H. Beppa and SwerChat 题意 给定两个时间段的好友列表，列表按照最后一条消息的时间降序排序。输出至少有多少人在两个时间段内发了消息。 思路 很显然，若发送了消息，那么这个人是从当前位置移动到第一个位置的。 或者更具体地说，我们从后往前遍历 \(b\) 数组，那么只需找到第一对相邻的数，满足在 \(a\) 数组的位置不符合要求即可。 当然，我们可以记录 \(a\) 中元素对应的下标来使查询复杂度降到 \(O(1)\)。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N], b[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; a[cur] = i; &#125; for(int i=1;i&lt;=n;i++) cin >> b[i]; int cnt = n; for(int i=n;i>=1;i--)&#123; cnt --; if(a[b[i - 1]] > a[b[i]]) break; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; &#125; 捏码，怎么就WA了 L. Controllers 题意 给定一个由 \(+, -\) 符号组成的字符串，对于 \(t\) 组询问，给定两个数 \(a, b\)，输出是否存在 \(a, b\) 的一个序列，使其带入表达式后值为 \(0\)。 思路 显然，我们有两个选择可以让最后的值为 \(0\)： 选择任意数，\(+-\) 任意次后答案一定是 \(0\)； 将 \(a, b\) 进行配对，用最小公倍数找出合法配对，进行“抵消”。 我们不妨统计 \(+-\) 的个数，记 \(pl\) 为个数的最小值，\(mi\) 为个数的最大值，并令 \(a\) 为 \(\max(a, b)\)，\(b\) 为 \(\min(a, b)\)；然后，我们计算出 \(lcm(a, b)\)，那么 \(lcm / a\) 个个数较少的符号和 \(lcm / b\) 个个数较多的符号即可进行配对。 考虑到两种配对方法的个数较少，且无法确定需要配对几次，所以我们不妨直接枚举所有 \(a, b\) 的配对，找出是否存在一种配对，使剩余的两种符号个数相同。若相同，我们直接选择第一种配对方式配对即可。 时间复杂度：\(O(n)?\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int gcd(int a, int b) &#123; while (b != 0) &#123; int tmp = a; a = b; b = tmp % b; &#125; return a; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, q; string op; cin >> n >> op >> q; int pl = 0; for(char e : op) if(e == '+') pl ++; int mi = n - pl; int tmp = min(pl, mi); mi = max(pl, mi); pl = tmp; while(q --)&#123; int a, b; cin >> a >> b; tmp = min(a, b); a = max(a, b); b = tmp; if(pl == mi)&#123; cout &lt;&lt; "YES\n"; continue; &#125; int lcm = a * b / gcd(a, b); int pa = lcm / a, pb = lcm / b; int t = min(pl / pa, mi / pb); bool f = false; for(int i=1;i&lt;=t;i++)&#123; if(pl - i * pa == mi - i * pb)&#123; f = true; break; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; 人类的智慧（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 290</title>
    <url>/blog/posts/348658234/</url>
    <content><![CDATA[Contestant. Rank 3650. Rating +66. A. Contest Result 题意 给定数组 \(a, b\)，输出 \(a_{b_i}\) 的总和。 思路 如题。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i = 1;i&lt;=n;i++) cin >> a[i]; int ans = 0; for(int i=0;i&lt;m;i++)&#123; int p; cin >> p; ans += a[p]; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; 太打卡了吧（（ B. Qual B 题意 给定一个由 \(o, x\) 组成的字符串，将第 \(k + 1\) 个及以后的 \(o\) 替换成 \(x\)，输出字符串。 思路 如题。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; string s; cin >> s; int cnt = 0; for(int i=0;i&lt;n;i++)&#123; if(s[i] == 'x') cout &lt;&lt; 'x'; else&#123; cnt ++; if(cnt > m) cout &lt;&lt; 'x'; else cout &lt;&lt; 'o'; &#125; &#125; &#125; 做的太慢了捏 C. Max MEX 题意 给定一个数组 \(a\)，找出一个长为 \(k\) 的子串 \(X\)，满足 \(MEX\) 值最大。 定义 \(MEX(X)\) 为最大的 \(m\) ，满足下面的条件： \([0, m)\) 都在 \(X\) 内； \(m\) 不在 \(X\) 内 思路 我们不妨将数组升序排序，去除所有的重复元素，然后从 \(0\) 开始匹配，若能找到 \(0, 1, \ldots, k\) ，那么输出 \(k + 1\)，否则找到最长的 \(0, 1, \ldots, t\) ，输出 \(t + 1\)。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 3e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a, a + n); a[n] = inf; int l = 0; for(int i=0;i&lt;=n;i++)&#123; if(a[i] == l - 1) continue; if(a[i] == l) l ++; if(l >= m) break; &#125; cout &lt;&lt; l; &#125; 模拟不明白了（（ D. Marking 题意 对于 \(t\) 个询问，给定三个整数 \(n, d, k\)，输出第 \(k\) 次标记的点。 标记满足下面的规则： 第一次标记 \(0\) 点； 重复下述操作 \(n - 1\) 次，其中 \(a\) 为前一次标记的下标： 令 \(x = (a + d)\mod N\)； 找到 \(x\) 及以后第一个没标记的下标并标记 思路 首先，很明显地，我们需要找出标记的周期，当完成一次周期后，我们需要移到下一位并继续循环，直至结束。 不难证明，周期是 \(x = \frac{n}{gcd(n, d)}\)，而我们只需要计算经过了多少个周期，然后将最后的答案加上这个值即可。 考虑到数据量不超过长整型，我们直接计算 \((d \times k)\mod n\) 即可，然后按照上述操作加上 \(\frac{k}{x}\) 即可。 时间复杂度：不会分析捏 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; private static long gcd(long a, long b) &#123; while(b != 0) &#123; long tmp = a; a = b; b = tmp % b; &#125; return a; &#125; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; long n = console.nextInt(), d = console.nextInt(), k = console.nextInt(); k --; console.println(d * k % n + k / (n / gcd(n, d))); &#125; console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; nnd，没考虑到类似于 \(6, 9\) 的测试数据，寄]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 288</title>
    <url>/blog/posts/50897737/</url>
    <content><![CDATA[Contestant. Rank 3721. Rating +41. A. Many A+B Problems 题意 给定 \(a, b\)，输出 \(a + b\)。 思路 如题 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0); int t; cin >> t; while(t --)&#123; int a, b; cin >> a >> b; cout &lt;&lt; a + b &lt;&lt; '\n'; &#125; return 0; &#125; 怎么会是呢 B. Qualification Contest 题意 给定 \(n\) 个由小写字母组成的字符串，输出字典序升序排序的前 \(k\) 个字符串。 思路 考虑到 \(sort\) 对字符串的排序就是按照字典序的，所以调函数输出即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 110; string a[N]; signed main() &#123; ios::sync_with_stdio(0); int k, n; cin >> n >> k; for (int i = 0; i &lt; n; i++) cin >> a[i]; sort(a, a + k); for (int i = 0; i &lt; k; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; '\n'; &#125; return 0; &#125; 草，卡了半天发现调函数就好了（ C. Don’t be cycle 题意 给定一个无向有环图，输出最小删除边数，使整个图无环。 思路 考虑到树的结构即为无向无环，所以我们不妨跑一遍最小生成树，剩余的边就是我们想要删去的边了。 时间复杂度：\(O(e \log_2 e)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010, M = 400010; int n, m; int f[N]; int u[M], v[M], ans = 0; int find(int x)&#123; return x == f[x] ? x : f[x] = find(f[x]); &#125; void kruskal()&#123; for(int i=0;i&lt;m * 2;i++)&#123; int eu = find(u[i]), ev = find(v[i]); if(eu != ev)&#123; ans ++; f[ev] = eu; &#125; &#125; &#125; signed main() &#123; ios::sync_with_stdio(0); cin >> n >> m; for(int i=1;i&lt;=n;i++) f[i] = i; for(int i=0;i&lt;m;i++)&#123; int a, b; cin >> a >> b; u[i &lt;&lt; 1] = a; v[i &lt;&lt; 1] = b; u[i &lt;&lt; 1 | 1] = b; v[i &lt;&lt; 1 | 1] = a; &#125; kruskal(); cout &lt;&lt; m - ans; return 0; &#125; 我蠢了，想了好一会儿]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 143</title>
    <url>/blog/posts/3290967404/</url>
    <content><![CDATA[Contestant. Rank 2199. Rating +10. A. Two Towers 题意 给定由两种不同颜色的元素叠成的塔，定义操作为将一个塔上的顶部元素移动到另一个塔，在若干次操作后，输出是否可以让两个塔的元素颜色相间。 思路 显然，这个问题可以抽象为：给定一个元素序列，找出一个点，将序列分成两半，使分割后的序列颜色相间。 那么，我们需要满足两个条件： 序列内没有连续 \(3\) 个及以上相同元素相邻； 序列内连续 \(2\) 个及以上相同元素相邻的组的个数最多只有 \(1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a, b; cin >> a >> b; string x, y; cin >> x >> y; reverse(y.begin(), y.end()); x += y; int n = a + b; char pre = -1; int cnt = 0; bool ans = true, found = false; for(int i=0;i&lt;n;i++)&#123; char cur = x[i]; if(cur == pre) &#123; cnt ++; if(cnt == 2)&#123; if(found)&#123; ans = false; break; &#125; found = true; &#125; if(cnt >= 3)&#123; ans = false; break; &#125; &#125;else cnt = 1; pre = cur; &#125; cout &lt;&lt; (ans ? "YES\n" : "NO\n"); &#125; return 0; &#125; 漏条件了，淦 B. Ideal Point 题意 给定 \(n\) 个区间，判断是否能删去一些区间，让 \(k\) 成为被最多数量的区间包含的点。 思路 显然，若不希望让其他节点成为被最多数量的区间包含的点，我们就希望两个区间的交集为一个点，也就是说，我们只需删到最后只剩下 \([x, k], [k, y]\) 即可。 换句话说，我们只需找出这样的区间，满足左边界为 \(k\) 或右边界为 \(k\)。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a, b; cin >> a >> b; string x, y; cin >> x >> y; reverse(y.begin(), y.end()); x += y; int n = a + b; char pre = -1; int cnt = 0; bool ans = true, found = false; for(int i=0;i&lt;n;i++)&#123; char cur = x[i]; if(cur == pre) &#123; cnt ++; if(cnt == 2)&#123; if(found)&#123; ans = false; break; &#125; found = true; &#125; if(cnt >= 3)&#123; ans = false; break; &#125; &#125;else cnt = 1; pre = cur; &#125; cout &lt;&lt; (ans ? "YES\n" : "NO\n"); &#125; return 0; &#125; nnd，一个水题卡半天 C. Tea Tasting 题意 给定 \(n\) 壶茶和 \(n\) 个品茶师，第 \(i\) 壶茶有 \(a_i\) 数量的茶，第 \(i\) 位品茶师一次可以喝 \(b_i\) 数量的茶。 规定有 \(n\) 轮喝茶，第 \(i\) 轮由 \([i, n]\) 内的品茶师喝 \([1, n - i + 1]\) 内的茶。 输出每位品茶师最后喝了多少。 思路 首先，我们可以发现，对于第 \(i\) 轮，我们考虑从第 \(i\) 位开始求和后第一个超过 \(a_i\) 的数的下标，此时我们就可以确定一轮下来有哪些品茶师喝了茶。 考虑到只有最后一个品茶师有可能喝到多余的茶，其余的品茶师喝的量都是次数乘上 \(b_i\)，那么我们不妨单独统计多余喝的量，其余的统计我们考虑使用差分。 当然，上述求和找下标的操作可以采用 前缀和+二分。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], b[N], sum[N], drunk[N], ans[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=1;i&lt;=n;i++) &#123; cin >> b[i]; drunk[i] = 0; ans[i] = 0; &#125; sum[0] = drunk[0] = ans[0] = 0; for(int i=1;i&lt;=n;i++) sum[i] = sum[i - 1] + b[i]; for(int i=1;i&lt;=n;i++) &#123; int x = lower_bound(sum + i, sum + n + 1, a[i] + sum[i - 1]) - sum - 1; //x为能吃的最后一个玩意儿 //if(x == 0) continue; int left = a[i] + sum[i - 1] - sum[x]; if(x &lt; n) ans[x + 1] += left; drunk[i] ++; drunk[x + 1] --; &#125; for(int i=1;i&lt;=n;i++)&#123; drunk[i] += drunk[i - 1]; ans[i] += drunk[i] * b[i]; cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; return 0; &#125; 过于模拟以至于思路很清晰也很单一 D. Triangle Coloring 题意 给定一个有 \(\frac{n}{3}\) 个连通块的带权无向有环图，每个连通块的三点均有一条边相连，构成 \(\frac{n}{3}\) 个三角形。将所有点染上两种颜色，满足两种颜色的点的个数相同，输出有多少方案让连接两个颜色不同的点的边的权值总和最大。 思路 显然，我们需要考虑一个连通块内权值重复的边，而我们关注的是最大值和次大值的情况： 全都相等，\(3\) 种选择； 次大值和最小值相等，\(2\) 种选择； 次大值和最大值相等，\(1\) 种选择； 没有一个相等，\(0\) 种选择。 照上述讨论，我们可以发现一个连通块的解等于最小值和多少条边是相等的。 而考虑到两种颜色的个数要相同，我们相当于在 \(t\) 个连通块中找出 \(\frac{t}{2}\) 个连通块染成同一种颜色，所以最后的答案即为所有连通块解的乘积乘上 \(C_{t}^{\frac{t}{2}}\)。 时间复杂度：不会分析 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 3e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= (a / b) * x; return d; &#125; int Inv(int a) &#123; int x, y; exgcd(a, mod, x, y); return (x % mod + mod) % mod; &#125; int C(int m, int n) &#123; int a = 1, b = 1; if (m &lt; n) return 0; while (n) &#123; a = (a * m) % mod; b = (b * n) % mod; m--; n--; &#125; return a * Inv(b) % mod; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin >> n; for (int i = 1; i &lt;= n; i++) cin >> a[i]; int t = n / 3; int ans = C(t, t / 2); for (int i = 0; i&lt;=n/3-1;i++) &#123; int minn = min(a[i * 3 + 3], min(a[i * 3 + 1], a[i * 3 + 2])); int cnt = 0; for (int j = 1; j &lt;= 3; j++) if (a[i * 3 + j] == minn) cnt++; ans = (ans * cnt) % mod; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0; &#125; 数组不要开小了！！ E. Explosions? 题意 给定一个数组 \(h\)，\(h_i\) 为第 \(i\) 个怪物的血量。每次操作可以使用任意数量的 \(MP\)，使任意一个怪物的血量扣除对应数量的值。 若怪物在遭到攻击后血量小于等于 \(0\)，那么怪物死亡。 定义"爆炸"为一个死亡的怪物将相邻的怪物的血量扣去 \(h_i - 1\)，若相邻的怪物血量被扣到 \(0\)，那么继续循环。 规定只能让"爆炸"发生一次或不发生，输出让所有怪物死亡的 \(MP\) 的最小值。 思路 答案的推导 首先，我们暂定爆炸的那个点下标为 \(p\)，之后再考虑 \(p\) 的选择。那么，我们不妨在最后使用爆炸，这样可以在爆炸前将所有元素调整到最好，也就是在 \([0,p]\) 内严格单调递增，\([p,n]\) 内严格单调递减。 我们不妨用补集的思路，算出最后满足上述条件的数组 \(h&#39;\) 的最大总和 \(sum\)，那么答案即为 \((\sum h_i) - sum\)。 总和的计算 首先，不难发现对于 \([0,p]\) 和 \([p, n]\) 的操作是类似的，那么我们不妨只考虑 \([0, p]\) 内的 \(sum&#39;\)。 "左边界" 对于 \(p - 1\) 点，假设该点满足 \(h_{p - 1} &gt; h _ p - 1\)，若需要构成连续爆炸，那么我们需要将 \(h_{p - 1}\) 改为 \(h_p - 1\)。同理，可推得对于 \(p - i\) 点，通式为 \(h_{p - i} &gt; h_p - i\)。 显然，因为严格单调递增，那么 \(h_p &gt; i\) 是一定成立的，也就是说，\(i \geq h_p\) 时到达边界。当然，按照上述的推导，\(p - i &lt; 0\) 或 \(h_{p - i} \leq h_p - i\) 时也会到达边界。 所以，对于左边界 \(j = p - i\)，将 \(i = p - j\) 和 \(h_{p - i} \leq h_p - i\) 联立，得到 \(h_j - j \leq h_p - p\)。 当然，若没有 \(j\) 满足上面的式子，那么我们将 \(j\) 设为 \(\max(-1, i - h_i)\)。 递推出总和 注意一下推导左边界的条件：\(h_{p - 1} &gt; h _ p - 1\)。这个条件有一个特点：我们目前所求得的"左边界"实际上是严格单调递增且相邻差值为 \(1\) 的序列的左边界，若出现了"断层"，那么 \(j\) 就有可能偏大了。 但是，不难发现 \(j\) 的推导和 \(p\) 后面的值是无关的，那么我们可以用递推的方式，先算出 \(j\) 前面"严格单调递增且相邻差值为 \(1\) 的序列"的总和，然后将这个总和加到 \(sum&#39;\) 中即可。 更具体地说，\(dp[i]\) 为以 \(i\) 点为右边界的"严格单调递增且相邻差值为 \(1\) 的序列"的总和，那么只要 \(j\) 对应的元素存在，我们就只需将 \(dp[i]\) 加上 \(dp[j]\) 。 有疑惑吗？请留意条件：\(h_{p - 1} \leq h _ p - 1\)。\(j\) 元素的值一定小于等于 \(j + 1\) 元素的值，所以加上 \(dp[j]\) 无额外条件。 计算 综上，我们只需对每个"严格单调递增且相邻差值为 \(1\) 的序列"求和即可，考虑到等差性，直接运用等差数列的求和公式即可。 因而， \(dp[i] = (i - j) \times h_i - \frac{(i - j)(i - j - 1)}{2}\)，\(j\) 存在时 \(dp[i] += dp[j]\)。 "左边界"的低复杂度求法 考虑到我们不可以在每次递推的时候都向前遍历满足条件的"左边界" \(j\)，因而我们需要一种更快的方法。 我们回归到条件 \(h_j - j \leq h_p - p\)。显然，我们需要找出满足该条件的 \(j\) 的最大值，而该思路恰好可以用单调栈实现（先入后出的逻辑适合本题），那么我们只需套上板子即可。 最后的答案 显然，上述操作是线性的，那么我们只需遍历所有的 \(p\)，然后输出最大值即可。 当然，因为 \(dpL\) 和 \(dpR\) 会有重叠，所以需要减去重叠的 \(h_i\)。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 3e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int hl[N], hr[N], dp[2][N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int sum = 0; for(int i=0;i&lt;n;i++) &#123; cin >> hl[i]; sum += hr[n - i - 1] = hl[i]; dp[0][i] = dp[1][i] = 0; &#125; for(int tp=0;tp&lt;2;tp++)&#123; int *h = tp == 0 ? hl : hr; stack&lt;pii> s; for(int i=0;i&lt;n;i++)&#123; while(!s.empty() &amp;&amp; s.top().first > h[i] - i) s.pop(); int j = max(-1LL, i - h[i]); if(!s.empty()) j = max(j, s.top().second); int len = i - j; dp[tp][i] = len * h[i] - len * (len - 1) / 2; if(j >= 0 &amp;&amp; len &lt; h[i]) dp[tp][i] += dp[tp][j]; s.emplace(h[i] - i, i); &#125; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; ans = max(ans, dp[0][i] + dp[1][n - i - 1] - hl[i] * 2); &#125; cout &lt;&lt; sum - ans &lt;&lt; '\n'; &#125; &#125; 好复杂.jpg]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 833 Div 2</title>
    <url>/blog/posts/1795773139/</url>
    <content><![CDATA[Practice. A. The Ultimate Square 题意 给定 \(n\) 个方块，第 \(i\) 个方块的宽度为 \(1\)，长度为 \(\lceil \frac{i}{2} \rceil\)。选取一些方块横向拼接成一个正方形，输出正方形的最大边长。 思路 显然，当 \(n\) 为奇数的时候，我们一定能将所有方块都用上，拼成一个长为 \(\frac{n + 1}{2}\) 的正方形；当 \(n\) 为偶数的时候，一个大方块将会多出来，而剩余的方块按照奇数的情况处理即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; signed main()&#123; ios::sync_with_stdio(false); int t, n; cin >> t; while(t --)&#123; cin >> n; cout &lt;&lt; n / 2 + n % 2 &lt;&lt; '\n'; &#125; &#125; 猜测即可 B. Diverse Substrings 题意 给定一串数字 \(a\)，\(a_i \in [0, 9]\)，对于所有连续子串，输出满足下面条件的个数： 对于子串中出现次数最多的数字的次数 \(maxx\) 以及不同数字的种数 \(dif\)，满足 \(maxx \leq dif\)。 思路 考虑到满足条件的子串长度最多只有 \(10 \times 10\)，我们直接暴力枚举即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 20, inf = 0x3f3f3f3f, mod = 998244353; int cnt[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int ans = 0; for(int i=0;i&lt;n;i++)&#123; memset(cnt, 0, sizeof cnt); int dif = 0, maxx = 0; for(int j=i;j&lt;n&amp;&amp;j-i&lt;100;j++)&#123; if(cnt[s[j] - '0'] == 0) dif ++; cnt[s[j] - '0'] ++; maxx = max(maxx, cnt[s[j] - '0']); if(maxx &lt;= dif) ans ++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; return 0; &#125; 太暴力了，虽然双指针确实不可行 C. Zero-Sum Prefixes 题意 给定数组 \(a\)，定义操作为将任意一个值为 \(0\) 的点替换成任意值，输出操作后所有前缀和中值为 \(0\) 的个数。 思路 考虑到修改一个元素，会影响到后面的元素的前缀和值，所以我们不妨直接从后面开始遍历。我们不妨从后往前找 \(0\)，当然，在找的过程中，记录 \(0\) 后面的元素的前缀和的值的出现次数，然后，我们只需把 \(0\) 改成出现次数最多的前缀和的值的相反数即可，该情况下答案加上最多的出现次数，这样不会影响到前面的答案，并且可以让后面前缀和为 \(0\) 的数尽可能多。 时间复杂度：\(O(n)?\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N], sum[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; sum[0] = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; sum[i] = sum[i - 1] + a[i]; &#125; int ans = 0; map&lt;int, int> mp; for(int i=n;i>=1;i--)&#123; mp[sum[i]] ++; if(a[i] == 0)&#123; int maxx = 0; for(auto &amp;e : mp) maxx = max(maxx, e.second); ans += maxx; mp.clear(); &#125; &#125; cout &lt;&lt; ans + mp[0]&lt;&lt; '\n'; &#125; return 0; &#125; 有点小贪心]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 834 Div 3</title>
    <url>/blog/posts/3651755215/</url>
    <content><![CDATA[Practice. A. Yes-Yes? 题意 给定一个字符串，判断其是否是 \(YESYESYES...\) 的连续子串。 思路 判断多出的前缀是否满足条件，若满足条件，以 \(3\) 个字符为一组匹配 \(YES\)。剩余的后缀特判即可。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; string s; cin >> s; n = (int) s.size(); int i = 0; if(s[i] != 'Y')&#123; if(s[i] == 'e' &amp;&amp; (n == 1 || s[i + 1] == 's')) i = 2; else if(s[i] == 's') i = 1; else i = -1; &#125; if(i != -1) for(;i&lt;n;i+=3)&#123; if(s[i] == 'Y' &amp;&amp; (i + 1 >= n || s[i + 1] == 'e') &amp;&amp; (i +2 >= n || s[i + 2] == 's')) continue; i = -1; break; &#125; cout &lt;&lt; (i == -1 ? "NO\n" : "YES\n"); &#125; return 0; &#125; 读题即可 B. Lost Permutation 题意 给定一个丢失了部分元素的排列，丢失的元素的总和为 \(s\)，输出是否能补全该排列。 思路 模拟即可。 我们遍历一遍，找出当前最大值之前的空位，去掉这些空位后，若 \(s\) 还有剩余，那么继续从最大值 \(+1\) 往下遍历，若能将 \(s\) 恰好减为 \(0\)，输出 \(YES\)。 时间复杂度：\(O(n)?\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; bool a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n, s; cin >> n >> s; memset(a, 0, sizeof a); int maxx = -1; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; a[cur] = true; maxx = max(maxx, cur); &#125; int tot = 0; for(int i=1;i&lt;=maxx;i++) if(!a[i]) tot += i; if(tot > s) cout &lt;&lt; "NO\n"; else&#123; int i = maxx + 1; while(tot &lt; s)&#123; tot += i ++; &#125; cout &lt;&lt; (tot == s ? "YES\n" : "NO\n"); &#125; &#125; return 0; &#125; 模拟就完事了 C. Thermostat 题意 给定一段区间 \([l, r]\)，区间内有两个点 \(a, b\)，定义一次操作为将当前位置加上或减去 \(p\)，\(p \geq x\)，操作后的数需要落在区间内。输出从 \(a\) 运动到 \(b\) 需要的最少操作数。 思路 显然，最多只需进行 \(3\) 次操作。 考虑到对称性，我们不妨来考虑 \(l \leq a \leq b \leq r\) 的情况，分类讨论一下： 无需操作，此时 \(a = b\)； 操作一次，此时应满足 \(b - a \geq x\)； 操作两次，此时我们可以向两端移动，只需任意一个满足即可。若向 \(l\) 移动，那么向下移动需要满足 \(a - l \geq x\)，考虑到步数只需大于等于 \(x\)，我们可以直接移动到 \(l\)，然后移动到 \(b\)。因为 \(l\) 到 \(b\) 的距离大于 \(l\) 到 \(a\) 的距离，那么我们无需多考虑。而向 \(r\) 移动时，在满足 \(r - a \geq x\) 的前提下，还需满足能运动到 \(b\)，即 \(r - a \geq x + \min(b - a, x)\)。 操作三次，相类似地，我们可以得到下面的式子：向 \(r\) 移动，\(r - a \geq x\) 、\(b - l \geq x\)；向 \(l\) 移动，\(a - l \geq x\)，\(r - b \geq x\)。 时间复杂度：\(O(1)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a, b, l, r, x; cin >> l >> r >> x >> a >> b; if(a == b) cout &lt;&lt; 0 &lt;&lt; '\n'; else if(abs(b - a) >= x) cout &lt;&lt; 1 &lt;&lt; '\n'; else if(a &lt; b)&#123; int ans1 = inf, ans2 = inf; if(a - l >= x || r - a >= x + min(b - a, x)) ans1 = 2; if((r - a >= x &amp;&amp; b - l >= x) || (a - l >= x &amp;&amp; r - b >= x)) ans2 = 3; cout &lt;&lt; (min(ans1, ans2) == inf ? -1 : min(ans1, ans2)) &lt;&lt; '\n'; &#125;else&#123; int ans1 = inf, ans2 = inf; if(r - a >= x || a - l >= x + min(a - b, x)) ans1 = 2; if((a - l >= x &amp;&amp; r - b >= x) || (r - a >= x &amp;&amp; b - l >= x)) ans2 = 3; cout &lt;&lt; (min(ans1, ans2) == inf ? -1 : min(ans1, ans2)) &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 讨论死我了 D. Make It Round 题意 给定两个整数 \(n, m\)，找出 \(k \in [1, m]\)，使 \(n \times k\) 连续后缀 \(0\) 的个数最多。若有多解，输出最大的；若无解，输出 \(n \times m\)。 思路 考虑到 \(10\) 的质因子为 \(2, 5\)，我们不妨将 \(n\) 后面连续的 \(0\) 都去掉，然后统计 \(n\) 中因数 \(2, 5\) 的个数，并尽量在答案中用对应的 \(5, 2\) 与之配对，然后在答案最后尽可能拼上 \(0\)。最后得到的答案即为 \(0\) 个数最多的，因为存在多解，我们将答案乘上 \(m / ans\)。 时间复杂度：不会分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long signed main()&#123; ios::sync_with_stdio(false); int t, n, m; cin >> t; while(t --)&#123; cin >> n >> m; int ans = 1, p = n; while(p % 10 == 0) p /= 10; while(p % 2 == 0 &amp;&amp; ans * 5 &lt;= m)&#123; p /= 2; ans *= 5; &#125; while(p % 5 == 0 &amp;&amp; ans * 2 &lt;= m)&#123; p /= 5; ans *= 2; &#125; while(ans * 10 &lt;= m) ans *= 10; cout &lt;&lt; m / ans * n * ans &lt;&lt; '\n'; &#125; &#125; 配对配对，贪一下嘛~ E. The Humanoid 题意 给定 \(n\) 个人，每个人有能力值 \(a_i\)。对于一个初始攻击力为 \(h\) 的怪物，它可以干掉所有 \(a_i &lt; h\) 的人，并将自己的攻击力提高 \(\lceil \frac{a_i}{2} \rceil\)。怪物有两个道具，道具一总数为 \(2\)，可以将攻击力翻倍；道具二总数为 \(1\)，可以将攻击力变为原来的三倍。道具使用后消失。输出怪物可以干掉的最多人数。 思路 显然，若想让后续能倍乘的基数变得更大，我们就可以贪心地按能力值升序排序人，这样在需要道具的时候，就能获得尽可能多的攻击力。 然而，使用哪个道具是不确定的，虽然 \(3\) 翻的倍数最多，但放在前面还是后面是不确定的。 考虑到道具只有 \(3\) 个，我们不妨枚举道具使用的顺序，然后用递归解决即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; int a[N], n; int cal(int b, int i, int use, int h)&#123; if(i == n) return 0; if(a[i] &lt; h) return cal(b, i + 1, use, h + a[i] / 2) + 1; else&#123; if(use == 3) return 0; return cal(b, i, use + 1, h * (b == use ? 3 : 2)); &#125; &#125; signed main()&#123; ios::sync_with_stdio(false); int t, h; cin >> t; while(t --)&#123; cin >> n >> h; for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a, a + n); int ans = 0; for(int i=0;i&lt;3;i++) ans = max(ans, cal(i, 0, 0, h)); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 一开始错在道具的使用顺序上了，不可以贪心地使用当前能用的最小的翻倍数]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 835 Div 4</title>
    <url>/blog/posts/3787113180/</url>
    <content><![CDATA[Practice A. Medium Number 题意 给定三个数，输出中位数。 思路 排序，输出中间的。 时间复杂度：\(O(1)\) (确信) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a[3]; for(int i=0;i&lt;3;i++) cin >> a[i]; sort(a, a + 3); cout &lt;&lt; a[1] &lt;&lt; '\n'; &#125; return 0; &#125; 过于打卡 B. Atilla's Favorite Problem 题意 给定一个字符串，输出最大字母在字母表的位置。 思路 如题，暴力模拟 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int r = 0; for(char e : s)&#123; r = max(r, (int) (e - 'a')); &#125; cout &lt;&lt; r + 1 &lt;&lt; '\n'; &#125; return 0; &#125; 为啥不直接学一段区间内的呢（划掉 C. Advantage 题意 给定一个数组 \(a\)，对于所有 \(a_i\)，输出其与除它之外的元素中的最大值的差值。 思路 如题，暴力模拟。 可以找出整个数组中的最大值和次大值，然后遍历到最大值时输出其与次大值的差即可，其余直接减去最大值。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int maxx = 0, smax = 0; for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; if(a[i] >= maxx)&#123; smax = maxx; maxx = a[i]; &#125;else if(a[i] >= smax) smax = a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i] == maxx) cout &lt;&lt; a[i] - smax &lt;&lt; ' '; else cout &lt;&lt; a[i] - maxx &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; return 0; &#125; 差点没读懂题（ D. Challenging Valleys 题意 给定一个数组 \(a\)，输出是否只有一组满足下面条件的 \(l, r\)： \(0 \le l \le r \le n-1\) \(a_l = a_{l+1} = a_{l+2} = \dots = a_r\) \(l = 0\) 或 \(a_{l-1} &gt; a_{l}\) \(r = n - 1\) 或 \(a_r &lt; a_{r+1}\) 思路 我们可以遍历整个数组，找出所有拐点，并记录其与其之后的单调性。 之后，我们可以遍历整个拐点数组，找出所有 “递减，递增” 和 “递减，不变，递增” 段，统计数量。 特别地，考虑到条件 \(3, 4\) 的特殊性，我们还需找出下面的情况： 整个数组单调 第一段单调区间值不变，第二段单调区间单调递增 最后一段单调区间值不变，倒数第二段单调区间单调递减 统计数量，判断数量是否为 \(1\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int pre; cin >> pre; if(n == 1) &#123; cout &lt;&lt; "YES\n"; continue; &#125; vector&lt;int> trend; int inc = -1, cnt = 0; for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; if(pre &lt; cur &amp;&amp; inc != 1) &#123; inc = 1; trend.emplace_back(inc), cnt ++; &#125;else if(pre == cur &amp;&amp; inc != 2)&#123; inc = 2; trend.emplace_back(inc), cnt ++; &#125;else if(pre > cur &amp;&amp; inc != 0)&#123; inc = 0; trend.emplace_back(inc), cnt ++; &#125; pre = cur; &#125; if(cnt == 1)&#123; cout &lt;&lt; "YES\n"; &#125; else &#123; int ans = 0; if ((trend[0] == 2 &amp;&amp; trend[1] == 1) || trend[0] == 1) ans++; if ((trend[cnt - 1] == 2 &amp;&amp; trend[cnt - 2] == 0) || trend[cnt - 1] == 0) ans++; for (int i = 0; i &lt; cnt; i++) &#123; if (trend[i] == 0) &#123; if(i + 1 &lt; cnt &amp;&amp; trend[i + 1] == 1) ans ++; if(i + 2 &lt; cnt &amp;&amp; trend[i + 1] == 2 &amp;&amp; trend[i + 2] == 1) ans ++; &#125; &#125; cout &lt;&lt; (ans == 1 ? "YES\n" : "NO\n"); &#125; &#125; return 0; &#125; 无脑模拟题，纯纯费时间 E. Binary Inversions 题意 给定一个二进制数组，定义操作为将任意元素 \(x\) 改为 \(1 - x\)，在操作最多只能执行一次的情况下，输出逆序对个数的最大值。 思路 显然，我们可以贪心地认为，我们只需找出最后一个 \(1\) 和第一个 \(0\)，判断不执行操作以及只对这两个元素执行操作后的结果的最大值。 对于找逆序对，我们可以维护一个前缀 \(1\) 个数的数组 \(pre\) 和后缀 \(0\) 个数的数组 \(suf\)，然后遍历所有的 \(0\)，统计 \(1\) 个数即可。 对于最后一个 \(1\) 的替换，价值为其前面 \(1\) 的个数，代价为后面 \(0\) 的个数。对第一个 \(0\) 的替换同理。 当然，需要特判整个数组只有一种元素的情况，根据上面的逻辑，输出 \(n - 1\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], pre[N], suf[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; pre[0] = 0; //前面的1 suf[n + 1] = 0; //后面的0 int one = -1, zero = -1; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; pre[i] = pre[i - 1]; if(a[i] == 1) &#123; pre[i] ++; one = i; &#125;else if(zero == -1) zero = i; &#125; int ans = 0; for(int i=n;i>=1;i--)&#123; suf[i] = suf[i + 1]; if(a[i] == 0) &#123; suf[i] ++; ans += pre[i]; &#125; &#125; if(one == -1 || zero == -1) cout &lt;&lt; n - 1 &lt;&lt; '\n'; else &#123; int d1 = suf[zero] - 1 - pre[zero], d0 = pre[one] - 1 - suf[one]; cout &lt;&lt; max(ans, ans + max(d1, d0)) &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 依然是模拟（ F. Quests 题意 给定 \(n\) 个操作，操作 \(i\) 可以获得 \(a_i\) 个硬币，每隔 \(k\) 时间可以进行一次重复的操作。给定硬币的需求 \(c\) 和限定的时间 \(d\)，输出在限定时间内满足硬币需求的最大 \(k\)。 若不存在该 \(k\)，输出 \(impossible\)；若 \(k\) 无穷大，输出 \(infinity\)。 思路 考虑到 \(k\) 越大，能在 \(d\) 天内获得的硬币数量会减小，存在单调性，因而我们不妨考虑二分答案。 我们可以贪心地认为，我们只需每隔 \(k\) 输出降序排序后的前 \(k\) 个数，因为一次性能获得的硬币更多，我们能间隔的时间就越长。 所以，我们只需 \(check\) 一下按上述操作获得的 \(d\) 天内的硬币数，进行二分即可。 当然，若最后的答案落在左边界，输出 \(impossible\)，落在右边界输出 \(infinity\)。 时间复杂度：\(O(n \log n + t \log n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n, c, d; cin >> n >> c >> d; for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a, a + n, greater&lt;>()); int l = 0, r = d + 2, mid; while(l &lt;= r)&#123; mid = (l + r + 1) >> 1; if(mid == 0) break; int tot = 0; for(int i=0;i&lt;d;i++) if(i % mid &lt; n) tot += a[i % mid]; if(tot >= c) l = mid + 1; else r = mid - 1; &#125; if(r == d + 2) cout &lt;&lt; "Infinity\n"; else if(l == 0) cout &lt;&lt; "Impossible\n"; else cout &lt;&lt; r - 1 &lt;&lt; '\n'; &#125; return 0; &#125; 二分一下就好简单（（ G. SlavicG's Favorite Problem 题意 给定一个带权值的无向无环图，给定两个点 \(a, b\)，定义 \(x = 0\)，从 \(a\) 开始向子节点走，到达节点 \(i\) 就会将 \(x\) 修改为 \(x\ XOR\ {w_i}\) 。在任意节点，可以选择传送到除 \(b\) 外的任意节点，并继续走。输出是否存在一种路径，使到达 \(b\) 后 \(x = 0\)。 思路 考虑到异或的性质，我们不妨跑两遍 \(Dfs\)，用回溯搜索即可，每次搜索的起始 \(x\) 值均为 \(0\)。 第一次搜索，我们从 \(a\) 节点开始走，计算所有 \(x\) 的可能值，用 \(map\) 记录下来； 第二次搜索，我们从 \(b\) 节点开始走，判断当前的 \(x\) 和 \(0\) 异或的值是否被记录过，若被记录过，那么我们一定可以用传送的方式使这两条路径联通，且最后答案符合要求。 当然，我们可以用邻接表存边。 时间复杂度：不会分析 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; struct Node&#123; int to, w; &#125;; vector&lt;Node> e[N]; bool vis[N], ans; map&lt;int, bool> mp; int n, a, b; void add(int u, int v, int w)&#123; e[u].push_back(&#123;v, w&#125;); e[v].push_back(&#123;u, w&#125;); &#125; void dfs1(int r, int v)&#123; if(vis[r] || r == b) return; vis[r] = true; mp[v] = true; for(auto x : e[r])&#123; dfs1(x.to, v ^ x.w); &#125; vis[r] = false; &#125; void dfs2(int r, int v)&#123; if(vis[r]) return; vis[r] = true; if(r != b &amp;&amp; mp[v ^ 0])&#123; ans = true; return; &#125; for(auto a : e[r])&#123; dfs2(a.to, v ^ a.w); &#125; vis[r] = false; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; cin >> n >> a >> b; for(int i=1;i&lt;=n;i++) e[i].clear(), vis[i] = false; for(int i=1;i&lt;n;i++)&#123; int u, v, w; cin >> u >> v >> w; add(u, v, w); &#125; mp.clear(); dfs1(a, 0); ans = false; dfs2(b, 0); cout &lt;&lt; (ans ? "YES\n" : "NO\n"); &#125; return 0; &#125; 简简单单的思维 + dfs]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 836 Div 2</title>
    <url>/blog/posts/959544692/</url>
    <content><![CDATA[Practice. A. SSeeeeiinngg DDoouubbllee 题意 给定一个字符串，将字符串复制一遍后拼接在一起得到一个新的字符串，将该字符串重新组合，输出一种回文组合。 思路 倒着拼到末尾。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; String s = scanner.next(); System.out.println(s + new StringBuilder(s).reverse()); &#125; &#125; &#125; 过于无脑 B. XOR = Average 题意 给定一个整数 \(n\)，构造一个长度为 \(n\) 的无重复元素的数组 \(a\)，满足 \(1 \leq a \leq 10 ^ 9\) 以及所有数的异或值等于平均值，即 \(a_1 \oplus a_2 \oplus \dots \oplus a_n = \frac{a_1 + a_2 + \dots + a_n}{n}\)。 输出数组的任意一种构造。 思路 我们来考虑奇偶性： \(n\) 为奇数时，我们只需输出 \(n\) 个 \(1\)，此时恰好满足条件； \(n\) 为偶数时，考虑到 \(1, 3\) 的平均数为 \(2\)，异或值也为 \(2\)，而偶数个相同数的异或值为 \(0\)，所以我们不妨输出 \(1,3\)，以及 \(n - 2\) 个 \(2\)，即可满足条件。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); if(n % 2 == 1)&#123; for(int i=0;i&lt;n;i++) System.out.print("1 "); System.out.println(); &#125;else&#123; System.out.print("1 3 "); for(int i=0;i&lt;n-2;i++) System.out.print("2 "); System.out.println(); &#125; &#125; &#125; &#125; 小的就足矣 C. Almost All Multiples 题意 给定整数 \(n, x\)，构建一个字典序最小的排列 \(p\)，满足下面的条件： \(p_1 = x, p_n = 1\)； \(p_i \% i = 0\)。 思路 显然，若不考虑条件，那么我们肯定会输出一个递增的排列。 当我们考虑条件后，我们不难发现 \(n\) 多余了，而 \(x\) 所在的原位置留空了。 但是，我们不可以直接将 \(x\) 的位置放上 \(n\)，因为我们需要考虑下面的两个条件： \(p_x = n =&gt; n \% x\)； 字典序最小 对于条件 \(1\)，若不满足，输出 \(NO\) 即可。 对于条件 \(2\)，我们不难发现，当 \(n\) 的因数比较多的时候，满足 \(n \% kx\) 的 \(k\) 可以有好多个，此时若 \(x\) 位置放上 \(n\)，所得到的字典序不一定是最小的。 我们来举一个例子： 1 12 2 此时，字典序最小的应为下述输出： 2 4 3 12 5 6 7 8 9 10 11 1 因此，我们不妨循环操作，对于 \(x\)，找出第一个满足 \(n \% kx, k \geq 2\) 的 \(k\)，将 \(p_i\) 修改为 \(kx\)、\(x\) 的值替换为 \(kx\) ，然后继续循环，直到 \(x \geq x\)。 时间复杂度：不知道 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n, x; cin >> n >> x; if(n % x != 0) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; vector&lt;int> ans(n); for(int i=1;i&lt;n-1;i++) ans[i] = i + 1; ans[n - 1] = 1; ans[0] = x; while(x &lt; n)&#123; for(int i=x*2;i&lt;=n;i+=x) &#123; if(n % i == 0)&#123; ans[x - 1] = i; x = i; break; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 一开始还真想着去直接交换了（ D. Range = √Sum 题意 给定一个整数 \(n\)，构建一个无重复元素的数组 \(a\)，满足 \(1 \leq a_i \leq 10 ^ 9\)，以及下面的式子： \(\max(a_1, a_2, \dots, a_n) - \min(a_1, a_2, \dots, a_n)= \sqrt{a_1 + a_2 + \dots + a_n}\)。 思路 我们来讨论 \(n\) 的奇偶性： 当 \(n\) 为偶数的时候，我们只需构建一个 \([n / 2, n / 2 + 1, \ldots, n - 1, n + 1, n + 2, \ldots, 3n / 2]\) 即可。 当 \(n\) 为奇数的时候，我们按照上述逻辑构建一个中间值为 \(n\)，向两端递减 \(1\) 的数组，此时，左边为 \(n\)，右边为 \(\sqrt {n (n + 1)}\)。 那么，我们希望构建一个数组，满足左右两边均为 \(n + 1\)。 我们执行下面的操作： ① 整个数组 \(+1\)； ② 左边界 \(-1\)，右边界 \(+1\)； ③ 倒数第二个数 \(+1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; if(n % 2 == 0) &#123; for(int i=n/2;i&lt;=n-1;i++) cout &lt;&lt; i &lt;&lt; ' '; for(int i=n+1;i&lt;=3*n/2;i++) cout &lt;&lt; i &lt;&lt; ' '; &#125; else &#123; vector&lt;int> ans(n); iota(ans.begin(), ans.end(), (n + 5) / 2); ans[0]--; ans[n - 1]++; ans[n - 2]++; for (int i = 0; i &lt; n; i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; return 0; &#125; 好一个思维 + 构造]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Polynomial Round 2022 Div 1 plus 2</title>
    <url>/blog/posts/266401019/</url>
    <content><![CDATA[Practice. 代码略去了快读模板 A. Add Plus Minus Sign 题意 给定一个长度为 \(n\) 的二进制字符串，输出 \(n-1\) 个加减运算符，满足最后的结果的绝对值最小。 思路 无视第一位，配对 \(1,1\)，对每一对输出 \(-,+\)，剩余的 \(1\) 输出 \(-\)，剩余的 \(0\) 输出任意符号。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; int n = console.nextInt(); char[] input = console.next().toCharArray(); int pre = -1, now = input[0] - '0'; char[] ans = new char[n - 1]; if(now == 1) pre = -2; for(int i=0;i&lt;n-1;i++)&#123; now = input[i + 1] - '0'; if(now == 0) ans[i] = '+'; else&#123; if(pre == -1) pre = i; else&#123; if(pre != -2) ans[pre] = '+'; ans[i] = '-'; pre = -1; &#125; &#125; &#125; if(pre != -1 &amp;&amp; pre != -2) ans[pre] = '+'; console.println(String.valueOf(ans)); &#125; console.close(); &#125; &#125; 略微简单的打卡题 B. Coloring 题意 给定 \(m\) 种颜色的数量，总量为 \(n\)，将长度为 \(n\) 的序列染上色，满足所有长度为 \(k\) 的连续子序列内没有相同的颜色，输出方案是否存在。 思路 我们不妨开一个数组记录所有的数量，然后降序排序。 显然，若一个颜色 \(p\) 在 \(x\) 位置出现了，那么在 \([x + 1, x + k - 1]\) 内都不能出现 \(p\)，那么我们不妨将序列按 \(k\) 分段，那么段数即为 \(d = \lceil \frac{n}{k} \rceil\)。 遍历排序后的数组，若 \(a_i &gt; d\)，那么就是无解的，输出 \(NO\) 即可，否则，我们只需将剩余的最少的颜色取出来和它一起配对为一个长为 \(d\) 的组合。 当然，配对次数过多时，我们会发现段数会减少 \(1\)，此时若能满足条件，就可以直接输出 \(YES\) 了。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; int n = console.nextInt(), m = console.nextInt(), k = console.nextInt(); Integer[] a = new Integer[m]; for(int i=0;i&lt;m;i++) a[i] = console.nextInt(); Arrays.sort(a, Comparator.comparingInt(o -> -o)); int d = n / k + (n % k == 0 ? 0 : 1), l = n % k; boolean ans = true; for(int i=0;i&lt;n;i++)&#123; int cur = a[i]; if(cur > d) &#123; ans = false; break; &#125; if(l == 0) break; l --; if(l == 0) d --; &#125; console.println(ans ? "YES" : "NO"); &#125; console.close(); &#125; &#125; 有点小贪心，因为不用考虑拿什么出来组合 C. Ice and Fire 题意 对于 \(n\) 个选手，选手 \(i\) 的能力值为 \(i\)。给定一个长为 \(n - 1\) 的二进制字符串 \(s\)，\(s_i\) 表示第 \(i\) 次比赛的输赢判定，\(0\) 则能力值低者胜，否则高者胜。对于所有 \(x \in [2,n]\)，输出选择不超过 \(x\) 个选手进行比赛，最后有多少个选手有机会成为胜者。 比赛机制为选择任意两个选手进行比赛，直至剩余最后一人，判定该选手为胜者。 思路 显然地，最后的获胜情况和最后一个输赢判定有直接关系。 更进一步地说，最后一段相同连续区间的长度决定了胜者的数量。 举一个例子，若 \(s\) 为 \(\ldots,1,0,0,0,0\)，那么能力值最大的三个选手一定不可能成为赢家，而恰好剩余的选手经过一定的排序都可以成为赢家。 因而，我们唯一关心的就是从后往前第一个不同的字符出现的位置，对于所有 \(x\)，输出数量即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; int n = console.nextInt(); char[] in = console.next().toCharArray(); int p0 = 1, p1 = 1; for(int i=1;i&lt;n;i++)&#123; int now = in[i - 1] - '0'; if(now == 0)&#123; p0 = i + 1; console.print(p1 + " "); &#125;else&#123; p1 = i + 1; console.print(p0 + " "); &#125; &#125; console.println(); &#125; console.close(); &#125; &#125; 想通了就很简单的思维题]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 139</title>
    <url>/blog/posts/1807504053/</url>
    <content><![CDATA[Practice. A. Extremely Round 题意 给定一个整数 \(n\)，输出 \([1,n]\) 内只有一位非 \(0\) 的数的个数。 思路 显然，对于 \(t\) 位，有 \(9\) 个满足要求的数，我们只需考虑到何时停下枚举即可。 时间复杂度：\(O(\log_{10} n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int a = n, tot = 0; while(a >= 10) a /= 10, tot ++; cout &lt;&lt; tot * 9 + a &lt;&lt; '\n'; &#125; return 0; &#125; 简单打卡题 B. Notepad# 题意 给定一个长为 \(n\) 且由小写字母构成的字符串，输出是否存在两段及以上长度大于等于 \(2\) 的相同连续子序列。 思路 我们不妨只寻找长为 \(2\) 的重复子串，也就是说我们只需记录 \(n - 1\) 对子序列的情况。我们可以边记录边向后遍历，并判断当前字母以及前一个字母是否在之前被记录过，若记录过则输出存在即可。 此处我们需要排除如下情况：\(hhh\)，此处不满足题意但会被误判为 \(YES\)，因而我们可以记录该子串在当前状态之前最近被统计的位置，然后判断位置是否和当前位置出现了交集即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 30; int a[N][N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; string cur; cin >> cur; cur = ' ' + cur; memset(a, 0, sizeof a); bool ok = false; for(int i=1;i&lt;n;i++)&#123; int o1 = cur[i] - 'a', o2 = cur[i + 1] - 'a'; if(a[o1][o2] != 0 &amp;&amp; a[o1][o2] != i - 1) &#123; ok = true; break; &#125; if(a[o1][o2] == 0) a[o1][o2] = i; &#125; cout &lt;&lt; (ok ? "YES" : "NO") &lt;&lt; '\n'; &#125; return 0; &#125; WA了好几遍捏 C. Hamiltonian Wall 题意 给定一个长为 \(n\)，宽为 \(2\) 的矩阵，矩阵元素为 \(B\) 或 \(W\)，输出是否可以从最左边列的某个元素 \(B\) 开始一笔画，在不重复经过同一个元素以及不经过元素 \(W\) 的前提下连接所有元素 \(B\)。不可以沿对角线连接。 思路 我们可以直接模拟，判断前者的入口在何处，若出现冲突就直接输出 \(NO\)。 具体按照下面的方法模拟： 找出第一个不是 \(BB\) 的列； 将入口更新为 \(B\) 出现的位置； 若相邻出现 \(WB,BW\) 或 \(BW,WB\)，输出 \(NO\); 若出现多个 \(BB\)，根据奇偶性判断之后的入口； 遇到 \(WW\) 直接输出 \(NO\)。 无冲突输出 \(YES\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; bool a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; char c; cin >> t; while(t --)&#123; cin >> n; for(int i=0;i&lt;n;i++)&#123; cin >> c; a[i] = c == 'B'; &#125; bool f = false, ans = true; int pre; cin >> c; if(a[0] &amp;&amp; c == 'B') pre = 2, f = true; else if(a[0]) pre = 0; else if(c == 'B') pre = 1; else pre = -1; for(int i=1;i&lt;n;i++)&#123; cin >> c; if(!ans) continue; int now; if(a[i] &amp;&amp; c == 'B') now = 2; else if(a[i]) now = 0; else if(c == 'B') now = 1; else now = -1; if(f &amp;&amp; now == 2) continue; f = false; if((pre == -1 &amp;&amp; now != -1) || (pre == 0 &amp;&amp; now == 1) || (pre == 1 &amp;&amp; now == 0))&#123; ans = false; continue; &#125; if(now == 2) now = 1 - pre; pre = now; &#125; cout &lt;&lt; (ans ? "YES" : "NO") &lt;&lt; '\n'; &#125; return 0; &#125; 太模拟了，不过貌似一笔画不止可以暴力模拟（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 852 Div 2</title>
    <url>/blog/posts/185684192/</url>
    <content><![CDATA[Contestant(alt). Rank 6738. Rating -86 (+414 -500). A. Yet Another Promotion 题意 定义两天内提供购物服务，每天的货物价格分别为 \(a, b\)，在第一天存在促销活动，购买 \(m\) 个货物后会赠送一个。输出购买 \(n\) 个货物的最少花费。 思路 对于 \(m+1\) 个所需货物，$m a $ 和 \((m + 1) \times b\) 分别为第一天和第二天的价格，那么我们只需分类讨论即可： 前者小，那么我们将能参与促销的货物全都在第一天购买，也就是总共有 \(\lfloor \frac{n}{m + 1} \rfloor \times m\) 个货物是参与了促销。此时，我们得到了 \(\lfloor \frac{n}{m + 1} \rfloor \times (m + 1)\) 个货物，那么剩余的货物就作为正常购买，我们用 \(\min(a,b)\) 购买即可； 后者小，直接全都在第二天买即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a, b, n, m; cin >> a >> b >> n >> m; cout &lt;&lt; min(n * b, (n / (m + 1)) * m * a + (n - (n / (m + 1)) * (m + 1)) * min(a, b)) &lt;&lt; '\n'; &#125; return 0; &#125; 一个大铸币没看懂题卡了半天 B. Fedya and Array 题意 给出如下定义： 若一个元素的相邻元素都比它大，那么定义其为 local minimum；若一个元素的相邻元素都比它小，那么定义其为 local maximum。 给定一个首尾相连的序列中 local maximum 的总和和 local minimum 的总和 \(x, y\)，构建该序列，满足相邻数相差 \(1\)，且长度最短。 思路 显然，\(y, y-1, \ldots , x , x + 1 , \ldots, y - 1\) 一定是一个符合条件的序列，下面我们来证明一下可行性： 若 \(a_i\) 和 \(b_i\) 为相邻的 local maximum 和 local minimum ，那么对于 \(a_i\)，想要得到 \(b_i\)，就必须得有 \(a_i - b_i\) 个数字，因而我们可以得到下面的式子： \(len = (a_1 - b_1) + (a_2 - b_1) + (a_2 - b_2) + \ldots + (a_k - b_k) + (a_1 - b_k)\) 化简即可得到 \(2(x - y)\)，证毕。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(0); int t, x, y; cin >> t; while(t --)&#123; cin >> x >> y; vector&lt;int> ans; for(int i=x;i>y;i--) ans.emplace_back(i); for(int i=y;i&lt;x;i++) ans.emplace_back(i); cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto &amp;i : ans) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; return 0; &#125; 好妙的做法 C. Dora and Search 题意 给定一个排列，输出一段连续区间的左右端点的下标，满足两个端点既不是区间内的最大值，也不是区间内的最小值。 思路 我们可以用类似双指针的方法，从两侧开始夹逼，只要去除区间外的点后，最大值和最小值都不在端点，那就直接输出。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(0); int t, n; cin >> t; while(t --)&#123; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; int l = 0, r = n - 1, vl = 1, vr = n; while(l &lt;= r)&#123; if(a[l] == vl) l ++, vl ++; else if(a[l] == vr) l ++, vr --; else if(a[r] == vl) r --, vl ++; else if(a[r] == vr) r --, vr --; else break; &#125; if(l &lt;= r) cout &lt;&lt; l + 1 &lt;&lt; ' ' &lt;&lt; r + 1 &lt;&lt; '\n'; else cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; return 0; &#125; 不是排列的话就只有找拐点了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 851 Div 2</title>
    <url>/blog/posts/989416061/</url>
    <content><![CDATA[Contestant. Rank 2650. Rating +7. A. One and Two 题意 给定一个包含 \(1\) 和 \(2\) 的数组，输出最小的 \(k\)，满足 \(a_1 \cdot a_2 \cdot \ldots \cdot a_k = a_{k+1} \cdot a_{k+2} \cdot \ldots \cdot a_n\)。 思路 维护一个后缀和，统计前面和后面的 \(2\) 的个数，输出第一个 \(k\)，满足 \(2\) 的个数一致。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; int a[N], suf[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; memset(a, 0, sizeof a); memset(suf, 0, sizeof suf); for(int i=1;i&lt;=n;i++)cin >> a[i]; for(int i=n;i>=1;i--) &#123; suf[i] = suf[i + 1]; if(a[i] == 2) suf[i] ++; &#125; int tot = 0; bool f = true; for(int i=1;i&lt;n;i++)&#123; if(a[i] == 2) tot ++; if(tot == suf[i + 1])&#123; cout &lt;&lt; i &lt;&lt; '\n'; f = false; break; &#125; &#125; if(f) cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; return 0; &#125; 你一个大铸币是怎么会想着纯模拟的啊（（ B. Sum of Two Numbers 题意 给定一个整数 \(n\)，定义 \(f(x) = x十进制下每位之和\)，输出任意两个数 \(x,y\)，满足 \(x + y = n, |f(x)-f(y)| \leq 1\)。 思路1 我们不妨除以 \(2\)，此时，若 \(n\) 为偶数，直接输出。 若 \(n\) 为奇数，则不可避免会出现十位不相同的情况（进位了）。此时，我们不妨遍历所有 \(i\)，将大的数减 \(5\)，小的数加 \(5\)，那么最后一定可以找到一组满足条件的数。 对上述思路的证明 我们令除 \(2\) 之后较小的数为 \(a\)，较大的数为 \(b\)。 首先，我们只需考虑 \(n\) 的个位为 \(9\) ，且十位为奇数的情况，此时 \(a+1\) 存在向前进位。那么，我们希望能尽量让 \(a\) 的高位总和降低，并让 \(b\) 的高位总和提高。 考虑到个位为 \(9\)，那么我们不妨先让 \(a\) 和 \(b\) 的个位分别变为 \(4\) 和 \(5\)，这样我们只需让高位的所有数之和相等，或者 \(a\) 的高位之和比 \(b\) 的高位之和大 \(1\)。 那么，我们来考虑高位的情况： 若 \(n\) 的十位小于 \(9\)，不难发现，我们只需让 \(a\) 的十位变为 \(b\) 的十位加一，这样可以让 \(a,b\) 的所有位之和相等，也就是说，只要输出 \(a+5,b-5\) 即可； 若 \(n\) 的十位为 \(9\)，那么事态发生了微妙的变化：存在进 \(2\) 位的情况了。但，只要百位不是奇数，我们依然可以按照情况 \(1\) 找出一个答案； 若 \(n\) 的十位为 \(9\)，百位为奇数，且千位不为 \(9\) 时，那么按照上述操作后，\(a+5\) 存在进 \(1\) 位的情况，方案不成立了； 此时，有趣的现象出现了：\(a+5\) 和 \(b-5\) 恰好差了 \(9\)，那么我们不妨把个位改为 \(9, 0\)，此时，我们可以构造出 \(a+10,b-10\)，满足差值为 \(1\)； 当千位、乃至更高位都为 \(9\) 时，差值会更大，但根据打表我们不难发现，\(a+5\) 和 \(b-5\) 的差值均为 \(9\) 的倍数，那么我们只要让高位的差值降低，最后一定能得到解。 时间复杂度：懒得分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; int a[N], suf[N]; int cal(int x)&#123; int res = 0; while(x > 0)&#123; res += x % 10; x /= 10; &#125; return res; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; int p = n / 2, q = n - p; while(abs(cal(p) - cal(q)) > 1) p += 5, q -= 5; cout &lt;&lt; p &lt;&lt; ' ' &lt;&lt; q &lt;&lt; '\n'; &#125; return 0; &#125; 思路2 按照上述证明的思路，我们可以找出一个规律： 首先，偶数直接输出 \(\frac{n}{2},\frac{n}{2}\)； 其次，个位不是 \(9\)，直接输出 \(\frac{n}{2},n-\frac{n}{2}\)； 否则，从证明思路，我们可以发现，以 \(10\) 为单位枚举从 \(9\) 开始的所有数，需要加减 \(5\) 的次数每隔 \(20,200,2000 \ldots\) 会变为一个特定值，该值我们可以打表找出，记该数组为 \(ans\)。 因此，对于该情况，我们只需从低位向高位枚举，找出第一个不是 \(9\) 的位置 \(cnt\)，以及该位置的数 \(val\)。若 \(val\) 为偶数，那么加减 \(ans[cnt-1] \times 5\)，否则加减 \(ans[cnt] \times 5\)。 时间复杂度：\(O(\log_{10} n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; int ans[10] = &#123;0, 1, 2, 10, 18, 100, 180, 1000, 1800, 10000&#125;; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; if(n % 2 == 0) cout &lt;&lt; n / 2 &lt;&lt; ' ' &lt;&lt; n / 2 &lt;&lt; '\n'; else if(n % 10 != 9) cout &lt;&lt; n / 2 &lt;&lt; ' ' &lt;&lt; n - n /2 &lt;&lt; '\n'; else&#123; int p = n / 2, q = n - p; int cnt = 0; while(n % 10 == 9) n /= 10, cnt ++; int val = n % 10; if(val == 0) val = 9, cnt --; if(val % 2 == 0) cout &lt;&lt; p + ans[cnt - 1] * 5 &lt;&lt; ' ' &lt;&lt; q - ans[cnt - 1] * 5 &lt;&lt; '\n'; else cout &lt;&lt; p + ans[cnt] * 5 &lt;&lt; ' ' &lt;&lt; q - ans[cnt] * 5 &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 我好蠢 C. Matching Numbers 题意 给定一个整数 \(n\)，配对 \(1,2n\) 内的所有数，使 \(n\) 对数的和按照升序排列后单调递增，且相邻数相差 \(1\)。输出一种配对。 思路 我们不难发现，若是偶数的话，我们是找不出这个序列的，可以通过计算验证。 对于奇数的话，我们可以根据等差公式算出中间的值 \(2n+1\)，而对于右边的数，我们不妨将小的数加上 \(2\)，大的数减去 \(1\)，这样就可以满足差值为 \(1\)，那么，如果中间的那对数为 \(1,2n\)，那么刚好右边可以组成 \(\frac{n}{2}\) 对，而剩下的数，我们恰好可以得到两对连续的数字，将小的和大的相加，恰好就是我们想要的。 输出即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; int a[N], suf[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; if(n % 2 == 0) cout &lt;&lt; "No\n"; else&#123; cout &lt;&lt; "YES\n"; for(int i=1;i&lt;=n/2+1;i++)&#123; cout &lt;&lt; i * 2 - 1 &lt;&lt; ' ' &lt;&lt; 2 * n - i + 1 &lt;&lt; '\n'; &#125; for(int i=1;i&lt;=n/2;i++)&#123; cout &lt;&lt; i * 2 &lt;&lt; ' ' &lt;&lt; 2 * n - i - n / 2 &lt;&lt; '\n'; &#125; &#125; &#125; return 0; &#125; md，思路很清晰但wa了一发 D. Moving Dots 题意 给定 \(n\) 个数轴上升序排序的点，所有点在同一时刻以相同的速度向与相邻数差值最小的数的方向移动（若差值相同，向左移动），两点相遇则停止移动。对于所有可不连续的子序列，统计每个子序列最后汇聚的点的个数，并输出总数。 思路 我们将问题转化为：对于所有 \([i,j]\) 内让点汇聚到两个及以上点的区间，排除这个区间内的所有数，剩下的数一定会汇聚到一个点，那么对于每个点，有选与不选两种情况，因此最后输出 \(2^p\)，\(p\) 为剩余的数的数量。 那么，对于这个区间的确定，我们不妨来考虑下面的两种情况： 对于汇聚到左边的点，最左边的点 \(i\) 应该向右边移动，那么我们找出从 \(i\) 开始，往前找第一个向左移动的即可，也就是说，应满足 \(k &lt; x_i, x_i - k \leq x_j - x_i\)。 同理，满足 \(k &gt; x_j,k - x_j &lt; x_j - x_i\)。 综上，\(2x_i - x_j \leq k &lt; 2x_j - x_i\)。 考虑到单调性，我们可以用二分查找。 时间复杂度：\(O(n^2 \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 3010; int x[N], pows[N], mod = 1e9 + 7; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin >> n; pows[0] = 1; for(int i=1;i&lt;=n;i++) &#123; //Awesome but strange solution from the official tutorial. cin >> x[i]; pows[i] = (pows[i - 1] * 2) % mod; &#125; int ans = 0; for(int i=1;i&lt;n;i++) for(int j=i+1;j&lt;=n;j++) &#123; int l = lower_bound(x + 1, x + n + 1, 2 * x[i] - x[j]) - (x + 1), r = lower_bound(x + j + 1, x + n + 1, 2 * x[j] - x[i]) - x; ans = (ans + pows[n - r + l + 1]) % mod; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0; &#125; 妙啊]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 140</title>
    <url>/blog/posts/1562475734/</url>
    <content><![CDATA[Practice. A. Cut the Triangle 题意 给定三个点，判断是否存在水平或数值的切割线，能将三个点所构成的三角形切割成两个三角形。 思路 很显然，我们只需判断是否存在直角三角形即可。 因为我们不知道哪个是直角，所以我们不妨找出所有 \(x\) 轴值相等的点和 \(y\) 轴相等的点。 更具体地说，我们统计一下满足上述条件的点，若为 \(1\) 个及以下，那么就可行，否则不可行。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 110; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int x1, y1, x2, y2, x3, y3; cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3; cout &lt;&lt; ((x1 == x2 || x2 == x3 || x1 == x3) &amp;&amp; (y1 == y2 || y2 == y3 || y1 == y3) ? "NO" : "YES") &lt;&lt; '\n'; &#125; return 0; &#125; 简简单单打卡题 B. Block Towers 题意 给定 \(n\) 个柱子，定义操作为选定两个大小不相等的柱子，并将大的柱子的一个方块移到小的柱子上。在任意次操作后，输出第一个柱子可能的最大方块数量。 思路 我们不妨直接排个序，然后找出第一个柱子的位置，并模拟。 当然，找位置可以用二分。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; int a0 = a[0]; sort(a, a + n); int t = upper_bound(a, a + n, a0) - a; for(int i=t;i&lt;n;i++)&#123; if(a[i] > a0) a0 += (a[i] - a0 + 1) / 2; &#125; cout &lt;&lt; a0 &lt;&lt; '\n'; &#125; return 0; &#125; 好模拟 C. Count Binary Strings 题意 给定一个数字 \(n\)，以及指定的约束，构造一个二进制字符串。 对于 \(n\) 行输入，第 \(i\) 行有 \(n - i + 1\) 个数字。 第 \(i\) 行第 \(j\) 列元素的值表示 \([i+j-1, n]\) 区间内容满足下面的约束： 值为 \(1\)，那么区间内所有元素必须一致； 值为 \(2\)，那么区间内至少存在一个数和其他数不同； 值为 \(0\)，无约束。 输出在上述约束下能构造多少个字符串。 思路 我们不难发现，要构造出不同的字符串，那么该位必须可以选 \(0\) 和 \(1\)。 又或者说，对于点 \(i\)，我们需要知道 \([1,i-1]\) 之间有多少和 \(i\) 不同的值。 考虑到前者的约束会影响后者，我们不妨考虑 \(dp\)。 我们可以枚举所有 \(i\)，与其不同的元素位于 \(j\)（当然，如果没有这个元素，\(j=0\) 即可），那么我们可以找出下面两种情况： 当前位和前一位相同，那么 \(dp[i+1][j]\ += dp[i][j]\)； 当前位和前一位不同，那么 \(dp[i+1][i]\ += dp[i][j]\)。 接下来，我们来考虑约束： 对于约束右区间为 \(i\)： 首先，对于情况 \(1\)，我们不能让 \(j\) 前面的约束存在 \(1\)，也不能让后面的约束存在 \(2\)，这样我们可以判断 \(dp[i][j]\) 是否可行，也可以判断 \(dp[i+1][j]\) 是否成立。 其次，对于情况 \(2\)，我们也不能让 \(i\) 之前的约束存在 \(1\)，否则 \(dp[i+1][i]\) 不成立。 满足上述条件后，对于递推的结果，枚举所有不同的点，右区间为 \(n\)，求和即可。 时间复杂度：\(O(n^3)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 110, mod = 998244353; int a[N][N], dp[N][N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin >> n; for(int i=0;i&lt;n;i++) for(int j=i;j&lt;n;j++) cin >> a[i][j]; if(a[0][0] != 2) dp[1][0] = 2; for(int i=1;i&lt;n;i++) for(int j=0;j&lt;i;j++)&#123; bool f = true; for(int k=0;k&lt;j;k++)&#123; if(a[k][i] == 1) f = false; &#125; for(int k=j;k&lt;=i;k++)&#123; if(a[k][i] == 2) f = false; &#125; if(f) dp[i + 1][j] = ((dp[i + 1][j] % mod) + (dp[i][j] % mod)) % mod; f = a[i][i] != 2; if(f) for(int k=0;k&lt;i;k++)&#123; if(a[k][i] == 1) f = false; &#125; if(f) dp[i + 1][i] = ((dp[i + 1][i] % mod) + (dp[i][j] % mod)) % mod; &#125; int ans = 0; for(int i=0;i&lt;n;i++) ans = (ans % mod + dp[n][i] % mod) % mod; cout &lt;&lt; ans; //好绕 return 0; &#125; 难死了，md D. Playoff 题意 给定一个整数 \(n\)，对于一个任意 \(2^n\) 的排列，存在 \(n\) 场比赛，\(2i\) 和 \(2i+1\) 进行比赛，满足下述比赛规则，获胜者进入下一轮，直到决出最后的胜利者。输出对于任意排列，胜利者会是哪些人。 规则：给定一个长度为 \(n\) 的二进制字符串，第 \(i\) 位决定了第 \(i\) 场比赛的输赢。若值为 \(0\) ，那么数值小的一方获胜，否则数值大的一方获胜。 思路 我们不妨先来找规律： 对于题例数据，我们不难发现，统计一下 \(1\) 的个数 \(x\) 和 \(0\) 的个数 \(y\)，答案即为 \([2^x,2^n-2^y+1]\) 内的所有数。 下面给出证明： 首先，我们不难发现，交换字符串某两位的位置，对最后两端的输赢是无影响的，只会决定最后的赢家； 并且，当值为 \(1\) 的时候，一定是大一点的值获胜，为 \(0\) 时一定时小一点的值获胜。 换句话说，决定了 \(1\) 和 \(0\) 的个数后，升序排序下两端一定范围内的值是一定不会取到的，因为在多场比赛后，一定会被筛去。 而正好相反地，除去这些一定会被筛去的值，剩余值一定有一种排列可以使它们成为赢家，因此证明了结论的正确性。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin >> n; int x = 0, y = 0; for(int i=0;i&lt;n;i++)&#123; char now; cin >> now; if(now == '1') x ++; else y ++; &#125; for(int i=(1 &lt;&lt; x);i&lt;=((1 &lt;&lt; n) - (1 &lt;&lt; y) + 1);i++) cout &lt;&lt; i &lt;&lt; ' '; return 0; &#125; 妥妥一个找规律（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 光棍新生欢乐赛</title>
    <url>/blog/posts/137870688/</url>
    <content><![CDATA[Rank 1. AC 4/9. 因为11.11为四根棍，所以注定只能写四题 A. 乘方 CSP 2022 T1 题意 比较 \(a ^ b\) 和 \(10 ^ 9\) 的大小关系。 思路1 try-catch 用大数算法直接算，如果算得出来，那就比较；算不出来，也就是溢出了，那么一定是大于 \(1e9\) 的，利用语言特性，捕获这个异常然后输出 \(-1\) 即可。 对应AC代码 import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); try&#123; BigInteger a = new BigInteger(scanner.next()); int b = scanner.nextInt(); BigInteger ans = a.pow(b); if(ans.compareTo(BigInteger.valueOf(1000000000L)) > 0) System.out.println(-1); else System.out.println(ans); &#125;catch(Throwable e)&#123; System.out.println(-1); //投机取巧.jpg &#125; &#125; &#125; 思路2 很简单，我们只需要循环 \(b\) 次把 \(a\) 乘上自己，判断一下是否大于 \(1e9\) 即可。 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(), b = scanner.nextInt(); long ans = 1L; for(int i=0;i&lt;b;i++) &#123; ans *= a; if(ans > 1000000000L) &#123; System.out.println(-1); return; &#125; &#125; System.out.println(ans); &#125; &#125; 对思路2的优化 可以使用快速幂降低时间复杂度。 注意：可能会爆long long，用大数解。 对应AC代码 import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); BigInteger weight = BigInteger.valueOf(scanner.nextLong()); int b = scanner.nextInt(); BigInteger ans = BigInteger.ONE; while(b > 0)&#123; if(b % 2 == 1) &#123; //二进制非递归快速幂 ans = ans.multiply(weight); if(ans.compareTo(BigInteger.valueOf(1000000000L)) > 0) &#123; System.out.println(-1); return; &#125; &#125; weight = weight.multiply(weight); //这里在测试点9会爆long b >>= 1; &#125; System.out.println(ans); &#125; &#125; 怎么能叫投机取巧呢（ B. 解密 CSP 2022 T2 题意 对于方程组 \(n = p q\) , \(ed = (p - 1) (q - 1) + 1\)，给定 \(n, d, e\)，解方程并输出 \(p, q\)。 思路 化简第二个式子得到 \(p + q = n - e d + 2\)，设其为 \(m\). 由第一个式子得到 \(p = \frac{n}{q}\). 由1和2，\(\frac{n}{q} + q = m =&gt; q ^ 2 - m q + n = 0\). 求 \(\Delta = m ^ 2 - 4 n\)，\(\Delta &lt; 0\) 即为无解的第一种情况. 运用求根公式求出 \(p, q\)，\(p\) 和 \(q\) 不为整数为无解的第二种情况，为整数就输出. 注意点： 肉眼可见会爆 \(int\)，用长整型. 不要用 \(java\)，会 \(tle\). 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; int main()&#123; int k; long long n, d, e; scanf("%d", &amp;k); for(int w=0;w&lt;k;w++)&#123; scanf("%lld %lld %lld", &amp;n, &amp;d, &amp;e); long long m = n + 2 - e * d; long long delta = m * m - 4 * n; if(delta &lt; 0) printf("NO\n"); else &#123; double p = (m - sqrt(delta)) / 2, q = (m + sqrt(delta)) / 2; if((int) p != p || (int) q != q) printf("NO\n"); else printf("%d %d\n", (int) p, (int) q); &#125; &#125; &#125; 简简单单数学题 C. 报数 NOIP 2021 提高组 题意 某数字为 \(x\) 的倍数， \(x\) 的特点是至少有一位有 \(7\) (与 \(7\) 相关)，则该数字不能被报出。 报到与 \(7\) 相关的数，输出 \(-1\)，否则输出下一个非 \(7\) 相关的数。 思路 做一个类似于埃氏筛的预处理。 我们用类似于埃氏筛的思路，筛掉与 \(7\) 相关的数的倍数。 开一个数组，记录下一个非 \(7\) 相关的数，否则赋值为自己（或者可以是任意非正数）。 读它。 值得注意的是，\(1e7\) 后面第一个非 \(7\) 相关的数是 \(10000010\)，所以我们不妨开 \(1e7+11\) 大小的数组，防止溢出。 对应AC代码 import java.util.*; public class Main&#123; private static boolean relate(int x)&#123; //是否与7相关 while(x > 0)&#123; if(x % 10 == 7) return true; x /= 10; &#125; return false; &#125; private static int[] preTreat()&#123; int[] next = new int[10000011]; for(int i=1;i&lt;10000011;i++)&#123; if(next[i] == 0 &amp;&amp; relate(i))&#123; //类似于埃氏筛 for(int j=1;i*j&lt;10000011;j++) next[i * j] = 1; &#125; &#125; int last = 1; for(int i=2;i&lt;10000011;i++)&#123; if(next[i] == 0)&#123; next[last] = i; last = i; &#125; else next[i] = i; //反正只要后面可以特判就行 &#125; return next; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); int[] next = preTreat(); for(int w=0;w&lt;t;w++)&#123; int cur = scanner.nextInt(); System.out.println(next[cur] == cur ? -1 : next[cur]); &#125; &#125; &#125; 算是第一次接触数论了（ D. 逻辑表达式 CSP 2022 T3 题面 在编程语言中，存在逻辑表达式“短路”的现象，如：当判断 \(\&amp;\) 时，若前面为 \(false\)，那么后面的条件直接不判断了。 给定一个由 \(0\)、\(1\)、\(\&amp;\) 、 \(|\) 和括号组成的逻辑表达式，其中 \(1\) 和 \(0\) 分别表示真与假。输出表达式的结果，以及形如 \(a \&amp; b\) 和 \(a | b\) 的短路各出现了几次。 思路1 expr 可以用类似于求中缀表达式的值的思路来做。 中缀表达式转后缀表达式 建立表达式树 计算并统计 这个方法码量有点大，dfs有点深，只能上cpp了（ 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; struct Node&#123; int val, left, right; &#125;; int ansAnd = 0, ansOr = 0, nodeSize = 0; vector&lt;Node> nodes; //expr 中缀转后缀 vector&lt;int> toSuffix(const string&amp; mid) &#123; vector&lt;int> ex; stack&lt;char> ts; map&lt;char, int> pri; pri['&amp;'] = 4; pri['|'] = 3; pri['('] = 2; for (char each : mid) &#123; if (each == '@') &#123; while (!ts.empty()) ex.push_back(pri[ts.top()]), ts.pop(); break; &#125; else if (each >= '0' &amp;&amp; each &lt;= '9') ex.push_back(each - '0'); else &#123; if (each == '(') ts.push(each); else if (each == ')') &#123; while (ts.top() != '(') ex.push_back(pri[ts.top()]), ts.pop(); ts.pop(); //弹出左括号 &#125; else &#123; while (!ts.empty() &amp;&amp; pri[ts.top()] >= pri[each]) ex.push_back(pri[ts.top()]), ts.pop(); ts.push(each); &#125; &#125; &#125; return ex; &#125; //建表达式树 void build(const vector&lt;int>&amp; suffix)&#123; stack&lt;int> index; for(int each : suffix)&#123; if(each == 0 || each == 1)&#123; nodes.push_back(&#123;each, -1, -1&#125;); index.push(nodeSize ++); &#125;else&#123; int r = index.top(); index.pop(); int l = index.top(); index.pop(); nodes.push_back(&#123;each, l, r&#125;); index.push(nodeSize ++); &#125; &#125; &#125; int dfs(int index) &#123; if (nodes[index].val == 0 || nodes[index].val == 1) return nodes[index].val; int l = dfs(nodes[index].left); if (l == 0 &amp;&amp; nodes[index].val == 4) &#123; ansAnd++; return 0; &#125; if (l == 1 &amp;&amp; nodes[index].val == 3) &#123; ansOr++; return 1; &#125; return dfs(nodes[index].right); //既然不断路，那么值一定只和右边的值有关 &#125; int main() &#123; string mid; cin >> mid; mid += "@"; build(toSuffix(mid)); printf("%d\n", dfs(nodeSize - 1)); printf("%d %d\n", ansAnd, ansOr); &#125; 思路2 分治 对于一个表达式，我们会先去找没有括号的优先级最高的符号，然后计算左右两边的值，这便是中缀表达式的直观求法。 由 \(1\) 所述，我们可以将表达式分层，并从优先级最高的那个符号开始左右分治求解，同时特判左边的值即可。 显然，我们不可能在每次求左右表达式的时候都遍历一遍字符串找符号，这肯定会 \(tle\)。于是乎，我们需要一个预处理，将当前位置之前该层最近的符号找出并记录它的下标。这样我们只要每次读取一下记录的下标是否在区间内即可。 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; int nowAnd[1000010], nowOr[1000010], lastAnd[1000010], lastOr[1000010]; string mid; int ansAnd, ansOr; int dc(int l, int r) &#123; if (nowOr[r] >= l) &#123; //or的优先级更高 int left = dc(l, nowOr[r] - 1); if (left == 1) &#123; ansOr++; return 1; &#125; return left | dc(nowOr[r] + 1, r); &#125; else if (nowAnd[r] >= l) &#123; int left = dc(l, nowAnd[r] - 1); if (left == 0) &#123; ansAnd++; return 0; &#125; return left &amp; dc(nowAnd[r] + 1, r); &#125; else if (mid[l] == '(' &amp;&amp; mid[r] == ')') return dc(l + 1, r - 1); return mid[l] - '0'; &#125; int main() &#123; cin >> mid; int n = mid.size(), layer = 0; mid = " " + mid; for (int i = 1; i &lt; n + 1; i++) &#123; //预处理 switch (mid[i]) &#123; case '(': layer++; break; case ')': layer--; break; case '|': lastOr[layer] = i; break; case '&amp;': lastAnd[layer] = i; break; &#125; nowAnd[i] = lastAnd[layer]; nowOr[i] = lastOr[layer]; &#125; printf("%d\n", dc(1, n)); printf("%d %d\n", ansAnd, ansOr); &#125; 怎么比赛里面还有码农题（ E. 音量调节 HAOI 2012 题意 给定一个初始值 \(beginLevel\) 以及最大值 \(maxLevel\)，对于一个数组 \(c\)，在第 \(i\) 次操作时，可选择将当前的值加上或减去 \(c_i\)，或不操作。输出最后的最大值。 思路 一眼丁真，鉴定为 分组背包 不会做的去看背包九讲 题目特点：每个 \(c\) 都要选上，可以 \(+c\) 可以 \(-c\)，有范围限定。 分组：分成 \(c\) 组，每组为 \(c\) 和 \(-c\)。 我们可以用 \(boolean\) 类型的 \(dp\) 数组存储当前音量能否达到，对此，有如下状态转移方程: \(dp[i][v] = dp[i][v] || dp[i - 1][v ± c]\) 套模板即可。 对应AC代码 import java.util.*; //快乐分组背包呀 public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int N = scanner.nextInt(), begin = scanner.nextInt(), V = scanner.nextInt(); boolean[][] dp = new boolean[N + 1][V + 1]; dp[0][begin] = true; for(int i=1;i&lt;=N;i++)&#123; int c = scanner.nextInt(); for(int v = V;v>=0;v--)&#123; if(v - c >= 0) dp[i][v] |= dp[i - 1][v - c]; if(v + c &lt;= V) dp[i][v] |= dp[i - 1][v + c]; &#125; &#125; for(int v=V;v>=0;v--) if(dp[N][v])&#123; System.out.println(v); return; &#125; System.out.println(-1); &#125; &#125; 略微变化了一下的分组背包 F. 上升点列 CSP 2022 T4 题意 给定 \(n\) 个点坐标，可添加 \(k\) 个任意坐标，求出最长单调欧几里得距离序列。 思路 这道题如果联想到最长上升子序列就迎刃而解了。 用二维dp做，前 \(i\) 个点插入 \(j\) 个点的最长长度。 观察欧几里得距离可发现，若要使i~j序列可取，那么需要加上 \(d\) 个点， \(d = xi - xj + yi - yj + 1\)。 类似于最长上升子序列，得到状态转移方程： $dp[i][p] = max(dp[i][p], dp[j][p - d] + d + 1), p∈[d, k] $。 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), k = scanner.nextInt(); int[][] data = new int[n + 1][2]; for(int i=1;i&lt;=n;i++) &#123; data[i][0] = scanner.nextInt(); data[i][1] = scanner.nextInt(); &#125; Arrays.sort(data, 1, n + 1, (o1, o2) -> o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0]); int[][] dp = new int[n + 1][k + 1]; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=k;j++) dp[i][j] = j + 1; //差了j个那就塞上j个 for(int i=2;i&lt;=n;i++)&#123; for(int j=i-1;j>=1;j--)&#123; //i状态由j状态推得 if(data[j][1] > data[i][1]) continue; //因为i状态由j状态推得，所以需要至少d个点才能满足欧几里得距离 int d = data[i][0] - data[j][0] + data[i][1] - data[j][1] - 1; for(int p=d;p&lt;=k;p++) dp[i][p] = Math.max(dp[i][p], dp[j][p - d] + d + 1); //最长上升子序列模板 &#125; &#125; int ans = 0; for(int i=1;i&lt;=n;i++) ans = Math.max(ans, dp[i][k]); System.out.println(ans); &#125; &#125; 想不到就废了（悲 G. 星球大战 JSOI 2008 题意 给定一个无向图，输出断开指定边后图中联通块的数量。 思路 首先是建立无向图，可以使用邻接表的方式存储。 标记这些需要断开的边，然后依次遍历各个边，若端点的根节点一样，那么就处于同一个连通块了。 因为至少存在 \(n\) 条边，那么连通块最多为 \(n-k\) 个。 综合 \(2\) 和 \(3\) 可知，答案即为 \(n - k - cnt\)，其中 \(cnt\) 为满足 \(2\) 条件的个数。 至于要输出每次打击后的值，我们可以逆向思维，将最后的状态还原到最初状态即可。 优化 我们可以使用并查集算法来优化。 没有解释地很清楚哈，还是有点难写的 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; typedef struct&#123; int a, b; //两点 int to; &#125;Edge; int parent[400010]; Edge edges[400010]; int tot = 0; int head[400010], broken[400010], ans[400010]; bool visited[400010]; //并查集查询，返回父节点id并将child全设为父节点直属下司( int findParent(int child) &#123; int ground = child, father = child; while (father != parent[father]) father = parent[father]; //更新father while (ground != parent[ground]) &#123; int tmp = ground; ground = parent[ground]; parent[tmp] = father; &#125; return father; &#125; //联通两个子树的爸爸即可(把一个爸爸设为另一个爸爸的直属下司 void unionIt(int x, int y) &#123; parent[findParent(x)] = findParent(y); &#125; void addEdge(int a, int b)&#123; edges[++tot].a = a; edges[tot].b = b; edges[tot].to = head[a]; head[a] = tot; &#125; int main() &#123; int n, m, u, v, k; long long w; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) parent[i] = i; //初始化并查集，我是我爸爸 for (int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; scanf("%d", &amp;k); for(int i=1;i&lt;=k;i++)&#123; scanf("%d", &amp;broken[i]); visited[broken[i]] = true; &#125; int united = n - k; for (int i = 0; i &lt; 2 * m; i++) &#123; if (!visited[edges[i].a] &amp;&amp; !visited[edges[i].b] &amp;&amp; findParent(edges[i].a) != findParent(edges[i].b)) &#123;//爸爸不一样，由union函数的写法可以看出俩玩意儿没联通 united --; unionIt(edges[i].a, edges[i].b); &#125; &#125; ans[k + 1] = united; for(int i=k;i>=1;i--)&#123; int x = broken[i]; visited[x] = false; united ++; for (int j = head[x]; j != 0; j = edges[j].to) &#123; int nowB = edges[j].b; if(!visited[nowB] &amp;&amp; findParent(x) != findParent(nowB))&#123; united --; unionIt(x, nowB); &#125; &#125; ans[i] = united; &#125; for(int i=1;i&lt;=k+1;i++) printf("%d\n", ans[i]); &#125; 反着想有时候会更简单 H. 虚拟内存 HNOI 2005 题意 设计一个程序完成题面所指的算法。 太模拟了，建议看原题（ 思路 一道逻辑很清楚但是不好写的模拟题。 我们很明显能发现，不可以 \(O(mn)\)，会寄，想想有序性，不难发现可以用优先队列。 我们需要存一下当前某一页的状态，方便找空页，我们可以用 \(map\)。 模拟 如果使用HashMap，对于某些如java的语言需要重写一下类的hashCode()和equals()方法，不然会像我一样WA。 当然，最好用cpp写，其他语言容易卡到tle和mle 对应AC代码 import java.util.*; public class Main&#123; private static class Page&#123; int id, cnt, time; Page(int id, int cnt, int time) &#123; this.id = id; this.cnt = cnt; this.time = time; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; Page page; //java版本低，用ide自动生成的还得改改（（（ if (!(o instanceof Page)) return false; page = (Page) o; return id == page.id &amp;&amp; cnt == page.cnt &amp;&amp; time == page.time; &#125; @Override public int hashCode() &#123; return Objects.hash(id, cnt, time); &#125; &#125; private static class Pair&lt;A, B>&#123; A A; B B; Pair(A a, B b) &#123; A = a; B = b; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; Pair&lt;?, ?> pair; if (!(o instanceof Pair&lt;?, ?>)) return false; pair = (Pair&lt;?, ?>) o; return Objects.equals(A, pair.A) &amp;&amp; Objects.equals(B, pair.B); &#125; @Override public int hashCode() &#123; return Objects.hash(A, B); &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); //优先队列 int n = scanner.nextInt(), m = scanner.nextInt(); Map&lt;Integer, Pair&lt;Integer, Integer>> data = new HashMap&lt;>(); PriorityQueue&lt;Page> least = new PriorityQueue&lt;>(((o1, o2) -> o1.cnt == o2.cnt ? o1.time - o2.time : o1.cnt - o2.cnt)); int ans = 0; for (int i = 0; i &lt; m; i++) &#123; int query = scanner.nextInt(); if(data.containsKey(query))&#123; int cnt = data.get(query).A, time = data.get(query).B; least.remove(new Page(query, cnt, time)); least.offer(new Page(query, cnt + 1, time)); data.put(query, new Pair&lt;>(cnt + 1, time)); ans ++; &#125;else if(data.size() &lt; n)&#123; data.put(query, new Pair&lt;>(1, i)); least.offer(new Page(query, 1, i)); &#125;else&#123; Page page = least.poll(); data.remove(page.id); data.put(query, new Pair&lt;>(1, i)); least.offer(new Page(query, 1, i)); &#125; &#125; System.out.println(ans); &#125; &#125; 题目读半天... I. 泡泡堂 ZJOI 2008 题意 给定两个队的选手的实力，在分配最好和最坏的情况下，分别输出 \(ZJ\) 队的分数。 思路 田忌赛马 1. 田忌最快的马比齐王最快的马快，比之 2. 田忌最快的马比齐王最快的马慢，用田忌最慢的马跟齐王最快的马比 3. 田忌最快的马的速度与齐王最快的马速度相等 ①田忌最慢的比齐王最慢的快，比之。 ②田忌最慢的比齐王最慢的慢，田忌慢马 \(VS\) 齐王快马 ③田忌最慢的与齐王最慢的相等，田忌慢马 \(VS\) 齐王快马 不予证明。 更具体地说 维护双指针$ head$ 和 \(end\), 按上述思路写 对应AC代码 import java.util.*; public class Main&#123; //md，一个贪心想了我好久 private static long judge(int n, long[] a, long[] b)&#123; int score = 0; int headA = 0, headB = 0, endA = n - 1, endB = n - 1; //双指针？ while(headA &lt;= endA &amp;&amp; headB &lt;= endB)&#123; if(a[headA] > b[headB])&#123; score += 2; headA ++; headB ++; &#125;else if(a[endA] > b[endB])&#123; score += 2; endA --; endB --; &#125; else &#123; if(a[headA] == b[endB]) score ++; headA ++; endB --; &#125; &#125; return score; &#125; //我就猜一猜 public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); long[] zj = new long[n], sb = new long[n]; for(int i=0;i&lt;n;i++) zj[i] = scanner.nextLong(); for(int i=0;i&lt;n;i++) sb[i] = scanner.nextLong(); Arrays.sort(zj); Arrays.sort(sb); System.out.printf("%d %d\n", judge(n, zj, sb), 2L * n - judge(n, sb, zj)); //有个小技巧（（（ &#125; &#125; md，一个贪心想了我好久]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 第四场世纪大战 - 带佐的回家路</title>
    <url>/blog/posts/1494271354/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/contest/p/29?tid=635bad6e691055e12dce5282 题意 带佐在数轴上。\(0\) 时刻，带佐位于 \(0\) 处。在时刻 \(i−1\) 和 \(i\) 之间的时间段中，带佐要么待在当前位置，要么向左或向右跳 \(i\) 个单位长度。输出带佐最早在哪个时刻可以到达 \(X\)。 思路 首先，结论是：首项为 \(1\)，公差为 \(1\) 的等差数列的前 \(n\) 项和满足 \(S_n &gt; x\) 的最小 \(n\) 即为答案。 下面给出证明思路： 上述结论的做法是： 令 \(m = 满足条件的最小 n\)，\(t = Sm - x\)，则只需在 \(t\) 时刻停留即可保证最后一步恰好走到 \(x\)。 上述结论的合理性： ① 我们不可能折回，因为折回后如果直接返回，只能前进 \(1\)，代价大于在 \(t\) 时刻停留的代价（可以根据等差数列理解，列方程来严格证明），而停留后返回代价明显更大（停留需要很长时间，而折回后返回前进的距离远没有这么长）。 ② 我们不可以停留太久，显然停留一次比停留多次代价小。 因此，用一个 \(while\) 轻松解决。 值得注意的是，上述证明不严密。 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); long x = scanner.nextLong(), t = 0, i = 1; while(t &lt; x)&#123; t += i; i ++; &#125; System.out.println(i - 1); &#125; &#125; 暴力就完事了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 模拟 - Air Conditioner</title>
    <url>/blog/posts/3649205289/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/P1304C 空调凉凉~ 题意 一个餐馆中有个空调，给定空调的初始温度为 \(m\)，每分钟可以选择上调或下调 \(1\) 个单位的温度，或选择不变。 给定 \(n\) 个食客的到达时间 \(t_i\) 以及所能适应的温度范围 \([l_i, r_i]\)，每个食客只会在 \(t_i\) 时刻逗留。 如果温度不在食客的适应范围内，他就会不舒服。输出空调能否使得所有食客都感到舒服。 思路 当初第一反应是维护一个温度值，根据食客的需求改变温度。但这里存在问题：对于有限的操作，最后能落在温度区间的温度是不唯一的。如果是这样，很多种可能叠加，不难发现会超时。 也许我们可以贪心地认为只要满足最低条件即可，但我们不能保证下一个本因可行的区间可能被判为不可行（如一直递增的温度区间）。 单个值失败了，那就多个值呗。 我们只要维护一个区间，让每次所有的可行解落在该区间。然后，对于每一个区间，将其与后面的区间进行区间重叠运算。 对于重叠的区间，有四种可能： 1.可行区间 \(cur\) 和后一个温度区间没有重叠 2.两区间左侧或右侧部分重叠 3.可行区间 \(cur\) 包含于后一个温度区间 4.可行区间 \(cur\) 被包含于后一个温度区间 对应AC代码 import java.util.*; public class Main &#123; static class Person&#123; long t, l, h; Person(long t, long l, long h)&#123; this.t = t; this.l = l; this.h = h; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int q = scanner.nextInt(); g:for(int i=0;i&lt;q;i++)&#123; int n = scanner.nextInt(), m = scanner.nextInt(); Person[] p = new Person[n]; for(int j=0;j&lt;n;j++) p[j] = new Person(scanner.nextLong(), scanner.nextLong(), scanner.nextLong()); long left = m - p[0].t, right = m + p[0].t; //以第一个人的到达时间划分初始区间 for(int j=0;j&lt;n;j++)&#123; Person cur = p[j]; if(cur.h &lt; left || cur.l > right)&#123; System.out.println("NO"); continue g; &#125;else if(j == n - 1)&#123; //如果是最后一个，只要有交集就已经成功 System.out.println("YES"); continue g; &#125; if(cur.l >= left &amp;&amp; cur.h &lt;= right)&#123; //包含关系 left = cur.l; right = cur.h; &#125;else if(cur.l >= left) left = cur.l; //右侧有区间重叠 else if(cur.h &lt;= right) right = cur.h; //左侧有区间重叠 left -= p[j + 1].t - cur.t; right += p[j + 1].t - cur.t; &#125; &#125; &#125; &#125; 第一次写题解，可能交代的不是很清楚。]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 图论 - 车站分级</title>
    <url>/blog/posts/1900600766/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/532?tid=6363a9a5691055e12dd288dc 其实如果没有给出是图论题的话，这题就难在想不想得到拓扑了。 题意 定义"要求"：对于任意停靠的车站，存在优先级，需要满足其余大于等于该车站优先级的车站必须停靠的条件。 给出满足"要求"的几条线路，求出需要划分的最少优先级数量。 思路 首先，我们确定一下每条线路需要处理的车站：从起点到终点这一段路上的所有车站。 对于"优先"这个概念，我们可以联系到图论中的父子关系，也就是建立有向边。 对于有向边，当我们将优先级小的车站作为父节点、优先级大的作为子节点时，就可以采用拓扑排序的逻辑。在每次 \(push\) 的时候，我们只需存入当前节点的优先级，依次迭代并记录优先级的最大值即可。 对于建立有向边，我们可以遍历这条线路上所有非停靠站，将所有车站依次连到各个非停靠车站上即可。 对应AC代码 import java.util.*; public class Main&#123; private static class Point&#123; //防止构建泛型数组 int inDegree; List&lt;Integer> edges = new ArrayList&lt;>(); &#125; //实现cpp里面的pair private static class Pair&lt;A, B>&#123; A A; B B; public Pair(A a, B b) &#123; A = a; B = b; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Pair&lt;?, ?> pair = (Pair&lt;?, ?>) o; if (!Objects.equals(A, pair.A)) return false; return Objects.equals(B, pair.B); &#125; @Override public int hashCode() &#123; int result = A != null ? A.hashCode() : 0; result = 31 * result + (B != null ? B.hashCode() : 0); return result; &#125; &#125; static int n, ans; static Point[] points; static boolean[][] edgeVisited; static void addEdge(int x, int y)&#123; if(points[x] == null) points[x] = new Point(); if(points[y] == null) points[y] = new Point(); points[x].edges.add(y); points[y].inDegree ++; &#125; static void topSort() &#123; //拓扑排序 Queue&lt;Pair&lt;Integer, Integer>> queue = new LinkedList&lt;>(); for (int i = 1; i &lt;= n; i++) if (points[i] != null &amp;&amp; points[i].inDegree == 0) &#123; //多余的站不用管了 queue.offer(new Pair&lt;>(i, 1)); //入度为零，优先级最低为1 &#125; while (queue.size() > 0) &#123; Pair&lt;Integer, Integer> x = queue.poll(); for (int y : points[x.A].edges) &#123; if (--points[y].inDegree == 0) &#123; queue.offer(new Pair&lt;>(y, x.B + 1)); //当所有能遍历到y的点都经过了，那就可以can can y了(不然会有重复 ans = Math.max(ans, x.B + 1); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); n = scanner.nextInt(); int m = scanner.nextInt(); points = new Point[n + 1]; edgeVisited = new boolean[n + 1][n + 1]; for(int w=0;w&lt;m;w++)&#123; int s = scanner.nextInt(); List&lt;Integer> stations = new ArrayList&lt;>(); boolean[] isStation = new boolean[n + 1]; for(int i=0;i&lt;s;i++) &#123; int now = scanner.nextInt(); stations.add(now); isStation[now] = true; &#125; for(int i=stations.get(0); i&lt;=stations.get(s - 1);i++)&#123; //非车站作为车站的爸爸建有向边 if(isStation[i]) continue; for(int j : stations)&#123; if(!edgeVisited[i][j])&#123; edgeVisited[i][j] = true; addEdge(i, j); &#125; &#125; &#125; &#125; topSort(); System.out.println(ans); &#125; &#125; 这题也可以用邻接表。 要交题的话还是建议cpp，java有点卡时间了。]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 图论 - Sorting it all out</title>
    <url>/blog/posts/3592285520/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/542?tid=6363ac4a691055e12dd289de 最短路题单，但是可以用拓扑（ 题意 给定 \(A - Z\) 中前 \(n\) 个字母的大小顺序，且都为小于关系，共有 \(m\) 个条件，从前往后判断满足所有条件的序列是否存在且唯一。 对于从前往后的 \(t\) 次遍历中，若能确定最后输出，则略过后面的输入。 有唯一解，输出 \(Sorted \ sequence \ determined \ after \ t \ relations: yyy...y.\) 有多解（冲突），输出 \(Inconsistency \ found \ after \ t \ relations.\) 无解（没有给全所有点的条件），输出 \(Sorted \ sequence \ cannot \ be \ determined.\) 思路 因为题面提到需要整个序列的顺序输出，而联想到拓扑排序，它可以将一个有向图转换成一个有先后顺序的序列，这正是我们需要的。 一切都一样，只是我们的有向图多了一个条件： 除了根和叶外，其他节点都是入度和出度为 \(1\) 的。 联想到拓扑排序的实现，若我们在每次循环的时候都判断一下队列的元素个数，大于 \(1\) 标记有多解，即可满足上述条件了。 当然，为了计算 \(t\)，跑一遍拓扑是不够的，我们要在加边的同时拓扑，来判断在加入这个条件后是否出现了多解或者无解。 考虑到入度的计算，不采用先加完边再跑拓扑的做法。 翻车实录 注意输出的优先级，如果冲突且无解，应该输出冲突。 \(POJ\) 远端题，不要用万能头和 \(for-each\) 语句。 对应AC代码 #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> using namespace std; int n, m, inDegree[30], copyInDegree[30], visited[30][30]; vector&lt;int> edges[30], ans; bool addEdge(int x, int y) &#123; //在邻接表中添加一条有向边 if(visited[x][y]) return true; visited[x][y] = true; edges[x].push_back(y); inDegree[y]++; return false; &#125; int topSort() &#123; //拓扑排序 queue&lt;int> q; memset(copyInDegree, 0, sizeof copyInDegree); //每次拓扑后入度不能被修改呢 for (int i = 0; i &lt; n; i++) &#123; if (inDegree[i] == 0) q.push(i); copyInDegree[i] = inDegree[i]; &#125; ans.clear(); bool inc = false; while (!q.empty()) &#123; if(q.size() > 1) inc = true; int x = q.front(); ans.push_back(x); q.pop(); for(int i=0;i&lt;edges[x].size();i++)&#123; int y = edges[x][i]; if (--copyInDegree[y] == 0) &#123; q.push(y); &#125; &#125; &#125; if(ans.size() &lt; n) return 2; if(inc) return 3; return 1; &#125; int main() &#123; scanf("%d %d", &amp;n, &amp;m); while (n != 0 || m != 0) &#123; memset(inDegree, 0, sizeof inDegree); memset(visited, 0, sizeof visited); memset(edges, 0, sizeof edges); bool skip = false; int t = 0, result = 3; for (int i = 1; i &lt;= m; i++) &#123; char input[4] = &#123;0&#125;; scanf("%s", input); if (addEdge(input[0] - 'A', input[2] - 'A')) continue; if (skip) continue; //跳过也得读完呐... result = topSort(); t++; if (result == 3) continue; //无解了 skip = true; //冲突和求出唯一解是只需判断一次的，后面直接跳过即可 &#125; if (result == 1) &#123; printf("Sorted sequence determined after %d relations: ", t); for (int i = 0; i &lt; ans.size(); i++) printf("%c", ans[i] + 'A'); printf(".\n"); &#125; else if (result == 2) printf("Inconsistency found after %d relations.\n", t); else printf("Sorted sequence cannot be determined.\n"); scanf("%d %d", &amp;n, &amp;m); &#125; &#125; 找个时间写写floyd的思路]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 树型dp - 三色二叉树</title>
    <url>/blog/posts/3903312395/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/512?tid=633d6550d2fe705a3c4684c7 之所以来写这个题解，是因为思路真的太清晰啦（（ 题意 给定一段由 \(0, 1, 2\) 组成的二叉树序列 \(S\)，序列由下面三种元素构成： \(0\)：表示该树没有节点； \(1 S_1\)：表示该数有一个节点，\(S_1\) 为其子树的二叉树序列； \(2 S_1 S_2\)：表示该树有两个子节点，\(S_1\) 和 \(S_2\) 分别表示其两个子树的二叉树序列。 根据上述序列建树，并标上红蓝绿三种颜色，相邻颜色不能重复，子节点颜色不能重复，求出这棵树中绿色节点的最大和最小数量。 思路 我们考虑下面的两个问题。 如何建树 根据题给条件，在给出根节点后，后面将会有一段数字作为根节点的子树，而其子树又可向右找到他的子树，以此类推。 但我们要如何确定下一个节点从哪里开始呢？显然，在上一个子节点遍历完后，下一个下标即为另一个子节点的开始下标。 于是乎，我们可以记录一下当前的下标在哪个位置，然后..... 这里也有两种写法。 递归写法 我们只需向下一次调用传递当前下标的位置，并返回处理结束后的下标位置（也可以开一个全局变量存储下标，效果是一样的）即可。 对应代码 void buildTree(int father)&#123; if(curIndex == inputTree.size()) return; cnt[father] = inputTree[curIndex ++] - '0'; for(int i=0;i&lt;cnt[father];i++) &#123; nodes[father][i] = ++tot; buildTree(tot); &#125; &#125; STL写法 我们不妨这么想，在找到根节点后，我们需要寻找它的两个子节点，而因为需要建树，我们需要知道这两个子节点对应的父节点是什么。 所以，我们可以使用一个数据结构存储这个根节点，在嵌套寻找的时候能正确获取上一个根节点，并能在两个子节点处理完后移除这个根节点。 这个数据结构满足一个特点：先进先出。 没错，就是栈结构。 对应代码 void buildTree() &#123; stack&lt;pair&lt;int, int>> root; //index, sum int cur = 0; root.push(pair&lt;int, int>(++tot, inputTree[0] - '0')); while (!root.empty()) &#123; pair&lt;int, int> father = root.top(); root.pop(); int now = inputTree[++cur] - '0'; father.second--; nodes[father.first][cnt[father.first]++] = ++tot; //建树 if (father.second > 0) root.push(father); if (now > 0) root.push(pair&lt;int, int>(tot, now)); &#125; &#125; 如何dp 在说之前，先吐槽一句我的代码，它看起来好蠢 我们不妨用状态机的写法，开一个二维 \(dp\) 数组第一维为下标，第二维为当前节点的一个状态。 显然，作为一个节点，他有三种状态——红蓝绿。 初始状态 将叶节点的所有状态赋值 \(1\). 状态转移 首先，如果一个父节点要成为绿色，那么他的子节点一定是红色、蓝色，或者蓝色、红色。当然如果只有一个子节点，那么这个子节点就是蓝色或者红色。 所以，对于一个父节点，对于一种颜色，它总会有两种取法，而又因为两种取法不影响父节点的颜色，所以 \(dp\) 的最大值就是两种情况的最大值，最小值同理。 这是最直接的思路，而按照这么写，代码会很冗长。 对应代码 void dfs(int root) &#123; for (int i = 0; i &lt; cnt[root]; i++) dfs(nodes[root][i]); if (cnt[root] == 0) &#123; dpMax[root][1] = 1; dpMin[root][1] = 1; &#125; else if (cnt[root] == 1) &#123; dpMax[root][0] = max(dpMax[nodes[root][0]][1], dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1], dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][1]); &#125; else if (cnt[root] == 2) &#123; dpMax[root][0] = max(dpMax[nodes[root][0]][1] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][1] + dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][1], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][1] + dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][1], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][1]); &#125; &#125; 是不是很蠢，我看着就想笑 最终结果 根节点分别为红蓝绿时，所记录下来的最大值和最小值即为答案。 对应AC代码 (递归) #include &lt;bits/stdc++.h> using namespace std; //你问我啥用cpp写，因为Java栈溢出了 int tot; int nodes[500010][2], dpMin[500010][3], dpMax[500010][3]; //0是红，1是绿，2是蓝，dp的值是绿色点的个数 int cnt[500010]; string inputTree; int curIndex = 0; void buildTree(int father)&#123; if(curIndex == inputTree.size()) return; cnt[father] = inputTree[curIndex ++] - '0'; for(int i=0;i&lt;cnt[father];i++) &#123; nodes[father][i] = ++tot; buildTree(tot); &#125; &#125; void dfs(int root) &#123; //好蠢 for (int i = 0; i &lt; cnt[root]; i++) dfs(nodes[root][i]); if (cnt[root] == 0) &#123; //断子绝孙 dpMax[root][1] = 1; dpMin[root][1] = 1; &#125; else if (cnt[root] == 1) &#123; //一个节点 dpMax[root][0] = max(dpMax[nodes[root][0]][1], dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1], dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][1]); &#125; else if (cnt[root] == 2) &#123; dpMax[root][0] = max(dpMax[nodes[root][0]][1] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][1] + dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][1], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][1] + dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][1], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][1]); &#125; &#125; int main() &#123; cin >> inputTree; buildTree(++ tot); dfs(1); cout &lt;&lt; max(dpMax[1][0], max(dpMax[1][1], dpMax[1][2])) &lt;&lt; " " &lt;&lt; min(dpMin[1][0], min(dpMin[1][1], dpMin[1][2])); &#125; 对应AC代码 (STL) #include &lt;bits/stdc++.h> using namespace std; //你问我啥用cpp写，因为Java栈溢出了 int tot; int nodes[500010][2], dpMin[500010][3], dpMax[500010][3]; //0是红，1是绿，2是蓝，dp的值是绿色点的个数 int cnt[500010]; string inputTree; void buildTree() &#123; stack&lt;pair&lt;int, int>> root; //index, sum int cur = 0; root.push(pair&lt;int, int>(++tot, inputTree[0] - '0')); while (!root.empty()) &#123; pair&lt;int, int> father = root.top(); root.pop(); int now = inputTree[++cur] - '0'; father.second--; nodes[father.first][cnt[father.first]++] = ++tot; //建树 if (father.second > 0) root.push(father); if (now > 0) root.push(pair&lt;int, int>(tot, now)); &#125; &#125; void dfs(int root) &#123; //好蠢 for (int i = 0; i &lt; cnt[root]; i++) dfs(nodes[root][i]); if (cnt[root] == 0) &#123; //断子绝孙 dpMax[root][1] = 1; dpMin[root][1] = 1; &#125; else if (cnt[root] == 1) &#123; //一个节点 dpMax[root][0] = max(dpMax[nodes[root][0]][1], dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1], dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][1]); &#125; else if (cnt[root] == 2) &#123; dpMax[root][0] = max(dpMax[nodes[root][0]][1] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][1] + dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][1], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][1] + dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][1], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][1]); &#125; &#125; int main() &#123; cin >> inputTree; buildTree(); dfs(1); cout &lt;&lt; max(dpMax[1][0], max(dpMax[1][1], dpMax[1][2])) &lt;&lt; " " &lt;&lt; min(dpMin[1][0], min(dpMin[1][1], dpMin[1][2])); &#125; 其实递归是写本题解的时候想到的，而有趣的是它反而是最优解。]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 树和堆 - 合并果子</title>
    <url>/blog/posts/2422309672/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/369?tid=6301e681027d8fe886628d9d 感觉之前写得太蠢了就重新写一下（ 题意 每次把最小的两个拿出来合并并将数量作为本次体力消耗，输出最小体力消耗值。 思路1 显然，我们只需边枚举边排序，考虑到数据范围够小，暴力是完全可行的。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; int d[20001]; int main() &#123; int n; cin >> n; for(int i=0;i&lt;n;i++) cin >> d[i]; sort(d, d + n); int ans = 0; for(int i=1;i&lt;n;i++)&#123; d[i] += d[i - 1]; ans += d[i]; sort(d + i, d + n); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; 思路2 不难发现，上面暴力的做法无非就是两个步骤：①排序 ②取最小两个加起来放回去 很巧的是，这些步骤完全可以使用封装好的堆结构来实现。 时间复杂度和上述暴力方法完全一致。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); PriorityQueue&lt;Integer> queue = new PriorityQueue&lt;>(); int n = scanner.nextInt(); for(int i=0;i&lt;n;i++) queue.offer(scanner.nextInt()); int ans = 0; while(true)&#123; if(queue.isEmpty()) break; int a = queue.poll(); if(queue.isEmpty()) break; int b = queue.poll(); queue.offer(a + b); ans += a + b; &#125; System.out.println(ans); &#125; &#125; 堆 = 暴力（暴论]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 搜索剪枝策略 - 靶形数独</title>
    <url>/blog/posts/1232478877/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/491?tid=633184a5ea0e1b063194593d 杰尼龟刚刚接触了信息学竞赛，有一天它遇到了这样一个题：靶形数独。 “简单！”杰尼龟心想，同时很快就写出了一份程序，可是测试时却出现了错误。 题意 完成一个每格具有分数的数独，使分数和最大。 铺垫 先来看看这题 数独 - 洛谷. 显然，我们只需要用 \(dfs\) 就可以了。 我们传递两个参数，代表当前我们搜索的点。 然后我们判断一下列有没有超出最大值，有的话跳到下一行即可。 不过需要注意的是，我们没有必要嵌套两个 \(for\) (你喜欢的话记得 \(break\) )，只需在传递参数的时候把当前列 \(+1\) 即可。 思路 首先，我们很容易想到直接套数独的模板，然后记录一下最高分即可。 这没有错，但你会喜提 \(2tle\)。 为什么呢？你可以试试用你的思维来解数独。 当拿到一个数独的时候，你的第一反应是什么？ 没错，自然是从空格最少的行填起。 这里就存在一个剪枝：对行排序。 我们可以用桶排序的方式，记录下排序后下标对应原行的下标即可。 还有一件事，你会如何算这个分数呢？ 用空间换时间，即数组 int k[10][10]=&#123; 0,0,0,0,0,0,0,0,0,0, 0,6,6,6,6,6,6,6,6,6, 0,6,7,7,7,7,7,7,7,6, 0,6,7,8,8,8,8,8,7,6, 0,6,7,8,9,9,9,8,7,6, 0,6,7,8,9,10,9,8,7,6, 0,6,7,8,9,9,9,8,7,6, 0,6,7,8,8,8,8,8,7,6, 0,6,7,7,7,7,7,7,7,6, 0,6,6,6,6,6,6,6,6,6 &#125;; 整出来一个公式：\(10 - \max(abs(i - 4), abs(j - 4))\) 对应AC代码 import java.util.*; public class Main &#123; static int[][] data = new int[10][10]; static boolean[][] rowVisited = new boolean[10][10], columnVisited = new boolean[10][10], squareVisited = new boolean[10][10]; static Integer[] reflectRow = new Integer[9]; static int ans = -1; private static void dfs(int x, int y)&#123; if(x == 9)&#123; int now = 0; for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; now += data[i][j] * (10 - Math.max(Math.abs(i - 4), Math.abs(j - 4))); &#125; ans = Math.max(ans, now); return; &#125; if(y == 9)&#123; dfs(x + 1, 0); return; &#125; int realX = reflectRow[x]; if(data[realX][y] != 0) dfs(x, y + 1); else &#123; int squareId = realX / 3 * 3 + y / 3; for (int i = 1; i &lt;= 9; i++) &#123; if (!rowVisited[realX][i] &amp;&amp; !columnVisited[y][i] &amp;&amp; !squareVisited[squareId][i]) &#123; rowVisited[realX][i] = true; columnVisited[y][i] = true; squareVisited[squareId][i] = true; data[realX][y] = i; dfs(x, y + 1); rowVisited[realX][i] = false; columnVisited[y][i] = false; squareVisited[squareId][i] = false; data[realX][y] = 0; //好久没写回溯了 &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); for(int i=0;i&lt;9;i++) reflectRow[i] = i; int[] cnt = new int[9]; for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; data[i][j] = scanner.nextInt(); rowVisited[i][data[i][j]] = true; columnVisited[j][data[i][j]] = true; squareVisited[i / 3 * 3 + j / 3][data[i][j]] = true; if(data[i][j] > 0) cnt[i] ++; &#125; Arrays.sort(reflectRow, (o1, o2) -> cnt[o2] - cnt[o1]); dfs(0, 0); System.out.println(ans); &#125; &#125; 好久不玩数独了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 模拟 - 立体图</title>
    <url>/blog/posts/1619629406/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/464?tid=62e26edd3a711450d9b817c5 题意 小渊很懒，给你各个位置的高度，让你画立体图。 思路 首先，根据题单名称，我们可以知道要模拟。 方块之间的前后视觉遮挡问题 首先，我们来考虑这个本题最难的点。 显然，对于斜二测画法的立体图，后面靠左的区域会被前者覆盖。那么我们自然会发现，从前往后画，覆盖问题会变得很复杂（不过也不是不能做）。 所以，我们不妨试试从俯视视角的左上角开始画。 我们以一个方块为一个单位开始画图。这里我们定义一个 \(char\) 二维数组来存储一个方块，并用题给的 \(.\) 符号来表示空区域。 char[][] one = &#123; "..+---+".toCharArray(), "./ /|".toCharArray(), "+---+ |".toCharArray(), "| | +".toCharArray(), "| |/.".toCharArray(), "+---+..".toCharArray() &#125;; 然后，对于每一个新加入的方块，我们只要对 \(one\) 进行行列的遍历，如果不为 \(.\)，就将前者对应位置覆盖。 定位 每个方块的大小是 \(6 \times 7\)，格子的数目也给出了范围，此处我们可以开一个存储数据的容量为 \(500 \times 500\) 的数组（其实是随便输的，可能还不满足最大的容量，只能说测试数据不够全面，反正开大一点就好啦~），那么右下角的点坐标就为 \((499, 499)\)。 好的，那我们先拿几个图来推一下坐标的式子。 此处定义每个格子的坐标为 \((i, j, h)\) 注：为了更加形象一点，我就直接定义 \(h\) 下标从 \(1\) 开始，而 \(i\) 和 \(j\) 仍从 \(0\) 开始。 image 对于左下角的高度为1的方块（即坐标为 \((m - 1, 0, 1)\) 的方块），他的左上顶点位于 \((494, 0)\)。 image 对于 \((m - 2, 1, 1)\) 的方块，他的左上顶点位于 \((492, 2)\)。 可见对于横纵坐标的改动，会有以 \(2\) 为倍数的改变，在高度为 \(1\) 时，我们可以推出下面的坐标式子： \((494 - 2(m - i - 1), 4j + 2(m - i - 1))\) 高度变化对坐标的影响是显而易见的。每当高度加 \(1\)，横坐标会减少 \(3\)（不能理解的话可以对照一下题面中两个方块上下相邻的图）。因此我们完善一下式子如下： \((497 - 2(m - i - 1) - 3h, 4j + 2(m - i - 1))\) 然后我们只需从俯视视角的左上角开始循环添加方块就 \(ok\) 了。 如何输出 在每次添加方格的时候，我们可以记录一下上区间和右区间，上区间就是所有左上顶点的纵坐标最小值，右区间就是所有右上顶点横坐标最大值。 对应AC代码 (java) import java.util.*; public class Main &#123; static char[][] one = &#123; "..+---+".toCharArray(), "./ /|".toCharArray(), "+---+ |".toCharArray(), "| | +".toCharArray(), "| |/.".toCharArray(), "+---+..".toCharArray() &#125;; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); char[][] ans = new char[500][500]; //开数组 for(int i=0;i&lt;500;i++) for(int j=0;j&lt;500;j++) ans[i][j] = '.'; //空位置填上占位符"." int m = scanner.nextInt(), n = scanner.nextInt(); int[][] height = new int[m][n]; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) height[i][j] = scanner.nextInt(); int top = 500, right = 0; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) for(int h=1;h&lt;=height[i][j];h++)&#123; //从左上角画起，存到数组底部，到时候记录最高和最右的位置即可 int startI = 497 - 2 * (m - i - 1) - 3 * h, startJ = 4 * j + 2 * (m - i - 1); top = Math.min(top, startI); right = Math.max(right, startJ + 6); for(int p=0;p&lt;6;p++) for(int q=0;q&lt;7;q++)&#123; if(one[p][q] != '.') ans[startI + p][startJ + q] = one[p][q]; &#125; &#125; for(int i=top;i&lt;=499;i++) &#123; for(int j=0;j&lt;=right;j++) System.out.print(ans[i][j]); System.out.println(); &#125; &#125; &#125; 对应AC代码 (cpp) #include &lt;bits/stdc++.h> using namespace std; char one[6][8] = &#123; "..+---+", "./ /|", "+---+ |", "| | +", "| |/.", "+---+.." &#125;; char ans[500][500]; //开数组 int height[52][52]; int main() &#123; for (int i = 0; i &lt; 500; i++) for (int j = 0; j &lt; 500; j++) ans[i][j] = '.'; //空位置填上占位符"." int m, n; scanf("%d %d", &amp;m, &amp;n); for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) scanf("%d", &amp;height[i][j]); int top = 500, right = 0; for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) for (int h = 1; h &lt;= height[i][j]; h++) &#123; //从左上角画起，存到数组底部，到时候记录最高和最右的位置即可 int startI = 497 - 2 * (m - i - 1) - 3 * h, startJ = 4 * j + 2 * (m - i - 1); top = min(top, startI); right = max(right, startJ + 6); for (int p = 0; p &lt; 6; p++) for (int q = 0; q &lt; 7; q++) &#123; if (one[p][q] != '.') ans[startI + p][startJ + q] = one[p][q]; &#125; &#125; for (int i = top; i &lt;= 499; i++) &#123; for (int j = 0; j &lt;= right; j++) printf("%c", ans[i][j]); printf("\n"); &#125; &#125; 过于模拟]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 838 Div 2</title>
    <url>/blog/posts/1762526761/</url>
    <content><![CDATA[Practice. A. Divide and Conquer 题意 给定一个数组 \(a\)，定义操作为选定一个元素并将其除 \(2\) 后向下取整，输出最少操作数，使整个数组的和为奇数。 思路 考虑到数据量比较小，我们不妨直接用“分治”的方法，考虑每个元素需要多少次才能改变奇偶性，然后找出操作数最少的元素，对应的操作数就是我们想要的答案。 当然，本来就是奇数的话就直接输出 \(0\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 60, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; memset(a, 0, sizeof a); cin >> n; int sum = 0, mn = inf; for(int i=0;i&lt;n;i++)&#123; int cnt = 0, x; cin >> x; a[i] = x; sum += a[i]; while(x % 2 == a[i] % 2 &amp;&amp; x > 0)&#123; cnt ++; x /= 2; &#125; mn = min(mn, cnt); &#125; if(sum % 2 == 0) cout &lt;&lt; 0 &lt;&lt; '\n'; else cout &lt;&lt; mn &lt;&lt; '\n'; &#125; return 0; &#125; 真就“分治”呗 B. Make Array Good 题意 给定一个数组 \(b\)，定义操作为将任意元素加上不超过其本身的自然数，操作数量不限，输出一种操作方案，使得对于任意的 \(i, j\)，有 \(\min(b_i, b_j) | \max(b_i, b_j)\)。 思路 既然操作数量不限，那么我们不妨把所有数加到 \(2\) 的倍数。 更具体地说，我们只需加到每个元素最近的 \(2\) 的次幂即可。 时间复杂度：\(O(n \log_2 n)?\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 60, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; cout &lt;&lt; n &lt;&lt; '\n'; for(int i=1;i&lt;=n;i++)&#123; int x; cin >> x; int to = 1; while(to &lt; x) to *= 2; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; to - x &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 限次数就难搞了 C. Binary Strings are Fun 题意 在二进制数组的条件下给出两个定义： 如果对于一个长度为奇数的数组，对于它的所有奇数下标 \(i\)，满足 \(b_i\) 是 \([1,i]\) 内出现次数至少占总数的一半的数，那么这个数组是好的。 若对于一个长度为 \(k\) 的数组 \(a\) 和一个长度为 \(2k-1\) 的数组 \(b\)，满足对于任意 \(i \in [1,k]\)，有 \(a_i = b_{2i-1}\)，那么称 \(b\) 是 \(a\) 的拓展数组。 现在，给定一个二进制数组 \(s\)，对于 \(s\) 的所有前缀，统计其 好的 拓展数组 的数量之和，并输出。 思路 首先，我们不难发现，若前两位是不相同的，那么我们可选的拓展值是唯一确定的，也就是说，想要让两个元素之间的拓展值有两种取法，那么这两个元素一定是相同的。 其次，若我们遇到了连续相同的一段，但后面被打断之后，那么我们就不得不在相同的这一段填上与之相反的值，否则无法满足后面的条件，所以我们应寻找后缀连续相同段的长度。 我们不妨记这个长度为 \(len\)，那么方案数即为 \(2^{len-1}\)。 显然，我们可以直接从左向右遍历，此时我们对应地判断+更新 \(len\) 与答案即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 60, inf = 0x3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; char pre = ' '; int ans = 1, tot = 0; for(int i=1;i&lt;=n;i++)&#123; char now; cin >> now; if(now == pre) ans = (ans * 2) % mod; else ans = 1; pre = now; tot = (tot + ans) % mod; &#125; cout &lt;&lt; tot &lt;&lt; '\n'; &#125; return 0; &#125; 算是想出来了一大半（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 841 Div 2</title>
    <url>/blog/posts/4132653795/</url>
    <content><![CDATA[Practice. A. Joey Takes Money 题意 给定一个包含 \(n\) 个 \(\geq 1\) 的元素的数组 \(a\)，定义操作为： 选定 \(i, j, i \neq j\)； 选两个 \(\geq 1\) 的正整数 \(x, y\)，满足 \(x \cdot y = a_i \cdot a_j\)； 将 \(a_i, a_j\) 改为 \(x, y\)。 输出任意次操作后数组的和的最大值 x2022。 思路 显然，对于 \(a_i, a_j\)，\(1 + a_i \cdot a_j\) 一定是所有操作中最大的和，那么我们可以依次从左到右将所有数都执行一遍该操作，得到 \(1, 1, 1, \ldots, \prod a_i\)，求和即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t-- > 0)&#123; int n = scanner.nextInt(); long[] a = new long[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); for(int i=0;i&lt;n-1;i++)&#123; a[n - 1] = a[n - 1] * a[i]; a[i] = 1; &#125; System.out.println(2022 * ((long) (n - 1) + a[n - 1])); &#125; &#125; &#125; 简单思维题 &amp; 2022x1 B. Kill Demodogs 题意 给定一个 \(n \times n\) 的矩阵，\((i, j)\) 位置的元素值为 \(i \times j\)。定义人物从 \((1, 1)\) 走到 \((n, n)\)，期间人物只能向下或向右移动一格，输出到达终点后经过的元素的值的总和的最大值。 思路 显然，我们走对角线是最优的，此时横坐标和纵坐标的值最相近。 此时，我们可以得到下面的式子： \(1 \times 1 + 1 \times 2 + 2 \times 2 + \ldots + (n - 1) \times n + n \times n\)。 我们将其拆成两个式子： \(1 \times 1 + 2 \times 2 + \ldots + n \times n\)； \(1 \times 2 + 2 \times 3 + \ldots + (n - 1) \times n\)。 对于上述两个式子，我们套用公式即可。 最后，我们可以得到下面的式子： \(\frac{n (n + 1) (2n + 1)}{6} + \frac{(n - 1) n (n + 1)}{3}\)。 此时，我们有两个选择：大数或者逆元。任选其一即可。 时间复杂度：\(O(1)?\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(), mod = 1000000007; while(t -- > 0)&#123; long n = scanner.nextInt(); System.out.println((2022 * ((BigInteger.valueOf(n).multiply(BigInteger.valueOf(n + 1)).multiply(BigInteger.valueOf(2 * n + 1)).divide(BigInteger.valueOf(6)).mod(BigInteger.valueOf(mod)).longValue() + BigInteger.valueOf(n - 1).multiply(BigInteger.valueOf(n)).multiply(BigInteger.valueOf(n + 1)).divide(BigInteger.valueOf(3)).mod(BigInteger.valueOf(mod)).longValue()) % mod)) % mod); &#125; &#125; &#125; 大数yyds C. Even Subarrays 题意 给定一个长度为 \(n\) 的数组 \(a\)，\(1 \leq a_i \leq n\)，输出连续的子序列的个数，子序列需满足子序列的异或值有偶数个因数。 思路 这里需要用到一个性质：只有完全平方数的因数数量是奇数。 所以，我们不妨找完全平方数，然后取一个补集即可。 考虑到异或的交换性，我们不妨用答案来枚举。 更具体地说，我们不妨从前向后遍历，\(cur\) 为前 \(i\) 个元素的异或值，我们用 \(m\) 数组存储这些异或值出现的次数，然后，我们枚举所有可能的答案，算出 \(cur\) 需要和 前面的哪一段区间的异或值 进行异或后得到完全平方数，用类似于前缀和的方式记录答案。 考虑到 \(a_i\) 的范围，我们只需枚举 \(2n\) 及以下的完全平方数即可。 时间复杂度：\(O(n \sqrt n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); long[] m = new long[2 * n]; int cur = 0; long cnt = 0; m[cur] = 1; for(int i=0;i&lt;n;i++)&#123; cur ^= a[i]; for(int j=0;j*j&lt;2*n;j++)&#123; int now = cur ^ (j * j); if(now &lt; 2 * n) cnt += m[now]; &#125; m[cur] ++; &#125; System.out.println((long) n * (n - 1) / 2 + n - cnt); &#125; &#125; &#125; 异或的性质太多力]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 840 Div 2</title>
    <url>/blog/posts/1344553303/</url>
    <content><![CDATA[Practice A. Absolute Maximization 题意 给定一个数组 \(a\)，定义操作为选择两个元素 \(a_i, a_j\)，并交换它们二进制下的第 \(b\) 位。输出任意次操作后的 \(\max(a) - \min(a)\) 的最大值。 思路 既然可以无限次交换，那么我们只要找出最高位，从最高位开始往下找，只要有一个元素该位存在 \(1\)，那么我们就拿过来构建新的数字，这样即可得到最大值。反之同理。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); for(int w=0;w&lt;t;w++)&#123; int n = scanner.nextInt(); int[] min = new int[12], max = new int[12]; for(int i=0;i&lt;12;i++)&#123; min[i] = 1; max[i] = 0; &#125; int maxLen = 0; String[] input = new String[n]; for(int i=0;i&lt;n;i++) &#123; input[i] = Integer.toBinaryString(scanner.nextInt()); maxLen = Math.max(maxLen, input[i].length()); &#125; for(int i=0;i&lt;n;i++) &#123; while(input[i].length() != maxLen) input[i] = "0" + input[i]; for(int j=0;j&lt;maxLen;j++) &#123; int now = input[i].charAt(j) - '0'; max[j] = Math.max(max[j], now); min[j] = Math.min(min[j], now); &#125; &#125; int maxx = 0, minn = 0; for(int i=0;i&lt;maxLen;i++) &#123; maxx = maxx * 2 + max[i]; minn = minn * 2 + min[i]; &#125; System.out.println(maxx - minn); &#125; &#125; &#125; 简单思维题 B. Incinerate 题意 给定 \(n\) 个怪物的生命值 \(h_i\) 以及攻击力 \(p_i\)，主角的攻击力为 \(k\)，定义一次攻击为将所有怪物扣去 \(k\) 点生命值，生命值小于等于 \(0\) 的怪物死亡，剩余攻击力最低的怪物将会将主角的攻击力削减到 \(k - p_i\)。输出是否可以将怪打完。 思路 模拟。 我们可以先按照生命值升序排序，维护一个存活的怪物的开始下标 \(index\)，那么想要快速获取到存活的怪物中攻击力最低的，我们可以维护一个后缀数组，存储 \(index\) 及以后的 \(p_{\min}\)。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.util.*; public class Main &#123; private static class Monster&#123; int h, p; Monster(int h)&#123; this.h = h; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); for(int w=0;w&lt;t;w++)&#123; int n = scanner.nextInt(), k = scanner.nextInt(); Monster[] m = new Monster[n]; for(int i=0;i&lt;n;i++) m[i] = new Monster(scanner.nextInt()); for(int i=0;i&lt;n;i++) m[i].p = scanner.nextInt(); Arrays.sort(m, Comparator.comparingInt(o -> o.h)); int[] suf = new int[n + 1]; suf[n] = Integer.MAX_VALUE; for(int i=n-1;i>=0;i--) suf[i] = Math.min(suf[i + 1], m[i].p); int index = 0, attack = 0; while(k > 0)&#123; for(int i=index;i&lt;n;i++)&#123; if(m[i].h - attack > k) break; index ++; &#125; if(index >= n) break; attack += k; k -= suf[index]; &#125; System.out.println(k > 0 ? "YES" : "NO"); &#125; &#125; &#125; 略微暴力但又不暴力（ C. Another Array Problem 题意 给定一个数组 \(a\)，定义操作为选择 \(i, j,i \neq j\)，将所有 \(a_k, k \in [i, j]\) 修改为 \(|a_i - a_j|\)。在任意次操作后，输出数组的总和的最大值。 思路 我们来考虑一下 \(4\) 个及以上的情况： 在这个情况里，我们不妨找出最大值所在的下标 \(imax\)，然后用类似下面的思路完成： \(\begin{array}{l}&gt;&gt;1\ 2\ 4\ 3 \\ =&gt; 1\ 1\ 4\ 3 \\ =&gt; 0\ 0\ 4\ 3 \\ =&gt; 4\ 4\ 4\ 3 \\ =&gt; 4\ 4\ 1\ 1 \\ =&gt; 4\ 4\ 0\ 0 \\ =&gt; 4\ 4\ 4\ 4\end{array}\) 也就是说，我们只需找出最大的值，最后一定有方案将所有数全都改为最大值。 那么 \(3\) 个数呢？此时存在局限性，若最大值在两端，那么和上述一致，但最大值在中间时，我们就只能找出两端的 \(\min , \max\)，然后取 \(a[1]-\min\) 和 \(\max\) 的最大值。 同上，两个数的时候，最大值即为两个元素的差。 当然，我们也可以不操作，所以需要取一下操作后的答案和原总和的最大值。 时间复杂度：\(O(n)?\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); for(int w=0;w&lt;t;w++)&#123; int n = scanner.nextInt(); long[] a = new long[n]; int maxIndex = 0; long sum = 0; for(int i=0;i&lt;n;i++)&#123; a[i] = scanner.nextLong(); sum += a[i]; maxIndex = a[maxIndex] &lt; a[i] ? i : maxIndex; &#125; long ans; if(n == 2) &#123; ans = Math.abs(a[1] - a[0]) * 2; &#125;else if(n == 3)&#123; if(maxIndex == 0 || maxIndex == 2) ans = a[maxIndex] * n; else&#123; long min = Math.min(a[0], a[2]), sMin = Math.max(a[0], a[2]); ans = Math.max(a[maxIndex] - min, sMin) * 3; &#125; &#125;else ans = a[maxIndex] * n; System.out.println(Math.max(sum, ans)); &#125; &#125; &#125; 很巧妙的思维题]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 839 Div 3</title>
    <url>/blog/posts/3095280907/</url>
    <content><![CDATA[Practice. A. A+B? 题意 给定一个形如 \(a+b\) 的字符串，输出答案。\(a, b \in [0, 9]\)。 思路 模拟。 时间复杂度：\(O(1)\) import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; String[] a = scanner.next().split("\\+"); System.out.println(Integer.parseInt(a[0]) + Integer.parseInt(a[1])); &#125; &#125; &#125; 过于签到，应该有语言可以一行解决吧 B. Matrix Rotation 题意 给定一个 \(2 \times 2\) 的矩阵，定义操作为将矩阵旋转 \(90°\)，输出任意次操作后，能否使矩阵满足下面的条件： 每一行的第一个元素小于第二个元素； 每一列的第一个元素小于第二个元素。 思路 模拟。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt: while(t -- > 0)&#123; int a = scanner.nextInt(), b = scanner.nextInt(), c = scanner.nextInt(), d = scanner.nextInt(); for(int i=0;i&lt;4;i++)&#123; if(a &lt; b &amp;&amp; b &lt; d &amp;&amp; a &lt; c &amp;&amp; c &lt; d)&#123; System.out.println("YES"); continue nxt; &#125; int tmp = b; b = a; a = c; c = d; d = tmp; &#125; System.out.println("NO"); &#125; &#125; &#125; 模拟就完事了 C. Different Differences 题意 给定两个整数 \(k, n\)，构造长度为 \(k\) 且严格递增的数组 \(a\)，其中 \(a_{k - 1} \leq n\)。输出一种构造，使数组 \([a_2 - a_1, a_3 - a_2, \ldots a_k - a_{k - 1}]\) 内不相同的元素数量最大。 思路 若数组无长度和大小限制，那么我们只需输出以 \(1\) 为首项和公差的等差数列的前 \(n\) 项和即可。 考虑到限制，我们在输出第 \(i\) 项的时候，还因考虑它的最大值 \(i + n - k\)，取一个最小值即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int k = scanner.nextInt(), n = scanner.nextInt(); int a = 1; for(int i=1;i&lt;=k;i++)&#123; System.out.printf("%d ", Math.min(a, i + n - k)); a += i; &#125; System.out.println(); &#125; &#125; &#125; 简单构造题 D. Absolute Sorting 题意 给定一个数组 \(a\)，所有元素均为正整数。输出一个 \(x\)，满足将所有数减掉 \(x\) 后取绝对值后的序列不递减。若无解，输出 \(-1\)。 思路 由题意，我们需要满足 \(|a_i - x| \leq |a_{i + 1} - x|\)。 我们不妨先来考虑 \(a_i &lt; a_{i + 1}\) 的情况： \(x \leq a_i\)，那么原式化为 \(a_i \leq a_{i + 1}\)，恒成立； \(x \geq a_{i + 1}\)，那么原式化为 \(a_i \geq a_{i + 1}\)，不成立； \(a_i &lt; x &lt; a_{i + 1}\)，那么原式化为 \(x - a_i \leq a_{i + 1} - x\)，即 \(x \leq \lfloor \frac{a_i + a_{i + 1}}{2} \rfloor\)。 综上所述，\(x \le \lfloor \frac{a_i + a_{i+1}}{2} \rfloor\)。 同理，当 \(a_i &gt; a_{i + 1}\) 时，\(x \ge \lceil \frac{a_i + a_{i+1}}{2} \rceil\)。 因而，我们只需求出左端点的最大值 \(l\) 和右端点的最小值 \(r\)，然后判断 \(l \leq r\) 是否成立即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int pre = scanner.nextInt(); int l = 0, r = Integer.MAX_VALUE; for(int j = 1; j &lt; n; j++) &#123; int cur = scanner.nextInt(); if(pre > cur) l = Math.max(l, (pre + cur + 1) / 2); if(pre &lt; cur) r = Math.min(r, (pre + cur) / 2); pre = cur; &#125; System.out.println(l &lt;= r ? l : -1); &#125; &#125; &#125; 简单的拆绝对值分类讨论]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - TypeDB Forces 2023 Div 1 plus 2</title>
    <url>/blog/posts/1090672605/</url>
    <content><![CDATA[Contestant. Rank 3808. Rating +17. A. Exponential Equation 题意 给定整数 \(n\)，输出一对 \(x, y\)，满足 \(x ^ y \cdot y + y ^ x \cdot x = n\)。 思路 不妨令 \(x = 1\)，那么 \(y = n / 2\)。 显然，当 \(n\) 为奇数的时候，一定是无解的，因为 \(x ^ y \cdot y\) 和 \(y ^ x \cdot x\) 的奇偶性一定是一致的。 所以，\(n\) 为偶数的时候，输出 \(1, n / 2\)。 时间复杂度：\(O(1)\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt: while (t-- > 0) &#123; int n = scanner.nextInt(); if(n % 2 == 1) System.out.println(-1); else System.out.printf("%d %d\n", 1, n / 2); &#125; &#125; &#125; 你说我怎么就这么蠢 B. Number Factorization 题意 给定一个整数 \(n\)，构建数组 \(a, p\)，使 \(n = \prod a_i^{p_i}\)。其中，\(a_i\) 必须为不相同的质数的乘积。 输出 \(\sum a_i \cdot p_i\) 的最大值。 思路 显然，\(a_i ^ {p_i} = a_i \cdot a_i \cdot \ldots\)，那么我们不妨直接拆开，令所有 \(p_i = 1\)。 那么，我们只需分解质因数，分别将出现次数 \(\geq 1\) 次、\(\geq 2\) 次 ... 的数相乘后求和即可。 时间复杂度：不会分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 500010, inf = 0x3f3f3f3f; #define int long long vector&lt;int> primes; bool vis[N]; void init() &#123; for (int i = 2; i &lt;= N; ++i) &#123; if (!vis[i]) &#123; primes.emplace_back(i); &#125; for (int j : primes) &#123; if (1ll * i * j > N) break; vis[i * j] = true; if (i % j == 0) break; &#125; &#125; &#125; vector&lt;tuple&lt;int, int, bool>> fact(int x) &#123; vector&lt;tuple&lt;int, int, bool>> f; for (int i : primes) &#123; if(i > x) break; if (x % i == 0) &#123; int cnt = 0; while (x % i == 0) x /= i, cnt ++; if(cnt != 0) f.emplace_back(i, cnt, false); &#125; &#125; if (x != 1) &#123; f.emplace_back(x, 1, false); &#125; return f; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t, n; cin >> t; while(t --) &#123; cin >> n; vector&lt;tuple&lt;int, int, bool>> f = fact(n); int ans = 0, cnt = f.size(); while(cnt > 0)&#123; int now = 1; for(auto &amp;e : f)&#123; int x, p, ok; tie(x, p, ok) = e; if(ok) continue; now *= x; p --; if(p == 0) get&lt;2>(e) = true, cnt --; get&lt;1>(e) = p; &#125; ans += now; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 写得好乱 C. Remove the Bracket 题意 给定一个数组 \(a\) 以及一个整数 \(s\)，对于所有 \(i \in [2, n- 1]\)，有 \(x_i+y_i=a_i\) 且 \((x_i - s)(y_i - s) \geq 0\)。 构造 \(x_i, y_i\)，让下列式子的值最小，并输出这个值 \(F = a_1 \cdot x_2+y_2 \cdot x_3+y_3 \cdot x_4 + \ldots + y_{n - 2} \cdot x_{n-1}+y_{n-1} \cdot a_n\) 思路 我们不妨来单独考虑 \(x_i,y_i\)： 将其放入式子，我们可以得到 \(\ldots+ y_{i-1}\cdot x_i+y_i\cdot x_{i+1}+\ldots\)。在这段式子里，若 \(x_i + 1,y_i - 1\)，那么整个式子将会减少 \(x_{i + 1} - y_{i - 1}\)。 也就是说，我们希望 \(x_i\) 或 \(y_i\) 取到 \(s\)，因为只有在边界才能找到最值。 因而，我们可以用 \(dp\) 枚举所有我们希望的情况中的最小值。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(), s = console.nextInt(); long[] min = new long[n + 1], max = new long[n + 1]; for(int i=1;i&lt;=n;i++)&#123; int cur = console.nextInt(); if(i == 1 || i == n)&#123; min[i] = max[i] = cur; &#125;else if(cur &lt;= s)&#123; min[i] = 0; max[i] = cur; &#125;else&#123; min[i] = Math.min(s, cur - s); max[i] = Math.max(s, cur - s); &#125; &#125; long[][] dp = new long[n + 1][2]; for(int i=2;i&lt;=n;i++)&#123; dp[i][0] = Math.min(dp[i - 1][0] + max[i - 1] * min[i], dp[i - 1][1] + min[i - 1] * min[i]); dp[i][1] = Math.min(dp[i - 1][0] + max[i - 1] * max[i], dp[i - 1][1] + min[i - 1] * max[i]); &#125; console.println(dp[n][0]); &#125; console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; 论想不到dp于是乱找规律这件事]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 849 Div 4</title>
    <url>/blog/posts/752853425/</url>
    <content><![CDATA[Contestant. Rank 3392. Rating -15. 代码略去了快读模板 A. Codeforces Checking 题意 给定一个字符，判断是否在 \(codeforces\) 字符串中出现。 思路 数组记录 + 读数组。 时间复杂度：\(O(1)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); boolean[] have = new boolean[26]; for(char each : "codeforces".toCharArray()) have[each - 'a'] = true; while(t -- > 0)&#123; console.println(have[console.next().toCharArray()[0] - 'a'] ? "YES" : "NO"); &#125; console.close(); &#125; &#125; 语法题 x1 B. Following Directions 题意 给定一个由 \(U,D,L,R\) 组成的字符串，分别代表向上、下、左、右移动一个单位距离。输出从原点开始移动，途中是否经过 \((1,1)\)。 思路 模拟。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); String step = console.next(); int x = 0, y = 0; for(char each : step.toCharArray())&#123; if(each == 'L') x --; else if(each == 'R') x ++; else if(each == 'U') y ++; else y --; if(x == 1 &amp;&amp; y == 1)&#123; console.println("YES"); continue nxt; &#125; &#125; console.println("NO"); &#125; console.close(); &#125; &#125; 语法题 x2 C. Prepend and Append 题意 给定一个二进制字符串，定义操作为在字符串左端拼接上 \(0\) 并在右端拼接上 \(1\)，或者在字符串左端拼接上 \(1\) 并在右端拼接上 \(0\)。给定的字符串为一个原字符串经过多次操作后得到的。输出最小的原字符串。 思路 遍历，找到第一个位置，满足两端的值相同。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); String in = console.next(); int cnt = 0; for(int i=0;i&lt;n/2;i++)&#123; if((in.charAt(i) == '0' &amp;&amp; in.charAt(n - i - 1) == '1') || (in.charAt(i) == '1' &amp;&amp; in.charAt(n - i - 1) == '0')) cnt ++; else break; &#125; console.println(n - cnt * 2); &#125; console.close(); &#125; &#125; 签到题 x3 D. Distinct Split 题意 给定一个字符串，将字符串分割为两个字符串，第一个字符串中不同字母的数量和第二个字符串中不同字母的数量之和最大，并输出这个最大值。 思路 维护一个前缀不同字母数量和后缀不同字母数量，然后枚举每一位，求 \(pre[i] + suf[i + 1]\) 的最大值。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); char[] s = console.next().toCharArray(); boolean[] ok1 = new boolean[26], ok2 = new boolean[26]; int[] pre = new int[n + 2], suf = new int[n + 2]; for(int i=1;i&lt;=n;i++)&#123; char e = s[i - 1]; pre[i] = pre[i - 1]; if(!ok1[e - 'a']) pre[i] ++; ok1[e - 'a'] = true; &#125; for(int i=n;i>=1;i--)&#123; char e = s[i - 1]; suf[i] = suf[i + 1]; if(!ok2[e - 'a']) suf[i] ++; ok2[e - 'a'] = true; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; ans = Math.max(ans, pre[i] + suf[i + 1]); &#125; console.println(ans); &#125; console.close(); &#125; &#125; 略微有点不签到起来了（（ E. Negatives and Positives 题意 给定一个数组 \(a\)，定义操作为选两个相邻的元素并将它们都取相反数。输出任意次操作后数组的总和的最大值。 思路 首先，因为操作数量不限制，我们不妨来考虑选几个连续的相邻元素。 举个例子，如 \([a,b,c,d,e]\)，我们从第一位开始操作到倒数第二位，操作看起来是这样的： \(\begin{array}{l} &gt;&gt; [-a, -b, c, d, e] \\ =&gt; [-a, b, -c, d, e] \\ =&gt; [-a, b, c, -d, e] \\ =&gt; [-a, b, c, d, -e]\end{array}\) 显然，只要是连续的操作，那么每次操作等效于移动负号的位置。 或者，换句话说，我们完全不需要考虑 “相邻” 这个条件，跳着操作是完全可行的。 那么，我们只需升序排序，然后将负数一对一对取反。 当然，若负数的数量为奇数，那么对于最后剩余的那个奇数，我们只需将其和最小的非负数比较绝对值即可。若负数的绝对值较大，那么直接把负数和最小非负数的符号交换一下即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); long[] a = new long[n]; long sum = 0; int cnt = 0; for(int i=0;i&lt;n;i++)&#123; int cur = console.nextInt(); sum += cur; a[i] = cur; if(a[i] &lt; 0) cnt ++; &#125; Arrays.sort(a); for(int i=0;i&lt;cnt/2*2;i++) sum -= 2 * a[i]; if(cnt % 2 == 1)&#123; int p = cnt / 2 * 2; if(p + 1 &lt; n)&#123; if(-a[p] > a[p + 1])&#123; sum -= 2 * a[p]; sum -= 2 * a[p + 1]; &#125; &#125; &#125; console.println(sum); &#125; console.close(); &#125; &#125; 简单思维题，但是也可以dp~ F. Range Update Point Query 题意 给定一个数组 \(a\) 以及 \(q\) 个询问，询问为下列情况任选其一： 给定 \(l, r\)，将 \([l,r]\) 内的所有数更新为每个数 十进制下每一位的和； 给定 \(x\)，输出 \(a_x\)。 输出询问所要求的内容。 思路 首先，询问 \(1\) 的操作具有收敛性，在 \(1e9\) 的范围内，第一次操作后的最大值只有 \(8 \times 9 = 72\)，那么我们不难发现，对于一个数，我们最多只能操作 \(3\) 次，超过 \(3\) 次后值一定不变。 我们定义一个数组 \(b\)，\(b_i\) 表示第 \(i\) 位已经操作了多少遍。 因而，我们只需考虑一个问题：怎么让区间更新和单点查询效率更高呢？ 没错，就是线段树。 不难发现，我们只需套上线段树的板子，然后略微修改即可。 时间复杂度：不会分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long int n, a[200005][4], d[600000], b[600000]; void update(int l, int r, int c, int s, int t, int p) &#123; if (l &lt;= s &amp;&amp; t &lt;= r) &#123; d[p] += (t - s + 1) * c, b[p] += c; // 如果区间被包含了，直接得出答案 return; &#125; int m = s + ((t - s) >> 1); if (b[p]) d[p &lt;&lt; 1] += b[p] * (m - s + 1), d[(p &lt;&lt; 1) | 1] += b[p] * (t - m), b[p &lt;&lt; 1] += b[p], b[(p &lt;&lt; 1) | 1] += b[p]; b[p] = 0; if (l &lt;= m) update(l, r, c, s, m, p &lt;&lt; 1); // 本行和下面的一行用来更新p*2和p*2+1的节点 if (r > m) update(l, r, c, m + 1, t, (p &lt;&lt; 1) | 1); d[p] = d[p &lt;&lt; 1] + d[(p &lt;&lt; 1) | 1]; // 计算该节点区间和 &#125; int getsum(int l, int r, int s, int t, int p) &#123; if (l &lt;= s &amp;&amp; t &lt;= r) return d[p]; int m = s + ((t - s) >> 1); if (b[p]) d[p &lt;&lt; 1] += b[p] * (m - s + 1), d[(p &lt;&lt; 1) | 1] += b[p] * (t - m), b[p &lt;&lt; 1] += b[p], b[(p &lt;&lt; 1) | 1] += b[p]; b[p] = 0; int sum = 0; if (l &lt;= m) sum =getsum(l, r, s, m, p &lt;&lt; 1); // 本行和下面的一行用来更新p*2和p*2+1的答案 if (r > m) sum += getsum(l, r, m + 1, t, (p &lt;&lt; 1) | 1); return sum; &#125; signed main() &#123; ios::sync_with_stdio(0); int t; cin >> t; while(t --) &#123; memset(a, 0, sizeof a); memset(d, 0, sizeof d); memset(b, 0, sizeof b); int q; cin >> n >> q; for (int i = 1; i &lt;= n; i++) &#123; int cur; cin >> cur; a[i][0] = cur; for(int j=1;j&lt;=3;j++)&#123; int x = a[i][j - 1]; while(x > 0)&#123; a[i][j] += x % 10; x /= 10; &#125; &#125; &#125; while (q--) &#123; int i1; cin >> i1; if(i1 == 1)&#123; int l, r; cin >> l >> r; update(l, r, 1, 1, n, 1); &#125;else&#123; int w; cin >> w; int t = getsum(w, w, 1, n, 1); t = min(3ll, t); cout &lt;&lt; a[w][t] &lt;&lt; '\n'; &#125; &#125; &#125; return 0; &#125; 不可以用Set的lower_bound来略微优雅一点地暴力，会炸 G1. Teleporters (Easy Version) 题意 给定一个数组 \(a\) 以及一个整数 \(c\)，\(c\) 为硬币的总数量，\(a_i\) 表示该传送点需要的硬币数量。定义每自主移动一步会扣除 \(1\) 个硬币，传送点是否使用是可选的，若使用传送点，将会使人物传送到原点，同时消耗对应数量的硬币。初始状态下，人物一定在原点，输出可使用传送点的最大数量。 思路 将 \(a\) 数组的所有数加上离原点的距离，升序排序 \(a\) 然后枚举即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(), c = console.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = console.nextInt() + (i + 1); Arrays.sort(a); int cnt = 0; for(int i=0;i&lt;n;i++)&#123; c -= a[i]; if(c &lt; 0) break; cnt ++; &#125; console.println(cnt); &#125; console.close(); &#125; &#125; 略微有点么签到 G2. Teleporters (Hard Version) 题意 在 \(G1\) 的基础上，传送点可以传送到原点 \(0\) 或 \(n + 1\)，但人物的初始位置一定是原点。 思路 显然，我们一定得枚举，若讨论的话，会特别复杂。 我们考虑存储 \(a_i\) 加上离两端距离的最小值，以及其加上离原点的最大值，按照前者升序排序。 然后，我们枚举所有点，对于所枚举到的点 \(a_i\)，我们将其视为第一个使用的传送点，那么剩余的硬币数量即为 \(c - a[i][1]\)。 也许我们可以像前一题那样直接遍历，但那样显然太复杂了。 我们不妨用前缀和 + 二分的方式，这样便可快速找出最大的满足条件的数量了。 当然，使用前缀和要考虑排除当前作为第一个传送点的点。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(), c = console.nextInt(); long[][] a = new long[n][2]; for(int i=0;i&lt;n;i++) &#123; int cur = console.nextInt(); a[i] = new long[]&#123;cur + Math.min(i + 1, n - i), cur + i + 1&#125;; &#125; Arrays.sort(a, Comparator.comparingLong(o -> o[0])); long[] pre = new long[n + 1]; for(int i=1;i&lt;=n;i++) pre[i] = pre[i - 1] + a[i - 1][0]; long cnt = 0; for(int i=0;i&lt;n;i++)&#123; long nc = c - a[i][1]; int l = 0, r = n, mid, max = 0; while(l &lt;= r)&#123; mid = (l + r) >> 1; if(pre[mid] - ((mid > i) ? a[i][0] : 0) &lt;= nc)&#123; max = Math.max(mid + (mid > i ? 0 : 1), max); l = mid + 1; &#125;else r = mid - 1; &#125; cnt = Math.max(cnt, max); &#125; console.println(cnt); &#125; console.close(); &#125; &#125; 草，赛时一直在分类讨论，快死了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 850 Div 2</title>
    <url>/blog/posts/2626568649/</url>
    <content><![CDATA[Contestant. Rank 530. Rating +127. 代码略去了快读模板 A1. Non-alternating Deck (easy version) 题意 给定 \(n\) 个颜色相同的卡片，取卡片顺序为 \(A,B,B,A,A,B,B,A,A,B,B,...\)，每次取卡片的数量依次递增，当无法继续取的时候，按照正常顺序，下一个取卡片的人取完所有卡片。输出 \(A,B\) 各取了多少卡片。 思路 暴力模拟。 时间复杂度：\(O(\sqrt n)?\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt() - 1; int w = 2; boolean who = false; int a = 1, b = 0, cnt = 0; while(n >= w)&#123; if(who) a += w; else b += w; n -= w; w ++; cnt ++; if(cnt == 2) &#123; who = !who; cnt = 0; &#125; &#125; if(who) a += n; else b += n; console.print(a + " " + b + "\n"); &#125; console.close(); &#125; &#125; 快速打卡 A2. Alternating Deck (hard version) 题意 给定 \(n\) 个颜色相间的卡片，第一个为白色，取卡片顺序为 \(A,B,B,A,A,B,B,A,A,B,B,...\)，每次取卡片的数量依次递增，当无法继续取的时候，按照正常顺序，下一个取卡片的人取完所有卡片。输出 \(A,B\) 各取了多少白色卡片和多少黑色卡片。 思路 暴力模拟。 多加几个变量标记即可。 时间复杂度：\(O(\sqrt n)?\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt() - 1; int w = 2; boolean who = false; int a1 = 1, b1 = 0, a2 = 0, b2 = 0, cnt = 0; while(n >= w)&#123; if(who) &#123; a1 += w / 2 + w % 2; a2 += w / 2; &#125; else &#123; b1 += w / 2; b2 += w / 2 + w % 2; &#125; n -= w; w ++; cnt ++; if(cnt == 2) &#123; who = !who; cnt = 0; &#125; &#125; if(who) &#123; a1 += n / 2 + n % 2; a2 += n / 2; &#125; else &#123; b1 += n / 2; b2 += n / 2 + n % 2; &#125; console.print(a1 + " " + a2 + " " + b1 + " " + b2 + "\n"); &#125; console.close(); &#125; &#125; 依然是快速打卡 B. Cake Assembly Line 题意 给定 \(n\) 个蛋糕的中心点 \(a\) 以及 \(n\) 个巧克力酱的固定涂抹范围的中心点 \(b\)，蛋糕的大小为 \([a_i - w, a_i + w]\)，巧克力酱的涂抹范围为 \([b_i - h, b_i + h]\)。所有蛋糕均在传送带上，且相对位置不变。输出是否可以移动传送带，让所有的巧克力酱都涂在蛋糕上。 思路 我们设 \(a_l = a[i] - w, a_r = a[i] + w, b_l = b[i] - h, b_r = b[i] + h\)。 显然，我们不可能模拟移动，因为数据范围太大了。 考虑到每一个蛋糕都有对应的最小和最大移动距离，那么我们只需枚举所有蛋糕，更新最小移动距离的最大值和最大移动距离的最小值即可，这样操作之后，\([\min,\max]\) 内的所有移动距离都可以满足条件了。 我们以左边界为参考点，那么对于一个蛋糕，移动距离的最小值为 \(br - ar\)，最大值为 \(bl - al\)。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(), w = console.nextInt(), h = console.nextInt(); long[] a = new long[n], b = new long[n]; for(int i=0;i&lt;n;i++) a[i] = console.nextInt(); for(int i=0;i&lt;n;i++) b[i] = console.nextInt(); long min = Long.MIN_VALUE, max = Long.MAX_VALUE; for(int i=0;i&lt;n;i++)&#123; long al = a[i] - w, ar = a[i] + w, bl = b[i] - h, br = b[i] + h; min = Math.max(min, br - ar); max = Math.min(max, bl - al); &#125; console.println(min &lt;= max ? "YES" : "NO"); &#125; console.close(); &#125; &#125; 只要一个参考点就够了 C. Monsters (easy version) 题意 给定一个序列 \(a\)，定义两种操作为： 选择任意一个非 \(0\) 数，将其减 \(1\)； 将整个序列所有非 \(0\) 数减 \(1\)，若减完后出现至少一个数为 \(0\)，那么本操作循环执行。 输出让整个序列为 \(0\) 的操作 \(1\) 的最小数量。 思路 显然，我们只需升序排序序列，然后构造一个不递减，相邻数之差 \(\leq 1\) 的序列即可。 如 \(1,1,1,4,4,5\)，将其构造为 \(1,1,1,2,2,3\)。 答案即为原序列和该序列的差。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = console.nextInt(); Arrays.sort(a); long cnt = 0, w = 0; for(int i=0;i&lt;n;i++)&#123; if(a[i] != w)&#123; w ++; cnt += a[i] - w; &#125; &#125; console.println(cnt); &#125; console.close(); &#125; &#125; 逾越丁真，鉴定为不开long long D. Letter Exchange 题意 给定 \(m\) 个由 \(w,i,n\) 构成的长度为 \(3\) 的字符串，定义一次操作为指定两个人互换他们的任意一个字符。输出操作数的最小值以及对应的操作方案。 思路 思维+模拟。 首先，由于题给限制，方案一定是存在的，那么互换字符会出现两种可能： \(A\) 缺了 \(a\)，但多了 \(b\)；\(B\) 缺了 \(b\)，但多了 \(a\)；那么 \(A,B\) 交换一下； \(A\) 缺了 \(a\)，但多了 \(c\)；\(B\) 缺了 \(c\)，但多了 \(b\)；\(C\) 缺了 \(b\)，但多了 \(a\)；那么三者互换一下。 对于上述操作，操作 \(1\) 的交换次数是 \(1\)，操作 \(2\) 的交换次数是 \(2\)。 显然，若只执行上面的两个操作，只要不出现无意义操作，操作数一定是最小的。 那么，我们可以执行完所有操作 \(1\) 后再执行操作 \(2\)，因为配对是最容易的，而且配对结束后，剩下的字符一定是满足操作 \(2\) 的条件的。 那么我们可以用数组存储所有 多 \(a\) 少 \(b\) 的数量，然后略微暴力模拟一下即可。 时间复杂度：懒得分析 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); List&lt;List&lt;Integer>> a = new ArrayList&lt;>(); for(int i=0;i&lt;6;i++) a.add(new ArrayList&lt;>()); //0 wi, 1 wn, 2 iw, 3 in, 4 nw, 5 ni for(int i=1;i&lt;=n;i++)&#123; String now = console.next(); int[] cnt = new int[3]; for(int j=0;j&lt;3;j++)&#123; char e = now.charAt(j); if(e == 'w') cnt[0] ++; else if(e == 'i') cnt[1] ++; else cnt[2] ++; &#125; if(cnt[0] == 1 &amp;&amp; cnt[1] == 1 &amp;&amp; cnt[2] == 1) continue; if(cnt[0] == 3) &#123; a.get(0).add(i); a.get(1).add(i); &#125;else if(cnt[1] == 3)&#123; a.get(2).add(i); a.get(3).add(i); &#125;else if(cnt[2] == 3)&#123; a.get(4).add(i); a.get(5).add(i); &#125;else if(cnt[0] == 2 &amp;&amp; cnt[1] == 0)&#123; a.get(0).add(i); &#125;else if(cnt[0] == 2 &amp;&amp; cnt[2] == 0)&#123; a.get(1).add(i); &#125;else if(cnt[1] == 2 &amp;&amp; cnt[0] == 0)&#123; a.get(2).add(i); &#125;else if(cnt[1] == 2 &amp;&amp; cnt[2] == 0)&#123; a.get(3).add(i); &#125;else if(cnt[2] == 2 &amp;&amp; cnt[0] == 0)&#123; a.get(4).add(i); &#125;else if(cnt[2] == 2 &amp;&amp; cnt[1] == 0)&#123; a.get(5).add(i); &#125; &#125; int cnt = Math.min(a.get(0).size(), a.get(2).size()) + Math.min(a.get(1).size(), a.get(4).size()) + Math.min(a.get(3).size(), a.get(5).size()); int left = Math.max(a.get(0).size(), a.get(2).size()) + Math.max(a.get(1).size(), a.get(4).size()) + Math.max(a.get(3).size(), a.get(5).size()) - cnt; cnt += left / 3 * 2; console.println(cnt); for(int i=0;i&lt;Math.min(a.get(0).size(), a.get(2).size());i++)&#123; console.println(a.get(0).get(i) + " w " + a.get(2).get(i) + " i"); &#125; for(int i=0;i&lt;Math.min(a.get(1).size(), a.get(4).size());i++)&#123; console.println(a.get(1).get(i) + " w " + a.get(4).get(i) + " n"); &#125; for(int i=0;i&lt;Math.min(a.get(3).size(), a.get(5).size());i++)&#123; console.println(a.get(3).get(i) + " i " + a.get(5).get(i) + " n"); &#125; if(left > 0) &#123; boolean b1 = a.get(0).size() > a.get(2).size(), b2 = a.get(1).size() > a.get(4).size(), b3 = a.get(3).size() > a.get(5).size(); for (int i = 0; i &lt; left / 3; i++) &#123; if(b1 &amp;&amp; !b2 &amp;&amp; b3)&#123; console.println(a.get(0).get(a.get(2).size() + i) + " w " + a.get(3).get(a.get(5).size() + i) + " i"); console.println(a.get(4).get(a.get(1).size() + i) + " n " + a.get(3).get(a.get(5).size() + i) + " w"); &#125;else&#123; console.println(a.get(2).get(a.get(0).size() + i) + " i " + a.get(1).get(a.get(4).size() + i) + " w"); console.println(a.get(5).get(a.get(3).size() + i) + " n " + a.get(1).get(a.get(4).size() + i) + " i"); &#125; &#125; &#125; &#125; console.close(); &#125; &#125; 依托答辩，但是Accepted.]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 6</title>
    <url>/blog/posts/3918832662/</url>
    <content><![CDATA[Rank 663/3064. AC 7/12. A. 阿宁的签到题 题意 根据分数输出等级。 思路 一门编程语言的基础之基础。 时间复杂度：\(O(1)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long x = scanner.nextLong(); if(1 &lt;= x &amp;&amp; x &lt;= 7) System.out.println("very easy"); else if(x &lt;= 233) System.out.println("easy"); else if(x &lt;= 10032) System.out.println("medium"); else if(x &lt;= 114514) System.out.println("hard"); else if(x &lt;= 1919810) System.out.println("very hard"); else System.out.println("can not imagine"); &#125; &#125; 送分还不写快点啊（（ B. 阿宁的倍数 题意 给定一个长度为 \(n\) 的数组 \(a\)，下标从 \(1\) 开始，对于 \(q\) 次操作，输出需要输出的内容。 操作分为两种： 修改操作：数组末尾增加一个数 \(x\)。 询问操作：对于所有 \(i&gt;x\)，输出有多少 \(a_i\) 是 \(a_x\) 的倍数。 思路 我们考虑维护两个数组 \(tot,pre\)。 其中，\(tot[a[i]]\) 表示整个序列有多少数是 \(a[i]\) 的倍数，\(pre[i]\) 表示 \([0, i]\) 区间内有多少数是 \(a[i]\) 的倍数。 那么，对于每次查询的 \(x\)，输出 \(tot[a[x]]-pre[x]\) 即可。 我们来考虑一下这两个数组如何构建： 我们可以从前往后遍历，枚举 \(a[i]\) 的所有因数 \(j\)，将所有 \(tot[j]\) 加上 \(1\)，那么我们可以保证最后得到的 \(tot\) 是我们想要的数组，与此同时， 按照上述遍历方法，\(tot[a[i]]\) 就是 \(pre[i]\) 的值。 在修改操作时，我们只需在加入新加的数 \(x\) 的同时，更新 \(tot,pre\) 即可。 时间复杂度：\(O(n \sqrt n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 400010; int a[N], tot[N], pre[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, q; cin >> n >> q; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; for(int j=1;j&lt;=a[i]/j;j++)&#123; if(a[i] % j == 0)&#123; tot[j] ++; if(j != a[i] / j) tot[a[i] / j] ++; &#125; &#125; pre[i] = tot[a[i]]; &#125; while(q --)&#123; int op, x; cin >> op >> x; if(op == 1)&#123; a[++ n] = x; for(int j=1;j&lt;=a[n]/j;j++)&#123; if(a[n] % j == 0)&#123; tot[j] ++; if(j != a[n] / j) tot[a[n] / j] ++; &#125; &#125; pre[n] = tot[a[n]]; &#125;else cout &lt;&lt; tot[a[x]] - pre[x] &lt;&lt; '\n'; &#125; return 0; &#125; 比较暴力但又不太暴力的做法 C. 阿宁的大背包 题意 给定背包的数量 \(n\)，\(n\) 个背包的大小构成一个 \(n\) 的排列，按照将相邻背包合成一个新的大背包的方式，经过 \(n-1\) 次合并，得到一个大背包。输出一个排列，满足最终背包最大，并输出值。 合并方式：\([a, b, c, d] =&gt; [a + b , b + c , c + d]\) 思路 我们直接来考虑 \(5\) 个物品时的合并结果： \(\begin{array}{l}&gt;&gt;[a, b, c, d, e] \\ =&gt; [a + b, b + c, c + d, d + e] \\ =&gt; [a + 2b + c, b + 2c + d, c + 2d + e] \\ =&gt; [a + 3b + 3c + d, b + 3c + 3d + e] \\ =&gt; [a + 4b + 6c + 4d + e] \end{array}\) 我们不妨留意一下从第二次合并后每项的系数，没错，就是杨辉三角。 于是，构建数组就非常明显了：我们只要按 中间向两侧递减 排列即可。 接着，考虑到数据范围并不大，于是下列两种方法均可行： 暴力合并； 计算出杨辉三角，作为系数和数组相乘。 考虑到暴力合并更不用脑子，这边采取方案 \(1\)。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int n = console.nextInt(); long mod = 1000000007; int[] a = new int[n]; for(int i=0;i&lt;n/2;i++) a[i] = i * 2 + 1; if(n % 2 == 1) a[n / 2] = n; for(int i=0;i&lt;n/2;i++) a[n - i - 1] = (i + 1) * 2; List&lt;Integer> ans = new ArrayList&lt;>(); for(int i=0;i&lt;n;i++) ans.add(a[i]); for(int t=n;t>=2;t--)&#123; List&lt;Integer> now = new ArrayList&lt;>(); for(int i=0;i&lt;t-1;i++) now.add((int)(((long) ans.get(i) + ans.get(i + 1)) % mod)); ans = now; &#125; console.println(ans.get(0)); for(int i=0;i&lt;n;i++) console.print(a[i] + " "); console.close(); &#125; //快读模板，此处略去 //public static class Console implements Closeable &#123;&#125; &#125; 优雅的暴力 D. 阿宁的毒瘤题 题意 给定一个字符串 \(s\)，修改任意一个字符为其他字符，让子序列 \(udu\) 的数量最小，子序列不一定连续。输出修改后的 \(s\)。 思路 不是 \(dp\) !!!! 首先，如果不删掉字符的话，做法就是很简单的 \(dp\)，但这题如果用 \(dp\) 解的话，会特别麻烦，且我无法证明正确性。 反而，这题是一道偏模拟的前缀和。 我们分别考虑删掉一个 \(d\) 和删掉一个 \(u\) 的代价： 对于一个 \(d\)，它的价值为 \(u_{pre} \times u_{suf}\)； 对于一个 \(u\)，它的价值为 \(ud_{pre} + du_{suf}\)。 于是，我们可以考虑前缀和的方法，统计正方向第 \(i\) 位前面有多少 \(u\)，反方向后面有多少 \(u\) 即可。 注意，不止有 \(u,d\) 这两个字符，不要偷懒不写 \(else\ if\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010, inf = 0x3f3f3f3f; int pre[N], ps[N], ss[N]; string s; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> s; int n = s.length(); int cu = 0; for(int i=0;i&lt;n;i++) if(s[i] == 'u') cu ++; int maxx = 0, maxi = 0; for(int i=0;i&lt;n;i++)&#123; if(i > 0) &#123; pre[i] = pre[i - 1]; ps[i] = ps[i - 1]; &#125; if(s[i] == 'u')&#123; pre[i] ++; &#125;else if(s[i] == 'd')&#123; if(maxx &lt; pre[i] * (cu - pre[i]))&#123; maxx = pre[i] * (cu - pre[i]); maxi = i; &#125; ps[i] += pre[i]; &#125; &#125; for(int i=n-1;i>=0;i--)&#123; ss[i] = ss[i + 1]; if(s[i] == 'd') ss[i] += (cu - pre[i]); else if(s[i] == 'u')&#123; if(maxx &lt; ps[i] + ss[i])&#123; maxx = ps[i] + ss[i]; maxi = i; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) cout &lt;&lt; (maxi == i ? 'a' : s[i]); &#125; 做了一个小时dp，最后10分钟才大彻大悟，人快哭出来力 E. 阿宁的生成树 待补充 F. 阿宁的二进制 题意 给定一个长度为 \(n\) 的数组 \(a\)，下标从 \(1\) 开始，定义 \(F(x)=cnt_1\ of\ binary\ x\)。如 \(F(5)=2\)。 对于独立的 \(q\) 次询问，定义一次操作为选定任意一个 \(i\)，执行 \(a_i=F(a_i)\)。给定操作数 \(k\) ，输出 整个数组的最大值 的最小值。 每次询问输出答案后，数组 \(a\) 恢复原样。 思路 我们不妨来考虑 \(1e9\) 范围内二进制下 \(1\) 最多的数，它总共有 \(30\) 个 \(1\)。 对于最大值 \(30\)，我们可以知道，第二次操作后最多只会有 \(4\) 个 \(1\)。 继续操作，剩下最多 \(2\) 个 \(1\)； 继续操作，剩下 \(1\) 个 \(1\)。 也就是说，对于任意 \(1e9\) 范围内的数，我们最多也只能进行 \(4\) 次操作，之后值就为固定的 \(1\)。 换句话说，题给 \(k\) 的范围是唬人的，真正 \(k\) 的范围应为 \(8 e 5\)。 那么，我们不妨先将所有询问都读入，然后桶排序一下，再枚举操作 \(p\) 次后的答案，若次数和询问相同，那么记录答案。我们不妨用大根堆来存储，让时间复杂度降到 \(k \log k\)。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010; pair&lt;int, int> qs[N]; int ans[N]; int F(int x) &#123; int cnt = 0; while (x != 0) &#123; if ((x &amp; 1) == 1) cnt++; x >>= 1; &#125; return cnt; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, q; cin >> n >> q; priority_queue&lt;int> pq; for(int i=0;i&lt;n;i++) &#123; int t; cin >> t; pq.emplace(t); &#125; for(int i=0;i&lt;q;i++)&#123; int t; cin >> t; qs[i] = &#123;t, i&#125;; &#125; sort(qs, qs + q, [](pair&lt;int, int> o1, pair&lt;int, int> o2)&#123;return o1.first &lt; o2.first;&#125;); int i = 0, to = 0; while(to &lt; q)&#123; int t = pq.top(); if(t == 1) break; pq.pop(); i ++; pq.push(F(t)); while(to &lt; q &amp;&amp; qs[to].first == i) ans[qs[to ++].second] = pq.top(); &#125; for(int t=0; t &lt; q; t++) &#123; if(ans[t] == 0) cout &lt;&lt; 1 &lt;&lt; '\n'; else cout &lt;&lt; ans[t] &lt;&lt; '\n'; &#125; &#125; 自从上次做过某题后，老想着会不会可以收敛（（ G. 阿宁的整数配对 题意 给定一个长度为 \(n\) 的数组 \(a\)，选出 \(k\) 对整数，输出每对整数相乘并求和的最大值。 思路 排一个序，从两端取即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), k = scanner.nextInt(); long[] a = new long[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); int l = 0, r = n - 1; long ans = 0; for(int i=0;i&lt;k;i++)&#123; if(a[l] * a[l + 1] > a[r] * a[r - 1])&#123; ans += a[l] * a[l + 1]; l += 2; &#125;else&#123; ans += a[r] * a[r - 1]; r -= 2; &#125; &#125; System.out.println(ans); &#125; &#125; 打卡打卡~ H. 阿宁讨伐虚空 题意 给定 \(x\) 个敌人，在 \([L,R]\) 内随机选一个 \(y\) ，若 \(y &lt; x\)，那么敌人能被攻击到。输出能被攻击到的概率。 思路 如题，分类讨论算一下概率即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 100010; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int x, l, r; cin >> x >> l >> r; if(l > x - 1) cout &lt;&lt; 0; else if(r &lt; x) cout &lt;&lt; 1; else cout &lt;&lt; ((double) (x - l) / (double) (r - l + 1)); &#125; 简简单单签到题 I. 阿宁前往沙城 题意 给定一个无向图，定义操作为选定两条边，将一条边删除，并将另一条边的长度改为 \(1\)。在 操作可在任意时间可执行无限次 的条件下，输出 \(1\) 到 \(n\) 的最短路。 思路 很显然，从第二条路开始，我们直接把前面的路毁掉即可。 所以我们不妨直接把所有边改成 \(1\)，用 \(dijkstra\) 跑一遍最短路即可。 但得到的答案会出现一种特殊情况：最短路将所有边都覆盖了。 在该情况下，第一条只能用原来的长度替代了。 因此，直接套板子然后略微修改一下即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010; struct edge &#123; int v, w; &#125;; struct node &#123; int dis, u; bool operator>(const node&amp; a) const &#123; return dis > a.dis; &#125; &#125;; vector&lt;edge> e[N]; int dis[N], vis[N], cnt[N]; priority_queue&lt;node, vector&lt;node>, greater&lt;> > q; void dijkstra(int s) &#123; memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; q.push(&#123;0, s&#125;); while (!q.empty()) &#123; int u = q.top().u; q.pop(); if (vis[u]) continue; vis[u] = 1; for (auto ed : e[u]) &#123; int v = ed.v, w = ed.w; if (dis[v] > dis[u] + w) &#123; dis[v] = dis[u] + w; cnt[v] = cnt[u] + 1; q.push(&#123;dis[v], v&#125;); &#125; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; int minn = 0x3f3f3f3f; for(int i=0;i&lt;m;i++)&#123; int u, v, w; cin >> u >> v >> w; if(u == 1 || v == 1) minn = min(minn, w); e[u].push_back(&#123;v, 1&#125;); e[v].push_back(&#123;u, 1&#125;); &#125; dijkstra(1); cout &lt;&lt; (cnt[n] &lt; m ? cnt[n] : dis[n] + minn - 1); &#125; oi-wiki的板子真好用（划掉 J. 阿宁指指点点 待补充 K. 阿宁大战小红 待补充 L. 阿宁睡大觉 题意 给定一个 \(n\) 行 \(n-i+1\) 列的地图（正方形的左上角），每行的最后一个格子是美梦格子，除 \(m\) 个噩梦格子外，其余格子都可以通过，输出从 \((1,1)\) 走到美梦格子的方案总数。 注意，\(m \leq 10\)。 思路 这题有一个很明显的特点：障碍数远小于总格子数。 不考虑噩梦格子的话，总方案数很好求，即为 \(2^{n-1}\)。但若用类似于 \(dfs\) 的方法去枚举能走的路径，显然是过于复杂的。 有没有一种算法，可以用类似于取补集的方法来大大降低时间复杂度呢？ 也许我们可以枚举不能走的路径，但暴力枚举也是不行的。 这里需要用到 容斥 。 对于两个噩梦格子，它们之间的方案数可以用组合数来求： 每条路径的节点数量是一致的，为 \((\Delta x - 1) + (\Delta y - 1)\)，而每条路径一定会有 \(\Delta x - 1\) 个节点是在 \(x\) 轴方向移动的，所以方案数即为 \(C_{\Delta x + \Delta y - 2}^{\Delta x - 1}\)。 于是，我们只需枚举所有选择即可，这里我们可以考虑用二进制进行状态压缩，直接用二进制位是否是 \(1\) 来考虑这个噩梦节点是否选上。当然也可以无脑递归套 \(for\)，但状压会更好写。 还有一个问题，若我们每次都算一遍两个节点的方案数，未免有些复杂，所以我们可以用 \(O1\) 复杂度的组合数求法。 容斥 我们来考虑三个集合，它们两两相交，且有一部分三个相交在一起，如下图： 容斥原理 - venn 图示例 对，这是一个韦恩图，而且我们可以很容易的得到下面这个式子： \(|A \cup B \cup C| = |A| + |B| + |C| - |A \cap B| - |B \cap C| - |C \cap A| + |A \cap B \cap C|\) 推广之后，对于 \(n\) 个集合的并集，我们只需按上述式子写，其中符号取决于选了几个集合，奇数为正偶数为负。 因而，对于所有噩梦格子的走法，利用容斥即可解决。 线性复杂度的组合数求法 显然，当数据量过大的时候，每次都用一遍 \(for\) 循环是不合理的，那么我们可以考虑预处理阶乘。 由于存在除法取模，我们需要用到乘法逆元，将除法取模转化为乘法取模。 逆元有一个很简单的求法，即费马小定理：对于 \(ab \equiv 1\ (\mod p)\)，乘法逆元 \(b = a ^ {p - 2}\)。 但每次用一遍快速幂也会提高时间复杂度，因而我们考虑线性求逆元，用到如下递推式： \(inv[i] = (mod - mod / i) \times inv[mod\%i] \ \%mod\) 对于阶乘的逆元，满足 \(facInv[i] = facInv[i - 1] \times inv[i]\ \% mod\) 满足上述条件后，\(C_n^m = fac[n] \times facInv[m]\ \% mod \times facInv[n - m]\ \% mod\)。 线性求逆元的证明 img 时间复杂度：\(O(m \times 2 ^ m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 400010, mod = 1e9 + 7; pii a[N], b[N]; int n, m, inv[N], fac[N], facInv[N], pow2[N]; //O1复杂度求组合数 int c(int n, int m)&#123; return fac[n] * facInv[m] % mod * facInv[n - m] % mod; &#125; signed main() &#123; ios::sync_with_stdio(0); cin >> n >> m; for(int i=0;i&lt;m;i++) cin >> a[i].first >> a[i].second; inv[1] = fac[0] = fac[1] = facInv[0] = facInv[1] = pow2[0] = 1; for(int i=2;i&lt;=n*2;i++)&#123; inv[i] = (mod - mod / i) * inv[mod % i] % mod; fac[i] = fac[i - 1] * i % mod; facInv[i] = facInv[i - 1] * inv[i] % mod; &#125; for(int i=1;i&lt;=n;i++) pow2[i] = pow2[i - 1] * 2 % mod; int ans = pow2[n - 1]; for(int i=1;i&lt;(1 &lt;&lt; m);i++)&#123; int t = 0; b[t ++] = &#123;1, 1&#125;; int sign = 1; for(int j=0;j&lt;m;j++)&#123; if((i >> j) &amp; 1)&#123; b[t ++] = a[j]; sign = -sign; &#125; &#125; sort(b, b + t); int now = pow2[n - 1 - (b[t - 1].first + b[t - 1].second - 2)]; for(int j=1; j &lt; t; j++)&#123; if(b[j - 1].second &lt;= b[j].second)&#123; int x = b[j].first - b[j - 1].first + 1, y = b[j].second - b[j - 1].second + 1; now = now * c(x + y - 2, x - 1) % mod; &#125;else&#123; now = 0; break; &#125; &#125; ans += sign * now; &#125; ans = (ans % mod + mod) % mod; cout &lt;&lt; ans &lt;&lt; '\n'; return 0; &#125; 有点震撼的说...]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 848 Div 2</title>
    <url>/blog/posts/1674252080/</url>
    <content><![CDATA[Contestant. Rank 2756. Rating +40. A. Flip Flop Sum 题意 给定一个只包含 \(1,-1\) 的序列，要求必须进行一次操作，将任意 \(i\) 对应的 \(a_i,a_{i+1}\) 的值取反，输出操作后序列总和的最大值。 思路 显然，若序列是 \(1,-1,1,-1,...\) ，那么操作对总和无影响。 当序列中存在 \(-1,-1\) 时，总和加 \(4\)。 其余情况，即序列中全是 \(1\)，总和减 \(4\)。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int sum = 0, pre = scanner.nextInt(); sum += pre; boolean f1 = false, f2 = false; for(int i=1;i&lt;n;i++)&#123; int a = scanner.nextInt(); sum += a; if(a == pre)&#123; if(!f1) &#123; if (a == -1)&#123; sum += 4; f1 = true; &#125; &#125; &#125;else f2 = true; pre = a; &#125; if(!f1 &amp;&amp; !f2) sum -= 4; System.out.println(sum); &#125; &#125; &#125; 别看错题啊喂 B. The Forbidden Permutation 题意 给定长度为 \(n\) 的排列 \(p\)、长度为 \(m\) 的数组 \(a\)、以及一个正整数 \(d\)，其中数组 \(a\) 无重复元素，且对于任意 \(a_i\) 满足 \(a_i \in [1,n]\) 。定义一次操作为交换相邻元素，输出最少的操作数，满足存在 \(i \in [1,m)\)，有 \(p[a_i] \geq p[a_{i+1}]\) 或 \(p[a_{i+1}] &gt; p[a_i] + d\)。 思路 显然，我们令 \(b[i]=p[a_i]\)，那么只要数组 \(b\) 是非递增的，就无需操作。 否则，我们可以执行下面的两个操作： 找出数组 \(b\) 中相邻差值最小的两个元素，将它们交换位置； 找出数组 \(b\) 中相邻差值最大的两个元素，将小的元素向左移，大的元素向右移，直至距离大于 \(d\)。 因为我们无需考虑最后数组的情况，所以我们只需计算一下即可： 对于操作 \(1\)，\(cnt=dist_{\min}\)； 对于操作 \(2\)，\(cnt=d-dist_{\max}+1\)。 显然，当 \(d\) 过大时，我们无法将元素的距离扩大到 \(d\)，此时只能执行操作 \(1\)。 时间复杂度：\(O(m)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0) &#123; int n = scanner.nextInt(), m = scanner.nextInt(), d = scanner.nextInt(); int[] p = new int[n + 1]; for(int i=1;i&lt;=n;i++) p[scanner.nextInt()] = i; int[] a = new int[m + 1]; int minDist = Integer.MAX_VALUE, maxDist = 0; for(int i=1;i&lt;=m;i++)&#123; a[i] = scanner.nextInt(); a[i] = p[a[i]]; if(i >= 2)&#123; minDist = Math.min(minDist, a[i] - a[i - 1]); maxDist = Math.max(maxDist, a[i] - a[i - 1]); &#125; &#125; if(minDist &lt;= 0 || maxDist > d) System.out.println(0); else&#123; if(d - maxDist + 1 > n - maxDist - 1) System.out.println(minDist); else System.out.println(Math.min(minDist, d - maxDist + 1)); &#125; &#125; &#125; &#125; 分类讨论呐 C. Flexible String 题意 给定两个字符串 \(a,b\)，满足字符串 \(a\) 最多只有 \(10\) 种不同的字母，定义一次操作为： 选择一个 \(i\)，将 \(a_i\) 放入集合 \(Q\)； 任意挑选一个字母，将其放入 \(a_i\)。 其中，集合 \(Q\) 内需要满足最多只有 \(k\) 个不同的字母。 寻找操作方案，让 \(a[l,r]=b[l,r],1 \leq l \leq r \leq n\) 的数量最大，并输出这个最大值。 \(x_1[l,r]=x_2[l,r]\) 表示对于 \(x1,x2\)，它们在 \([l,r]\) 区间内的所有字符都一样。 思路 首先，我们只需考虑选 \(k\) 种不同的字母然后将其标记，最后遍历一遍计算答案即可。 因为数据量较小，且我们无需考虑选择字母的先后，那么 \(Dfs\) 可行。 更具体地说，我们只需找出所有满足 \(a[i] \neq b[i]\) 的 \(a[i]\) 的字母种类 \(cnt\)，然后枚举所有长度为 \(k\) 的组合并计算答案的最大值即可。 暴力即可。 时间复杂度：\(O(C_{cnt}^k \times n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 100010; int n, k; char a[N], b[N]; bool same[N]; char cnt[26]; int ans; vector&lt;int> w; bool use[26]; void dfs(int p, int t)&#123; if(t == k)&#123; int tot = 0, cur = 0; for(int i=0;i&lt;n;i++)&#123; if(same[i] || use[a[i] - 'a']) tot ++; else&#123; cur += (tot + 1) * tot / 2; tot = 0; &#125; &#125; if(tot != 0) cur += (tot + 1) * tot / 2; ans = max(ans, cur); &#125;else&#123; for(int i=p+1;i&lt;w.size();i++)&#123; use[w[i]] = true; dfs(i, t + 1); use[w[i]] = false; &#125; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while (t--) &#123; memset(cnt, 0, sizeof cnt); cin >> n >> k >> a >> b; for (int i = 0; i &lt; n; i++) &#123; if (a[i] == b[i]) same[i] = true; else cnt[a[i] - 'a']++, same[i] = false; &#125; w.clear(); int sum = 0; for (int i = 0; i &lt; 26; i++) &#123; if (cnt[i]) &#123; w.emplace_back(i); sum ++; &#125; &#125; if (k == 0) &#123; int tot = 0, cur = 0; for (int i = 0; i &lt; n; i++) &#123; if (same[i]) tot++; else &#123; cur += (tot + 1) * tot / 2; tot = 0; &#125; &#125; if (tot != 0) cur += (tot + 1) * tot / 2; cout &lt;&lt; cur &lt;&lt; '\n'; &#125; else &#123; if (sum - k &lt;= 0) &#123; cout &lt;&lt; (n + 1) * n / 2 &lt;&lt; '\n'; &#125; else &#123; ans = 0; for (int i = 0; i &lt;= sum - k; i++) &#123; use[w[i]] = true; dfs(i, 1); use[w[i]] = false; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; &#125; &#125; 不要忘了初始化啊啊啊啊，在功亏一篑中屈服.jpg]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 5</title>
    <url>/blog/posts/1889400236/</url>
    <content><![CDATA[Rank 379/3037. AC 7/12. A. 小沙の好客 题意 给定 \(n\) 个商品，对于 \(Q\) 个询问，挑选最多 \(k\) 个价值不大于 \(x\) 的商品，输出价值和的最大值。 思路 二分前缀和。 或者使用 \(stl\) 里的 \(upperbound\)。 时间复杂度：\(O(n+\log n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), q = scanner.nextInt(); long[] a = new long[n + 1]; for(int i=1;i&lt;=n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); long[] sum = new long[n + 1]; for(int i=1;i&lt;=n;i++) sum[i] = sum[i - 1] + a[i]; while(q -- > 0)&#123; int k = scanner.nextInt(), x = scanner.nextInt(); int l = 1, r = n, mid; while (l &lt;= r) &#123; mid = (l + r) >> 1; if (a[mid] &lt;= x) l = mid + 1; else r = mid - 1; &#125; if(r >= k) System.out.println(sum[r] - sum[r - k]); else System.out.println(sum[r]); &#125; &#125; &#125; 二分别忘了咋写啊草 B. 小沙の博弈 题意 两个很聪明的人进行博弈，每个人面前有无数多个格子，每个格子可以放无限个石子。给定 \(n\) 个石子，两个人交替操作，每次操作可以从这对石子里拿出任意数量的石子并放入第一个没有石子的格子里。 胜负取决于两人面前格子的字典序大小，字典序小的人获胜。 思路 显然，要让字典序小，聪明的人绝对会只拿 \(1\) 个，那么整个问题就简化为对 \(n\) 的奇偶性判断了。 \(n\) 为奇数的时候，后手赢，\(n\) 为偶数的时候，平局。 先手没有必胜策略。 时间复杂度：\(O(1)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); System.out.println(n % 2 == 0 ? "win-win!" : "Yaya-win!"); &#125; &#125; 你这先手怎么这么菜啊.jpg C. 小沙の不懂 题意 对于两个可能含有前导 \(0\) 的数字 \(a,b\)，以及一个长度为 \(10\) 且从 \(0\) 开始的排列 \(p\)，给定 \(a,b\) 按照排列 \(p\) 进行映射操作后的数，数字可能也有前导 \(0\)，判断能否确定原数 \(a,b\) 的大小关系。 注：映射操作指 \(t_i=p_{a_i}\) 思路 分类讨论题。 我们设给定的数为 \(n,m\)，对应于 \(a,b\)。 若 \(n\) 和 \(m\) 的长度相同：若它们完全一致，那么 \(a\) 和 \(b\) 相等；否则无法判断。 若 \(n\) 的长度大于 \(m\)，那么我们先考虑将 \(n\) 和 \(m\) 右对齐后多出来的部分 \(t\)，因为考虑到前导 \(0\)，若 \(t\) 中有至少两个不同的数字，那么 \(t\) 对应的原数部分一定有一个数不是 \(0\)，那么 \(n\) 的位数一定比 \(m\) 多，\(n&gt;m\)；否则，我们设 \(t\) 中唯一出现的数为 \(x\) ，那么我们只要判断 \(n\) 剩下部分的最高位和 \(m\) 的最高位是否都是 \(x\) 即可，如果是的话就无法判断，否则 \(n\) 依旧大于 \(m\)。 反之同理。 时间复杂度：懒得分析 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String a = scanner.next(), b = scanner.next(); int la = a.length(), lb = b.length(); if(a.equals(b)) System.out.println("="); else if(la > lb)&#123; char p = a.charAt(0); boolean f = false; for(int i=1;i&lt;la-lb;i++) &#123; if(a.charAt(i) != p)&#123; f = true; break; &#125; &#125; if(f) System.out.println(">"); else&#123; if(b.charAt(0) == p &amp;&amp; a.charAt(la - lb) != p) System.out.println(">"); else System.out.println("!"); &#125; &#125; else if(lb > la)&#123; char p = b.charAt(0); boolean f = false; for(int i=1;i&lt;lb-la;i++) &#123; if(b.charAt(i) != p)&#123; f = true; break; &#125; &#125; if(f) System.out.println("&lt;"); else&#123; if(a.charAt(0) == p &amp;&amp; b.charAt(lb - la) != p) System.out.println("&lt;"); else System.out.println("!"); &#125; &#125;else System.out.println("!"); &#125; &#125; 题目太阅读理解了 D. 小沙の赌气 题意 两个人打游戏，打下一关需要满足前一关通关。对于每一个人，每轮会给定 \(1\) 个 \([l,r]\) 区间，只要 \(l-1\) 关已通关，那么 \([l,r]\) 内的所有关都瞬间通关，区间可保留到后面使用。输出每一轮的领先情况以及领先数量。 思路 对于一个人的通关情况，我们可以用一个数 \(num\) 来表示，对于每一个区间，我们可以判断它的左边界和 \(num+1\) 的大小关系，若大于，那么无法合并区间，我们将其存下来，否则，我们用右边界更新 \(num\)。 在每次 \(num\) 更新后，因为我们有区间存下来，所以我们需要判断是否可以继续合并。于是，我们可以维护一个左边界的小根堆，将所有左边界 \(\leq num+1\) 的区间全都更新一遍即可。 于是乎，我们比较 \(num\) 即可。 时间复杂度：\(O(n \log k)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.AtomicInteger; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[][] x = new int[n][2], y = new int[n][2]; for(int i=0;i&lt;n;i++) x[i] = new int[]&#123;scanner.nextInt(), scanner.nextInt()&#125;; for(int i=0;i&lt;n;i++) y[i] = new int[]&#123;scanner.nextInt(), scanner.nextInt()&#125;; AtomicInteger num1 = new AtomicInteger(0), num2 = new AtomicInteger(0); PriorityQueue&lt;int[]> q1 = new PriorityQueue&lt;>(Comparator.comparingInt(o -> o[0])), q2 = new PriorityQueue&lt;>(Comparator.comparingInt(o -> o[0])); for(int i=0;i&lt;n;i++)&#123; work(x[i], num1, q1); work(y[i], num2, q2); System.out.println(num1.get() == num2.get() ? "win_win!" : (num1.get() > num2.get() ? "sa_win!" : "ya_win!")); System.out.println(Math.abs(num1.get() - num2.get())); &#125; &#125; private static void work(int[] now, AtomicInteger num, PriorityQueue&lt;int[]> q)&#123; if(now[0] > num.get() + 1)&#123; q.offer(now); &#125;else&#123; int r = Math.max(num.get(), now[1]); while(!q.isEmpty())&#123; int[] c = q.peek(); if(c[0] &lt;= r + 1)&#123; q.poll(); r = Math.max(r, c[1]); &#125;else break; &#125; num.set(r); &#125; &#125; &#125; woc怎么这么简单 E. 小沙の印章 待补充 F. 小沙の串串 题意 给定一个字符串 \(n\)，定义一次操作为任意选择一个字符并将其移到最后，输出 \(k\) 次操作后字典序最大的字符串。 思路 因为考虑到字典序的贪心性：只要比较第一个不相同的字符即可判断字典序的大小。 也就是说，我们只需让前几位尽可能大即可。 那么，若两个字母之间存在比他们小的数，我们就可以考虑维护一个 \(l\)，将 \(l+k\) 内的所有元素都移到后面。 对于字符串的输出，我们可以用三个字符串分开存储，最后拼接在一起。 更具体地说，我们可以从大到小枚举所有字母，并从前往后枚举 \([l,l+k]\) 内的该字母，将这些字母全都移到后面，并更新 \(l,k\)。更新之后，可能存在剩余未移到后面的字母，因而在上一个操作前，我们可以直接把 \(l\) 之前的字母删除。 时间复杂度：\(O(n)?\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 100010; queue&lt;int> q[30]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, k; cin >> n >> k; string s, s1, s2, s3; cin >> s; for(int i=0;i&lt;n;i++)&#123; q[s[i] - 'a'].emplace(i); &#125; int l = 0, l1 = 0; while(k)&#123; for(int i=25;i>=0;i--)&#123; while(!q[i].empty() &amp;&amp; q[i].front() &lt; l) q[i].pop(); if(!q[i].empty() &amp;&amp; q[i].front() &lt;= l + k)&#123; int t = q[i].front(); q[i].pop(); k -= t - l; while(l &lt; t) s2 += s[l ++]; s1 += s[l ++]; l1 ++; break; &#125; &#125; if(l == n) break; &#125; for(int i=l;i&lt;n;i++) s3 += s[i]; while(!s1.empty() &amp;&amp; k)&#123; s2 += s1[l1 -- - 1]; s1.pop_back(); k --; &#125; sort(s2.rbegin(), s2.rend()); cout &lt;&lt; (s1 + s3 + s2); &#125; 草，这题很好听懂但很难说明白思路 G. 小沙の编码 待补充 H. 小沙の店铺 题意 给定初始价格 \(x\)，每卖出去 \(k\) 件，单价上涨 \(y\) 元。给定 \(n\) 个客户，第 \(i\) 个客户的购买 \(n - i + 1\) 个商品，单价在每一个客户买完后才会变化。若接待完 \(n\) 个客户都没有卖出去至少 \(T\) 元货物，输出 \(-1\)，否则输出卖出的价钱。 思路 纯模拟打卡题 时间复杂度：\(O(n)?\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 1010; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int x, y, k, n, t; cin >> x >> y >> k >> n >> t; int cnt = 0, tot = 0, now = 0; while("If the world love me")&#123; cnt ++; tot += n * (x + now / k * y); now += n; if(tot >= t) &#123; break; &#125; if(n - 1 &lt;= 0)&#123; cnt = -1; break; &#125; n --; &#125; cout &lt;&lt; cnt; &#125; 差点打卡题卡了一会儿 I. 小沙の金银阁 题意 给定 \(m\) 个灵石，在 \(n\) 次猜测中，给出灵石数量的猜测，猜错会扣除相同数量的灵石，规定只有一次会猜对，输出猜测的最优方案。 思路 乱猜，从 \(m\) 开始除 \(2\) 向上取整，剩余数放到第一位。 时间复杂度：\(O(\log_2 m)?\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long n = scanner.nextLong(), m = scanner.nextLong(); //1e15约2e50 if(n > 51 || m &lt; (1L &lt;&lt; (n - 1))) System.out.println(-1); else&#123; long[] out = new long[60]; for(int i=1;i&lt;n;i++)&#123; out[i] = m / 2 + m % 2; m /= 2; &#125; System.out.printf("%d ", m); for(int i=(int)n-1;i>0;i--) System.out.printf("%d ", out[i]); &#125; &#125; &#125; 正常一点的题解 乱猜就完事了（（ J. 小沙の最短路 待补充 K. 小沙の抱团 easy 题意 给定 \(n\) 个人，定义一个指令为要求以 \(x\) 人为单位抱团，落单的人淘汰，在所有操作都能被所有抱团的人认可的情况下，输出最少操作数。 思路 要让操作被所有人认可，那么应该满足少数服从多数的原则，因而我们可以以 $ + 1$ 为一组，让这样可以让留下的人最少。 暴力模拟求操作数即可 时间复杂度：\(O(\log_2 n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long n = scanner.nextLong(); long cnt = 0; while(n > 2)&#123; cnt ++; n = n / 2 + 1; &#125; System.out.println(cnt); &#125; &#125; 怎么感觉还是乱猜（（ L. 小沙の抱团 hard 题意 在上一题的基础上，指令是给定的，且每个指令有对应的代价，但每个指令可以被重复使用。输出让剩余人数最少的最小代价。 思路 考虑到代价以及重复使用，我们可以用类似于完全背包的写法。 当剩余 \(2\) 人时，一定无法让人数继续减少，所以我们可以从 \(n\) 个人的状态枚举到 \(2\) 个人的状态。 对于当前剩余 \(i\) 个人的情况下，我们枚举所有指令 \((b,x)\)，每个指令执行后剩余的人数即为 \(i - i \% x\)，因而我们可以得到下面的状态转移方程： \(dp[i - i \% x[i]] = min(dp[i - i \% x[i]], dp[i] + b[i])\) 当没有一个指令可行的时候，或者剩余 \(2\) 人时，输出结果。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 100010, M = 510, inf = 10000000000ll; struct sb&#123; int b, x; &#125;o[M]; int dp[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i=0;i&lt;m;i++) cin >> o[i].b >> o[i].x; for(int i=2;i&lt;n;i++) dp[i] = inf; bool ok = false; for(int i=n;i>2;i--)&#123; if(dp[i] == inf) continue; bool f = true; for(int j=0;j&lt;m;j++)&#123; int mod = i % o[j].x; if(mod == 0 || i &lt;= o[j].x) continue; dp[i - mod] = min(dp[i - mod], dp[i] + o[j].b); f = false; &#125; if(f) &#123; cout &lt;&lt; dp[i]; ok = true; break; &#125; &#125; if(!ok) cout &lt;&lt; dp[2]; &#125; 简单的dp]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 4</title>
    <url>/blog/posts/127583546/</url>
    <content><![CDATA[Rank 445/3193. AC 6/13. A. 清楚姐姐学信息论 题意 给定 \(a\) 进制和 \(b\) 进制，用该进制下的一定数量的号码牌表示数字。输出用哪个进制可以用 \(a \times b\) 张号码牌表示更多的数。 思路 显然，我们只需比较 \(a ^ b\) 和 \(b ^ a\) 的大小，但我们无需模拟计算，因为只有 \(2,3\) 组合的时候，\(2 &lt; 3,2 ^ 3 &lt; 3 ^ 2\)，其余情况均为 \(a &lt; b , a ^ b &gt; b ^ a\)。所以对该情况特判即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(), b = scanner.nextInt(); if ((a == 2 &amp;&amp; b == 3) || (a == 3 &amp;&amp; b == 2)) System.out.println(3); else System.out.println(Math.min(a, b)); &#125; &#125; 淦，还有特判，被坑了 B. 清楚姐姐学构造 题意 给定数组 \(c\) 和质数 \(m\)，构造两个数组 \(a,b\)，满足下面的同余方程组： \(\left\{\begin{aligned} a_i \equiv a_{N-i-1}\ (\mod m) \\ b_i \equiv -b_{N-i-1}\ (\mod m) \\ c_i \equiv a_i+b_i\ (\mod m) \end{aligned} \right.\) 若可构造，输出 \(YES\) 以及一种构造，否则输出 \(NO\)。 一句话题意 在模系下构造两个数列，一个满足奇函数性质，另一个满足偶函数性质，两个数列的和为任意给定数列。 思路 考虑到对称性，我们不妨设 \(a_i=a_{N-i-1}=x,b_i=m-b_{N-i-1}=y\)。 那么，\(a_i+b_i=x+y,a_{N-i-1}+b_{N-i-1}=x+m-y\)。 代入第三个式子，我们可以得到 \(x+y \equiv c_i\ (\mod m),x-y \equiv c_{N-i-1}\ (\mod m)\)。 两式相加，\(2x \equiv c_i+c_{N-i-1}\ (\mod m)\)，即 \(x=\frac{c_i+c_{N-i-1}+km}{2},k \in Z\)。 因而，我们只需判断分子的奇偶性，然后即可计算出 \(x\)。 同理可得 \(y\)。 若数组的长度为奇数，那么将会多出来一项 \(N/2\)，观察可得 \(a_i=c_i+km,b_i=0,k \in Z\) 符合题意。 遍历输出即可。 时间复杂度：\(O(\frac{n}{2})\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 100010; #define int long long int a[N], b[N], c[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i=0;i&lt;n;i++) cin >> c[i]; for(int i=0;i&lt;n/2;i++)&#123; int k1 = c[i] + c[n - i - 1], k2 = c[i] - c[n - i - 1], x, y; if(k1 % 2 == 0)&#123; if(m == 2) &#123; x = m + k1; y = m + k2; &#125; else &#123; x = m * 2L + k1; y = m * 2L + k2; &#125; &#125;else&#123; if(m == 2)&#123; cout &lt;&lt; "NO\n"; return 0; &#125;else &#123; x = m + k1; y = m + k2; &#125; &#125; x /= 2; y /= 2; a[i] = a[n - i - 1] = x; b[i] = y; b[n - i - 1] = m - y; &#125; if(n % 2 == 1) &#123; a[n / 2] = c[n / 2]; b[n / 2] = 0; &#125; cout &lt;&lt; "YES\n"; for(int i=0;i&lt;n;i++) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; for(int i=0;i&lt;n;i++) cout &lt;&lt; b[i] &lt;&lt; ' '; &#125; 不会有人暴力吧（（ C. 清楚姐姐学01背包(Easy Version) 题意 给定 \(n\) 个物品以及总容量 \(m\)，第 \(i\) 个物品的体积为 \(w_i\)，价值为 \(v_i\)。任选若干个物品放入背包，满足物品总体积小于容量 \(m\)，运用 \(01\) 背包求出最大价值 \(Val_{\max}\)。 现在，枚举每个物品，将该物品去除后，得到最大价值 \(Val&#39;_i\)，若\(Val&#39;_i&lt;Val_{\max}\)，那么该物品必选，输出 \(0\)；否则输出 \(x\)，满足该物品加上价值 \(x\) 后该物品必选。 \(N,M\) 均不超过 \(100\)。 思路 鉴于本题数据量很小，我们可以直接按照题面进行暴力模拟，对每个物品去掉后的情况进行 \(01\) 背包，若非必选，那么再以去掉该物品后的容量为总容量跑一遍 \(01\) 背包，将结果与 \(Val_{\max}\) 做差 \(+1\) 即可得到答案。 时间复杂度：\(O(nnm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 110, inf = 0x3f3f3f3f; #define int long long int n, m; int w[N], v[N], dp[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> n >> m; for(int i=1;i&lt;=n;i++)&#123; cin >> w[i] >> v[i]; &#125; for (int i = 1; i &lt;= n; i++) for (int l = m; l >= w[i]; l--) &#123; dp[l] = max(dp[l], dp[l - w[i]] + v[i]); &#125; int maxx = dp[m]; for(int i=1;i&lt;=n;i++)&#123; memset(dp, 0, sizeof dp); for (int p = 1; p &lt;= n; p++) &#123; int cw = p == i ? 0 : w[p], cv = p == i ? 0 : v[p]; for (int l = m; l >= cw; l--) &#123; dp[l] = max(dp[l], dp[l - cw] + cv); &#125; &#125; if(maxx > dp[m]) cout &lt;&lt; 0 &lt;&lt; '\n'; else&#123; memset(dp, 0, sizeof dp); for (int p = 1; p &lt;= n; p++) &#123; int cw = p == i ? 0 : w[p], cv = p == i ? 0 : v[p]; for (int l = m - w[i]; l >= cw; l--) &#123; dp[l] = max(dp[l], dp[l - cw] + cv); &#125; &#125; cout &lt;&lt; maxx - dp[m - w[i]] - v[i] + 1 &lt;&lt; '\n'; &#125; &#125; &#125; 令人感慨 D. 清楚姐姐学01背包(Hard Version) 题意 同 \(C\) 题，但 \(N,M\) 不超过 \(5000\)。 思路 暴力解决不了问题了。 我们回到 \(01\) 背包的二维实现：枚举所有物品，以及所有可能的最大容量，取 该状态的价值 和 前一个状态加上当前物品的价值 的最大值。 那么，我们自然可以发现，只要将 \(C\) 题的代码改成二维背包，那么至少最后一个 \(for\) 循环是不必要的，因为对于前 \(i-1\) 个物品，以 \(m-w[i]\) 为最大容量的 \(dp\) 值 我们已经 在前面 以 \(O(n^2)\) 的复杂度 推得了。 那么 \(i\) 后面物品的怎么办？从上面的分析我们可以知道，任意小于 \(m\) 的背包容量对应的答案均可通过 \(O(n^2)\) 的“预处理”得到，那么我们不妨从后往前跑一遍 \(01\) 背包，于是乎，对于第一维为 \(n-i\) 的 \(dp\) 数组，我们只需枚举容量即可。 更具体地 从前往后跑一遍 \(01\) 背包，得到二维数组 \(dpz\)；再从后往前跑一遍 \(01\) 背包，得到二维数组 \(dpf\)； 枚举每一个物品：维护对于 \(dpz\) 的 \(i\) 前一位的状态下容量的前缀最大值数组 \(mxz\)，对于 \(dpf\) 的 \(i\) 后一位的状态下容量的后缀最大值数组 \(mxf\)。然后，遍历前 \(i-1\) 个的最大容量 \(j\)，剩余的分给去掉前 \(i\) 个物品后剩下物品的最大容量，那么，\(mxz[j]+mxf[m-j]\) 的最大值即为 去掉 \(i\) 后的最大价值 \(Val&#39;_i\)。 综合步骤 \(2\) 和暴力做法的最后一个 \(for\) 循环，我们只需将 前 \(i-1\) 个物品，第 \(i\) 个物品，剩下的物品 抽象为三个物品，然后利用 \(01\) 背包的第二层循环计算出必须将 \(i\) 选中的最大值 \(Val&#39;_p\)。 输出 \(\max(0,Val&#39;_i-Val&#39;_p+1)\) 即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 5010; #define int long long int n, m; int w[N], v[N], dpz[N][N], dpf[N][N], mxz[N], mxf[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> n >> m; for (int i = 1; i &lt;= n; i++) &#123; cin >> w[i] >> v[i]; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) &#123; dpz[i][j] = dpz[i - 1][j]; dpf[i][j] = dpf[i - 1][j]; if (j >= w[i]) dpz[i][j] = max(dpz[i][j], dpz[i - 1][j - w[i]] + v[i]); if (j >= w[n - i + 1]) dpf[i][j] = max(dpf[i][j], dpf[i - 1][j - w[n - i + 1]] + v[n - i + 1]); &#125; for (int i = 1; i &lt;= n; i++) &#123; memset(mxz, 0, sizeof mxz); memset(mxf, 0, sizeof mxf); for (int j = 1; j &lt;= m; j++) &#123; mxz[j] = max(mxz[j - 1], dpz[i - 1][j]); mxf[j] = max(mxf[j - 1], dpf[n - i][j]); &#125; int vi = 0, vp = 0; for (int j = 0; j &lt;= m; j++) &#123; vi = max(vi, mxz[j] + mxf[m - j]); if (m - j >= w[i]) vp = max(vp, max(mxz[j] + mxf[m - j - w[i]] + v[i], mxf[j] + mxz[m - j - w[i]] + v[i])); &#125; cout &lt;&lt; max(0ll, vi - vp + 1) &lt;&lt; '\n'; &#125; &#125; 居然有点想出来了，毕竟背包就是贪心嘛 E. 清楚姐姐打怪升级 题意 给定 \(N\) 只怪物，第 \(i\) 只怪物的生命值上限为 \(h_i\)，生命恢复速度为 \(v_i\)。主角的攻击间隔为 \(t\)，攻击力为 \(a\)。 对于每个怪物，每个时刻初，恢复 \(v_i\) 点生命值，直至上限 \(h_i\)。 在 \(1+k \times t\) 时刻末，主角挑选一只怪物，扣除 \(a\) 点生命值，若剩余生命值为非正数，则判定怪物死亡。 输出在哪个时刻末可杀死所有怪物。若永远无法杀死则输出 \(-1\)。 思路 贪心。 我们采取将一只怪物杀死再去杀另一只的做法，使每只需要杀死的怪物能恢复的生命值最小。 显然，在下次攻击前，怪物能恢复 \(v_i \times t\) 点血量，如果恢复的血量大于主角攻击力 \(a\)，那么直接输出 \(-1\)。 否则： 如果一击秒杀，时刻 \(+1\)； 否则，在每次砍怪物之后，有效扣血为 \(a - v \times t\)，将其与第一次剩余的血量 \(h-a\) 进行除法运算即可。注意需要特判可能出现的一次砍完的情况。 因最后一只怪物的计算会多出一个单位等待时间，所以我们将其减去。 时间复杂度：\(O(n)\) 对应AC代码 import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long n = scanner.nextLong(), t = scanner.nextLong(), a = scanner.nextLong(); long tick = 0; for(int i=0;i&lt;n;i++)&#123; long h = scanner.nextLong(), v = scanner.nextLong(); if(h &lt;= a) &#123; tick ++; continue; &#125; if(v * t >= a)&#123; System.out.println(-1); return; &#125;else &#123; if ((h - a) % (a - v * t) == 0) tick += ((h - a) / (a - v * t) + 1); else tick += ((h - a) / (a - v * t) + 2); &#125; &#125; System.out.println((tick - 1) * t + 1); &#125; &#125; 模拟+贪心呐 F. 清楚姐姐学树状数组 题意 构建一个 \(2^k\) 的树状数组对应的二叉树，二叉树的中序遍历为节点编号，如下图： 给定 \(q\) 个查询，输出询问的节点在前、中、后序遍历中分别是第几个。 思路 \(Dfs\)。 我们从 \(2^k\) 开始向下遍历，根据树状数组的特性，我们可以知道下一个需要遍历的点的值： 若向左，\(nxt=now-\frac{lowbit(now)}{2}\)；若向右，\(nxt=now+\frac{lowbit(now)}{2}\)。 接着，我们先来看前序遍历的规律：对于下一个节点，若向左子树移动，那么前序遍历的值会 \(+1\)，否则会 \(+lowbit(now)\)。 而对于后序遍历，类似于前序：对于下一个节点，若向右子树移动，那么后序遍历的值会 \(-1\)，否则会 \(-lowbit(now)\)。 特别地，在后续遍历中，从 \(2^k\) 移动到 \(2^{k-1}\) 时，后序遍历只相差 \(1\)，特判即可。 注： 当然，我们也可以用递推的方式，初始化数组后按照找对称点的方式解题。 时间复杂度：\(O(q \log_2x)\) #include &lt;bits/stdc++.h> using namespace std; #define int long long int ans, maxx, x; int lb(int x)&#123; return x &amp; (-x); &#125; void dfs(int now, bool inc) &#123; if (now == x) return; if (now > x) &#123; if (inc) ans++; else ans -= (now == maxx ? 1 : lb(now)); dfs(now - lb(now) / 2ll, inc); &#125; else &#123; if (inc) ans += lb(now); else ans--; dfs(now + lb(now) / 2ll, inc); &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int k, q; cin >> k >> q; maxx = (1ll &lt;&lt; k); while(q --)&#123; cin >> x; ans = 1; dfs(maxx, true); cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; x &lt;&lt; ' '; ans = maxx; dfs(maxx, false); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 你说你这个蠢人怎么连找规律都找不出来呢.jpg G. 清楚姐姐逛街(Easy Version) 题意 给定一个迷宫，终点按照固定方式移动，以题给字符确定方向。给定多个查询，包括一个起点，输出从起点开始到可变终点的最短路。 思路 考虑到查询数量很少，我们采用暴力的做法： 从起点开始 \(Bfs\)，确定能到达的每个点的最短路径长度。 模拟终点移动，若遍历到的点存在路径长度小于等于当前终点移动的长度，那么输出答案。 时间复杂度：\(O(nmq)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 810; #define int long long char mp[N][N]; int dis[N][N], dx[4] = &#123;0, 0, -1, 1&#125;, dy[4] = &#123;-1, 1, 0, 0&#125;; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m, xs, ys, Q; cin >> n >> m >> xs >> ys >> Q; for(int i=0;i&lt;n;i++) cin >> mp[i]; memset(dis, 0x3f, sizeof dis); queue&lt;pair&lt;int, int>> q; q.emplace(xs, ys); dis[xs][ys] = 0; while(!q.empty())&#123; auto t = q.front(); q.pop(); int px = t.first, py = t.second; for(int i=0;i&lt;4;i++)&#123; int x = px + dx[i], y = py + dy[i]; if(x >= 0 &amp;&amp; x &lt; n &amp;&amp; y >= 0 &amp;&amp; y &lt; m &amp;&amp; mp[x][y] != '#' &amp;&amp; dis[x][y] > dis[px][py] + 1) &#123; dis[x][y] = dis[px][py] + 1; q.emplace(x, y); &#125; &#125; &#125; while(Q --)&#123; int x, y, ans, step = 1; cin >> x >> y; while(true)&#123; char cur = mp[x][y]; if(cur == 'L' &amp;&amp; mp[x][y - 1] != '#') y --; else if(cur == 'R' &amp;&amp; mp[x][y + 1] != '#') y ++; else if(cur == 'U' &amp;&amp; mp[x - 1][y] != '#') x --; else if(cur == 'D' &amp;&amp; mp[x + 1][y] != '#') x ++; else &#123; if(dis[x][y] == -1) &#123; ans = -1; break; &#125; &#125; if(dis[x][y] &lt;= step) &#123; ans = step; break; &#125; step ++; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 为啥BFS要这么写才对捏 H. 清楚姐姐逛街(Hard Version) 待补充，倍增+二分答案 I. 清楚姐姐采蘑菇 待补充，莫队+单调性 J. 清楚姐姐学排序 题意 给定数组 \(a\) 的 \(M\) 对元素大小关系，求顺序确定的位置和该位置的元素。 即对于位置 \(k\)，若确定位置在第 \(i\) 位，那么 \(b_k=i\)，否则 \(b_k=-1\)。输出顺序数组 \(b\)。 思路 显然，如果对于一个数，有 \(a\) 个数小于它，\(b\) 个数大于它，那么如果满足 \(a+b+1=n\)，该数的位置就一定唯一确定。 因此，我们直接枚举每个点即可。因为可能存在包含关系 \(a&lt;b,b&lt;c,a&lt;c\)，所以我们需要 \(Dfs\)。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 1010; #define int long long vector&lt;int> e[N][2]; int res[N], vis[N]; int dfs(int x, int t)&#123; if(vis[x]) return -1; vis[x] = true; int ans = 0; for(int each : e[x][t])&#123; ans += dfs(each, t) + 1; &#125; return ans; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i=0;i&lt;m;i++)&#123; int x, y; cin >> x >> y; e[x][0].emplace_back(y); e[y][1].emplace_back(x); &#125; memset(res, -1, sizeof res); for(int i=1;i&lt;=n;i++)&#123; memset(vis, 0, sizeof vis); int cntl = dfs(i, 1); vis[i] = false; int cntr = dfs(i, 0); if(cntl + cntr == n - 1) res[cntl + 1] = i; &#125; for(int i=1;i&lt;=n;i++) cout &lt;&lt; res[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; 不该不做这题... K. 清楚姐姐玩翻翻乐 待补充 L. 清楚姐姐的三角形I 题意 对于 \(\Delta ABC\)，顶点对应的边分别为 \(l_a, l_b, l_c\)。记 \(V_A=l_b+l_c,V_B=l_a+l_c,V_C=l_a+l_b\)，给定 \(V_A,V_B,V_C\)，输出 \(l_a,l_b,l_c\)。无解输出 \(NO\)。 思路 显然，\(l_a=\frac{V_B+V_C-V_A}{2},l_b=\frac{V_A+V_C-V_B}{2},l_c=\frac{V_A+V_B-V_C}{2}\)，那么我们只需判断两边之和大于第三边以及分子是否为偶数即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 500010, inf = 0x3f3f3f3f; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, va, vb, vc; cin >> t; while(t -- > 0)&#123; cin >> va >> vb >> vc; int la = vb + vc - va, lb = va + vc - vb, lc = va + vb - vc; if(la % 2 == 1 || lb % 2 == 1 || lc % 2 == 1)&#123; cout &lt;&lt; "NO\n"; &#125;else&#123; la /= 2; lb /= 2; lc /= 2; if(la + lb > lc &amp;&amp; la + lc > lb &amp;&amp; lb + lc > la)&#123; cout &lt;&lt; "YES" &lt;&lt; '\n' &lt;&lt; la &lt;&lt; ' ' &lt;&lt; lb &lt;&lt; ' ' &lt;&lt; lc &lt;&lt; '\n'; &#125;else cout &lt;&lt; "NO\n"; &#125; &#125; &#125; 怎么可以暴力呢 M. 清楚姐姐的三角形II 题意 给定数组长度 \(N\)，构造一个数组，满足相邻三个数不能构成三角形。 思路 \(1,1,2,1,1,2,1,1,2,1,...\) 输出即可 时间复杂度：\(O(n/3)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 500010, inf = 0x3f3f3f3f; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n; cin >> n; for(int i=0;i&lt;n/3;i++)&#123; cout &lt;&lt; "1 1 2 "; &#125; if(n % 3 == 1) cout &lt;&lt; "1"; if(n % 3 == 2) cout &lt;&lt; "1 1"; &#125; 差点斐波那契（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 847 Div 3</title>
    <url>/blog/posts/3800321871/</url>
    <content><![CDATA[Practice. A. Polycarp and the Day of Pi 题意 将输入与 "\(314159265358979323846264338327\)" 比对，输出从头开始匹配成功的最大数量。 思路 模拟即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; String a = "314159265358979323846264338327"; String b = scanner.next(); int n = b.length(), cnt = 0; for(int i=0;i&lt;n;i++)&#123; if(a.charAt(i) != b.charAt(i)) break; cnt ++; &#125; System.out.println(cnt); &#125; &#125; &#125; 题例有给圆周率的值，草 B. Taisia and Dice 题意 给定 \(3\) 个整数 \(n, s, r\)，构造一个数组 \(a\)，满足最大值为 \(s - r\)，数组的长度为 \(n\)，总和为 \(s\)。 思路 从大到小放入能放的最大数即可，上限需要考虑后面是否可以放 \(1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; int s, r; cin >> n >> s >> r; int maxx = s - r; cout &lt;&lt; maxx &lt;&lt; ' '; s -= maxx; for(int i=n-2;i>=0;i--)&#123; int cur = min(6ll, max(1ll, min(maxx, s - i))); cout &lt;&lt; cur &lt;&lt; ' '; s -= cur; &#125; cout &lt;&lt; '\n'; &#125; &#125; 反正别用DFS就行 C. Premutation 题意 给定 \(n\) 的一种排列分别去掉每一位后构成的 \(n-1\) 个子序列，输出原排列。 思路 考虑第一位即可。 第一位中出现次数最多的数即为原排列的第一个数，而出现最少的数所在子序列即为原排列去掉第一个数后的子序列，拼起来即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 110; int a[N][N]; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --) &#123; memset(a, 0, sizeof a); cin >> n; int h1, h2, c1 = 0, c2 = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n - 1; j++) &#123; cin >> a[i][j]; &#125; if(c1 == 0 || h1 == a[i][0]) h1 = a[i][0], c1 ++; else h2 = a[i][0], c2 ++; &#125; int h = c1 > c2 ? h1 : h2; for(int i=0;i&lt;n;i++)&#123; if(a[i][0] != h)&#123; cout &lt;&lt; h &lt;&lt; ' '; for(int j=0;j&lt;n-1;j++) cout &lt;&lt; a[i][j] &lt;&lt; ' '; break; &#125; &#125; cout &lt;&lt; '\n'; &#125; &#125; 找规律就行力 D. Matryoshkas 题意 给定一个数组 \(a\)，将其拆分成任意数量的子序列，满足子序列升序排序后相邻元素相差 \(1\)，且无重复元素，输出子序列的最小数量。 思路 我们可以考虑模拟的做法，将所有子序列抽象为序列中最大的数，作为几堆候选区域： 在升序排序数组 \(a\) 后，我们依次将元素 \(a_i\) 放入，放入前，我们先拿出候选中数值最小的，然后分类讨论： 如果满足 \(+1\) 后和\(a_i\) 相同，那么我们直接将元素放入该候选区域； 如果两数相同，那么两数均可作为下一个数的可能候选区域，所以新建一个区域并放入该数； 否则，那么这个候选区域无法再进行匹配，直接取出并计数。 最后，剩下的堆数加上被取出的堆数即为答案。 当然，为了降低复杂度，考虑使用优先队列。 时间复杂度：\(O(nt \log t),t为队列长度\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); int[] a = new int[n]; PriorityQueue&lt;Integer> q = new PriorityQueue&lt;>(Comparator.comparingInt(o -> o)); for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); int cnt = 0; for(int i=0;i&lt;n;i++)&#123; boolean ok = false; while(!q.isEmpty())&#123; int now = q.poll(); if(now + 1 == a[i]) &#123; q.offer(a[i]); ok = true; break; &#125;else if(now == a[i])&#123; q.offer(a[i]); q.offer(a[i]); ok = true; break; &#125; else cnt ++; &#125; if(!ok) q.offer(a[i]); &#125; System.out.println(cnt + q.size()); &#125; &#125; &#125; 其实可以不用这么模拟，太模拟了（（ E. Vlad and a Pair of Numbers 题意 给定一个整数 \(n\)，满足 \(a \oplus b = \frac{a+b}{2}=n\)，输出满足条件的任意一组 \(a,b\)。 思路 我们先来考虑 \(a \oplus b = a+b=t\)： 对于任意二进制数 \(t\)，当我们从高位向低位遍历时，若遇到 \(1\)，那么我们不妨在 \(a\) 的该位填上 \(1\)，在 \(b\) 的该位上填上 \(0\)，这样即可满足异或运算和加法运算的值一致。 而对于 \(a \oplus b = \frac{a+b}{2}=n\)： 我们注意到有除 \(2\) 的运算，该操作等效于将 \(a+b\) 的二进制结果向低位移动一位，此时，若按照上述做法，我们会发现 \(1\) 的位置恰好差了一位，那么我们就希望能出现进位的操作。 考虑到对于二进制运算，\(11+01=100\)，那么我们不妨在上述做法的基础上，在 \(1\) 后面一位对应的 \(a,b\) 位置上分别填上 \(1,0\)，这样就可以满足我们的需求了。 而显而易见，当 \(1\) 出现在最后一位（奇数），或者有连续的 \(1\) 存在时，即为无解。 时间复杂度：\(O(\log_2n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt: while (t-- > 0) &#123; int n = scanner.nextInt(); //有连着的1就不行 if(n % 2 == 1)&#123; System.out.println(-1); continue nxt; &#125; int a = 0, b = 0; boolean f = false; for(char e : Integer.toBinaryString(n).toCharArray())&#123; int p = e - '0'; if (f) &#123; if (p == 1) &#123; System.out.println(-1); continue nxt; &#125; else &#123; a = a * 2 + 1; b = b * 2 + 1; f = false; &#125; &#125; else &#123; f = p == 1; a *= 2; b *= 2; if(f) a ++; &#125; &#125; System.out.printf("%d %d\n", a, b); &#125; &#125; &#125; 真的不是找规律题么（（ F. Timofey and Black-White Tree 题意 对于一个 \(n\) 个点 \(n-1\) 个边的无向无环图，给定操作顺序，将 \(n\) 个点按照顺序涂成黑色，输出从第 \(2\) 个操作开始，对于每次操作后，所有任意两个黑点的距离的最小值。 思路 我们可以考虑树形 \(dp\) 的写法，其中 \(dp[i]\) 表示第 \(i\) 个点 在涂色前 该点的所有子节点中 黑色的点到该点的最短距离。 难道我们要把子节点全都遍历一遍吗？显然不用。 这是一个无向无环图，那么显然一个点只有一个父节点，只要根节点确定了，我们构建一个数组即可。 因此，我们不妨从要涂色的点开始，向上 \(Dfs\) 到根节点，在遍历的同时记录当前已经遍历的边数 \(st\)。在遍历到节点 \(i\) 时，我们以这个点为跳板，用 \(dp[i]+st\) 更新最终答案，并将 \(dp[i]\) 更新为 \(\min(dp[i],st)\) 即可。 深搜剪枝 根节点的确定：在绝大多数情况下，取子节点最多的点作为根节点是更优的，这样可以让链条结构更多，从而一定程度降低时间复杂度； 只遍历父节点 \(st&gt;=ans\) 时，结束遍历：显然，我们需要求答案的最小值，那么就算我们继续遍历，最后更新的 \(dp\) 值是一定大于等于 \(ans\) 的，因而我们就没必要 让其他将要涂黑的点 以这个点为跳板 来更新 \(ans\) 了。而恰恰因为我们至少遍历了 \(ans-1\) 个，可以保证 最小路径所在边 一定被我们遍历过了，因而答案没有问题。 整体来看 确定根节点； 从根节点开始向下 \(Dfs\) 一遍，求出每个点的父节点； 依次遍历要涂黑的点，向上 \(Dfs\) 并更新 \(dp\) 值。 时间复杂度：不会分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 200010, inf = 0x3f3f3f3f; #define int long long vector&lt;int> e[N]; int dp[N], c[N], root, ans, vis[N], f[N];//cut2: 只遍历爹，因为爹只有一个（无环 void dfs1(int fa)&#123; for(int p : e[fa])&#123; if(vis[p]) continue; vis[p] = true; f[p] = fa; dfs1(p); &#125; &#125; void dfs2(int child, int st)&#123; if(st >= ans) return; //cut3: 步数那么多就没必要继续走，防止每次都被卡O(n) if(dp[child] != inf) ans = min(ans, dp[child] + st); dp[child] = min(st, dp[child]); if(child != root) dfs2(f[child], st + 1); &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --) &#123; cin >> n >> c[0]; for(int i=1;i&lt;n;i++) &#123; cin >> c[i]; dp[i] = inf; vis[i] = false; e[i].clear(); &#125; dp[n] = inf; vis[n] = false; e[n].clear(); int maxx = -1; root = 1; //cut1: 根节点选分支最多的 for(int i=1;i&lt;n;i++)&#123; int u, v; cin >> u >> v; e[u].emplace_back(v); e[v].emplace_back(u); int s1 = e[u].size(), s2 = e[v].size(); if(max(s1, s2) > maxx) &#123; maxx = max(s1, s2); root = s1 > s2 ? u : v; &#125; &#125; dfs1(root); ans = inf; dfs2(c[0], 0); for(int i=1;i&lt;n;i++)&#123; dfs2(c[i], 0); cout &lt;&lt; ans &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; &#125; 我趣，怎么一遍过]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 844 Div 1 plus 2</title>
    <url>/blog/posts/405635716/</url>
    <content><![CDATA[Contestant. Rank 4776. Rating -20 (+30 -50). A. Parallel Projection 题意 给定一个长方体，在长方体的顶部和底部各取一个点，一只蚂蚁只能在平面上向平行于边的方向移动，求出蚂蚁从一个点移动到另一个点的最短路径。 思路 从四个方向分别模拟一下求最小值即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int w = scanner.nextInt(), d = scanner.nextInt(), h = scanner.nextInt(); int a = scanner.nextInt(), b = scanner.nextInt(), f = scanner.nextInt(), g = scanner.nextInt(); int p1 = Math.min(a + f + Math.abs(g - b), b + g + Math.abs(f - a)); a = w - a; b = d - b; f = w - f; g = d - g; int p2 = Math.min(a + f + Math.abs(g - b), b + g + Math.abs(f - a)); System.out.println(h + Math.min(p1, p2)); &#125; &#125; &#125; 还是用蚂蚁理解更加经典（（ B. Going to the Cinema 题意 给定数组 \(a\)，对于任意 \(i\)，提出一个要求：“我只在 不算上我的前提下 至少有 \(a_i\) 个人陪我一起去 的前提下去电影院，否则我会难过。” 注意考虑逆否命题：“我不去电影院，而且只有不到 \(a_i\) 个人抛下我去电影院，我依然是开心的，否则我也会难过。” 输出所有不让任何人伤心的安排的总数。 思路 首先，显然我们一定得让 \(a_i=0\) 的人全都去电影院，不然逆否命题一定不成立。 接着，我们遍历剩下按升序排序的 \(a_i\)，同理找出必须去的人，在找出第一个不一定要去的人的时候停止遍历。 然后，我们遍历后面可以不选上的人，并在选上后判断后者是否必须去。 最后，所有可以不选上的人的个数即为答案，因为若在递增序列里间隔选人，会导致命题不成立。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) a[i] = scanner.nextInt(); Arrays.sort(a); int c = 0, i = 0, ans = 0; for(;i&lt;n;i++)&#123; if(a[i] == 0) c ++; else if(a[i] &lt;= c) c ++; else break; &#125; ans++; while (i++ &lt; n) &#123; c++; if (a[i] &lt;= c) &#123; ans++; while (i &lt; n &amp;&amp; a[i] &lt;= c) &#123; i++; c++; &#125; &#125; &#125; System.out.println(ans); &#125; &#125; &#125; 云里雾里 C. Equal Frequencies 题意 给定一个字符串 \(s\)，定义一次操作为替换 \(s_i\) 为任意其他字母，输出操作数最少的结果，使结果中所有字母出现的次数均相同。 思路 考虑到小写字母只有 \(26\) 个，我们不妨枚举所有可能的段数，找出操作数最少的情况然后输出即可。 如何判断操作数最少呢？对于每个字母 \(c\)，我们不难发现：\(\min(\frac{n}{k},freq_c)\) 即为当前需要保留的数量。因此，去除保留的数量，剩余即为操作数。 确定段数之后，我们先将字符串中各个字母按照出现次数降序排序，然后从头开始遍历每一个字母，若字母数量过多，那么将多出来的位置留空，如果过少，那么在留空的位置填上缺少的字母。最后将序列输出即可。 时间复杂度：\(O(n^2)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); char[] o = scanner.next().toCharArray(); List&lt;Pair&lt;Integer, List&lt;Integer>>> f = new ArrayList&lt;>(); for(int i=0;i&lt;26;i++) f.add(new Pair&lt;>(i, new ArrayList&lt;>())); for(int i=0;i&lt;n;i++) f.get(o[i] - 'a').B.add(i); f.sort(Comparator.comparingInt(o1 -> -o1.B.size())); int best = 0, cnt = 1, cur; for(int i=1;i&lt;=26;i++)&#123; if(n % i > 0) continue; cur = 0; for(int j=0;j&lt;i;j++) cur += Math.min(n / i, f.get(j).B.size()); if(best &lt; cur)&#123; best = cur; cnt = i; &#125; &#125; System.out.println(n - best); List&lt;Integer> extra = new ArrayList&lt;>(); char[] res = new char[n]; for(int i=0;i&lt;cnt;i++)&#123; for(int j=0;j&lt;n/cnt;j++)&#123; if(j &lt; f.get(i).B.size())&#123; res[f.get(i).B.get(j)] = (char) ('a' + f.get(i).A); &#125;else&#123; extra.add(f.get(i).A); &#125; &#125; &#125; int p = 0; for(int i=0;i&lt;n;i++)&#123; System.out.printf("%c", res[i] == 0 ? (char) ('a' + extra.get(p ++)) : res[i]); &#125; System.out.println(); &#125; &#125; //实现cpp里的pair 此处略去 //public static class Pair&lt;A, B>&#123;&#125; &#125; 没想到暴力直接取段数 D. Many Perfect Squares 题意 给定数组 \(a\)，输出将整个数组加上任意非负数 \(x\) 后完全平方数的最多个数。 思路 首先，答案绝对是 \(\geq1\) 的，那么我们来考虑 \(&gt; 1\) 的情况，也就是在该情况下枚举所有 \(a_i,a_j\)，满足 \(a_i+x=p^2,a_j+x=q^2\)，然后再枚举所有数，统计完全平方数个数即可。 那么我们来考虑下如何枚举 \(x\)： 显然，\(a_j - a_i = q^2 - p^2 = (q - p)(q + p)\)，那么 \(q-p\) 即为 \(a_j-a_i\) 的因数，因为数据范围不大，直接暴力枚举所有因数是可行的。 设因数为 \(d\)，我们可以得到下面的式子 \(\begin{cases} q - p = d \\ q + p = \frac{a_j - a_i}{d} \end{cases}\) 继续化简，得到 \(\begin{cases} p = \frac{1}{2}(\frac{a_j - a_i}{d} - d) \\ q = \frac{1}{2}(\frac{a_j - a_i}{d} + d) \\ \end{cases}\) 也就是说，只要括号内的式子是偶数，那么 \(d\) 即为一种可行解。 时间复杂度：\(O(n^2f(x)),f(x)为差值的因数个数\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 500010; #define int long long int a[60]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; int ans = 1; for(int i=0;i&lt;n-1;i++) for(int j=i+1;j&lt;n;j++) &#123; int d = a[j] - a[i], x; for (int p=1;p&lt;=d/p;p++) &#123; if(d % p == 0)&#123; if((d / p - p) % 2 == 1 || (d / p + p) % 2 == 1) continue; x = ((d / p - p) / 2) * ((d / p - p) / 2) - a[i]; if(x &lt; 0) continue; int cnt = 0; for(int e=0;e&lt;n;e++)&#123; int s = floor(sqrt(a[e] + x)); if(s * s == a[e] + x) cnt ++; &#125; ans = max(ans, cnt); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 好一个暴力枚举]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 845 Div 2 and ByteRace 2023</title>
    <url>/blog/posts/1008203407/</url>
    <content><![CDATA[Practice. A. Everybody Likes Good Arrays! 题意 给定一个数组 \(a\)，定义一次操作为将奇偶性相同的相邻元素相乘并合并为一个元素，输出让数组 \(a\) 满足所有相邻数奇偶性不同的最小操作数量。 思路 显然，奇偶性相同的两个数相乘后奇偶性是不变的，那么我们只需统计有多少组相邻元素的奇偶性相同即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int cur = scanner.nextInt() % 2; int cnt = 0; for(int i=1;i&lt;n;i++)&#123; int a = scanner.nextInt(); if(a % 2 == cur) cnt ++; else cur = a % 2; &#125; System.out.println(cnt); &#125; &#125; &#125; 还是挺简单的思维题 B. Emordnilap 题意 给定一个整数 \(n\)，对于所有 \(n\) 的排列，分别将各个排列镜像复制到右边，输出所有新数对的逆序对的总数量。 思路 可以证明，对于任意一个排列，所有大于 \(1\) 的数字 \(t\) 总能在其右边找到总共为 \(2 \times (t-1)\) 个比它小的数，从而构成对应数量的逆序对。因而，对于一个长度为 \(n\) 的排列，进行镜像复制后，逆序对总数为 \(2 \times (1+2+...+(n-1))=n \times (n-1)\)。 显然，对于 \(n\)，总共有 \(A_n^n\) 种排列，与上式相乘即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; long n = scanner.nextInt(); long fact = 1L, mod = 1000000007; for(long i=2;i&lt;=n;i++) fact = (fact * (i % mod)) % mod; System.out.println((((fact * (n % mod)) % mod) * ((n - 1) % mod)) % mod); &#125; &#125; &#125; 难得B题想的这么快 C. Quiz Master 题意 给定数组 \(a\)，选择任意可不连续的子序列 \(b\)，满足对于任意 \(t \in [1,m]\)，有 \(b_i \mod t = 0\)，输出满足条件的子序列中 \(b_{\max}-b_{\min}\) 的最小值。 思路 双指针，类似于滑动窗口的解法。 我们考虑用双指针维护一个 \([l,r]\) 的满足题意的区间，在向右移动 \(r\) 的同时，找出满足条件的 \(l\) 的最小值即可。 更具体地说，我们可以开一个数组 \(cnt\) ，在向右移动 \(r\) 之前，我们先将 \(a[r]\) 的所有因子 \(f[a[r]]\) 对应的 \(cnt[f[a[r]]] +1\)，并在加之前判断值是否为 \(0\)，如果是，那么这个因数是第一次出现，因此即可统计 \([1,m]\) 是否被完全覆盖。向右移动 \(l\) 之前的操作与上述操作类似。 时间复杂度：\(O(n \times f(x)),f(x)为x的因数数量\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; static int N = 100010; private static List&lt;List&lt;Integer>> init()&#123; List&lt;List&lt;Integer>> res = new ArrayList&lt;>(); for(int i=0;i&lt;=N;i++) res.add(new ArrayList&lt;>()); for(int i=1;i&lt;=N;i++) for(int j=i;j&lt;=N;j+=i)&#123; res.get(j).add(i); &#125; return res; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); List&lt;List&lt;Integer>> f = init(); int t = scanner.nextInt(); nxt: while(t -- > 0)&#123; int n = scanner.nextInt(), m = scanner.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); int l = 0, r = 0, best = Integer.MAX_VALUE, now = 0; int[] cnt = new int[N]; while(r &lt; n)&#123; for(int each : f.get(a[r]))&#123; if(each > m) break; if(cnt[each] == 0) now ++; cnt[each] ++; &#125; while(now == m)&#123; best = Math.min(a[r] - a[l], best); for(int each : f.get(a[l]))&#123; if(each > m) break; if(cnt[each] == 1) now --; cnt[each] --; &#125; l ++; &#125; r ++; &#125; System.out.println(best == Integer.MAX_VALUE ? -1 : best); &#125; &#125; &#125; 妙啊.jpg]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 846 Div 2</title>
    <url>/blog/posts/871658605/</url>
    <content><![CDATA[Contestant. Unrated, with problem C removed. A. Hayato and School 题意 给定一个数组 \(a\)，输出一对下标，满足下标对应的元素的和为奇数。保证数组 \(a\) 至少有 \(3\) 个元素。 思路 分类讨论： 奇数元素数量大于 \(3\)，直接输出前三个奇数。 偶数只有 \(1\) 个，或者没有奇数，无解。 输出一对”奇，偶，偶“即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 310; pair&lt;int, int> a[N], b[N]; #define ll long long int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int o = 0, e = 0; for(int i=1;i&lt;=n;i++)&#123; int p; cin >> p; if(p % 2 == 0) a[e ++] = &#123;p, i&#125;; else b[o ++] = &#123;p, i&#125;; &#125; if(o >= 3)&#123; cout &lt;&lt; "YES" &lt;&lt; '\n'; cout &lt;&lt; b[0].second &lt;&lt; " " &lt;&lt; b[1].second &lt;&lt; " " &lt;&lt; b[2].second &lt;&lt; '\n'; &#125;else if(o == 0 || e == 1)&#123; cout &lt;&lt; "NO" &lt;&lt; '\n'; &#125;else&#123; cout &lt;&lt; "YES" &lt;&lt; '\n'; cout &lt;&lt; b[0].second &lt;&lt; " " &lt;&lt; a[0].second &lt;&lt; " " &lt;&lt; a[1].second &lt;&lt; '\n'; &#125; &#125; &#125; 这么签的题居然WA了，淦 B. GCD Partition 题意 给定一个数组 \(a\)，将数组 \(a\) 切割为任意数量的连续段，满足相邻区间头尾没有交集，对每段分别求和，输出求和后所有和的最大公约数的最大值。 思路 可以证明，分隔为两段后可以保证取到 \(gcd_{\max}\)，因此我们枚举即可。 若需略微证明，因求出的 \(gcd\) 一定是 \(sum_a / d\) (\(d\) 是段数) 的因数，显然 \(d\) 越小，能遍历到的因数就更多，所以分两段即可。 既然分两段，暴力即可。 时间复杂度：\(O(n \times f(x)),f(x)指gcd函数复杂度\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; private static long gcd(long a, long b) &#123; while(b != 0) &#123; long tmp = a; a = b; b = tmp % b; &#125; return a; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); long tot = 0; long[] a = new long[n + 1]; for(int i=1;i&lt;=n;i++) tot += a[i] = scanner.nextInt(); long ans = 1, sum = 0; for(int i=1;i&lt;n;i++)&#123; sum += a[i]; ans = Math.max(ans, gcd(sum, tot - sum)); &#125; System.out.println(ans); &#125; &#125; &#125; 怎么还会去想分段怎么分呢，真是，淦 D. Bit Guessing Game 题意 互动游戏，对于一个未知数 \(n\)，有最多 \(30\) 次的猜测机会。对于每次给出的二进制下 \(n\) 中 \(1\) 的个数，允许减去一个值 \(x\)，使 \(n=n-x\)，\(n\) 值得改变会影响下一轮数量的给出。若能确定答案，输出即可。 思路 我们考虑到题给范围为 \(10^9\)，此时二进制的最大位数恰好为 \(30\)，那么我们不妨枚举所有位的情况。 首先，对于一个二进制数，我们引入一个结论： 若某一位为 \(1\)，我们将该位减去后，一定可以保证 \(1\) 的数量恰好 \(-1\)； 而若某一位为 \(0\)，则恰好相反，我们找不出有一种情况满足 \(1\) 的数量恰好 \(-1\)。 因此，我们可以从低位向高位枚举，若满足条件，那么将目标数字的该位标为 \(1\)，否则，在下一次猜测的时候，我们需要减去原先被我们减去的值，以达到反悔的目的。而显然，无论我们减去多少原先的值，最后剩下的数一定大于 \(0\)，因此方案可行。 时间复杂度：\(O(\log_2n)\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int cnt = scanner.nextInt(); int ans = 0, b = 0, on = 0; while(cnt > 0)&#123; System.out.printf("- %d\n", (1 &lt;&lt; on) - b); System.out.flush(); int now = scanner.nextInt(); if(now == -1) return; //wa了... if(cnt - now == 1) &#123; b = 0; cnt = now; ans += 1 &lt;&lt; on; &#125; else b += (1 &lt;&lt; on) - b; on ++; &#125; System.out.printf("! %d\n", ans); System.out.flush(); &#125; &#125; &#125; 我跟自己写的代码玩游戏.jpg]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 843 Div 2</title>
    <url>/blog/posts/1640782794/</url>
    <content><![CDATA[Contestant. Rank 6984. Rating -84 (+16 -100). A1. Gardener and the Capybaras (easy version) 题意 给定一个由 \(a\) 和 \(b\) 构成的字符串，将其分成三部分 \(a,b,c\)，输出一种分法，让 \(b\) 成为三者中的最值。 对于两个字符串 \(x\)，\(y\)，若 \(x &lt; y\)，当且仅当下面任意一个条件成立： \(x\) 是 \(y\) 的前缀，但\(x \neq y\)； \(x_1=&#39;a&#39;,y_1=&#39;b&#39;\)。 思路 我们分成两个情况考虑： 遍历 \([2,n-1]\)，若出现 \(a\)，那么让 \(&#39;a&#39;\) 单独成为中间的字符，这样中间的字符一定是最小的，直接输出即可。 如果不存在，那么我们让 \([2,n-1]\) 的所有字符作为中间的字符串，因为第一位为 \(b\)，且足够长，一定可以保证其为最大。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t -- > 0)&#123; char[] a = scanner.next().toCharArray(); int n = a.length; for(int i=1;i&lt;n-1;i++)&#123; if(a[i] == 'a')&#123; for(int j=0;j&lt;i;j++)&#123; System.out.print(a[j]); &#125; System.out.print(" a "); for(int j=i+1;j&lt;n;j++)&#123; System.out.print(a[j]); &#125; System.out.println(); continue nxt; &#125; &#125; System.out.printf("%c ", a[0]); for(int i=1;i&lt;n-1;i++) System.out.print(a[i]); System.out.printf(" %c", a[n - 1]); System.out.println(); &#125; &#125; &#125; 怎么会是呢，简单思维题怎么能想那么久呢 A2. Gardener and the Capybaras (hard version) 题意 参见 \(A1\) 题。差别是数据量更大。 思路 参见 \(A1\) 题。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main &#123; public static void main(String[] args) throws Throwable&#123; Console console = new Console(); int t = console.nextInt(); nxt:while(t -- > 0)&#123; char[] a = console.next().toCharArray(); int n = a.length; for(int i=1;i&lt;n-1;i++)&#123; if(a[i] == 'a')&#123; for(int j=0;j&lt;i;j++)&#123; console.print(a[j]); &#125; console.print(" a "); for(int j=i+1;j&lt;n;j++)&#123; console.print(a[j]); &#125; console.println(); continue nxt; &#125; &#125; console.print(a[0] + " "); for(int i=1;i&lt;n-1;i++) console.print(a[i]); console.print(" " + a[n - 1]); console.println(); &#125; console.close(); &#125; //快读模板 此处省略 //public static class Console implements Closeable &#123;&#125; &#125; java在输入多的时候记得用快读 B. Gardener and the Array 题意 给定数组 \(c\)，输出 是否有两个可不连续的不同子序列 满足 将 序列的所有数 进行 或运算 后得到的数相等。 思路 将每个数转为二进制，记录二进制下每一位有多少个数为 \(1\)。 遍历所有数，若有一个数每一位都出现了不止 \(2\) 次，那么这个数可以被删去，从而和整个序列的或运算值相等。 若没有一个数满足上面的条件，输出 \(NO\)。 不宜开二维数组。 时间复杂度：\(O(nk)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; int main() &#123; int T, n, k, p; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); vector&lt;vector&lt;int>> c(n); map&lt;int, int> cnt; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;k); for (int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;p); c[i].push_back(p); cnt[p]++; &#125; &#125; bool res = false; for (int i=0;i&lt;n;i++) &#123; bool f = true; for (int j=0;j&lt;c[i].size();j++) &#123; if (cnt[c[i][j]] &lt; 2) f = false; &#125; if (f) &#123; res = true; break; &#125; &#125; printf(res ? "Yes\n" : "No\n"); &#125; &#125; 既然不好用二维数组，那就果断vector C. Interesting Sequence 题意 给定两个数 \(n,x\)，输出满足 \(n\&amp;(n+1)\&amp;(n+2)\&amp;...\&amp;m=x\) 的 \(m\) 值，若不存在，输出 \(-1\)。 思路 首先，观察可得，我们无法让 \(n\) 变大，因为随着 \(n\) 的递增，较低位会出现 \(0\)，从而使整个数减小。 其次，我们只能让一些低位变成 \(0\)，所以我们可以遍历每一位，此处可以分类讨论： \(n\) 中是 \(0\) ，但 \(x\) 中是 \(1\) ：无解，结束遍历； \(n\) 中是 \(1\) ，但 \(x\) 中是 \(0\) ：标记此点，且该点以后若 \(x\) 中出现 \(1\)，那么为无解，结束遍历； \(n\) 中是 \(0\) ，且 \(x\) 中是 \(0\) ：若未遇到 \(2\) 类情况，那么记录下最后一个满足本情况的点 \(last0\)； \(n\) 中是 \(1\) ，且 \(x\) 中是 \(1\) ：既然匹配，那么 \(last0\) 应标为 \(-1\)，否则会影响整体的值。 最后，对于 \(n\)，在 \(last0\) 的位置将其改为 \(1\)，并把 \(last0\) 后的位置改为 \(0\)，转换为十进制输出即可。 时间复杂度：\(O(n)\)左右 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt: while (t-- > 0) &#123; long a = scanner.nextLong(), b = scanner.nextLong(); if (a == b) &#123; System.out.println(a); continue; &#125; if (b % 2 != 0) &#123; System.out.println(-1); continue; &#125; int[] ba = new int[64], bb = new int[64]; int la = 0, lb = 0; while (a > 0) &#123; ba[la++] = (int) (a % 2); a /= 2; &#125; if (b == 0) &#123; long ans = 1; for (int i = 0; i &lt; la; i++) ans *= 2; System.out.println(ans); continue; &#125; while (b > 0) &#123; bb[lb++] = (int) (b % 2); b /= 2; &#125; if (lb != la) &#123; System.out.println(-1); continue; &#125; int last0 = -1; boolean f = false; for (int i = 0; i &lt; la; i++) &#123; int ta = ba[la - i - 1], tb = bb[lb - i - 1]; if (ta == tb) &#123; if (!f &amp;&amp; ta == 0) last0 = la - i - 1; if(ta == 1) last0 = -1; continue; &#125; if (ta == 0 &amp;&amp; tb == 1) &#123; System.out.println(-1); continue nxt; &#125; if (ta == 1 &amp;&amp; tb == 0) f = true; &#125; if (last0 == -1) &#123; System.out.println(-1); &#125; else &#123; long ans = 0; for (int i = la - 1; i > last0; i--) ans = ans * 2 + ba[i]; ans = ans * 2 + 1; for (int i = last0 - 1; i >= 0; i--) ans *= 2; System.out.println(ans); &#125; &#125; &#125; &#125; 写得有点过度码农了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 141</title>
    <url>/blog/posts/707152960/</url>
    <content><![CDATA[Contestant. Rank 3946. Rating +15 (+165 -150). A. Make it Beautiful 题意 给定一个数组 \(a\)，将其重新排列，使其满足对于任意 \(a_i\)，均满足前缀和 \(sum_{i-1} \neq a_i\)。 思路 将数组降序排列即可。 需要特判一种情况，当降序排列后，第一个数和第二个数重复，那么需要向后枚举，找到第一个不一样的数，将其和第一个数交换即可。若没有这个数，输出 \(NO\)。 时间复杂度：最坏\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t -- > 0)&#123; int n = scanner.nextInt(); int[] sum = new int[n + 1]; Integer[] a = new Integer[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a, (o1, o2) -> o2 - o1); if(a[0] != a[1])&#123; System.out.println("YES"); for(int i=0;i&lt;n;i++) System.out.printf("%d ", a[i]); System.out.println(); continue nxt; &#125; boolean flag = false; for(int i=2;i&lt;n;i++)&#123; if(a[i] != a[1])&#123; int tmp = a[i]; a[i] = a[1]; a[1] = tmp; flag = true; break; &#125; &#125; if(flag)&#123; System.out.println("YES"); for(int i=0;i&lt;n;i++) System.out.printf("%d ", a[i]); System.out.println(); &#125;else System.out.println("NO"); &#125; &#125; &#125; 签到签到，简单的贪心 B. Matrix of Differences 题意 给定矩阵的规模 \(n\)，构造一个 \(n \times n\) 的矩阵，使所有相邻的 \(x,y\) 的 \(|x-y|\) 值中不同的数值的个数最大。 思路 既然要让不同的差值出现，那么我们可以按照 \(1,n-1,2,n-2,...\) 的方式排列，为了让这个排列的数字能相邻，最简单的方法就是按蛇形排布，输出这个排列即可。 时间复杂度：\(O(n^2)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t -- > 0)&#123; int n = scanner.nextInt(); int[][] a = new int[n][n]; int now = 1; boolean flag = true; int l = 1, r = n * n; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; int p = i % 2 == 0 ? j : n - j - 1; a[i][p] = flag ? l ++ : r --; flag = !flag; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++)&#123; System.out.printf("%d ", a[i][j]); &#125; System.out.println(); &#125; &#125; &#125; &#125; 怎么赛时就是想了那么久呢... C. Yet Another Tournament 题意 给定数组 \(a\)，规定自己和其他的对手的输赢取决于准备时间，如果将要打败的对手的等待时间总和小于等于 \(m\) ，那么判定为获胜。而其他的对手之间的输赢取决于下标，\(i&gt;j\) 时 \(i\) 赢。在允许出现同名次的条件下，打败的对手越多，排名越靠前，输出自己的排名。 思路 我们把这两个类型拆分成两个问题，最后合并在一起： 升序排序准备时间，统计能打败多少人，记为 \(ans\)； 因为 \(ans+1 &gt; ans\)，所以 \(ans+1\) 的排名会更高，所以我们需要将 \(ans+1\) 对应的值替换过来，否则排名会向后移一位。所以我们需要判断 \(ans+1\) 在排序前数组中对应的值是否可以替换掉 \(ans\) 在排序后数组中对应的值，如果不可以，那么将排名后移。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t -- > 0) &#123; int n = scanner.nextInt(), m = scanner.nextInt(); int[] a = new int[n + 2], b = new int[n + 1]; for (int i = 1; i &lt;= n; i++) a[i] = b[i] = scanner.nextInt(); Arrays.sort(b, 1, n + 1); int ans = 0, sum = 0; for (int i = 1; i &lt;= n; i++) &#123; if(sum + b[i] > m) break; sum += b[i]; ans ++; &#125; if (sum + a[ans + 1] - b[ans] > m) System.out.println(n - ans + 1); else System.out.println(Math.max(n - ans, 1)); &#125; &#125; &#125; 题目要看清]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 142</title>
    <url>/blog/posts/3006209530/</url>
    <content><![CDATA[Contestant. Rank 2570. Rating +70. A. GamingForces 题意 给定一个数组 \(a\)，定义操作可任选其一： 将其中两个元素减 \(1\) 将某个元素减为 \(0\) 输出最少的操作数，使 \(a\) 的所有元素都减为 \(0\)。 思路 将所有为 \(1\) 的元素配对，扣去偶数个 \(1\) 后，剩下的元素全都执行操作 \(2\) 即可。 时间复杂度：最坏\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int cnt = 0; for(int i=0;i&lt;n;i++) if(scanner.nextInt() == 1) cnt ++; System.out.println(n - cnt / 2); &#125; &#125; &#125; 简单签到题 B. Stand-up Comedian 题意 给定整数 \(a_1\)，\(a_2\)，\(a_3\)，\(a_4\)，\(4\) 个整数代表了四个类型对应的笑话数量： \(A\) 和 \(B\) 都喜欢 \(A\) 喜欢，\(B\) 不喜欢 \(B\) 喜欢，\(A\) 不喜欢 \(A\) 和 \(B\) 都不喜欢 初始状态下，两人的心情值都为 \(0\)，对于喜欢的笑话，心情会 \(+1\)，否则会 \(-1\)。 输出最多能讲多少个笑话。 思路 模拟+思维 首先，我们先把类型 \(1\) 讲完，如果 \(a_1=0\)，直接判 \(1\) 个。 接着，我们讨论 \(|a_2-a_3|\) 和 \(a_1\) 的大小关系，若 \(a_1\) 较小，那么笑话是讲不完的，只有 \(2 \times (a_1+\min(a_2,a_3)) + 1\) 个笑话可以讲。 否则，将 \(|a_2-a_3|\) 讲完后，判断剩余的可以讲多少个 \(a_4\) 即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int[] a = new int[4]; for(int i=0;i&lt;4;i++) a[i] = scanner.nextInt(); if(a[0] == 0)&#123; System.out.println(1); continue; &#125; int n = Math.min(a[1], a[2]), ans = 0; ans += a[0] + n * 2; int m = Math.max(a[1] - n, a[2] - n); if(a[0] &lt; m)&#123; System.out.println(2 * (a[0] + n) + 1); &#125;else&#123; ans += m; ans += Math.min(a[0] - m + 1, a[3]); System.out.println(ans); &#125; &#125; &#125; &#125; 思路好乱 C. Min Max Sort 题意 给定一个排列 \(p\)，定义一次操作为任选两个元素，将其从原排列中取出，将较小元素放至排列头部，较大元素放至排列尾部，输出最小的操作数，使最后的排列升序。 思路 逆向思维 显然，我们需要对形如 \([i,n-i+1]\) 的元素对进行操作。 考虑到一个不需要移动的元素对，应满足三个条件： \(i\) 在 \(n-i+1\) 前面 \(i\) 在 \(i+1\) 前面 \(n-i\) 在 \(n-i+1\) 前面 筛出所有不需要移动的元素对并取补集即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); int[] w = new int[n + 1]; int ans = n / 2; for (int i = 1; i &lt;= n; i++) w[scanner.nextInt()] = i; for (int i = n / 2; i >= 1; i--) &#123; //排除不用移动的 if (w[i] &lt; w[i + 1] &amp;&amp; w[n - i + 1] > w[n - i] &amp;&amp; w[i] &lt; w[n - i + 1]) ans--; else break; &#125; System.out.println(ans); &#125; &#125; &#125; 反着想简单多了 D. Fixed Prefix Permutations 题意 给定整数 \(n\) 和 \(m\)，定义两个排列 \(p\)，\(q\) 的乘积为一个新的排列 \(r\)，其中 \(r_j=q_{p_j}\)。给定长度为 \(m\) 的 \(n\) 个排列，对于每一个排列，输出其与所有 \(n\) 个排列的乘积构成的排列的最大美丽值。其中美丽值定义为满足 \(p_1=1,p_2=2,...,p_k=k\) 的 \(k\) 的最大值（\(p_1 \neq 1\)时美丽值为 \(0\)）。 思路 显然，对于给定的排列 \(p\) 和 \(q\)，若已知 \(q\)，那么所构造出来的 \(r\) 和 \(p\) 是一一对应的。所以，我们可以将问题转化一下： 对于所有 \(q\)，先预处理构造出满足 \(k=m\) 的排列 \(p_t\) ，然后对于每一个 \(p\) ，在所有 \(p_t\) 中依次匹配，输出从第一个开始最大的连续匹配数量。 为了让匹配的复杂度降到最低，我们可以采用字典树。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 50010; int n, m; int a[N][20], tmp[20]; class Trie &#123; private: vector&lt;Trie*> children; public: Trie() : children(12)&#123;&#125; void insert() &#123; Trie* node = this; for (int i=0;i&lt;m;i++) &#123; int ch = tmp[i]; if (node->children[ch] == nullptr) &#123; node->children[ch] = new Trie(); &#125; node = node->children[ch]; &#125; &#125; int find(int index) &#123; Trie* node = this; int dep = 0; for (int i=0;i&lt;m;i++) &#123; int ch = a[index][i]; if (node->children[ch] == nullptr) &#123; return dep - 1; &#125; node = node->children[ch]; dep ++; &#125; return dep; &#125; &#125;; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; Trie root = *new Trie(); cin >> n >> m; for(int i=0;i&lt;n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cin >> a[i][j]; tmp[a[i][j]] = j; &#125; root.insert(); &#125; for(int i=0;i&lt;n;i++)&#123; cout &lt;&lt; root.find(i) &lt;&lt; " "; &#125; cout &lt;&lt; '\n'; &#125; &#125; 题目真的很难看懂...]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 842 Div 2</title>
    <url>/blog/posts/3350941822/</url>
    <content><![CDATA[Contestant. Rank 7746. Rating -64 (+186 -250). A. Greatest Convex 题意 给定 \(k\)，输出满足条件的 \(x\)，使 \(x!+(x-1)!\) 为 \(k\) 的倍数。 思路 \(x!+(x-1)!=(x-1)!(x+1)\)，显然，令 \(x+1=k\) 即可，答案即为 \(k-1\)。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; System.out.println(scanner.nextInt() - 1); &#125; &#125; &#125; 怎么会有这么签到的题 B. Quick Sort 题意 给定整数 \(k\) 以及一个排列 \(p\)，定义一次操作为选择 \(k\) 个数并将其升序移至排列末尾。输出最少操作数，使整个排列升序。 思路 显然，最后的排列一定是 \(1,2,3,...\)，那么，我们不妨先来考虑单个元素是否需要移至后面。 对于一个元素 \(t\)，如果它的前面没有出现 \(t-1\)，那么显然我们只有将他移动至最后才能让排列成功构造出来，否则我们就无需操作。 所以，我们只需统计需要移动的元素数量 \(sum\)，然后输出 \(\lfloor \frac{sum}{k} \rfloor\) 即可，因为每次移动我们可以选多个。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(), k = scanner.nextInt(); boolean[] a = new boolean[n + 1]; int sum = 0; for(int i=0;i&lt;n;i++)&#123; int cur = scanner.nextInt(); a[cur] = true; if(cur != 1)&#123; if(!a[cur - 1]) &#123; a[cur] = false; sum ++; &#125; &#125; &#125; System.out.println((int) Math.ceil((double) sum / k)); &#125; &#125; &#125; 从一个推向多个是否合理呢 C. Elemental Decompress 题意 给定数组 \(a\) 以及其长度 \(n\)，规定 \(1 \leq a_i \leq n\)。构造两个排列 \(p\)，\(q\)，满足 \(\max(p_i,q_i)=a_i\)。若能构造，输出 \(YES\) 以及其中一种构造，否则输出 \(NO\)。 思路1 显然，一个数不能出现三次及以上，否则无法构造。 并且，我们可以发现，排序后的数组，若出现元素满足 \(a_i&lt;i\)，那么也无法构造（可以使用反证法） 那么，我们可以降序排序数组，并执行下面的两个操作： 遍历数组，将重复两次的数分散到两个数组内，做拆分（此时可排除出现三次及以上的数）； 遍历数组，如果 \(a_i\) 在 \(p\) 内，那么寻找不在 \(q\) 中的最大值，将其放入 \(q\)，反之亦如此。 遍历结束后，若全都填满了就是有解，输出即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main &#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt:while(t -- > 0)&#123; int n = console.nextInt(); int[][] a = new int[n + 1][2]; boolean[] inp = new boolean[n + 1], inq = new boolean[n + 1]; for(int i=1;i&lt;=n;i++) a[i] = new int[]&#123;i, console.nextInt()&#125;; Arrays.sort(a, 1, n + 1, Comparator.comparingInt(o -> -o[1])); int[] p = new int[n + 1], q = new int[n + 1]; for(int i=1;i&lt;=n;i++)&#123; int k = a[i][0], v = a[i][1]; if(inp[v] &amp;&amp; inq[v])&#123; console.println("NO"); continue nxt; &#125; if(inp[v])&#123; q[k] = v; inq[v] = true; &#125;else&#123; p[k] = v; inp[v] = true; &#125; &#125; int rp = n, rq = n; for(int i=1;i&lt;=n;i++)&#123; int k = a[i][0]; if(p[k] == 0)&#123; while(inp[rp]) rp --; inp[rp] = true; if(rp > q[k])&#123; console.println("NO"); continue nxt; &#125; p[k] = rp --; &#125;else&#123; while(inq[rq]) rq --; inq[rq] = true; if(rq > p[k])&#123; console.println("NO"); continue nxt; &#125; q[k] = rq --; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!inp[i] &amp;&amp; !inq[i])&#123; console.println("NO"); continue nxt; &#125; &#125; console.println("YES"); for(int i=1;i&lt;=n;i++) console.print(p[i] + " "); console.println(); for(int i=1;i&lt;=n;i++) console.print(q[i] + " "); console.println(); &#125; console.close(); &#125; //快读模板，此处略去 //public static class Console implements Closeable &#123;&#125; &#125; 思路2 首先，这种思路无法通过 \(Test3\)。 若未考虑到 思路\(1\) 中第二个结论，那么我们可以考虑使用链表的方式，遍历排序后的数组的时候，我们可以把求得的解对应的元素删去，从而获取到我们想要的元素。 时间复杂度约为\(O(n^2)\)，无法通过 对应AC代码 在赛时可以思考能否得出一些特定的结论出来]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Hello 2023</title>
    <url>/blog/posts/3186977285/</url>
    <content><![CDATA[Contestant. Rank 3574. Rating +50 (+400 -350). A. Hall of Fame 题意 给定一个只有 \(L\) 和 \(R\) 的长度为 \(n\) 的字符串，对于第 \(i\) 个字符，\(L\) 表示将 \([1,i-1]\) 照亮，\(R\) 表示将 \([i+1,n]\) 照亮。对于该字符串，允许选择一个 \(i\)，将 \(i\) 和 \(i+1\) 对应的字符交换，该操作最多可执行一次。判断是否可以将所有点照亮。若无需交换，输出 \(0\)；若交换后才满足条件，输出 \(i\)；若无法满足条件，输出 \(-1\)。 思路 很显然，只要出现 \(R,...,L\) 的排列，就一定可以满足条件。 那么，我们首先可以寻找第一个 \(R\) 之后有没有 \(L\)，只要找到了 \(L\) 就直接输出 \(0\) 即可。 否则，我们就需要寻找 \(LR\)，并将其交换，并输出 \(L\) 对应的下标。 否则，输出 \(-1\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t-- > 0)&#123; int n = scanner.nextInt(); char[] a = scanner.next().toCharArray(); int l = 0, r = 0, lr = -1; boolean preR = false; for(int i=0;i&lt;a.length;i++)&#123; if(i &lt; a.length - 1 &amp;&amp; lr == -1 &amp;&amp; a[i] == 'L' &amp;&amp; a[i + 1] == 'R') lr = i + 1; if(a[i] == 'R') preR = true; else if(preR)&#123; System.out.println(0); continue nxt; &#125; &#125; System.out.println(lr); &#125; &#125; &#125; 简单思维题 B. MKnez's ConstructiveForces Task 题意 给定数组的长度 \(n\)，构造一个非零数组 \(s\)，满足对于任何 \(i \in [1,n)\)，有 \(s_1+s_2+...+s_n=s_i+s_{i+1}\)。若不可构造，输出 \(NO\)，否则输出 \(YES\)，以及所构造的数组。 思路 将等式右边移到左边，那么我们只需满足任意取出两个数后数组的和都为 \(0\) 即可。那么很显然，当 \(n\) 为偶数时，我们只需构造一个 \(1,-1,1,-1,...\) 的数组即可。 而当 \(n\) 为奇数的时候，既然等式左边有 \(n\) 项，而右边有 \(2\) 项，若仍然考虑相邻数的和相等的构造方式的话，我们不妨让这个相等的和为 \(1\)，这样的话，式子将会变为 \(s_x+\frac{n}{2}=1\)，那么多出来的项 \(s_x\) 即为 \(1-\frac{n}{2}\) 。因而，令 \(w=\frac{n}{2}\)，我们只需构造 \(1-w,w,1-w,w,1-w,...\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t-- > 0)&#123; int n = scanner.nextInt(); if(n == 3) System.out.println("NO"); else&#123; System.out.println("YES"); if(n % 2 == 0)&#123; for(int i=0;i&lt;n/2;i++) System.out.print("1 -1 "); &#125;else&#123; int w = n / 2; System.out.printf("%d ", 1 - w); for(int i=0;i&lt;n/2;i++) System.out.printf("%d %d ", w, 1 - w); &#125; System.out.println(); &#125; &#125; &#125; &#125; 既然是成对的，那就让和也成对呗 C. Least Prefix Sum 题意 给定一个数组 \(a\)，定义一次操作为任取一个数并将其改为它的相反数。输出最少的操作数，使 \(a\) 的前 \(m\) 项和为 \(a\) 的所有前 \(k\) 项和（\(k \in [1,n]\)）中的最小值。 思路 对于题给式子 \(a_1+a_2+...+a_k \geq a_1+a_2+...+a_m\)， 当 \(k \leq m\) 时，将不等式左边移到右边，我们可以得到第一个条件：以 \(m\) 为结尾的不包括 \(a_1\) 的后缀和均为非正数。 同理，当 \(k \geq m\) 时，将不等式右边移到左边，我们可以得到第二个条件：以 \(m+1\) 为第一项的前缀和均为非负数。 因为上述两者差不多，我们不妨来考虑前者。 显然，在遍历所有后缀和的时候，我们不可以在发现某一项不满足时直接把这一项取相反数，因为我们不能保证后面的项比这一项小，而将最大值取反才是最优解。 因此，为了每次查询的复杂度降到一个合理的值，我们可以采用优先队列。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t-- > 0) &#123; int n = scanner.nextInt(), m = scanner.nextInt(); long[] a = new long[n + 1]; for(int i=1;i&lt;=n;i++) a[i] = scanner.nextInt(); PriorityQueue&lt;Long> positive = new PriorityQueue&lt;>((o1, o2) -> Math.toIntExact(o2 - o1)); PriorityQueue&lt;Long> negative = new PriorityQueue&lt;>(Comparator.comparingLong(o -> o)); long cnt = 0, sum = 0; for(int i=m;i>=2;i--)&#123; sum += a[i]; if(a[i] > 0) positive.offer(a[i]); while(sum > 0) &#123; sum -= 2 * positive.poll(); cnt ++; &#125; &#125; sum = 0; for(int i=m + 1;i&lt;=n;i++)&#123; sum += a[i]; if(a[i] &lt; 0) negative.offer(a[i]); while(sum &lt; 0) &#123; sum -= 2 * negative.poll(); cnt ++; &#125; &#125; System.out.println(cnt); &#125; &#125; &#125; 优先队列yyds]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 3</title>
    <url>/blog/posts/2583580825/</url>
    <content><![CDATA[Rank 196/3562. AC 7/11. 这标题显然是参考了arcaea的final verdict包的剧情，对吧 A. 不断减损的时间 题意 给定一个数组，数值可以为负数。对于无限次的操作，你可以任选一个偶数并将其除以 \(2\)，输出最后总和的最大值。 思路 将所有正偶数暴力除到奇数为止，并求和即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); long ans = 0; for(int i=0;i&lt;n;i++)&#123; int a = scanner.nextInt(); if(a &lt;= 0) ans += a; else&#123; while(a % 2 == 0) a /= 2; ans += a; &#125; &#125; System.out.println(ans); &#125; &#125; 快速签到 B. 勉强拼凑的记忆 题意 给定 \(n\) 块矩形积木，积木的大小为 \(1 \times k\)，\(k\) 可在 \([1,\lceil \frac{n}{2} \rceil ]\) 内任意选择，若能使用所有积木搭成正方形，输出最大的边长，否则输出 \(-1\)。 思路 很难说思路，因为可以打表打出规律（（ 前 \(30\) 个根据打表得到 \(1,-1,2,2,3,4,5,5,6,6,\) \(7,8,9,9,10,10,11,12,13,13,\) \(14,14,15,16,17,17,18,18,19,20\) 很容易就可以得到一个通式 \(ans=\frac{(q \times 2 + q \ \%\ 2)}{3}\) 至于为什么会这样，我们可以考虑 \(6\) 以上的数，因为横放几个最长的方块，然后再竖着放一个方块，最后在最后一行填满方块，即为 \(6 -11\) 之间的规律，而 \(12\) 以上，我们就可以发现最底下还可以再塞一行，然后在右边再放上一个方块依然是可行的，以此类推... 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; long q = scanner.nextLong(); if(q == 2) System.out.println(-1); //下面式子会算成0... else System.out.println((q * 2 + q % 2) / 3); &#125; &#125; &#125; 打表好累.jpg C. 忽远忽近的距离 题意 构造一个排列，满足 \(2 \leq |a_i-i| \leq 3\)。 思路 打表，暴力找规律即可。 可以发现是 \(4\) 个为一块有规律输出的，处理结尾数字即可。 时间复杂度：\(O(1)\) （确信 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n; cin >> n; if(n &lt; 4) cout &lt;&lt; -1 &lt;&lt; '\n'; else if(n == 4) cout &lt;&lt; "3 4 1 2\n"; else if(n == 5) cout &lt;&lt; "4 5 1 2 3\n"; else if(n == 6) cout &lt;&lt; "4 5 6 1 2 3\n"; else if(n == 7) cout &lt;&lt; -1 &lt;&lt; '\n'; else if(n == 8) cout &lt;&lt; "3 4 1 2 7 8 5 6\n"; else if(n == 9) cout &lt;&lt; "3 4 1 2 7 8 9 5 6\n"; //狠狠地打表 else &#123; int i = 0; if (n % 4 == 3) for (; i &lt; n / 4 - 2; i++) cout &lt;&lt; i * 4 + 3 &lt;&lt; " " &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " "; else for (; i &lt; n / 4 - 1; i++) cout &lt;&lt; i * 4 + 3 &lt;&lt; " " &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " "; if (n % 4 == 0) cout &lt;&lt; i * 4 + 3 &lt;&lt; " " &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2; else if (n % 4 == 1) cout &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 5 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " " &lt;&lt; i * 4 + 3; else if (n % 4 == 2) cout &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 5 &lt;&lt; " " &lt;&lt; i * 4 + 6 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " " &lt;&lt; i * 4 + 3; else cout &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 5 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " " &lt;&lt; i * 4 + 3 &lt;&lt; " " &lt;&lt; i * 4 + 9 &lt;&lt; " " &lt;&lt; i * 4 + 10 &lt;&lt; " " &lt;&lt; i * 4 + 11 &lt;&lt; " " &lt;&lt; i * 4 + 6 &lt;&lt; " " &lt;&lt; i * 4 + 7 &lt;&lt; " " &lt;&lt; i * 4 + 8; &#125; &#125; 打表好累.jpeg D. 宿命之间的对决 题意 给定一个正整数 \(n\)，小红和小紫轮流取当前数的因子 \(x\) ，使当前数减少 \(x\) 。如果小红获胜，则输出 "\(kou\)"，否则输出 "\(yukari\)" 思路 简单的博弈题。 我们先假设每个人都只拿 \(1\) 个，那么最后一定是第一次拿的时候当前数为偶数的一方获胜。 然而，输的一方肯定想要获胜，那么他一定要拿掉偶数个才行，而无论他怎么拿，获胜方都可以只拿掉奇数来使他只能从奇数的因数中取，从而不可能取到偶数，因而必输。 所以，判奇偶即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println(scanner.nextLong() % 2 == 1 ? "yukari" : "kou"); &#125; &#125; 次世代の宿命之红砍光光（？ E. 公平守望的灯塔 题意 给定在平面直角坐标系的整点 \(A(x_A,y_A)\) 和 \(B(x_B,y_B)\) ，输出一个整点 \(C\) ，使得 \(\Delta ABC\) 为以 \(AB\) 为斜边的 等腰\(Rt\Delta\)。 思路 "K型全等"，找出中点后用全等即可解出。 当 \(A\) 和 \(B\) 横坐标的差值和纵坐标的差值的奇偶性不一致时，\(C\) 点一定会有小数 \(0.5\) 存在，因此该条件无解。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long xa = scanner.nextLong(), ya = scanner.nextLong(), xb = scanner.nextLong(), yb = scanner.nextLong(); if(Math.abs(xa - xb) % 2 == Math.abs(ya - yb) % 2)&#123; //初中数学？ long mid2x = xa + xb, mid2y = ya + yb; System.out.printf("%d %d\n", (mid2x + mid2y) / 2 - ya, (mid2y - mid2x) / 2 + xa); &#125;else System.out.println("No Answer!\n"); &#125; &#125; 画个图，不就是个初中数学题嘛 F. 迎接终结的寂灭 题意 输出 \(42\)。 思路 输出 \(42\)。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; System.out.println(42); &#125; &#125; 怎么会是呢 G. 严肃古板的秩序 题意 给定一个运算式，其中等式左边的符号全都被替换成 \(?\)，等式右边只有一个数字，符号只有三种可能：\(+\)，\(-\)， #，其中定义\(a\)#\(b=a^a \mod b,a&gt;0且b&gt;0\)，三个符号的优先级相同，输出一个合法的式子，否则输出 \(-1\)。 思路 暴力 \(Dfs\) 即可，其中模幂运算需要使用快速幂。 时间复杂度：\(O(3^x \log n),x \leq 12\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; static int n; static long ans; static long[] nums; static char[] op; static boolean ok = false; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String[] s = scanner.next().split("\\?"); n = s.length; nums = new long[n]; for(int i=0;i&lt;n-1;i++) nums[i] = Long.parseLong(s[i]); nums[n - 1] = Long.parseLong(s[n - 1].split("=")[0]); ans = Long.parseLong(s[n - 1].split("=")[1]); op = new char[n - 1]; dfs(0, nums[0]); if(!ok) System.out.println(-1); &#125; private static void dfs(int index, long last)&#123; if(index == n - 1)&#123; if(last == ans) &#123; ok = true; print(); &#125; return; &#125; if(ok) return; op[index] = '+'; dfs(index + 1, last + nums[index + 1]); if(ok) return; op[index] = '-'; dfs(index + 1, last - nums[index + 1]); if(ok || last &lt;= 0 || nums[index + 1] &lt;= 0) return; op[index] = '#'; dfs(index + 1, BigInteger.valueOf(last).modPow(BigInteger.valueOf(last), BigInteger.valueOf(nums[index + 1])).longValue()); &#125; private static void print()&#123; System.out.printf("%d", nums[0]); for(int i=1;i&lt;n;i++)&#123; System.out.printf("%c%d", op[i - 1], nums[i]); &#125; System.out.printf("=%d\n", ans); &#125; &#125; 很经典的回溯搜索 H. 穿越万年的轮回 待补充 I. 灵魂碎片的收集 题意 定义 \(S(n)\) 为 \(n\) 的所有不包括 \(n\) 的因数的和，给定正整数 \(x\)，输出满足 \(S(n)=x\) 的正整数 \(n\)，否则输出 \(-1\)。 限制 对于输入的 \(x\)，有以下限制： \(x\%2=0\)，则 \(x-1\) 和 \(x-3\) 之间一定有一个是质数。 \(x\%2=1\)，则无限制 思路 我们可以直接从限制入手： 若 \(x\) 为偶数，且 \(x-1\) 是质数，那么显然只有一种分解 \(S(n)=1+(x-1)=x\)，那么 \(n=(x-1)^2\)。 若 \(x\) 为偶数，且 \(x-3\) 是质数，那么也只有一种分解 \(S(n)=1+2+(x-3)=x\)，那么 \(n=2(x-3)\)。 若 \(x\) 为奇数，因为 \(1\) 一定是其中一个因子，那么剩下的一定是偶数。因为所有偶数都可以分解为两个质数之和，那么我们可以直接暴力，枚举出一种可能即可。 当然，为了判定素数方便，我们采取用线性筛打表的方式来让查询的复杂度降到 \(O(1)\)。 时间复杂度：懒得分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 1000010; #define ll long long vector&lt;int> primes; bool vis[N + 1], isPrime[N + 1]; void init() &#123; for (int i = 2; i&lt;= N; ++i) &#123; if (!vis[i]) &#123; primes.emplace_back(i); isPrime[i] = true; &#125; for (int &amp;j : primes) &#123; if (1ll * i * j > N) break; vis[i * j] = true; if (i % j == 0) break; &#125; &#125; &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t; ll x; cin >> t; int ans[] = &#123;0, -1, -1, 4, 9, -1, 25, 8&#125;; while (t--) &#123; cin >> x; if(x &lt;= 7) cout &lt;&lt; ans[x] &lt;&lt; '\n'; else &#123; if (x % 2 == 0) &#123; if (isPrime[x - 1]) cout &lt;&lt; (x - 1) * (x - 1) &lt;&lt; '\n'; else cout &lt;&lt; 2 * (x - 3) &lt;&lt; '\n'; &#125; else &#123; for (int i = 2; i &lt;= x; i++) &#123; if(isPrime[i] &amp;&amp; isPrime[x - i - 1]) &#123; cout &lt;&lt; (ll)i * (x - i - 1) &lt;&lt; '\n'; break; &#125; &#125; &#125; &#125; &#125; &#125; 赛时眼瞎了没看到限制 J. 无法磨灭的悔恨 待补充 K. 永恒守候的爱恋 题意 假设 \(p_1,p_2,...,p_n\) 为前 \(n\) 个素数，定义 \(S\) 为 \(a_i\) 个 \(p_i\) 组成的多重集合 \((i \in [1,n])\)。 例如，多重集{2,2,3,3,3,7}可以表示为： \(n=4,a=[2,3,0,1]\)。 定义\(f(i)\) 为一个数组前 \(i\) 个元素的乘积的因子数量，给定 \(n\) 和数组 \(a\)，他表示了一个大小为 \(\displaystyle{size=\sum_{i=1}^{n}a_i}\) 的多重集。用这个多重集的所有元素构造一个大小为 \(size\) 的数组，输出 \(\displaystyle{\sum_{i=1}^{size}f(i)}\) 的最大值，对 \(10^9+7\) 取模。 思路 \(Buff\) 叠满的数学题。 我们先来考虑因子个数：根据算数基本定理，对于一个分解式 \(x=P_1^{\alpha_1}P_2^{\alpha_2}...P_n^{\alpha_n}\)，因数数量为 \((\alpha_1 + 1)(\alpha_2 + 1)...(\alpha_n+1)\)。 那么既然我们要让这个乘积更大，我们就可以每次都不重复地将数字放上去，如 \(|2,3,7||2,3||3|\)。那么对于第一块，结果为 \(2 \times 1 \times 1\)、\(2 \times 2 \times 1\)、\(2 \times 2 \times 2\)。对于第二块，结果为 \(3 \times 2 \times 2\)、\(3 \times 3 \times 2\)。对于第三块，结果为 \(4 \times 3 \times 2\)。 显然，上述式子是分块的等比数列求和，其中 \(q=2,\frac{3}{2},\frac{4}{2},...\) 因而，我们只需一块一块地处理即可。 当然，为了快速求出每一块的元素个数，我们只需在读入的时候使用差分的方法，具体地来说： 横向从左到右绘制一张柱状图，那么纵切面的数量即为每块的元素数量。 时间复杂度：不好评价 对应AC代码 注意，此代码不一定能运行通过，有概率会超时 import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] t = new int[200010]; for(int i=0;i&lt;n;i++)&#123; t[scanner.nextInt() + 1] --; t[1] ++; &#125; int max = 0; for(int i=1;i&lt;200010;i++) &#123; t[i] += t[i - 1]; if(t[i] == 0) &#123; max = i - 1; break; &#125; &#125; long ans = 0, a1 = 1, an; BigInteger res = BigInteger.ONE, ip1, mod = BigInteger.valueOf(1000000007L); for(int i=1;i&lt;=max;i++)&#123; //规避一下逆元 int now = t[i], nxt = t[i + 1]; ip1 = BigInteger.valueOf(i + 1); res = res.multiply(ip1.modPow(BigInteger.valueOf(now - nxt), mod)).mod(mod); a1 = (a1 * (i + 1)) % 1000000007L; an = res.multiply(ip1.modPow(BigInteger.valueOf(nxt), mod)).mod(mod).longValue(); ans = (ans + (an * (i + 1)) % 1000000007L + 1000000007L - a1) % 1000000007L; a1 = an; &#125; System.out.println(ans); &#125; &#125; 不用考虑第几个质数是啥呢]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 2</title>
    <url>/blog/posts/4009320463/</url>
    <content><![CDATA[Rank 906/3920. AC 5/12. A. Tokitsukaze and a+b=n (easy) 题意 在两个闭区间 \([L1, R1]\) 和 \([L2, R2]\) 之间取两个数 \(a\)，\(b\)，满足 \(a+b=n\)。\(a \neq b\) 时交换两者可算作两种选法。输出选法总数。 思路 暴力枚举 \(a\)，\(b\)。快速签到。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T = scanner.nextInt(); while(T -- > 0)&#123; int n = scanner.nextInt(); int l1 = scanner.nextInt(), r1 = scanner.nextInt(); int l2 = scanner.nextInt(), r2 = scanner.nextInt(); int cnt = 0; for(int i=l1;i&lt;=r1;i++)&#123; int j = n - i; if(j >= l2 &amp;&amp; j &lt;= r2) cnt ++; &#125; System.out.println(cnt); &#125; &#125; &#125; 先签了再说 B. Tokitsukaze and a+b=n (medium) 题意 同\(A\)题，只有样例数量增加了。 思路 一个取交集的思路： 当两个集合有交集时，那么将存在一段值相等的区间，因而我们化 \(a+b=n\) 为 \(a=n-b\) ，求等式两边集合的交集的元素数量即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T = scanner.nextInt(); while (T-- > 0) &#123; int n = scanner.nextInt(); long l1 = scanner.nextInt(), r1 = scanner.nextInt(), l2 = scanner.nextInt(), r2 = scanner.nextInt(); System.out.println(Math.max(0, Math.min(n - l1, r2) - Math.max(n - r1, l2) + 1)); &#125; &#125; &#125; 这么好的思路，赛时怎么就没想到呢，淦 C. Tokitsukaze and a+b=n (hard) 题意 给定 \(m\) 个区间，在不同的区间内分别取 \(a\)，\(b\)，同 \(AB\)，输出方案数。 思路 在 \(B\) 题的思路基础上，我们只需先用差分快速求出一个点 \(t_i\) 被多少个区间覆盖，求和后便可很快算出一段区间内有多少元素在交集之内了，这里我们可以使用两次前缀和。注意，这里需要排除在相同区间内取交集。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; static final int N = 400010, mod = 998244353; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); int[] l = new int[m], r = new int[m]; long[] sum = new long[N + 1]; for(int i=0;i&lt;m;i++)&#123; l[i] = scanner.nextInt(); r[i] = scanner.nextInt(); sum[r[i] + 1] --; sum[l[i]] ++; &#125; for(int i=1;i&lt;=N;i++) &#123; sum[i] += sum[i - 1]; sum[i] %= mod; &#125; for(int i=1;i&lt;=N;i++) &#123; //差分转前缀和 sum[i] += sum[i - 1]; sum[i] %= mod; &#125; long ans = 0; for(int i=0;i&lt;m;i++)&#123; int l1 = l[i], r1 = r[i], l2 = n - r[i], r2 = n - l[i]; if(r2 &lt; 1) continue; l2 = Math.max(1, l2); ans += sum[r2] - sum[l2 - 1]; ans -= Math.max(0, Math.min(r1, r2) - Math.max(l1, l2) + 1); while(ans &lt; 0) ans += mod; ans %= mod; &#125; System.out.println(ans); &#125; &#125; 想不出来B题那个简单的做法这题就寄咯 D. Tokitsukaze and Energy Tree 题意 给定一个根为 \(1\) 、有 \(n\) 个节点的树，将 \(n\) 个为 \(v_i\) 的能量球放到 \(n\) 个节点上，在每次放置时可获得自己加上子树的所有能量，输出能获得的最大能量。 思路1 显然，我们可以贪心地认为从小到大从顶部往下按层放置即可，这样就可以保证最大的能量在层数最大的叶节点。 因而，我们可以直接用 \(BFS\) 暴力模拟解决问题。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long const int N = 200020; int n; vector&lt;int> e[N]; int w[N], idx = 1; ll ans = 0; int v[N]; bool vis[N]; void bfs()&#123; queue&lt;pair&lt;int, int>> q; q.emplace(1, 1); ans += v[idx ++]; vis[1] = true; while(q.size())&#123; auto t = q.front(); q.pop(); for(int c : e[t.first])&#123; if(vis[c]) continue; vis[c] = true; ans += (t.second + 1) * v[idx ++]; q.emplace(c, t.second + 1); &#125; &#125; &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> n; for(int i=1;i&lt;n;i++)&#123; int f; cin >> f; e[f].emplace_back(i + 1); &#125; for(int i=1;i&lt;=n;i++) cin >> v[i]; sort(v + 1, v + n + 1); bfs(); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; 思路2 题目输入有限制，在给出节点 \(i\) 的父亲的时候，满足父亲的下标小于 \(i\) ，所以是没必要 \(BFS\) 的，直接用数组即可。 时间复杂度：\(O(n)\) #include&lt;bits/stdc++.h> using namespace std; const int N = 200010; #define ll long long ll v[200005], d[200005]; int main() &#123; int n, f, ans = 0; d[1] = 1; cin >> n; for(int i=2;i&lt;=n;i++) &#123; cin >> f; d[i] = d[f] + 1; &#125; for(int i=1;i&lt;=n;i++) cin >> v[i]; sort(v + 1, v + n + 1); sort(d + 1, d + n + 1); for(int i=1;i&lt;=n;i++) ans += v[i] * d[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 看清题目的输入啊，完全没必要BFS E. Tokitsukaze and Function 题意 给定函数 \(f(x)= \lfloor \frac{n}{x} \rfloor + x - 1\) 以及区间 \([L,R]\)，输出 使 \(f(t)\) 最小 的 最小整数 \(t\) 。 思路 首先，去掉向下取整符号后，这是一个对勾函数，那么最小值将在 \(\sqrt x\) 处取到。 保留符号后，最小值会在 \(\lfloor \sqrt x \rfloor\) 和 \(\lceil \sqrt x \rceil\) 处取到，我们记为 \(p\)。 显然，在尝试几个数后，我们可以发现存在至少一段值都为最小值的区间，且 \(p\) 在区间内部。 不过，因为我们需要取 \(t_{\min}\)，所以我们只需从 \(p\) 点向左找转折点，即左边的值大于自身的那个点。 我们先来特判几个情况： \(p \leq L\) 时，输出 \(l\) 即可。 \(p &gt; R\) 时，我们可以将寻找转折点的区间缩小为 题给区间 \([L,R]\) 。 我们可以发现，题目给的数据量特别大，而且我们要找的区间是有单调性的，二分查找即可。 时间复杂度：\(O(\log x)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T = scanner.nextInt(); while(T -- > 0) &#123; long n = scanner.nextLong(), l = scanner.nextLong(), r = scanner.nextLong(); long p = Math.round(Math.sqrt(n)) + 1; if(p &lt;= l)&#123; System.out.println(l); continue; &#125; if (f(n, p - 1) &lt;= f(n, p)) p --; if(p > r) p = r; long left = l, right = p, mid; while(left &lt; right)&#123; mid = (left + right) >> 1; if(f(n, mid) &lt;= f(n, right)) right = mid; else left = mid + 1; &#125; System.out.println(left); &#125; &#125; private static long f(long n, long x)&#123; return n / x + x - 1; &#125; &#125; 不要死磕在一道题 F. Tokitsukaze and Gold Coins (easy) 题意 给定 \(n \times 3\) 有障碍迷宫，输出从 \((1，1)\) 到 \((n, 3)\) 的所有路径中经过的点的个数，不重复计算。 思路 正反两遍 \(BFS\)，统计被访问两遍的点的个数即可，无需找规律。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long const int N = 500010; int n; bool have[N][4], vis[N][4][2]; void bfs(pair&lt;int, int> s, int w) &#123; queue&lt;pair&lt;int, int>> q; q.emplace(s); while (!q.empty()) &#123; auto t = q.front(); q.pop(); if(vis[t.first][t.second][w]) continue; vis[t.first][t.second][w] = true; if (w) &#123; if (t.first - 1 > 0 &amp;&amp; !have[t.first - 1][t.second]) q.emplace(t.first - 1, t.second); if (t.second - 1 > 0 &amp;&amp; !have[t.first][t.second - 1]) q.emplace(t.first, t.second - 1); &#125; else &#123; if (t.first + 1 &lt;= n &amp;&amp; !have[t.first + 1][t.second]) q.emplace(t.first + 1, t.second); if (t.second + 1 &lt;= 3 &amp;&amp; !have[t.first][t.second + 1]) q.emplace(t.first, t.second + 1); &#125; &#125; &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, k, x, y; cin >> t; while (t--) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= 3; j++) &#123; vis[i][j][0] = vis[i][j][1] = have[i][j] = false; &#125; cin >> n >> k; while (k--) &#123; cin >> x >> y; have[x][y] = !have[x][y]; &#125; bfs(&#123;1, 1&#125;, 0); bfs(&#123;n, 3&#125;, 1); vis[1][1][0] = vis[1][1][1] = false; long long cnt = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= 3; j++) if (vis[i][j][0] &amp;&amp; vis[i][j][1]) cnt++; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; &#125; 先试试暴力啊，怎么会t呢？ G. Tokitsukaze and Gold Coins (hard) 待补充 H. Tokitsukaze and K-Sequence 题意 给定数组 \(a\)，将其划分为 \(k\) 个非空可不连续的子序列，输出 \(k \in [1, n]\) 时子序列的总和的最大值。定义子序列的值为只出现一次的数字个数。 思路 定义 \(cnt_i\) 为出现 \(i\) 次的数的个数。 \(k=1\) 时，显然答案为 \(cnt_1\)。 \(k&gt;1\) 时，我们可以将 \(cnt_p,p \in [k,n]\) 对应数都留下一个，其余全都取出作为新子序列，此时答案为上一个答案的基础上加上 \(cnt_k+(cnt_k+cnt_{k+1}+...+cnt_{n})\)。 可以证明此时的个数最大。 因此，我们可以用类似于后缀和的方法写。 当然也有更简单的写法。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.BigInteger; import java.util.*; public class Main&#123; //快读，此处略过 //public static class Console implements Closeable &#123;&#125; public static void main(String[] args) throws Throwable&#123; Console scanner = new Console(); int T = scanner.nextInt(); while(T -- > 0)&#123; int n = scanner.nextInt(); Map&lt;Integer, Integer> cnt = new HashMap&lt;>(); int max = 0; for(int i=0;i&lt;n;i++) &#123; int b = scanner.nextInt(); int p = cnt.getOrDefault(b, 0) + 1; cnt.put(b, p); max = Math.max(max, p); &#125; int[] p = new int[max + 1], suf = new int[max + 1]; for(int e : cnt.keySet()) p[cnt.get(e)] ++; suf[max] = p[max]; for(int i=max-1;i>=1;i--) suf[i] = suf[i + 1] + p[i]; long ans = p[1]; scanner.println(ans); for(int i=2;i&lt;=max;i++)&#123; ans += suf[i] + p[i]; scanner.println(ans); &#125; for(int i=max+1;i&lt;=n;i++) scanner.println(ans); &#125; scanner.close(); &#125; &#125; 很签的题呢 I. Tokitsukaze and Musynx 题意 对于 \(n\) 个 \(Note\)，有 \(5\) 个判定区间，每个区间有对应分数，输出调整谱面延时后分数的最大值。 给定 \(n\) 个音符，每个音符有对应判定分 \(x\)，定义五个判定区间 \((- \infty,a)\), \([a,b)\), \([b,c)\), \([c,d]\), \((d,+\infty)\)，\(x\) 落在区间内可获得对应分数 \(v_1\)，\(v2\)，\(v3\)，\(v4\)，\(v5\)。输出将所有的 \(x\) 加上或减去任意值后判定分总和的最大值。 思路 考虑到枚举 \(h\) 的时间复杂度过大，我们尝试另一种暴力枚举的方法： 将所有 \(x\) 减去一个较大的值，使所有的音符全都落在第一个判定区间内； 用数组存储每一个音符达到下一个判定区间的 \(\Delta x\)，以及对应的分数改变量； 按 \(\Delta x\) 升序排序，枚举所有改变量并算出分数的最大值即可。 时间复杂度：\(O(4n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long const ll N = 200010, inf = 1e18; ll x[N]; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) &#123; int n, a, b, c, d, v1, v2, v3, v4, v5; cin >> n; for (int i = 0; i &lt; n; i++) &#123; cin >> x[i]; x[i] -= 2ll * 1e9; &#125; cin >> a >> b >> c >> d >> v1 >> v2 >> v3 >> v4 >> v5; vector&lt;pair&lt;ll, int>> p; for (int i = 0; i &lt; n; i++) &#123; p.emplace_back(a - x[i], v2 - v1); p.emplace_back(b - x[i], v3 - v2); p.emplace_back(c - x[i], v4 - v3); p.emplace_back(d + 1 - x[i], v5 - v4); &#125; sort(p.begin(), p.end()); ll cur = v1 * n, ans = cur; for (auto &amp;e: p) &#123; cur += e.second; ans = max(ans, cur); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 一个音游人居然没开这题 J. Tokitsukaze and Sum of MxAb 题意 给定数组 \(a\)，定义 \(MxAb(i,j)=\max(|a_i-a_j|,|a_i+a_j|)\)，求 \(\displaystyle{\sum_{i=1}^n\sum_{j=1}^nMxAb(i,j)}\)。 思路 很显然，同号取和的绝对值，异号取差的绝对值，总和显然是和所有 \(|a_i|\) 的总和有关的。 可以贪心的认为，\(ans=sum\{|a_i|\} \times 2n\)。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T = scanner.nextInt(); while(T -- > 0)&#123; int n = scanner.nextInt(); int[] a = new int[n]; long ans = 0; for(int i=0;i&lt;n;i++) &#123; a[i] = scanner.nextInt(); ans += Math.abs(a[i]); &#125; System.out.println(ans * 2 * n); &#125; &#125; &#125; 签到题呢 K. Tokitsukaze and Synthesis and Traits 待补充 L. Tokitsukaze and Three Integers 题意 给定序列 \(a\) 和正整数 \(p\)，对于所有 \(x=0...p-1\)，输出满足条件的三元组 \([i,j,k]\) 的数量。 满足条件： $i j \(，\)i k\(，\)j k$； \((a_i·a_j+a_k) \equiv x(\mod p)\) 思路 因为 \(n\) 为 \(1e3\) 级别，所以可以考虑时间复杂度为 \(n^2\) 的做法。 我们可以把式子分解成 \((a_i·a_j) \mod p =(x-a_k) \mod p\)，因此我们只需计算等式左右两边的配对情况即可。 需要注意的是，\(k\) 不能和 \(i\)，\(j\) 相等，所以最后需要排除。 时间复杂度：\(O(n^2)\) 对应AC代码 import java.io.*; import java.math.BigInteger; import java.util.*; public class Main&#123; //快读，此处略过 //public static class Console implements Closeable &#123;&#125; public static void main(String[] args) throws Throwable&#123; Console console = new Console(); int n = console.nextInt(), p = console.nextInt(); long[] a = new long[n + 1]; for(int i=1;i&lt;=n;i++) a[i] = console.nextInt(); long[] cnt = new long[p]; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) cnt[(int)((a[i] * a[j]) % p)] += 2; long[] ans = new long[p]; for(int x=0;x&lt;p;x++) for(int k=1;k&lt;=n;k++)&#123; long i = x - a[k]; if (i &lt; 0) i += (-i / p + 1) * p; ans[x] += cnt[(int)(i % p)]; &#125; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++)&#123; ans[(int)((a[i] * a[j] + a[i]) % p)] -= 2; ans[(int)((a[i] * a[j] + a[j]) % p)] -= 2; &#125; for(int i=0;i&lt;p;i++) console.print(ans[i] + " "); console.close(); &#125; &#125; 别看了仔细想想就切题啊喂]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 1</title>
    <url>/blog/posts/2012230069/</url>
    <content><![CDATA[Rank 449/4376. AC 7/13. A. World Final? World Cup! (I) 题意 \(A\)队与\(B\)队轮流点球，\(A\)先手，判断\(10\)场内是否有某队必胜，输出该场次，或者输出\(-1\) 思路 对于第 \(i\) 场 \((i \in [0,9])\) ，剩余 \(left=10-i-1\) 场未打。 分开判断\(A\)队和\(B\)队， 对于\(A\)队，还有 \(left/2+(1-i\%2)\) 场； 对于\(B\)队，还有 \(left/2\) 场。 计算差值即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int a = 0, b = 0; char[] in = scanner.next().toCharArray(); int i = 0; for(;i&lt;10;i++) &#123; if (i % 2 == 0) a += in[i] - '0'; else b += in[i] - '0'; int left = 10 - i - 1; if (a > b + left / 2 + (1 - i % 2)) break; if (b > a + left / 2) break; &#125; System.out.println(i != 10 ? i + 1 : -1); &#125; &#125; &#125; 很签的题要做快一点 B. World Final? World Cup! (II) 待补充 C. 现在是，学术时间 (I) 题意 每个教授有一篇引用量为 \(a_i\) 的论文，一个教授可发表多篇论文，找出一种分配方式使所有教授的 \(H\) 指数最大。\(H\) 指数定义为使得"该教授发表的所有论文中，有至少 \(H\) 篇论文的引用量大于等于 \(H\) "这一命题成立的最大的 \(H\)。 思路 很容易发现，我们只需升序将文章分配，如果遇到有一篇论文分配不能让 \(h_i\) 增大，那就让另一个教授发表。因为每个教授只有一篇论文，所以论文无处可放的可能只有一个：引用量为 \(0\)。 \(ans=n-cnt_0\) 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int cnt = n; for(int i=0;i&lt;n;i++) &#123; int a = scanner.nextInt(); if(a == 0) cnt --; &#125; System.out.println(cnt); &#125; &#125; &#125; 能贪心就别想着去模拟 D. 现在是，学术时间 (II) 题意 在平面直角坐标系中，给定两个与坐标轴平行的矩形，第一个矩形由对角线上的两点 \((0,0)\) 和 \((x,y)\) 确定，第二个矩形的一个顶点为点 \(P(x_p,y_p)\)。记两矩形的交集面积为 \(S_1\)， 并集面积为 \(S_2\)， 输出 \(\{\frac{S_1}{S_2}\}_{\max}\)。 思路 根据糖水原理，分子小于分母时，分子和分母各加上\(k\)，分式结果变大。 那么，我们只需在每个方向上取交集的最大值，然后计算即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; //写太乱了，不建议做参考 int x = scanner.nextInt(), y = scanner.nextInt(), xp = scanner.nextInt(), yp = scanner.nextInt(); if(xp &lt;= x &amp;&amp; yp &lt;= y)&#123; System.out.println((double) Math.max(Math.max((x - xp) * (y - yp), xp * (y - yp)), Math.max(xp * yp, (x - xp) * yp)) / (x * y)); &#125;else if(xp > x &amp;&amp; yp > y)&#123; System.out.println((double) (x * y) / (xp * yp)); &#125;else if(xp > x &amp;&amp; yp &lt;= y)&#123; System.out.println(Math.max((double) (x * yp) / (x * y + yp * (xp - x)), (double) (x * (y - yp)) / (x * y + (y - yp) * (xp - x)))); &#125;else&#123; System.out.println(Math.max((double) (y * xp) / (x * y + xp * (yp - y)), (double) (y * (x - xp)) / (x * y + (x - xp) * (yp - y)))); &#125; &#125; &#125; &#125; 猜就完事了 E. 鸡算几何 题意 一根夹角不为 \(180°\) 和 \(360°\) 的 \(L\) 型铁丝，先后给出在平面中的三个点的坐标，判断是否出现了以边为轴的翻转。 思路1 计算四条边和 \(x\) 轴正半轴的夹角，判断较长边是否出现在较短边的顺时针方向。 时间复杂度：\(O(1)?\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int xa = scanner.nextInt(), ya = scanner.nextInt(), xb = scanner.nextInt(), yb = scanner.nextInt(), xc = scanner.nextInt(), yc = scanner.nextInt(); double xd = scanner.nextDouble(), yd = scanner.nextDouble(), xe = scanner.nextDouble(), ye = scanner.nextDouble(), xf = scanner.nextDouble(), yf = scanner.nextDouble(); if(calLen(xa, ya, xb, yb) == calLen(xc, yc, xb, yb))&#123; System.out.println("NO"); continue; &#125; System.out.println(judge(xa, ya, xb, yb, xc, yc) == judge(xd, yd, xe, ye, xf, yf) ? "NO" : "YES"); &#125; &#125; //返回较长边是否在较短边的顺时针方向 private static boolean judge(double xd, double yd, double xe, double ye, double xf, double yf)&#123; double de = calLen(xe, ye, xd, yd), ef = calLen(xe, ye, xf, yf); double dde = calDegree(xe, ye, xd, yd), def = calDegree(xe, ye, xf, yf); if(de > ef)&#123; if(dde > def)&#123; if(dde - def > 180) return true; else return false; &#125;else&#123; if(def - dde > 180) return false; else return true; &#125; &#125;else &#123; if(dde > def)&#123; if(dde - def > 180) return false; else return true; &#125;else&#123; if(def - dde > 180) return true; else return false; &#125; &#125; &#125; private static double calDegree(double startX, double startY, double endX, double endY)&#123; double tan = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI; if(tan &lt; 0) tan += 360; return tan; &#125; private static double calLen(double x1, double y1, double x2, double y2)&#123; return Math.sqrt(Math.pow(Math.abs(x1 - x2), 2) + Math.pow(Math.abs(y1 - y2), 2)); &#125; &#125; 思路2 通过叉乘的方式，判断较长边和较短边的位置关系。 时间复杂度：\(O(1)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; double calLen(double x1, double y1, double x2, double y2)&#123; return sqrt(pow(abs(x2 - x1), 2) + pow(abs(y2 - y1), 2)); &#125; double calCross(double x1, double y1, double x2, double y2)&#123; return x1 * y2 - x2 * y1; &#125; int main() &#123; int t, xa, ya, xb, yb, xc, yc; double xd, yd, xe, ye, xf, yf; cin >> t; while(t --)&#123; cin >> xa >> ya >> xb >> yb >> xc >> yc >> xd >> yd >> xe >> ye >> xf >> yf; double ab = calLen(xa, ya, xb, yb), bc = calLen(xb, yb, xc, yc), de = calLen(xd, yd, xe, ye), ef = calLen(xe, ye, xf, yf); if(ab == bc)&#123; cout &lt;&lt; "NO\n"; continue; &#125; //叉乘判断的是一个边在另一个边的哪个方向，那我们就需要用长边叉乘短边（或者换过来 if(ab &lt; bc) swap(xa, xc), swap(ya, yc); if(de &lt; ef) swap(xd, xf), swap(yd, yf); cout &lt;&lt; (calCross(xa - xb, ya - yb, xc - xb, yc - yb) * calCross(xd - xe, yd - ye, xf - xe, yf - ye) &lt; 0 ? "YES\n" : "NO\n"); &#125; return 0; &#125; L型到底是不是直角呢？ F. 鸡玩炸蛋人 题意 给出一个不一定联通的无向图以及每个点的标记情况。一个符合要求的方案定义为在一个连通块内取两个可以重复的点作为起点和终点，在路上按题给要求做上标记，并不能经过已经做过标记的点。若起点和终点有一个不同即视为方案不同。输出方案数，若无合法方案，输出 \(0\) 。 思路 因为标记后才不能回溯，所以我们完全可以以 \(DFS\) 深度遍历，并在回溯时做上标记。 也就是说，只要起点终点确定，一定能使方案符合要求。 因而，一个连通图的方案数即为 \(pow(cnt，2)\) ，\(cnt\) 为连通图的大小（点的数量）。 根据有标记的连通块个数分三种情况输出答案即可。 时间复杂度：\(O(tnm)\)，\(t\)为连通块数量 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long const int N = 200020; vector&lt;int> e[N]; int egg[N], n, m; bool vis[N]; pair&lt;ll, bool> dfs(int root)&#123; if(vis[root]) return &#123;0, false&#125;; vis[root] = true; ll cnt = 1; //我自己 bool have = egg[root] > 0; for(int t : e[root])&#123; auto c = dfs(t); if(c.second) have = true; cnt += c.first; &#125; return &#123;cnt, have&#125;; &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> n >> m; for(int i=0;i&lt;m;i++)&#123; int u, v; cin >> u >> v; e[u].emplace_back(v); e[v].emplace_back(u); &#125; for(int i=1;i&lt;=n;i++) cin >> egg[i]; ll tot = 0, cnt, eggCnt = 0; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]) continue; auto one = dfs(i); tot += one.first * one.first; if(one.second)&#123; eggCnt ++; cnt = one.first * one.first; &#125; &#125; if(eggCnt == 0) cout &lt;&lt; tot &lt;&lt; '\n'; else if(eggCnt == 1) cout &lt;&lt; cnt &lt;&lt; '\n'; else cout &lt;&lt; 0 &lt;&lt; endl; &#125; 多看看题，这题真的比上一题好做多了 G. 鸡格线 题意 给定数组 \(a\) ，对于 \(m\) 次询问，分成两种操作处理： 输入 \(l\)，\(r\)，\(k\)，对区间 \([l,r]\) 中的所有数字执行 \(k\) 次赋值操作：\(a_i=round(10\sqrt x)\)。 输出所有数字的和 重点 当操作次数 \(k \geq 20\) 时，\(f(x)=x\)，可以根据收敛证明。 思路1 维护一个 \(Set\)，存放剩下需要操作的数，然后暴力即可。 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); long[] a = new long[n + 1]; long sum = 0; TreeSet&lt;Integer> left = new TreeSet&lt;>(); for(int i=1;i&lt;=n;i++) &#123; sum += a[i] = scanner.nextInt(); if(f(a[i]) != a[i]) left.add(i); &#125; while(m -- > 0)&#123; int op = scanner.nextInt(); if(op == 1)&#123; int l = scanner.nextInt(), r = scanner.nextInt(), k = scanner.nextInt(); while(true)&#123; Object next = left.higher(l - 1); if(next == null) break; int nxt = Integer.parseInt(String.valueOf(next)); if(nxt > r) break; for(int i=1;i&lt;=Math.min(k, 20);i++)&#123; //最多20次操作即可让x0=f(x0) sum -= a[nxt]; a[nxt] = f(a[nxt]); sum += a[nxt]; &#125; if(a[nxt] == f(a[nxt])) left.remove(nxt); l = nxt + 1; &#125; &#125;else System.out.println(sum); &#125; &#125; private static long f(long x)&#123; return Math.round(Math.sqrt(x) * 10); &#125; &#125; 思路2 如果 \(l\) 已完成，那么可以用并查集的方式找到一个连通块后面的未完成点，开数组记录完成情况以及完成后连通块指向的点即可。 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long const int N = 100010; ll a[N]; int p[N], ne[N]; bool ok[N]; int find(int x) &#123; return p[x] == x ? x : p[x] = find(p[x]); &#125; void merge(int x, int y) &#123; x = find(x), y = find(y); p[y] = x; ne[x] = max(ne[x], ne[y]); &#125; ll f(ll x)&#123; return round(sqrt(x) * 10); &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; ll sum = 0; for (int i = 1; i &lt;= n; i++) &#123; cin >> a[i]; sum += a[i]; ne[i] = i + 1; p[i] = i; &#125; while (m-- > 0) &#123; int op; cin >> op; if (op == 1) &#123; int l, r, k; cin >> l >> r >> k; while (true) &#123; int nxt = ok[l] ? ne[find(l)] : l; if (nxt > r) break; for (int i = 1; i &lt;= min(k, 20); i++) &#123; //最多20次操作即可让x0=f(x0) sum -= a[nxt]; a[nxt] = f(a[nxt]); sum += a[nxt]; &#125; if (a[nxt] == f(a[nxt])) &#123; ok[nxt] = true; if (nxt &lt; n &amp;&amp; ok[nxt + 1]) merge(nxt, nxt + 1); if (nxt > 1 &amp;&amp; ok[nxt - 1]) merge(nxt, nxt - 1); &#125; l = nxt + 1; &#125; &#125; else cout &lt;&lt; sum &lt;&lt; '\n'; &#125; &#125; 思路3 一眼线段树，但我不会写。 对应AC代码 待补充 这题其实难在k H. 本题主要考察了DFS 题意 一个拼图有 \(n^2\) 块，部分块之间用凸出和缺口固定，缺口面积和凸出面积相等。一块拼图可用 上右下左 边的情况来表现状态，\(0\) 平整，\(1\) 缺口，\(2\) 凸起。给出 \(n^2-1\) 块，输出剩下的那块拼图的成本（\(10-cnt_1+cnt_2\)）。 思路 标题骗人，配对\(1\)和\(2\)即可 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int one = 0, two = 0; for(int i=0;i&lt;n * n -1;i++)&#123; String s = scanner.next(); for(char each : s.toCharArray())&#123; if(each == '1') one ++; else if(each == '2') two ++; &#125; &#125; int need = 10; if(one &lt; two)&#123; need -= two - one; &#125;else if(one > two)&#123; need += one - two; &#125; System.out.println(need); &#125; &#125; &#125; 这题还能做得再快点！ I. 本题也主要考察了DFS 待补充 J. 本题竟也主要考察了DFS 待补充 K. 本题主要考察了dp 题意 构建长为 \(n\)，只有 \(m\) 个 \(1\) 的 \(01\) 字符串，使连续的长度为\(3\)的子区间中满足 \(cnt_1&gt;cnt_0\) 的子区间的数量最小，并输出数量。 思路1 可以证明在 \(100,100,100,...\) 序列的最后插 \(1\) 的情况下数量最小。 那么，我们可以分三种情况： \(n \geq 3m-2\) 时，\(100\) 排不到结束，数量为 \(0\)。 \(n==m\)，一定只有 \(n - 2\) 个，不能再多了。 我们寻找成对出现的 \(00\) 和 \(0?0\)，可以得到对数为 \(\frac{3}{2}(n-m) + (n-m)\%2 + 1\)，用总对数 \(n-2\) 扣除即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); if(n >= 3 * m - 2)&#123; System.out.println(0); &#125;else if(n == m)&#123; System.out.println(n - 2); &#125;else&#123; System.out.println(n - 1 - (n - m) / 2 * 3 - (n - m) % 2); &#125; &#125; &#125; 思路2 根据思路\(1\)的第一句话，模拟建立字符串并遍历统计个数。 时间复杂度：\(O(n)\) 对应AC代码 待补充 思路3 状压\(dp\)可解。 对应AC代码 待补充 来波逆向思维~ L. 本题主要考察了运气 题意 \(5\) 个团体，每个团体 \(4\) 人，对于猜测次数，输出\((\)猜对的数学期望\(-3.45)/0.05\)。 思路 五个团体，\(x=0.2 \times 1 + 0.2 \times 2 + 0.2 \times 3 + 0.4 \times 4=2.8\)； 四个人，\(y=0.25 \times 1+0.25 \times 2 + 0.5 \times 3=2.25\)； \(ans=32(5.05)\)。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; System.out.println(32); &#125; &#125; 6遍就猜对了哈哈哈 M. 本题主要考察了找规律 题意 将 \(m\) 份仙贝分给 \(n\) 位朋友。若分给某个好朋友时，还剩 \(x\) 个仙贝，并给了他 \(y\) 个仙贝，那么定义每个朋友的好感度为 \(\frac{y}{x}\)。求出总好感度的最大值。 思路 动态规划，不是找规律！！！ \(dp[i][j]\) 为 目前给了 \(i\) 个人仙贝，总共给了 \(j\) 个仙贝的最大总好感度。 枚举第 \(i\) 个人分到的仙贝数 \(k\)，得到状态转移方程： \(dp[i][j]=max(dp[i-1][j-k]+\frac{k}{m-(j-k)}),k \leq j\) 时间复杂度：小于\(O(nm^2)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); double[][] dp = new double[n + 1][m + 1]; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; double max = 0; for(int k=1;k&lt;=j;k++)&#123; max = Math.max(max, dp[i - 1][j - k] + (double) k / (m - j + k)); &#125; dp[i][j] = max; &#125; &#125; System.out.println(dp[n][m]); &#125; &#125; 防诈骗]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 837 Div 2</title>
    <url>/blog/posts/2672195264/</url>
    <content><![CDATA[Practice. Solved 3 of 6. A. Hossam and Combinatorics 题意 定义数对 \((a_i,a_j)\) 满足 \(i \neq j\)。给定数组 \(a\)，输出满足 \(|a_i-a_j|\) 最大的数对数量。 思路 既然要找出 \(\max(|a_i-a_j|)\)，那么我们就需要先把它求出来。更具体地说，我们在读入数组 \(a\) 的时候可以顺便记录下来最大值 \(maxx\) 和最小值 \(minn\)，方便后续操作。 考虑到我们不可能再对数组进行多次遍历，我们可以在读入数组 \(a\) 的时候也记录一下每个数字出现的次数 \(cnt\)，为节省空间我们可以用 \(map\) 存储。 令 \(maxx-minn=dist\)，那么对于一个数对 \((a_i,a_j)\)，我们只需满足 \(|a_i-a_j|=dist\)，去掉绝对值，我们便可以得到两个式子：\(a_j=a_i-dist\)，\(a_j=a_i+dist\)。不妨记此时的 \(a_j\) 为左值和右值，那我们就只需遍历所有 \(a_i\)，判断一下 \(cnt[a_j]\) 是否大于 \(0\) 即可。对于左值和右值，我们可以分开标记以防重复计算（看到题解并没有这么做，待考证.jpg) 对于每次遍历的统计，我们只需 \(ans+=cnt[a_i] \times cnt[a_j] \times 2\) 即可。 时间复杂度：最坏 \(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 100010, inf = 0x3f3f3f3f; int a[N]; bool stl[N], str[N]; int main() &#123; int T, n; scanf("%d", &amp;T); while (T--) &#123; memset(a, 0, sizeof a); memset(stl, 0, sizeof stl); memset(str, 0, sizeof str); scanf("%d", &amp;n); map&lt;int, long long> cnt; int minn = inf, maxx = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;a[i]); cnt[a[i]] ++; minn = min(minn, a[i]); maxx = max(maxx, a[i]); &#125; int dist = maxx - minn; long long ans = 0; if(dist == 0) ans = (long long) n * (n - 1); else for(int i=0;i&lt;n;i++)&#123; if(!stl[a[i]]) &#123; stl[a[i]] = true; if (a[i] > dist &amp;&amp; cnt[a[i] - dist] > 0) &#123; str[a[i] - dist] = true; ans += cnt[a[i]] * cnt[a[i] - dist] * 2; &#125; &#125; if(!str[a[i]]) &#123; str[a[i]] = true; if (cnt[a[i] + dist] > 0) &#123; stl[a[i] + dist] = true; ans += cnt[a[i]] * cnt[a[i] + dist] * 2; &#125; &#125; &#125; printf("%lld\n", ans); &#125; &#125; 思维还是很重要滴 B. Hossam and Friends 题意 给定 \(m\) 组关系，约定除了这些关系外其他人都是好朋友，输出所有连续子序列中满足所有人都是好朋友的数量。 思路 我们先用一种双指针的思维来模拟一下：一开始，\(l=0,r=0\)，然后我们将 \(r\) 向后移，会发现我们能向右移的范围在缩小。因为每扩大一次区间，我们就会遇到更多对陌生人。为了处理这种情况，我们可以在读入关系 \((x,y)\) 的时候顺便记录下来 \(\min(x,y)\) 对应的 \(\max(x,y) -1\)，这样我们在每次遍历的时候就可以以 \(O(1)\) 的时间复杂度更新右端点最大值了，当无法继续时，我们再更改 \(l\)，直到结束。 上述思路是完全正确的，但存在一个问题：暴力模拟 \(1e10\) 的复杂度绝对是超时的。 顺着不行，我们来换个方向。依然是固定 \(l\)，但这次我们从 \(n-1\) 往回推，就不难发现一个递推式子了： 定义 \(nxt[i]\) 为以 \(i\) 为左边界的满足条件的最小右边界，那么 \(nxt[i]=\min(e[i],nxt[i+1])\) 。这里的 \(e\) 数组即为1中记录的关系 \((x,y)\)。 很好理解，在向左移动头节点的时候，尾节点已经遍历过后面的所有值，因而我们可以直接用动态规划的思路来推出 \(nxt\) 数组。 接下来就好办了，既然对于每个左边界 \(i\)，都能找到确定的右边界 \(nxt[i]\)，那么连续子区间数量就为 \(nxt[i]-i+1\) 了。 当然，\(e\) 数组和 \(nxt\) 数组完全可以合并。 时间复杂度： \(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 100010, inf = 0x3f3f3f3f; int nxt[N]; int main() &#123; int T, n, m, x, y; scanf("%d", &amp;T); while (T--) &#123; //hey, this is easy. scanf("%d %d", &amp;n, &amp;m); for(int i=1;i&lt;=n;i++) nxt[i] = n; for(int i=0;i&lt;m;i++)&#123; scanf("%d %d", &amp;x, &amp;y); nxt[min(x, y)] = min(nxt[min(x, y)], max(x, y) - 1); &#125; for(int i=n-1;i>=1;i--) nxt[i] = min(nxt[i], nxt[i + 1]); long long ans = 0; for(int i=1;i&lt;=n;i++) ans += nxt[i] - i + 1; printf("%lld\n", ans); &#125; &#125; 都想到双指针了，何不换个方向想想看呢 C. Hossam and Trainees 题意 给定数组 \(a\)，输出是否有满足 \(gcd(a_i,a_j)&gt;1,i \neq j\) 的 \(i,j\)。 思路 优雅的暴力 我们只需打表，筛出所有我们需要的质数，然后分解质因数并记录每个因数出现的次数即可，只要有一个 \(cnt \geq 2\)，那么直接判YES即可。 当然，这么暴力是绝对超时的，我们可以考虑下面的优化思路： 线性筛法，复杂度降到 \(O(n)\)。 既然是分解质因数，那么我们只需分解小的那一半即可，大的无需考虑，因而我们可以把边界缩小到 \(\sqrt{10^9}=31623\)。 时间复杂度： \(O(\frac{n \sqrt{A}}{\log n})\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 1e5 + 5; vector&lt;int> primes; bool vis[N + 1]; map&lt;int, int> cnt; void init() &#123; for (int i = 2; i &lt;= N; ++i) &#123; if (!vis[i]) &#123; primes.emplace_back(i); &#125; for (int &amp;j : primes) &#123; if (1ll * i * j > N) break; vis[i * j] = true; if (i % j == 0) break; &#125; &#125; &#125; bool fact(int x) &#123; int max = (int) sqrt(x); for (int &amp;i : primes) &#123; if(i > max) break; if (x % i == 0) &#123; while (x % i == 0) x /= i; cnt[i] ++; if(cnt[i] == 2) return true; &#125; &#125; if (x != 1) &#123; cnt[x] ++; if(cnt[x] >= 2) return true; &#125; return false; &#125; int main() &#123; init(); int T, n; scanf("%d", &amp;T); while (T--) &#123; cnt.clear(); scanf("%d", &amp;n); bool ok = false; for(int i=0;i&lt;n;i++)&#123; int x; scanf("%d", &amp;x); if(ok) continue; if(fact(x)) ok = true; &#125; printf(ok ? "YES\n" : "NO\n"); &#125; &#125; 有时候可以想想暴力+优化的思路呢]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Good Bye 2022</title>
    <url>/blog/posts/3334935914/</url>
    <content><![CDATA[Contestant. Rank 9289. Rating -54 (+446 -500). A. Koxia and Whiteboards 题意 给定序列 \(a\) , \(b\) , 执行 \(m\) 次操作，对于第 \(j\) 次操作，将序列 \(a\) 中任意数值修改为 \(b_j\) ，输出操作之后序列 \(a\) 的总和的最大值。 思路1 注意到题目所给 \(n\) 和 \(m\) 很小，因而我们可以遍历 \(b_j\)，在每次替换前 \(sort\) 一遍 \(a\) 数组，然后替换 \(a_0\) 即可。 一句话，暴力+模拟。 时间复杂度：\(O(mn \log n)\) 当然也可以用优先队列优化时间复杂度，不过优化后差不多，所以不放代码了。 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t-- > 0)&#123; int n = scanner.nextInt(), m = scanner.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); for(int i=0;i&lt;m;i++) &#123; Arrays.sort(a, 0, n); a[0] = scanner.nextInt(); &#125; long ans = 0; for(int i=0;i&lt;n;i++) ans += a[i]; System.out.println(ans); &#125; &#125; &#125; 思路2 先大胆假设：既然对于 \(a\) 中的修改是任意的，那么我们只要把 \(a\) 升序排序，依次用降序排序的 \(b\) 中的值替换即可。 假设如此，但需要注意到一点：操作的顺序是不能更改的。 因此，在排序前，我们需要一并存下来 \(b_i\) 的下标。在替换时，我们需要记录访问到的 \(b_i\) 所存原下标的最大值 \(imax\)，如果 \(imax \neq m-1\)，那么肯定还有一些较小的值等待替换，这些值显然是小于剩下的 \(a_i\) 的。所以，我们可以贪心的认为，我们只需找到替换后的一个合适的 \(a_p\)，用 \(b_{m-1}\) 替换即可。 那么，我们来考虑如何选取这个 \(a_p\)： 因为替换后的 \(a\) 序列是先递减后递增的，那么最小值将出现在最后一次替换的 \(b_j\) 和未替换的第一个 \(a_{i+1}\) （ \(b_j\) 替换 \(a_i\) ）之间，即 \(a_p=\min(a_{i+1}, b_j)\)。当然，肯定要判一下 \(i\) 的大小，不能越界。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(), m = scanner.nextInt(); int[] a = new int[n]; int[][] b = new int[m][2]; for (int i = 0; i &lt; n; i++) a[i] = scanner.nextInt(); for (int i = 0; i &lt; m; i++) b[i] = new int[]&#123;i, scanner.nextInt()&#125;; int lastB = b[m - 1][1]; Arrays.sort(a); Arrays.sort(b, (o1, o2) -> o2[1] - o1[1]); long ans = 0; int i = 0, j = 0, lastChange = 0, lastChangedI = 0, approached = 0; for (; i &lt; n &amp;&amp; j &lt; m; i++) &#123; if (a[i] &lt; b[j][1]) &#123; approached = Math.max(approached, b[j][0]); lastChange = b[j][1]; lastChangedI = i; ans += b[j++][1]; &#125; else ans += a[i]; &#125; for (; i &lt; n; i++) ans += a[i]; if(j == 0) ans = ans - a[0] + lastB; else if(j &lt; m &amp;&amp; approached != m - 1) &#123; ans = ans - (lastChangedI + 1 > n - 1 ? lastChange : Math.min(lastChange, a[lastChangedI + 1])) + lastB; &#125; System.out.println(ans); &#125; &#125; &#125; 有时候很简单的签到题不要想太多 B. Koxia and Permutation 题意 给定 \(n\)，\(k\)，求出一种 \(n\) 的排列 \(p\)，使得对于每个长度为 \(k\) 的连续子序列中，最大值和最小值的和最小。 思路 既然要让最大值和最小值的和最小，那么我们就需要让最大值出现的次数尽量少，最小值出现的次数尽量多。 因而，结合区间的移动，我们可以先降序地输出 \(k-1\) 个数，然后再输出 \(1\)，此时1出现的次数被最大化。 同理，那么我们就可以在降序输出后升序输出 \(k\) 个数，然后重复上述2个步骤，循环输出至无数可输出为止。 当然，可以证明交替输出和上述思路得到的序列性质是一样的。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; int n, k; scanf("%d %d", &amp;n, &amp;k); int l = 1, r = n, now = k - 1; for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", now > 0 ? r-- : l++); now--; if (now == 1 - k) now = k - 1; &#125; printf("\n"); &#125; &#125; 思维题还是要多做做，写太慢了。 而且如果用java写的话，需要使用快读，否则会超时。 C. Koxia and Number Theory 题意 给定序列 \(a\) ，判断是否存在 \(x\) ，满足对于任意不同的两个下标 \(i\) , \(j\) ，都有 \(gcd(a_i+x,a_j+x)=1\)。 做法 显然不能出现重复数值 考虑每个质数 \(t\) , 遍历序列 \(a\) , 统计所有 \(a_i \% t\) 出现的次数，若全都大于2，判定NO 对于第二步的数学证明 假设 \(a_u\) 和 \(a_v\) 同余于质数 \(p\)，那么 \(a_u+x\) 和 \(a_v+x\) 同余于 \(p\)。 在1的条件下，要使 \(gcd(a_u+x,a_v+x)\) 不被 \(p\) 整除，则必须满足 \((x + a_u) \not\equiv 0 \pmod p\) 。 因而，我们需要存在至少一个 \(a_i \% p\) 的值 \(j\) ，满足 \(x \equiv (p-j) \pmod p\)，这样，我们就可以使用 中国剩余定理 (CRT) 解出 \(x\)。 任取一个 \(j\) ，若它的出现次数 \(cnt_j\geq2\)，那么存在 \(x\) 符合条件1的条件。此时，根据上面的证明，可以得出\(x \not\equiv (p-j) \pmod p\) 。 由上述证明，若所有 \(cnt_i\geq2\)，那么无法解出 \(x\) ，判定为NO。 对于上述证明的具体例子 判定YES的一个例子： 对于下面的输入 1 3 5 7 10 取 \(p = 2\)，则可得取余后的序列 \(1, 1, 0\)，此时 \(cnt_0&lt;2\)，\(cnt_1\geq2\)，有 \(x \equiv 2-0 \pmod 2\) 取 \(p = 3\)，则可得取余后的序列 \(2, 1, 1\)，此时 \(cnt_1\geq2\)，\(cnt_2&lt;2\)，有 \(x \equiv 3-2 \pmod 3\) ... 对于每一个 \(p\) ，都有一个同余方程组，可根据 \(CRT\) 求出 \(x\) 的一个通解。从而，我们可以联立后解出 \(x\)。 判定NO的一个例子： 对于下面的输入 1 11 6 9 12 14 16 17 18 20 25 28 30 取 \(p = 5\)，则可得取余后的序列 \(1,4,2,4,1,2,3,0,0,3,0\)，此时对于任意 \(j\)，都有 \(cnt_j\geq2\)，因而我们无法找到一个式子满足\(x \equiv (p-j) \pmod p\)，从而无法解得 \(x\) 。 中国剩余定理 (CRT) 对于 \(m_1, m_2, ...,m_n\)，满足 \(gcd(m_1,m_2,..,m_n)=1\)，则对于如下形式的一元线性同余方程组 \(\begin{cases} x \equiv a_1 \pmod{m_1}\\ x \equiv a_2 \pmod{m_2}\\ \cdots\\ x \equiv a_n \pmod{m_n} \end{cases}\) 计算 \(M=\prod\limits_{i=1}^n m_i,M_i=\dfrac{M}{m_i}\)，即 \(M_i\) 是除 \(m_i\) 之外其他整数的乘积； 设 \(t_i\) 为 \(M_i\) 模 \(m_i\) 的逆元，即求 \(t_i = (M_i)^{-1}\pmod{m_i}\)； 上述方程组的通解为：\(x=a_1t_1M_1+a_2t_2M_2+...+a_nt_nM_n+kM，k\in Z\) 。模 \(M\) 后，只有一个解 \(x=a_1t_1M_1+a_2t_2M_2+...+a_nt_nM_n\)。 更加直观的做法 枚举所有元素，若有重复则判NO； 枚举所有 \(2 \sim n/2\) 的数 \(p\)，若模 \(p\) 后的序列所有数字出现的次数都大于 \(2\)，那么判NO。 第二步的可行性 肉眼可见，当 \(n\) 足够大时，判断素数的步骤是超时的，但因为我们是从小到大枚举的，因而我们可以保证所有合数在被枚举到之前都已经被判断过，且加上对于合数的可行性判断后，时间复杂度在合理范围内。 对于右边界 \(n/2\)，我们考虑抽屉原理：将 \(n+1\) 个物品放入 \(n\) 个抽屉，肯定有至少一个抽屉有两个物品。 那么，对于 \(n\) 个物品，放入大于 \(n/2\) 个抽屉中，我们肯定无法让所有抽屉都放上 \(2\) 个物品。 因而，我们只需遍历到 \(n/2\) 即可。 时间复杂度：\(O\left(\frac{n^2}{\log n} \right)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t -- > 0)&#123; int n = scanner.nextInt(); long[] a = new long[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextLong(); for(int i=1;i&lt;n;i++) for(int j=i-1;j>=0;j--) if(a[i] == a[j])&#123; System.out.println("NO"); continue nxt; &#125; for(int i=2;i&lt;=n / 2;i++)&#123; int[] m = new int[i]; boolean f = false; for(int j=0;j&lt;n;j++) m[(int)(a[j] % i)] ++; for(int j=0;j&lt;i;j++) &#123; if(m[j] &lt; 2) &#123; f = true; break; &#125; &#125; if(!f)&#123; System.out.println("NO"); continue nxt; &#125; &#125; System.out.println("YES"); &#125; &#125; &#125; 数论得多看看力，有时候可以多尝试一些数据来找寻规律。]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
</search>
