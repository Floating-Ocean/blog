<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome to My Blog</title>
    <url>/blog/posts/2656694144/</url>
    <content><![CDATA[欢迎来到 Floating Ocean’s Blog!这是一个部署在 $Github$ 上的个人博客，博客目前涵盖部分算法竞赛平台的个人题解和思路，随本人刷题进度更新，欢迎大家偷窥我是否在卷。 博客基于 $Hexo + Butterfly$ 改造，支持评论、一言等拓展功能。 以下为最近更新的题解，详见归档页。 站点更新日志 有关文章更新日志，请移步 归档 页 23.04.05 迁移站点主题至 $Butterfly$，同步了部分功能 23.03.08 调整部分ui 23.03.07 优化站点资源加载速度 23.03.06 将所有扣分局的文章信息框标红 修复几处链接错误 23.03.04 更新主页 更新置顶功能 添加短链功能，显示在文章标题的右下角 添加 $warn$ 标签，在文章中以红色引用框显示 这是一个带有warn标签的提示 23.03.02 添加 $todo$ 标签，在文章中以黄色引用框显示 这是一个带有todo标签的提示 23.02.19 添加 $info$ 标签，在文章中以绿色引用框显示 添加文章底部版权框 点击一言进入官网 这是一个带有info标签的提示 23.02.12 添加顶部加载条，和文章阅读进度条样式一致 23.02.11 全局更改了动画差值器 23.02.10 加入每日一言 优化评论区样式 23.02.09 改用 $prism$ 渲染代码 加入 $spoiler$，用于 $detail$ 标签的支持 23.02.06 优化评论区样式 23.02.02 评论区功能完善 23.02.01 新增评论区功能 23.01.30 更新图标库 加入站内搜索 23.01.24 站点独立为新的 $repo$ 23.01.15,18,19,21 优化样式 23.01.14 搭建初始框架 到底了捏，更新还在路上~]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - CodeTON Round 4 Div 1 plus 2</title>
    <url>/blog/posts/3139923560/</url>
    <content><![CDATA[Contestant(alt). 开摆Rank 5778. Rating -11(+89 -100). A. Beautiful Sequence题意给定一个序列，输出是否存在一个子序列，存在一个元素满足 $a_i = i$。 思路显然，我们只需遍历一遍序列，找出一个 $a_i$，满足 $a_i \leq i$ 即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; bool f = false; for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; if(cur &lt;= i) f = true; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 水 B. Candies题意对于一个数 $x$，定义操作如下： $x :=2x + 1$ $x := 2x - 1$ 给定一个若干次操作后的数，判断初始值是否为 $1$，并输出方案。 思路首先，得到的数都是奇数，所以我们从这里下手即可。 我们判断 $\frac{x-1}{2}$ 的奇偶性，若为奇数，那么 $x := \frac{x-1}{2}$，否则 $x := \frac{x + 1}{2}$ 。 可以断定，只要一开始 $x$ 不是偶数，最后的结果一定是 $1$。 时间复杂度：$O(log_2n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; if(n % 2 == 0) &#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; vector&lt;int> ans; while(n > 1)&#123; if((n - 1) / 2 % 2 == 0) n = (n + 1) / 2, ans.emplace_back(1); else n = (n - 1) / 2, ans.emplace_back(2); &#125; reverse(ans.begin(), ans.end()); cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 你说我这脑子怎么就转不过来呢 C. Make It Permutation题意给定一个序列，定义操作为下面两者任选其一： 删除一个元素，代价为 $c$； 插入一个元素，代价为 $d$。 找出代价最小的一种方案，使最后的序列变为任意长度的排列，输出最小代价。 思路贪心。 我们先记最后的答案为 $cost$。 首先，我们不妨先把序列排个序，然后用 $unique$ 剔除重复元素，毕竟重复元素是一定要删去的，我们记剔除这些元素的总代价为 $rm$。 然后，我们从大到小遍历，处理相邻的两个数。对于这两个数，我们定义差值为 $dist$，以及右边那个数的后面还有 $cnt$ 个数字。那么，我们有两种处理： $dist=1$，那么不用管之 $dist &gt; 1$，我们需要比较一下删除这个元素和补上缺少的数的代价。 需要注意的是，如果我们决定删除这个数，那么后面的数都要一并删去。因为后面的数不删去的话，需要补全的数就更多了，而我们已经判定删除的代价更小。也就是说，删除后总代价更新为 $rm + c (cnt + 1)$。 而补全数字的代价为 $d(dist-1)$，也就是说，更新后的总价值为 $cost+d(dist-1)$。 因此，我们比较 $cost+d(dist-1)$ 和 $rm + c (cnt + 1)$ 即可。 需要注意的是，当第一个数不是 $1$ 的时候，我们不能删完所有数，所以一定会出现补全的代价。 到这里并没有结束，你会发现样例过不去。 这里有个有趣的点，我们为何不直接删掉所有数，然后放一个 $1$ 进去呢？我们将其和答案取最小值即可。 时间复杂度：$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, c, d; cin >> n >> c >> d; //反着做，看看删掉和补充哪个赚 vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a.begin(), a.end()); int rm = a.size(), sz = unique(a.begin(), a.end()) - a.begin(); rm -= sz; if(a[0] != 1) a.insert(a.begin(), 0ll), sz ++; int cost = rm * c; for(int i=sz-1;i>0;i--)&#123; int dis = a[i] - a[i - 1] - 1; if(a[i - 1] != 0 &amp;&amp; cost + dis * d > rm * c + c * (sz - i))&#123; cost = rm * c + c * (sz - i); &#125;else cost += dis * d; &#125; cout &lt;&lt; min(d + c * n, cost) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 简单的贪心捏，就是我怎么老搞错（ D. Climbing the Tree题意定义一个蜗牛在爬树，每天上升 $a$，下降 $b$，当某一天距离树的顶部小于等于 $a - 1$ 时，即可爬到顶。树的高度记为 $h$。 定义询问为下者二选一： $1\ a\ b \ n$，表示给定一组限制，在 $a, b$ 的条件下在第 $n$ 爬到顶。若限制不满足前面得到的范围，输出 $0$；否则输出 $1$，并更新 $h$ 的可能范围； $2\ a\ b$，判定这个条件下所需天数是否有唯一解，有的话输出，否则输出 $-1$。 思路首先，这是一道数学题。 我们先来考虑第一个： 如果它要在第 $n$ 天到达，首先前提是第 $n - 1$ 天不会到达，也就是说，$h \geq (a - b)(n - 1) + b$； 其次，爬到顶的条件是距离树的顶部小于等于 $a - 1$，也就是说，$h \leq (a - b)(n - 1) + (a - 1)$。 所以，若原求得的区间和 $[(a - b)(n - 1) + b, (a - b)(n - 1) + (a - 1)]$ 有交集，那么更新区间为两者交集，否则输出 $0$。 我们记得到的 $h \in [lh, rh]$。 我们再来看看第二个： 首先，如果能一步登天，即 $a - 1 \geq rh$，那么直接输出 $1$ 即可。 否则，我们只需满足一个不等式：$(a - b)(n - 1) + b \leq h \leq (a - b)(n - 1) + (a - 1)$。 化简可得： $\begin{cases} n \leq \frac{h - b}{a - b} + 1 \ n \geq \frac{h - (a - 1)}{a - b} + 1\end{cases} $ 那么，我们把 $rh$ 带入第一个式子，$lh$ 带入第二个式子，即可求出 $n$ 的所有可能范围。 那么，我们判断一下左右端点取整后是否相等即可。注意，右端点向下取整，左端点向上取整，因为这样取整后得到的区间是在原区间内的最长区间。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int q; cin >> q; int lh = -1, rh = inf; while(q --)&#123; int tp; cin >> tp; if(tp == 1)&#123; int a, b, n; cin >> a >> b >> n; int now = (a - b) * (n - 1); int now_l = n == 1 ? 0 : now + b, now_r = n == 1 ? a - 1 : now + a - 1; if(a &lt;= b || now_l > rh || now_r &lt; lh) cout &lt;&lt; 0 &lt;&lt; ' '; else&#123; cout &lt;&lt; 1 &lt;&lt; ' '; lh = max(lh, now_l), rh = min(rh, now_r); &#125; &#125;else&#123; int a, b; cin >> a >> b; if(a > rh) &#123; cout &lt;&lt; 1 &lt;&lt; ' '; continue; &#125; int min_x = (int) ceil((double) (lh - (a - 1)) / (double) (a - b)) + 1, max_x = (int) floor((double) (rh - (b)) / (double) (a - b)) + 1; if(min_x != max_x) cout &lt;&lt; -1 &lt;&lt; ' '; else cout &lt;&lt; min_x &lt;&lt; ' '; &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 别用 C++ 64位交即可.]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - 2023愚人节场</title>
    <url>/blog/posts/3616853689/</url>
    <content><![CDATA[Contestant. Rank WASTED. Unrated. A. Are You a Robot?题意给定一个图片，输出图片里的单词。 思路如图，为”$security$”。 头脑复杂度：$O(0)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; cout &lt;&lt; "security\n"; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 人也不一定看得出第一个字母是s（划掉 B. Was it Rated?题意给定一个 $[1, 25]$ 内的数字，输出对应的答案。 思路$Rated?$，$Codeforces$ 前 $25$ 场只有 $15, 20, 21$ 场是 $Unrated$，因此这三场输出 $NO$ 即可。 头脑复杂度：$O(n^2)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; map&lt;int, bool> mp = &#123; &#123;1, true&#125;, &#123;2, true&#125;, &#123;3, true&#125;, &#123;4, true&#125;, &#123;5, true&#125;, &#123;6, true&#125;, &#123;7, true&#125;, &#123;8, true&#125;, &#123;9, true&#125;, &#123;10, true&#125;, &#123;11, true&#125;, &#123;12, true&#125;, &#123;13, true&#125;, &#123;14, true&#125;, &#123;15, false&#125;, &#123;16, true&#125;, &#123;17, true&#125;, &#123;18, true&#125;, &#123;19, true&#125;, &#123;20, false&#125;, &#123;21, false&#125;, &#123;22, true&#125;, &#123;23, true&#125;, &#123;24, true&#125;, &#123;25, true&#125; &#125;; cout &lt;&lt; (mp[n] ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 属于是没想到（x C. Digits题意给定 $t$ 组数据，每组数据有 $n$ 个数，$n$ 不给出。观察输入输出，输出答案。 思路我们可以发现，按照 $3, 1, 4$ 的方法分隔，每组的数相乘就是输出的值。 我们不妨猜测 $n$ 为圆周率，按规律做即可。 头脑复杂度：$O(inf)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int t; cin >> t; string s = "31415926535897932384626433832795"; for(int i=0;i&lt;t;i++)&#123; int n = s[i] - '0'; int ans = 1; while(n --)&#123; int cur; cin >> cur; ans *= cur; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 这属实没料到 D. Trivial Conjecture题意角谷猜想，给定整数 $k$，输出一个数，使得进行操作后前 $k$ 个数不出现 $1$。 思路首先，角谷猜想能告诉我们一个正整数按照题给操作是一定会变为 $1$ 的，而且操作数远小于原数字。 那么，上面有一个值得注意的点：正整数。 有意思的是，题目又没说一定要输出正整数。 输出 $0$ 即可。 头脑复杂度：$O(-1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int tmp; cin >> tmp; cout &lt;&lt; 0 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 我是大蠢比 E. Not a Geometry Problem题意给定三个数，计算方法未知。 输出一个数，设这个数为 $a$，标准答案为 $b$，那么只要满足 $\frac{|a-b|}{\max(1,|b|)} \le 10^6$，答案即为正确。 思路$a = 0$ 就可以让整个式子变为 $1$。 头脑复杂度：$O(0)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 怎么我赛时的时候题面是俄文（? F. Factorization题意给定一个数，输出它的最大质因数。 数为下面两者任选其一： $4167792762229302596005813$ 或 $\begin{aligned}&amp;502326648535222453054166634657971818804572580\&amp;255694785590270206376893052666523759828749572\ &amp;821869200397402455443130219791674914146276480\&amp;544216264509037323019703862145022909043607926\&amp;185591029614599889902115472391135622402044979\&amp;347133959392884686037208893694733655782993294\&amp;168167973855585231709683012084723677082273198\&amp;866111120369101303677409522966567521782715484\&amp;001992772768993119841291702786496058775824381\&amp;444079748162416745495656333618343487208147794\&amp;874337933873576016717726298883519261055062303\&amp;842274145012056670644839715140659887936321934\&amp;474824687778512706909988484451300384818197143\&amp;498259061041 \end{aligned}$ 思路我们先随便找一个网站分解一下第一个数：$991999999999 \times 4201403994187$。 很有趣，第一个数是有规律的。 那么，我们不妨枚举因子的长度和 $1$ 出现的位置，用大数硬跑，即可得到答案。 第二个数为： $\begin{aligned}&amp;9999999999999999999999999999999999999999999999\&amp;9999999999999999999999999999999999999999999999\&amp;9999999999999999999999999999999999999999999999\&amp;9999999999999999999999999999999999999999999999\&amp;9999999999999999999999999999999999999999999999\&amp;9999999999999999999999999999999999199999999999\&amp;9999999999999999999999\&amp;*\&amp;5023266485352224530541666346579718188045725802\&amp;5569478559027020637689305266652375982874957282\&amp;1869200397402455443130219791674914146276480544\&amp;2162645090373230197038621450229090436079261855\&amp;9102961459988990211547239113562240204497934713\&amp;3959392884686037208893694733655783395155486996\&amp;15181802856501740938959\end{aligned}$ 头脑复杂度：$O(妈妈生的)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string s; cin >> s; if (s == "4167792762229302596005813") cout &lt;&lt; "4201403994187\n"; else cout &lt;&lt; "50232664853522245305416663465797181880457258025569478559027020637689305266652375982874957282186920039740245544313021979167491414627648054421626450903732301970386214502290904360792618559102961459988990211547239113562240204497934713395939288468603720889369473365578339515548699615181802856501740938959\n"; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 我还真去用网站分解后面的了（x G. Colour Vision题意一张绿色的柱状图。 思路首先，我们可以根据输入输出猜测，每个测试数据的第一行是下面两个字符串的长度。 其次，我们仿照前几个小时做的牛客愚人节$A$ 题（小学数学必考数一数），把图片下载下来看一看颜色。 我们可以得到色值：$01722B$。 有趣，我们来看看比赛 $id=1722$ 的 $B$ 题（B. Colorblindness）。 题面告诉我们，大条件是蓝绿色盲，而我们需要把 $G, B$ 当成一样的字母进行判断。 那么，我们不妨将所有的 $G$ 替换为 $B$，然后比较字符串即可。 当然，不知道 $n$ 这里会不会真的是字符串长度，但我们反正只需考虑前 $n$ 个字符即可。 头脑复杂度：$O(inf ^ 2)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; string s1, s2; cin >> s1 >> s2; bool f = true; for(int i=0;i&lt;n;i++)&#123; if(s1[i] == 'G') s1[i] = 'B'; if(s2[i] == 'G') s2[i] = 'B'; if(s1[i] != s2[i]) f = false; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 什么解谜啊 H. Expected Twist 待补充，题解看不懂捏 I. Mountain Climber题意给定一个由小写字母组成的字符串，观察输入输出和题目，输出真假。 思路爬山，爬什么山呢？当然是字母的山咯（x。 参考下面的网站，我们可以得到高的字母和低的字母： Ascender Descender 高的字母为 $\mathtt{tdfhklb}$，低的为 $\mathtt{qypgj}$。 继续观察，我们可以发现，我们需要从 $0$ 高度向上爬，在过程中不向下爬到 $0$ 的条件下，在最后爬回 $0$，即为 $YES$。 头脑复杂度：$O(?)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string s; cin >> s; string up = "tdfhklb", down = "qypgj"; int h = 0; bool f = true; for(char e : s)&#123; if(up.find(e) &lt; up.size()) h ++; else if(down.find(e) &lt; down.size())&#123; if(h == 0) f = false; h --; &#125; &#125; cout &lt;&lt; (f &amp;&amp; h == 0 ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 爬不动了（x J. Unmysterious Language题意用一个未知语言和评测机对话。 思路下面给出尝试的过程： 提交一个 $C++$ 代码，得到回复 “wrong answer I’m sorry, as a language model, I’m not able to compile and execute code.” 盲猜为英文对话，提交一句 $Accepted$，得到回复 “wrong answer I’m sorry, but I’m not sure what you are asking. If you have any question or need any assistance, feel free to ask and I’ll do my best to help you.” 推得需要一句话，或者某个关键词，我们随便聊一句 “How can I get an “Accepted” judge?”，得到回复 “wrong answer I can give you AC, but did you forget something important?” 看来关键词不对，尝试疑问句 “You mean what important?”，得到和上面一样的回复. 出于奇怪的礼貌，我们随口问一句 “If there is something important, please give me AC.”，得到 $Accepted.$，以及回复 “ok I will give you AC, as you wish.” 有趣的是，本题的关键字只有 $Please$，只要语句不长，就会被判通过。 于是，你可以自娱自乐一下： “Please give me WA.” “ok I will give you AC, as you wish.” 头脑复杂度：$O(-inf)$ 对应AC代码代码？ please 对没错，就一个单词（什么垃圾关键词AI]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 861 Div 2</title>
    <url>/blog/posts/3027651998/</url>
    <content><![CDATA[Practice. A. Lucky Numbers题意 此处给出 $A$ 题和 $C$ 题的定义： 对于一个数字，将所有位上的数取出，组成一个序列 $a$。定义 $l = a{max} - a{min}$。 那么， 给定一个区间 $[l ,r]$，$l$ 的最大值对应的数就是最幸运数，最小值对应的数就是最不幸运数。 给定一个区间 $[l, r]$，输出任意一个最幸运数。 思路首先，如果考虑幸运数，那么我们不难发现，我们只需关注十位和个位上的数即可，因为在这里就可以搞出最大值。 那么，暴力遍历 $[l, l + 100]$ 即可。 时间复杂度：$O(100x)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int l, r; cin >> l >> r; pii ans = &#123;0, l&#125;; for(int i=l;i&lt;=min(l + 100, r);i++)&#123; int tmp = i, mn = inf, mx = 0; while(tmp > 0)&#123; int cur = tmp % 10; mn = min(mn, cur); mx = max(mx, cur); tmp /= 10; &#125; if(ans.fs &lt; mx - mn)&#123; ans = &#123;mx - mn, i&#125;; &#125; &#125; cout &lt;&lt; ans.sc &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 为什么我会想着去构造（（ B. Playing in a Casino题意给定 $n$ 个人的 $m$ 张手牌对应的数字，构成序列 $a_{i,x}$。 遍历 $i \in [2, n], j \in [1, i - 1]$，统计 $|a_i[0] - a_j[0]| + |a_i[1] - a_j[1]| + \ldots + |a_i[m] - a_j[m]|$ 的总和。 输出总和。 思路显然，我们可以直接竖着看，看一下去掉绝对值的情况。 不难发现，我们固定第二维 $x$，那么对于竖向构造得到的每一个序列，我们进行排序，可以得到形如下面的序列： $a, b, c, d, e$。 最后，这个序列的值为 $-4a-2b+2d+4e$。 或者说，我们只需排序后遍历，乘上权重加起来即可。权重首项为 $n - 1$，依次递减 $2$。 时间复杂度：$O(mn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> a(m, vector&lt;int>(n)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin >> a[j][i]; int ans = 0; for(int i=0;i&lt;m;i++)&#123; sort(a[i].begin(), a[i].end()); for(int j=0;j&lt;n/2;j++) ans += (a[i][n - j - 1] - a[i][j]) * (n - 1 - 2 * j); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 简简单单（x C. Unlucky Numbers题意给定一个区间 $[l, r]$，输出任意一个最不幸运数。 思路我们可以考虑用 $DFS$ 来实现，用拼接的方式得到答案。 考虑下面的两个剪枝： 当前拼接得到的数可以预测是否一定超出边界，如对于 $12$，范围为 $[135, 189]$，那么由 $12 \times 10 + 10 = 130 &lt; 135$ 可知一定不在边界内。另一个边界直接判大小即可。 因为深搜，所以能提前得到一些答案，那么如果当前 $max - min$ 已经大于之前求得的答案了，就不用继续了。 时间复杂度：不会分析 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; string l, r, ans; int val = inf, vl, vr; void init()&#123;&#125; void dfs(int x, int mn, int mx, const string&amp; now)&#123; int vn = stoll(now); if(x == l.size())&#123; if(vn >= vl &amp;&amp; vn &lt;= vr &amp;&amp; mx - mn &lt; val)&#123; val = mx - mn; ans = now; &#125; return; &#125; int exp = vn * pow(10, l.size() - x); //优化一下查找 if(exp + pow(10, l.size() - x) &lt; vl || exp > vr || mx - mn >= val) return; for(int i=0;i&lt;=9;i++) dfs(x + 1, min(mn, i), max(mx, i), now + (char) (i + '0')); &#125; void solve() &#123; cin >> l >> r; vl = stoll(l), vr = stoll(r); if(l.size() &lt; r.size())&#123; for(int i=0;i&lt;l.size();i++) cout &lt;&lt; 9; cout &lt;&lt; '\n'; &#125;else&#123; ans = ""; val = inf; for(int i=l[0]-'0';i&lt;=r[0]-'0';i++)&#123; dfs(1, i, i, to_string(i)); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 就很无脑，不知道dp咋做（]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 860 Div 2</title>
    <url>/blog/posts/302073386/</url>
    <content><![CDATA[Contestant. Rank 3134. Rating -36. 坐大牢局 A. Showstopper题意给定两个序列 $a, b$，规定一次操作为任取 $i$，交换 $a_i, b_i$。输出任意次操作后，是否可以让 $a_n = max(a_i), b_n = max(b_i)$。 思路首先，既然最后方案我们无需考虑，那么我们不妨定义 $a$ 为最小值的序列，$b$ 为最大值的序列，那么只要满足上面的条件，就是有解，否则无解。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n), b(n); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;n;i++) cin >> b[i]; if(a[n - 1] > b[n - 1]) swap(a[n - 1], b[n - 1]); bool f = true; for(int i=0;i&lt;n-1;i++) &#123; int mn = min(a[i], b[i]), mx = max(a[i], b[i]); if (mn > a[n - 1] || mx > b[n - 1]) f = false; &#125; cout &lt;&lt; (f ? "Yes\n" : "No\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 猜结论题 x1 B. Three Sevens题意给定 $n$ 局的参赛情况，在前面一局胜利的玩家不会参与下面的比赛。输出任意一种获胜玩家列表排列。 思路我们不妨反过来考虑，也就是说，在后面出现的玩家一定不是前面的赢家，那么我们直接倒着遍历即可。 首先，我们遍历参加了该局的玩家，若只要有一个没被标记，那么就是有解的，我们随便输出一个即可。 然后，我们标记参加了该局的玩家，这样即可防止其在前面作为赢家。 时间复杂度：$O(mn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;vector&lt;int>> a(n, vector&lt;int>()); for(int i=0;i&lt;n;i++)&#123; int cnt; cin >> cnt; a[i] = vector&lt;int>(cnt); for(int j=0;j&lt;cnt;j++) cin >> a[i][j]; &#125; vector&lt;bool> st(50010, false); vector&lt;int> ans(n); for(int i=n-1;i>=0;i--)&#123; bool f = false; for(auto e : a[i])&#123; if(!st[e]) ans[i] = e, f = true; st[e] = true; &#125; if(!f)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; &#125; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 这可比A题好做多了 C. Candy Store题意给定 $n$ 组 $a_i, b_i$，定义 $d_i$ 为 $a_i$ 的因数，$c_i = b_id_i$。 构造一组 $d$，将 $c$ 划分为 $x$ 段值相等的序列，输出 $x_{min}$。 思路我们来考虑 $x = 1$ 的情况： 首先，$c_i = b_id_i$，也就是说，$c_i$ 是 $b_i$ 的倍数。那么，$c_1 \times c_2 \times \ldots \times c_n$ 是 $lcm(b_1, b_2, \ldots, b_n)$ 的倍数。 其次，$d_i$ 是 $a_i$ 的因数，那么 $b_id_i$ 就是 $a_ib_i$ 的因数，也就是说，$gcd(a_1b_1, a_2b_2, \ldots, a_nb_n)$ 是 $c_1 \times c_2 \times \ldots \times c_n$ 的倍数。 所以，$gcd(a_1b_1, a_2b_2, \ldots, a_nb_n) \% lcm(b_1, b_2, \ldots, b_n)=0$ 就是其能成为一段区间的条件。 显然，如果一个元素能划分到前面的序列中，那么我们完全可以不考虑它，因为就算把他放进来，不影响数量。 因此，我们可以贪心地直接遍历统计个数。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b); &#125; int lcm(int a, int b)&#123; return a * b / gcd(a, b); &#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n), b(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i] >> b[i]; &#125; int g = 0, l = 1, ans = 1; for(int i=0;i&lt;n;i++)&#123; g = gcd(g, a[i] * b[i]); l = lcm(l, b[i]); if(g % l != 0)&#123; ans ++; g = a[i] * b[i]; l = b[i]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 没想到啊没想到… D. Shocking Arrangement题意给定一个总和为 $0$ 的序列，重新排序这个序列，满足 $\max\limits{1 \le l \le r \le n} \lvert a_l + a{l+1} + \ldots + a_r \rvert &lt; \max(a_1, a_2, \ldots, a_n) - \min(a_1, a_2, \ldots, a_n),$ 若不能满足，输出 $No$。 思路首先，我们定义 $sum_i$ 为前 $i$ 个数的前缀和，那么 $\max\limits{1 \le l \le r \le n} \lvert a_l + a{l+1} + \ldots + ar \rvert = sum{max} - sum_{min}$。 那么，我们让 $sum{max} &lt; \max(a_1, a_2, \ldots, a_n), sum{min} &gt; \min(a_1, a_2, \ldots, a_n)$ 即可。 如何实现？我们不妨随便放一个数上去，然后记录当前放入的前 $i$ 个数的和 $x$，若 $x &gt; 0$，那么我们加上一个负数，直到 $x \leq 0$，反之亦然。 考虑到总和为 $0$，所以如果 $x &gt; 0$，剩余的数的和一定为 $-x$，所以后面一定会有几个负数，让 $x \leq 0$。 此时，一定有解，而若要判无解，当且仅当整个序列都是 $0$。 对细节的证明思路的第一句话是贪心的（有乱猜的嫌疑）。 为什么呢？因为，$sum{max}$ 不一定在 $sum{min}$ 右边。 或者说，$S_x, S_y, S_z, Sx&gt;0, S_y &lt; 0, S_z &gt; 0$，这样的区间要如何保证 $|S_y| &lt; \max(a_1, a_2, \ldots, a_n) - \min(a_1, a_2, \ldots, a_n)$ 呢？ 首先，根据思路，$Sx$ 一定小于等于 $\max(a_1, a_2, \ldots, a_n)$，而 $|S_x| \geq |S{y-1}|$，所以 $|S_y| &lt; \max(a_1, a_2, \ldots, a_n) + abs(\min(a_1, a_2, \ldots, a_n))$。 因此得证。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; stack&lt;int> p, q; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur >= 0) p.emplace(cur); else if(cur &lt; 0) q.emplace(cur); &#125; if(q.empty())&#123; cout &lt;&lt; "No\n"; return; &#125; cout &lt;&lt; "Yes\n"; int now = 0; for(int i=0;i&lt;n;i++)&#123; if(now &lt;= 0)&#123; now += p.top(); cout &lt;&lt; p.top() &lt;&lt; ' '; p.pop(); &#125;else&#123; now += q.top(); cout &lt;&lt; q.top() &lt;&lt; ' '; q.pop(); &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 猜结论题 x2]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 295</title>
    <url>/blog/posts/1688399541/</url>
    <content><![CDATA[Contestant. Rank 2267. Rating +74. A. Probably English题意给定一个字符串序列，输出序列中是否包含下面的 $5$ 个单词： $and, not, that, the, you$。 思路如题，别打错即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; vector&lt;string> mp = &#123;"and", "not", "that", "the", "you"&#125;; int n; cin >> n; bool f = false; while(n --)&#123; string s; cin >> s; for(auto e : mp) if(s == e) f = true; &#125; cout &lt;&lt; (f ? "Yes\n" : "No\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 打错了草 B. Bombs题意给定一个矩阵，矩阵由 “.”, “#” 和数字组成。对于任意数字 $x$，将其周围所有 曼哈顿距离 小于等于 $x$ 且为 “#” 的点替换为 “.”。输出替换后的矩阵。 其中，对于两个点 $(x_1, y_1), (x_2, y_2)$，曼哈顿距离为 $|x_1 - x_2| + |y_1 - y_2|$。 思路直接模拟。 当然，不要直接替换，判断一下是不是 “#” 再说。 时间复杂度：$O(nmp^2)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; vector&lt;string> s(n); for (int i = 0; i &lt; n; i++) cin >> s[i]; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) &#123; char now = s[i][j]; if (now != '#' &amp;&amp; now != '.') &#123; int cnt = now - '0'; s[i][j] = '.'; for (int x = 1; x &lt;= cnt; x++) for (int p = 0; p &lt;= x; p++) &#123; int q = x - p; if (i + p &lt; n &amp;&amp; j + q &lt; m &amp;&amp; s[i + p][j + q] == '#') s[i + p][j + q] = '.'; if (i + p &lt; n &amp;&amp; j - q >= 0 &amp;&amp; s[i + p][j - q] == '#') s[i + p][j - q] = '.'; if (i - p >= 0 &amp;&amp; j + q &lt; m &amp;&amp; s[i - p][j + q] == '#') s[i - p][j + q] = '.'; if (i - p >= 0 &amp;&amp; j - q >= 0 &amp;&amp; s[i - p][j - q] == '#') s[i - p][j - q] = '.'; &#125; &#125; &#125; for (auto e: s) cout &lt;&lt; e &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 论我debug了半天这道简单题这件事 C. Socks题意给定一个序列，在一个元素只能在一对数的条件下，输出可以找出多少对相同的数。 思路如题，将所有数找出，答案即为各个数量除 $2$。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; map&lt;int, int> cnt; int n; cin >> n; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; cnt[cur] ++; &#125; int ans = 0; for(auto e : cnt) ans += e.second / 2; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 这也太水了（（ D. Three Days Ago题意给定一个由 $[0, 9]$ 内数字组成的序列，输出 所有连续子序列中 满足 所有数出现次数均为偶数 的个数。 思路首先，奇偶性相同的前缀和，它们的差值一定是偶数，那么，我们只需考虑奇偶性。 也就是说，对于一种 $[0, 9]$ 的奇偶性排列，若有 $x$ 个相同的，那么答案加上 $\frac{x(x - 1)}{2}$。 对于这种排列，我们不妨用状压，那么，用 $map$ 就完事了。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string s; cin >> s; int n = s.size(); map&lt;int, int> cnt; cnt[0] = 1; int cur = 0; for(int i=0;i&lt;n;i++)&#123; int t = s[i] - '0'; cur ^= (1 &lt;&lt; t); cnt[cur] ++; &#125; int ans = 0; for(auto i : cnt) ans += (i.second - 1) * i.second / 2; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 以后写状压还是写简单一点为好（（]]></content>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 145</title>
    <url>/blog/posts/759924825/</url>
    <content><![CDATA[Contestant. Rank 2205. Rating -13. A. Garland题意给定 $4$ 盏灯的颜色，颜色为 $[0, 9]$ 内的任意数字。初始状态所有灯均关闭，打开一盏灯的条件是之前打开的灯的颜色与其不一致，第一次可以打开任意一盏灯。输出将所有灯打开所需最小次数。 思路首先，这题只有 $4$ 盏灯。 所以，我们直接分类讨论即可。 我们先将灯按照颜色代码升序排序，那么如果第一个数和最后一个数相等，输出 $-1$； 否则，前三个数相等或者后三个数相等时，需要 $6$ 次； 否则，$4$ 次足矣。 时间复杂度：$O(4log4)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string s; cin >> s; sort(s.begin(), s.end()); if(s[0] == s[3]) cout &lt;&lt; -1 &lt;&lt; '\n'; else if(s[0] == s[2] || s[1] == s[3]) cout &lt;&lt; 6 &lt;&lt; '\n'; else cout &lt;&lt; 4 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 我居然没看到只有4个… B. Points on Plane题意给定整数 $n$，代表当前有 $n$ 个点。将这些点放入平面直角坐标系，满足坐标均为整数。在限制任意一对点的距离都严格大于 $1$ 的条件下，输出最小的总代价。其中，对于一个点 $(x, y)$，单点的代价为 $|x| + |y|$，总代价为所有点的代价最大值。 思路我们来固定 $x$ 看 $y$： $x = k$，那么 $y = 0$； $x = k - 1$，那么 $y = -1, 0, 1$； 归纳可得，对于 $x$ 的所有正数取值，$y$ 的取值总数为 $1 + 2 + \ldots + (k + 1) = \frac{(k + 1)(k + 2)}{2}$； 同理， $x$ 为负数时，$y$ 的取值总数为 $1 + 2 + \ldots + k = \frac{k(k+1)}{2}$。 那么，我们可以得到总和 $(k + 1) ^ 2$。 那么，最后的答案即为 $\lceil \sqrt n \rceil - 1$。 注意精度问题即可。 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; int ans = sqrt(n); if(ans * ans &lt; n) ans ++; cout &lt;&lt; ans - 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 离谱的是在 C++ 17 下，$\lfloor \sqrt{n - 1} \rfloor$ 可以作为答案卡过去 C. Sum on Subarrays题意构造一个序列，满足所有连续子序列的和均不为 $0$，且和为正数的序列数量为给定值 $k$。 思路首先，我们不妨打表，$s_i$ 为 $i$ 个数的连续子序列个数，即 $s_i = \frac{i(i + 1)}{2}$。 那么，我们不难发现，$s_{i + 1} - s_i = i + 1$。 那么，在 $s_i$ 个数的基础上，我们再添加 $x \in [0, i]$ 个数，就可以等于 $k$。 更具体地说，我们不妨在序列前面放上 $q$ 个相同的正数 $x$，其中 $s_q$ 为 $s$ 中第一个不大于 $k$ 的值。 那么，我们还需 $cnt = k - s_q$ 个数，我们不妨在后面放一个负数 $p$，让 以这个数作为结尾的 子序列的和 为负数 的个数为 $q - cnt$。 这样的话，以 $t \in [1, cnt]$ 为头，负数 $p$ 为尾的子序列的和就是正数了。 剩下还有一些空位，我们填上负无穷大，也就是最小值 $-1000$ 即可。 当然，正数 $x$ 不能为 $1$，这样会让某个总和变为 $0$，那么我们取 $2$ 即可。 在取 $2$ 的条件下，负数 $p = -2(q - cnt) - 1$。 当然，我们用递增的序列取代这些相等的正数也是可以的。 时间复杂度：$O(nlogn)$ 对应AC代码1#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; vector&lt;int> s = &#123;0&#125;; void init()&#123; for(int i=1;i&lt;=1000;i++) s.emplace_back(i * (i + 1) / 2); &#125; void solve() &#123; int n, k; cin >> n >> k; int q = upper_bound(s.begin(), s.end(), k) - s.begin() - 1; int cnt = k - s[q]; for(int i=0;i&lt;q;i++) cout &lt;&lt; 2 &lt;&lt; ' '; if(cnt != 0) cout &lt;&lt; -(q - cnt) * 2 - 1 &lt;&lt; ' ', q ++; for(int i=q;i&lt;n;i++) cout &lt;&lt; -1000 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 对应AC代码2#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; vector&lt;int> s = &#123;0&#125;; void init()&#123; for(int i=1;i&lt;=1000;i++) s.emplace_back(i * (i + 1) / 2); &#125; void solve() &#123; int n, k; cin >> n >> k; int q = 0; while(s[q + 1] &lt;= k) q ++; for(int i=0;i&lt;q;i++) cout &lt;&lt; q - i + 1 &lt;&lt; ' '; k -= s[q]; if(k != 0) &#123; cout &lt;&lt; -1 * (s[q - k] + q - k + 1) &lt;&lt; ' '; q ++; &#125; for(int i=q;i&lt;n;i++) cout &lt;&lt; -1000 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 我怎么就这么蠢.jpg D. Binary String Sorting题意给定一个二进制字符串，规定操作为下面两个任选一： 交换两个相邻元素； 删掉一个元素 第一个操作的代价为 $1e12$；第二个操作的代价为 $1e12 + 1$。 输出让整个字符串变为不递减序列的最小代价。 思路首先，这题可以 $dp$，但是我们不妨来想想怎么贪心。 我们下面有四种方案，取最小值即可： 删掉所有的 $1$； 删掉所有的 $0$； 遍历所有的 $0$，将前面的 $1$ 删掉，后面的 $0$ 删掉； 遍历所有的 $0$，若前面为 $1$，那么把这个 $1$ 和当前的 $0$ 交换，然后删去前面剩余的 $1$，以及后面的 $0$。 前面三者是显然的，而对于第四个，我们不妨考虑其他的移动情况。 显然，$11$ 和 $00$ 没必要交换；$01$ 不用管，因为满足递增；$10$ 交换即可；剩余的情况，我们都需要移动至少两次，那还不如删掉呢。 因此，贪心是成立的。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int x = 1e12; string s; cin >> s; int n = s.size(); s = " " + s; vector&lt;vector&lt;int>> pre(n + 1, vector&lt;int>(2, 0)); int cnt0 = 0; for(int i=1;i&lt;=n;i++)&#123; int now = s[i] - '0'; if(now == 0) cnt0 ++; pre[i][now] = pre[i - 1][now] + 1; pre[i][1 - now] = pre[i - 1][1 - now]; &#125; int ans = min(cnt0, n - cnt0) * (x + 1); for(int i=1;i&lt;=n;i++)&#123; if(s[i] == '0') &#123; ans = min(ans, (pre[i][1] + cnt0 - pre[i][0]) * (x + 1)); if(s[i - 1] == '1') ans = min(ans, x + (pre[i][1] + cnt0 - pre[i][0] - 1) * (x + 1)); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 赛时一看到dp就溜了（（]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 859 Div 4</title>
    <url>/blog/posts/3765805359/</url>
    <content><![CDATA[Contestant(alt). Rank 5166. Rating -27(+123 -150). A. Plus or Minus题意给定三个数 $a, b, c$，判断 $a+b = c$ 还是 $a - b = c$，前者输出 $+$，后者输出 $-$，保证有解。 思路如题。 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int a, b, c; cin >> a >> b >> c; if(a + b == c) cout &lt;&lt; '+' &lt;&lt; '\n'; else cout &lt;&lt; '-' &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 这才应该是低程的签到题啊（（ B. Grab the Candies题意给定一个序列 $a$，按次序拿出 $a_i$，定义 $a_i$ 为偶数时 $A$ 拿走 $a_i$，否则 $B$ 拿走 $a_i$。输出是否可以将序列重新排列，使得每次取走后 $A$ 持有的总和严格大于 $B$。 思路如题。 很显然，我们先全排满偶数，再排奇数即可。 那么，题目转化为偶数的总和和奇数的总和的比较。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int sum1 = 0, sum2 = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur % 2 == 0) sum1 += cur; else sum2 += cur; &#125; cout &lt;&lt; (sum1 > sum2 ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 脑子得稍微动一下的题（ C. Find and Replace题意给定一个字符串，规定可将一种字母全部替换为 $0$ 或 $1$，在全部替换后，输出是否可以将字符串变为相邻字符不相同的字符串，即 $0101$ 相间。 思路显然，我们只需对每一个字母去考虑，如果任意两个距离最近的相同的字母的距离为奇数，那么就构造不出来，否则一定可以。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> pre(26, -1); string s; cin >> s; bool f = true; for(int i=0;i&lt;n;i++)&#123; int cur = s[i] - 'a'; if(pre[cur] != -1 &amp;&amp; (i - pre[cur]) % 2 == 1)&#123; f = false; break; &#125; pre[cur] = i; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 差点看错题 D. Odd Queries题意给定一个序列，对于 $q$ 次 独立 询问，给定一段区间 $[l, r]$ 以及一个整数 $k$，将区间内的数字全都修改为 $k$ 后，输出序列的总和是否为奇数。 思路既然询问是独立的，那么我们直接对所有询问单独考虑即可。 也就是说，我们不需要模拟修改，而只需求出值。 那么，很简单，我们求出前缀和，然后用 $O(1)$ 的复杂度拿出区间前后的元素总和，最后判断加上区间内的值能否变为奇数即可。 时间复杂度：$O(n + q)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, q; cin >> n >> q; vector&lt;int> sum(n + 1, 0); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; sum[i] = sum[i - 1] + cur; &#125; while(q --)&#123; int l, r, k; cin >> l >> r >> k; cout &lt;&lt; ((sum[l - 1] + (r - l + 1) * k + sum[n] - sum[r]) % 2 == 1 ? "YES\n" : "NO\n"); &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 这题怎么更水了（ E. Interview题意互动游戏。 背景：给定几堆石子，每堆石子都由权值为 $1$ 的石子堆叠得到，特殊地，有一堆石子中有一个石子的权值为 $2$。 初始：给定堆数，以及每堆石子的 个数。 互动：输出一段区间的左右端点，返回这段区间内所有石子的 权值和。 限制：最多 $30$ 次。 目标：输出特殊的石子在哪个堆里。 思路首先，我们可以跑一遍前缀和，方便后续查询。 其次，如果我们询问了区间 $[1, k]$，得到的值等于个数，那么我们可以断定特殊的石子在 $[k + 1, n]$ 里，反之就在前者里。 那么，对于 $k$ 的选择，我们直接用二分的思路做即可。 最后二分的结果就是答案。 次数为 $log_2n$，不超过 $30$。 时间复杂度：$O(tlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> sum(n + 1, 0); for(int i=1;i&lt;=n;i++) &#123; int cur; cin >> cur; sum[i] = sum[i - 1] + cur; &#125; int l = 1, r = n, mid; while(l &lt; r)&#123; mid = (l + r) >> 1; cout &lt;&lt; "? " &lt;&lt; mid - l + 1 &lt;&lt; ' '; for(int i=l;i&lt;=mid;i++) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n'; cout.flush(); int g; cin >> g; if(g == sum[mid] - sum[l - 1]) l = mid + 1; else r = mid; &#125; cout &lt;&lt; "! " &lt;&lt; l &lt;&lt; '\n'; &#125; signed main()&#123; //ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 我怎么会想着去在两边都询问一次呢，我好铸 F. Bouncy Ball题意给定一个矩阵，以左上角为原点建立坐标系，给定两个点 $(i_1, j_1), (i_2, j_2)$，以及初始运动方向 $s, s \in {DL, DR, UL, UR}$（$DL$ 表示向左下角走，也就是 $(i, j) =&gt; (i + 1, j - 1)$，其余同理）。在碰到边界后，会发生反弹，如向左上角走，碰到上边界后会反弹，向左下角继续移动。在碰到边角后，运动方向反转，此处记反弹次数为 $1$ 次，而不是 $2$ 次。 输出从 $(i_1, j_1)$ 开始运动，到第一次到达 $(i_2, j_2)$ 后，经历了多少次反弹。 无法到达输出 $-1$。 思路数据量并不大，直接模拟即可。 在模拟的时候，我们记录是否已经从某个方向运动到该格子。那么，只要碰到被我们记录过的格子，只要方向一致，那么就出现了循环，直接打断即可。 时间复杂度：最坏$O(4nm)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, m, i, j, si, sj; string ori; cin >> n >> m >> i >> j >> si >> sj >> ori; bool vis[n + 1][m + 1][4] = &#123;&#125;; int d = ((ori[0] == 'D' ? 0 : 1) &lt;&lt; 1) + (ori[1] == 'R' ? 0 : 1); //00 DR, 01: DL, 10: UR, 11: UL int cnt = 0; while (!vis[i][j][d]) &#123; if (i == si &amp;&amp; j == sj) &#123; cout &lt;&lt; cnt &lt;&lt; '\n'; return; &#125; vis[i][j][d] = true; int new_d = d; if ((d == 0 || d == 1) &amp;&amp; i == n) new_d += 2; if ((d == 0 || d == 2) &amp;&amp; j == m) new_d ++; if ((d == 1 || d == 3) &amp;&amp; j == 1) new_d --; if ((d == 2 || d == 3) &amp;&amp; i == 1) new_d -= 2; if (new_d != d) cnt++; d = new_d; if (d % 2 == 1) j--; else j++; if ((d >> 1) == 1) i--; else i++; &#125; cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 居然，居然，居然就是暴力… G1. Subsequence Addition (Easy Version) 详见G2，区别是G1的数据量更小 G2. Subsequence Addition (Hard Version)题意给定一个初始只含一个数字 $1$ 的序列，规定操作为选择序列中的任意元素，将选定元素之和加入序列中。 现在，给定一个序列，输出其是否为上述操作所得。 思路我们可以贪心地认为，排序之后，较大的数一定小于等于所有比他小的数的和，而且只要满足这个条件，一定有一种方案得到这个数。 至于为什么，我们可以想想二分，序列中的数一定是某些数的和，那么如此拆分下去，就是一群 $1$ 的和，而且数量的集合覆盖 $[1, sum]$，所以是成立的。 具体的证明需要用到归纳法。 因此，我们排个序，然后判断所有 $ai$ 是否大于等于 $sum{i - 1}$ 即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a.begin(), a.end()); int sum = 1; bool f = a[0] == 1; for(int i=1;i&lt;n;i++)&#123; if(!f) break; if(i &lt; 2 &amp;&amp; a[i] != 1 || a[i] > sum) f = false; sum += a[i]; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 很有趣一贪]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 福师大第26届低程</title>
    <url>/blog/posts/1549174805/</url>
    <content><![CDATA[Contestant. Rank 2. Solved 4/8. A. ACM? 你也想打ACM?题意对于 $n$ 道题，给定 $k$ 个提交记录，规定罚时为 $20$ 分钟，按照 $ACM/ICPC$ 赛制计算通过题数和总用时。 思路首先，没过的题不算罚时，过了的题重复提交无效。 因为题给数据是按照时间排序的，那么，我们不妨从前往后遍历，用数组记录当前的状态。 对于下面的 $AC$ 代码，其中 $ok_i$ 表示当前是否过了 $i$ 题；$a_i$ 表示第 $i$ 道题最早是在 $a_i$ 时刻通过的；$p_i$ 表示第 $i$ 道题在通过前 $WA$ 了几次。 最后，我们遍历所有题，如果过题了，记录过题数，并将总用时加上 $a_i + 20p_i$。 时间复杂度：$O(nk)$ 本题测试点数据量过大，java需要使用快读，cpp若使用cin需要关闭输入输出流同步 对应AC代码 (cpp)#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; int a[N], p[N]; bool ok[N]; void solve()&#123; int n, k; cin >> n >> k; for(int i=0;i&lt;k;i++)&#123; string s; cin >> s; int id, h, m, now = 0, st = 0; bool msg = true; for(int i=0;i&lt;s.size();i++)&#123; char e = s[i]; if(e == ':')&#123; if(st == 0)&#123; id = now; now = 0; st = 1; &#125;else if(st == 1)&#123; m = now; now = 0; st = 2; &#125; &#125;else if(e == '-')&#123; h = now; now = 0; &#125;else if(e >= '0' &amp;&amp; e &lt;= '9')&#123; now = now * 10 + (e - '0'); &#125;else if(e == 'u')&#123; //读到u就差不多了 msg = false; break; &#125;else break; &#125; int cal = h * 60 + m; if(!ok[id]) a[id] = cal; if(msg) ok[id] = true; else if(!ok[id]) p[id] ++; &#125; int cnt = 0, tot = 0; for(int i=1;i&lt;=n;i++)&#123; cnt += ok[i] ? 1 : 0; if(ok[i]) tot += a[i] + p[i] * 20; &#125; cout &lt;&lt; cnt &lt;&lt; ' ' &lt;&lt; tot &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 对应AC代码 (java)import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception &#123; Console console = new Console(); int n = console.nextInt(), k = console.nextInt(); boolean[] ok = new boolean[n + 1]; int[] a = new int[n + 1], p = new int[n + 1]; for (int i = 0; i &lt; k; i++) &#123; String[] s = console.next().split(":"); int id = Integer.parseInt(s[0]), cal = Integer.parseInt(s[1].split("-")[0]) * 60 + Integer.parseInt(s[1].split("-")[1]); if (!ok[id]) a[id] = cal; if (s[2].equals("accepted")) ok[id] = true; else if (!ok[id]) p[id]++; &#125; int cnt = 0, tot = 0; for (int i = 1; i &lt;= n; i++) &#123; cnt += ok[i] ? 1 : 0; if (ok[i]) tot += a[i] + p[i] * 20; &#125; console.print(cnt + " " + tot + "\n"); console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; java挂掉后果断切cpp，淦 B. 任何邪恶? 终将绳之以法!题意给定一个满二叉树，满足根节点为 $1$，节点 $x$ 的子节点为 $2x, 2x + 1$。 定义操作为下面三者任选一： $1\ x$，输出 $x$ 节点到其他被标记节点的最短距离总和； $2\ x$，标记 $x$ 节点； $3\ x$，取消标记 $x$ 节点。 给定 $q$ 个询问，执行对应操作。 思路一些废话首先，节点 $a, b$ 的最短距离为两者 离 它们的 最近公共祖先 的距离 之和。 也就是说，这个路径一定是先向上找，再从一个节点折返，最后从下找的。 这个节点就像一个跳板，不过当然，跳板可以是起点自己。 当然，讨论到这里，我们也许可以对每个查询，都去跑一遍最近公共祖先（$LCA$），但我觉得没这个必要。 不过，有没有一种可能，对于一个跳板，我们可以预处理出它的左右子树各有多少点被标记了，以及这些点距离跳板的距离呢。 这个预处理过程可以放在标记的时候。而且，我们不难发现这个过程是可逆的。因而，在取消标记的时候，我们进行相反的操作就好了。 具体思路计算首先，我们先来考虑怎么计算： 我们不妨从查询点 $x$ 开始向上遍历，并记录当前走了 $st$ 步。遍历时，我们传递一下当前遍历到的父节点 $p$ 是由哪个子树来的，这个参数和 $x$ 的奇偶性有关。这样的话，我们就可以拿出另一个子树中所有被标记点到 $p$ 的距离和 $sum$，以及被标记的节点数 $cnt$。画个图易得，$x$ 到 $p$ 这段路被反复经过了 $cnt$ 次，经过这个跳板后，剩余距离的总和就是 $sum$，因此，以 $p$ 为跳板，我们可以得到贡献 $sum + cnt \times st$。 上述过程对于 $p \neq x$ 的情况是成立的，而 $p = x$ 时，两个子树的值我们都需要考虑（传参时，我们不妨传递一个特殊值，如 $-1$），具体的贡献计算方式和上面一致。 特别地，若我们遍历到的 $p$ 是被标记过的，那么贡献会多出 $st$。 预处理对于加上一个标记 $x$ 的操作，我们可以从该节点开始向上遍历，直到根节点为止。 同样，在遍历的时候，我们记录步数 $st$，并传递 $p$ 是由哪个子树来的，然后将 $p$ 对应子树的 $sum$ 加上 $st$，$cnt$ 加上 $1$。 取消标记的做法恰好相反，减去即可。 时间复杂度：反正挺复杂 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; pii dp[N][2]; int ans; bool is[N]; void up_dfs_add(int x, int from, int st)&#123; if(x == 0) return; if(from == -1)&#123; dp[x][0].first += st; dp[x][1].first += st; &#125;else dp[x][from].first += st, dp[x][from].second ++; up_dfs_add(x / 2, x % 2, st + 1); &#125; void up_dfs_del(int x, int from, int st)&#123; if(x == 0) return; if(from == -1)&#123; dp[x][0].first -= st; dp[x][1].first -= st; &#125;else dp[x][from].first -= st, dp[x][from].second --; up_dfs_del(x / 2, x % 2, st + 1); &#125; void up_dfs_cal(int x, int from, int st)&#123; if(x == 0) return; int cur; if(from == -1) cur = dp[x][0].first + dp[x][1].first > 0 ? (dp[x][0].first + dp[x][0].second * st + dp[x][1].first + dp[x][1].second * st) : 0; else cur = dp[x][1 - from].first > 0 ? (dp[x][1 - from].first + dp[x][1 - from].second * st) : 0; ans += cur; if(is[x]) ans += st; up_dfs_cal(x / 2, x % 2, st + 1); &#125; void solve()&#123; int n, q; cin >> n >> q; while(q --)&#123; int tp, x; cin >> tp >> x; if(tp == 1)&#123; ans = 0; up_dfs_cal(x, -1, 0); cout &lt;&lt; ans &lt;&lt; '\n'; &#125;else if(tp == 2) is[x] = true, up_dfs_add(x, -1, 0); else is[x] = false, up_dfs_del(x, -1, 0); &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 复杂之，但类似的题其实做过好几次吧，有点像树型dp C. 蘑菇! 提莫来采蘑菇啦! 没做，待补充 D. 锁屏图案? 当然是第k长的最好看!题意对于一个九宫格锁屏图案，规定需要一笔将所有点连起来，且不能重复使用同一个点。 规定连接了两个点的时候，若这个路径经过了一个未被使用的点，那么这个点一定要一起被连上，否则视为不合法，如斜角上的 $159$，在没使用过 $5$ 前，$195$ 是不合法的。 定义满足条件的全排列中，排序的主关键字为路径长，次要关键字为字典序，按照降序排列。 给定 $q$ 个询问，对于给定的 $k$，输出第 $k$ 个排列。 思路首先，数据量很小，$9!$ 的复杂度完全可以暴力。 那么，我们不妨枚举所有全排列，然后算出可行解的路径长，以及排列的结果，按照这个排个序然后取出来就好了。 唯一麻烦的是码量。 时间复杂度：$O(8 \cdot 9 \cdot 9! \cdot q)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-7; struct node&#123; string ans; double dist; &#125;; vector&lt;node> ans; vector&lt;int> a = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; vector&lt;pii> pos(10); double cal(int x, int y)&#123; return sqrt(pow(abs(pos[x].fs - pos[y].fs), 2) + pow(abs(pos[x].sc - pos[y].sc), 2)); &#125; bool check(int l, int r, int mid)&#123; int l_pos = -1, r_pos = -1, m_pos = -1; for(int i=0;i&lt;9;i++)&#123; if(a[i] == l) l_pos = i; else if(a[i] == r) r_pos = i; else if(a[i] == mid) m_pos = i; &#125; if(l_pos > r_pos) swap(l_pos, r_pos); return l_pos + 1 != r_pos || m_pos &lt; r_pos; &#125; void init()&#123; for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=3;j++) pos[3 * (i - 1) + j] = &#123;i, j&#125;; do&#123; vector&lt;vector&lt;int>> checker = &#123;&#123;1, 3, 2&#125;, &#123;1, 7, 4&#125;, &#123;3, 9, 6&#125;, &#123;7, 9, 8&#125;, &#123;3, 7, 5&#125;, &#123;1, 9, 5&#125;, &#123;2, 8, 5&#125;, &#123;4, 6, 5&#125;&#125;; bool f = true; for(auto e : checker) f &amp;= check(e[0], e[1], e[2]); if(!f) continue; node now = &#123;&#125;; for(int i=0;i&lt;9;i++)&#123; now.ans += (a[i] + '0'); now.ans += " "; if(i > 0) now.dist += cal(a[i], a[i - 1]); &#125; ans.emplace_back(now); &#125;while(next_permutation(a.begin(), a.end())); //这里学到了，好用的东西 sort(ans.begin(), ans.end(), [](node o1, node o2)&#123; return abs(o1.dist - o2.dist) > eps ? o1.dist > o2.dist : o1.ans > o2.ans; &#125;); &#125; void solve()&#123; int k; cin >> k; cout &lt;&lt; ans[k - 1].ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 草，怎么赛时就没想着去做捏，这么暴力（（（ E. 微积分？低程竟然有微积分？题意给定一个多项式，满足式子中没有重复次幂，项按照次幂降序排序，次幂最小为 $0$。项的系数可以为负，但不会为 $0$。 输出它的积分。 思路很清晰的模拟题，坑点在于化简和系数 $1$。 化简很简单，除以 $gcd$ 即可。 系数 $1$ 不做过多解释，自行体会（ 时间复杂度：$O(n)$乘上点常数 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b); &#125; void solve()&#123; string exp; cin >> exp; exp += "#"; //end int now = 0, root = 0; cout &lt;&lt; "y="; bool tp = false; for(int i=3;i&lt;exp.size();i++)&#123; char cur = exp[i]; if(cur == 'x')&#123; root = (now == 0 ? 1 : now); now = 0; if(i >= exp.size() - 2 || exp[i + 1] != '^')&#123; if(root % 2 == 0 &amp;&amp; root / 2 != 1) cout &lt;&lt; root / 2 &lt;&lt; "x^2"; else if(root % 2 == 0) cout &lt;&lt; "x^2"; else cout &lt;&lt; root &lt;&lt; "/" &lt;&lt; 2 &lt;&lt; "x^2"; root = 0; &#125; &#125; else if(cur == '+' || cur == '-' || cur == '#') &#123; if(tp)&#123; int p = now; if(root % (p + 1) == 0 &amp;&amp; root / (p + 1) == 1) cout &lt;&lt; "x^" &lt;&lt; p + 1; else if(root % (p + 1) == 0) cout &lt;&lt; root / (p + 1) &lt;&lt; "x^" &lt;&lt; p + 1; else&#123; int x = gcd(p + 1, root); cout &lt;&lt; root / x &lt;&lt; "/" &lt;&lt; (p + 1) / x &lt;&lt; "x^" &lt;&lt; (p + 1); &#125; &#125;else if(now == 1) cout &lt;&lt; "x"; else if(now != 0) cout &lt;&lt; now &lt;&lt; "x"; tp = false; now = 0; if(cur == '+' || cur == '-') cout &lt;&lt; cur; else cout &lt;&lt; "+C"; &#125; else if(cur == '^') tp = true; else now = now * 10 + (cur - '0'); &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 系数1太坑了捏 F. SCI! 我就是要发SCI!题意给定 $n$ 个字符串，从中选 $k$ 个字符串并进行任意组合，输出最小的字典序。 思路首先，”从 $n$ 个东西中选 $k$ 个”，很容易让人想到背包问题，或者更具体地，这是一个 $01$ 背包。 但是，再套上板子之前，我们思考一下怎么递推。 有一个错误的思路（这也是我在赛时想到的奇怪思路），就是用一维的 $dp$，$dp_j$ 表示选了 $j$ 个后的最小字典序。那么我们直接枚举所有的字符串 $s_i$，遍历 $j$。对于 $dp_j$ ，遍历其中的字符串，将 $si$ 依次插入缝中，最后找出一种插法，使得 $dp_j$ 的字典序变小即可。 显然，我们不可以随意遍历，但有没有一种无需考虑插入位置的方法呢？ 我们来考虑任意两个字符串 $s_i, s_j$，如果 $s_i + s_j &lt; s_j + s_i$，那么很显然，前者的字典序更小。 那么，如果有三个呢？如果 $s_j + s_k &lt; s_k + s_j$，那么依然是前者的字典序更小。此时，我们联立起两个式子，会发现有趣的事情：$s_i + s_k &lt; s_k + s_i$。 也就是说，如果我们按照 $s_i + s_j$ 的字典序升序排序，就可以直接将取出的任意的 $k$ 个字符串拼接起来，而无需考虑这 $k$ 个字符串的顺序，此时字典序一定是最小的。 那么，问题就剩下从 $n$ 个东西中选 $k$ 个，代价最小的问题了，也就是求最小代价的 $01$ 背包。 事情到这里并未结束，我们来看下面的样例： 4 3 bbaba bba b b 不难发现，这组数据的答案为 $bbababb$。但如果我们套上板子，直接跑，得到的答案是 $bbababbab$。 问题在哪里呢？我们并没有考虑拼接上的答案的后缀，而如果出现了前缀一致的情况，我们无法控制让后缀尽可能短。 那么，很简单的解决方法，就是反着 $dp$，反着拼，这样就可以保证所有后缀的情况都被我们遍历过了。 时间复杂度：$O(n ^ 2)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve()&#123; int n, k; cin >> n >> k; vector&lt;string> s(n); for(int i=0;i&lt;n;i++) cin >> s[i]; vector&lt;string> dp(k + 1, "&#123;"); //保证ans原来的字典序为inf dp[0] = ""; sort(s.begin(), s.end(), [](string o1, string o2)&#123; return o1 + o2 > o2 + o1; //倒着做来让所有后缀都被遍历到 &#125;); for(auto e : s) //一维01背包 for(int j=k;j>=1;j--)&#123; dp[j] = min(dp[j], e + dp[j - 1]); &#125; cout &lt;&lt; dp[k] &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 还好赛时没怎么看这题（打完01的板子就突然意识到思路不对了，草 G. 旅行! 我就是想去旅行! 不会，样例都没过.jpg，待补充 H. WF？刚打低程就想着WF？题意定义 $5$ 种奖牌类型由低到高分别为 $LowerLevelProgrammingCompetition$，$SchoolCompetition$，$ProvincialCompetition$，$Regional$，$ECfinal$，$WF$。奖牌由低到高分为铜 ($Cu$)，银 ($Ag$)，金 ($Au$)。当然还有铁牌，但不计入。 定义三个相同的牌可以合成一个等级更高的牌，输出拿到 $WF$ 的金牌的最早时刻，不能拿到则输出可以拿到的价值最高的牌，什么牌都拿不到（打铁）输出 $-1$。 思路模拟即可。注意不要打错单词。 对于最后价值最高的牌的记录，不妨用 “类型” $\times 10 + $ “奖牌” 的方式存，方便一点（（ 时间复杂度：$O(n)$ #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;vector&lt;int> > cnt(6, vector&lt;int>(3)); map&lt;string, int> mp; mp["LowerLevelProgrammingCompetition"] = 0; mp["SchoolCompetition"] = 1; mp["ProvincialCompetition"] = 2; mp["Regional"] = 3; mp["ECfinal"] = 4; mp["WF"] = 5; mp["Cu"] = 0; mp["Ag"] = 1; mp["Au"] = 2; mp["Fe"] = -1; int hi = -1; int time = -1; for(int i=0;i&lt;n;i++)&#123; string s, a; cin >> s >> a; int id = mp[s], what = mp[a]; if(what == -1) continue; cnt[id][what] ++; if(id == 5 &amp;&amp; what == 2 &amp;&amp; time == -1) time = i + 1; hi = max(hi, id * 10 + what); if(cnt[id][what] == 3)&#123; cnt[id][what] = 0; if(what == 2) &#123; if(id &lt; 5)&#123; cnt[id + 1][0] ++; hi = max(hi, (id + 1) * 10); &#125;else&#123; if(time == -1) time = i + 1; &#125; &#125; else if(what &lt; 2) &#123; cnt[id][what + 1] ++; hi = max(hi, id * 10 + what + 1); if(id == 5 &amp;&amp; what + 1 == 2 &amp;&amp; time == -1) time = i + 1; &#125; &#125; &#125; if(time != -1) cout &lt;&lt; time &lt;&lt; '\n'; else if(hi != -1)&#123; int id = hi / 10, what = hi % 10; string ans; //懒得再写一个map了，累 if(id == 0) ans = "LowerLevelProgrammingCompetition"; else if(id == 1) ans = "SchoolCompetition"; else if(id == 2) ans = "ProvincialCompetition"; else if(id == 3) ans = "Regional"; else if(id == 4) ans = "ECfinal"; else ans = "WF"; cout &lt;&lt; ans &lt;&lt; ' '; if(what == 0) ans = "Cu"; else if(what == 1) ans = "Ag"; else ans = "Au"; cout &lt;&lt; ans &lt;&lt; '\n'; &#125;else cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; Ag == Au]]></content>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 858 Div 2</title>
    <url>/blog/posts/2942373806/</url>
    <content><![CDATA[Contestant. Rank 1247. Rating +30. A. Walking Master题意给定两个点 $(a, b), (c, d)$，定义对于点 $(x, y)$ 的操作为下面任选一： $x + 1, y + 1$； $x - 1$ 输出从 $(a, b)$ 走到 $(c, d)$ 需要的最小操作数，无解输出 $-1$。 思路画个图即可。 首先，我们需要向上移动 $d - b$，如果 $d - b &lt; 0$ 就是无解。 此时，横坐标变为 $a + d - b$，还需要向左移动 $a + d - b - c$，如果 $a + d - b - c &lt; 0$ 也是无解。 若有解，输出 $d - b + a + d - b - c$。 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; void solve()&#123; int a, b, c, d; cin >> a >> b >> c >> d; if(b > d || a + d - b &lt; c) cout &lt;&lt; -1 &lt;&lt; '\n'; else cout &lt;&lt; a + d - b - c + d - b &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 就还是那么签（ B. Mex Master题意给定一个序列，定义答案为 由相邻数相加构成的新序列中 不在 这个序列中的 最小自然数。将序列重新排序，输出最小答案。 思路首先，若 $0$ 的个数小于等于 $\frac{n + 1}{2}$，那么一定可以在连续的两个 $0$ 里面插入一个数，使最后的序列没有 $0$，答案即为 $0$； 其次，若整个序列的最大值大于 $1$，那么我们只需将 $1$ 全部放到后面，然后第一个 $1$ 之前不要放 $0$ 即可，答案即为 $1$； 接着，若整个序列的最大值为 $1$，那么一定有一个 $1$ 会和 $0$ 去相加，使最后的序列出现 $1$，而因为 $0$ 的个数足够多，我们只需在所有 $1$ 之间插 $0$，就可以避免出现 $2$，答案即为 $2$； 否则，整个序列都是 $0$，答案一定是 $1$。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; map&lt;int, int> cnt; int mx = 0; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; mx = max(mx, cur); cnt[cur] ++; &#125; if(cnt[0] &lt;= (n + 1) / 2) cout &lt;&lt; 0 &lt;&lt; '\n'; else if(cnt[0] == n) cout &lt;&lt; 1 &lt;&lt; '\n'; else cout &lt;&lt; (mx == 1 ? 2 : 1) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 一开始想错了（（ C. Sequence Master题意若一个长为 $2n$ 的序列，它的所有长度为 $n$ 的子序列满足选定的数的 乘积 与剩余数的 和 相等，那么定义其为好序列。 给定一个长为 $2n$ 的序列 $p$，选定一个好序列，定义答案为 $\sum|p_i - q_i|$，输出答案的最小值。 思路猜想首先，我们来以小见大，看看 $a, b, c, d$ 如何成为一个好序列： 拿出其中两个式子：$ab=c+d, ac=b+d$，我们可以得出 $b = c$ 或 $a = -1$。 同理，那么我们不妨猜测整个序列都是相等的数 $x$，或者会有至少一个数 $t$ 不是 $-1$。 讨论1下面我们来探讨一下第一个条件的局限性： 首先，它是一定成立的，毕竟 $x=0$ 一定是一个解，但可能出现其他解； 若只有两个数，那么 $x$ 可以为任意值； 若只有四个数，满足 $x ^ 2 = 2x$，$x = 2$； 若超过四个数，那么我们不难发现 $x ^ k = kx$ 对于 $k$ 为偶数的情况下是无整数解的。 讨论2下面我们来探讨一下第二个条件的局限性： 我们无法让大于等于 $2$ 个数不为 $-1$，列式可发现无实数解； $n$ 为奇数的时候，依然无解； 其余情况，我们可以解得 $t = n$。 总结最后，答案即为上面条件所算出的答案的最小值。 时间复杂度：$O(2n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int ans = inf; vector&lt;int> a(2 * n); for(int i=0;i&lt;2*n;i++) cin >> a[i]; if(n == 1)&#123; if(a[0] > a[1]) swap(a[0], a[1]); ans = a[1] - a[0]; &#125;else if(n == 2)&#123; ans = 0; for(int i=0;i&lt;4;i++) ans += abs(a[i] - 2); &#125; if(n % 2 == 0)&#123; int mn = inf, sum = 0; for(int i=0;i&lt;2*n;i++)&#123; sum += abs(a[i] + 1); mn = min(mn, abs(a[i] - n) - abs(a[i] + 1)); &#125; ans = min(ans, sum + mn); &#125; int sum = 0; for(int i=0;i&lt;2*n;i++) sum += abs(a[i]); ans = min(ans, sum); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 漏了奇数的情况，md 有更直接的做法，这里比较麻烦]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Nebius Welcome Round Div 1 plus 2</title>
    <url>/blog/posts/1381135032/</url>
    <content><![CDATA[Contestant. Rank 1761. Rating +54. A. Lame King题意给定一个坐标系，其中 $x \in [-100, 100], y \in [-100, 100]$。给定一个坐标 $[s, t]$，输出按规定从 $[0, 0]$ 走到 $[s, t]$ 需要的最短时间。 规定若需要连续从相同方向移动，需要间隔一秒。 思路首先，若我们需要一直向右，那么停留一秒绝对比向垂直方向绕路快，所以，我们不妨以折线的方式移动，直到横坐标或纵坐标等于终点时，向同一方向间隔移动。 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int a, b; cin >> a >> b; a = abs(a), b = abs(b); cout &lt;&lt; (a + b) + (a != b ? abs(a - b) - 1 : 0) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 画个图的事情（（ B. Vaccination题意对于 $n$ 个病人，每个病人需要在 $[t_i, t_i + w]$ 时间内被扎一针。在某个时间点 $x$，可以拿出一个包含 $k$ 个剂量的包装，这个包装会在 $x + d + 1$ 时过期。给定整数 $n, k, d, w$，输出需要拿出的包装的最小数量。 思路为了要当前的包装可以包括更多的人，我们不妨在某一个病人的 $t_i + w$ 时刻拿出包装，并枚举后面有多少个 $t_j$ 小于 $t_i + w + d$，这样即可贪心地求出最小值。 就这样，没了。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, k, d, w; cin >> n >> k >> d >> w; int ans = 0; vector&lt;pii> a(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i].first; a[i].second = a[i].first + w; &#125; int i = 0; while(i &lt; n)&#123; int l = a[i].second, r = l + d; int now = i; for(int j=0;j&lt;k;j++)&#123; if(i + j >= n || a[i + j].first > r) break; now ++; &#125; ans ++; i = now; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 这还需要证明吗，这还需要证明吗（ C. Pull Your Luck题意给定一个圆盘，按顺序写好了 $0, 1, 2, …, n - 1$，换言之，$0, n - 1$ 相邻。规定可以转动 $p$ 秒，第一秒将当前值增加 $p$，第二次增加 $p - 1$，以此类推。对于给定的起点，输出是否可以进行一次 $[1, p]$ 秒的转动，使终点为 $0$。 思路首先，我们很容易列出一个式子： $n - x + kn = \frac{p(p+1)}{2}$ 但这个式子推不了什么。 有趣的是，若我们一直循环加上数的话，在取到 $n-1$ 之后，所有数均会变小，但值得注意的是这些数因均相邻而出现了周期。 因而，在一个周期内，若出现了 $0$，输出即可。能保证最后的复杂度足够小。 时间复杂度：不大就对了 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, x, p; cin >> n >> x >> p; int cur = x; for(int i=1;i&lt;=min(p, 2*n);i++)&#123; cur = (cur + i) % n; if(cur == 0) &#123; cout &lt;&lt; "YES\n"; return; &#125; &#125; cout &lt;&lt; "NO\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 捏吗，一直在想怎么搞式子 D. Accommodation题意给定 $n$ 个长度为 $m$ 的二进制串，满足 $m\ \%\ 4 = 0$，将字符串分割为 $\frac{m}{4}$ 个长度为 $2$ 的子串和 $\frac{m}{2}$ 个长度为 $1$ 的子串。输出所有含 $1$ 子串个数总和的最大值和最小值。 思路若我们需要让个数尽可能大，我们当然希望将 $11$ 分割开，也就是构造非 $11$ 的大窗，那么，我们不妨枚举所有含有 $0$ 的可能的大窗，拿掉这些后，剩余的作为小窗，即可让个数尽可能大。 相反地，要让个数尽可能小，我们就希望尽可能不将 $11$ 分割开，也就是主动构造为 $11$ 的大窗，这时，能构造多少个，$1$ 的个数就能减少多少。 有趣的是，只要分割出 $\frac{m}{4}$ 个长度为 $2$ 的子串，剩余的一定长度均为 $1$，且恰好 $\frac{m}{2}$ 个；反之亦然。 当然，如果这题数据量小的话，可以 $dp$。 时间复杂度：$O(nm)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; int mn = 0, mx = 0; while (n--) &#123; string s; cin >> s; int c1 = 0, c2 = 0, tot = 0; for (int i = 0; i &lt; m; i++) tot += s[i] - '0'; for (int i = 0; i &lt; m - 1; i ++) if (s[i] == '1' &amp;&amp; s[i + 1] == '1') c1 ++, i ++; for (int i = 0; i &lt; m - 1; i ++) if (s[i] == '0' || s[i + 1] == '0') c2 ++, i ++; mn += tot - min(c1, m / 4); mx += tot - max(0ll, m / 4 - c2); &#125; cout &lt;&lt; mn &lt;&lt; ' ' &lt;&lt; mx &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 似了，在想怎么dp，贪心还没贪对（一直想着拆]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 857 Div 2</title>
    <url>/blog/posts/1495891783/</url>
    <content><![CDATA[Virtual Participant. Unofficial Rank 382. Solved 4/7. A. Likes题意定义 $a_i$ 为一个人对 $|a_i|$ 的”喜欢”状态，当 $a_i &gt; 0$ 时，该人对 $|a_i|$ 点了”喜欢”，否则将其撤回了”喜欢”。规定未点喜欢就不能撤回”喜欢”。 给定打乱顺序后的若干人的”喜欢”操作，定义 $b_i$ 为进行第 $i$ 次操作后得到的”喜欢”数量。将操作按一定方案排序，输出让每次操作得到的数量最大和最小的序列 $b$。 思路首先，若要让数量最少，我们直接在点了”喜欢”后立刻取消即可，那么最后得到的答案会有 $x$ 个 $0\ 1$，$x$ 即为负数的个数。剩余的数只能让 $b$ 严格递增 $1$。 若要让数量最多，那么我们只需在全部点完后再取消。这时得到一个先递增后递减的序列。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; int cur; cin >> cur; if(cur &lt; 0) cnt ++; &#125; for(int i=1;i&lt;=n-cnt;i++) cout &lt;&lt; i &lt;&lt; ' '; for(int i=1;i&lt;=cnt;i++) cout &lt;&lt; n - cnt - i &lt;&lt; ' '; cout &lt;&lt; '\n'; for(int i=0;i&lt;cnt;i++) cout &lt;&lt; "1 0 "; for(int i=1;i&lt;=n-2*cnt;i++) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 瞎模拟即可 B. Settlement of Guinea Pigs题意给定一个操作序列，定义操作为下面任选一： “1”表示引入一个未知性别的猪，按规则放入一个栅栏内； “2”表示确定所有已经引入的猪的性别，按照规则重新排列。 定义一个栅栏内的猪性别需一致，且最多有两个猪。 输出最后需要至少多少个不同的栅栏。 思路首先，在不知道性别的时候，新引入的猪只能单独放到一个栅栏内。 其次，若知道了性别，那么我们需要对奇偶性分类讨论： 若为奇数，那么母猪和公猪的数量一定为一个偶一个奇，那么当前就需要 $($总数量$+1)/2$ 个栅栏 若为偶数，那么会出现两个偶数或两个奇数的可能，但我们不能确定为哪一种情况，所以我们考虑大的那个数量，也就是两个奇数的情况。这个时候，我们需要 总数量$/2+1$ 个栅栏。 最后，对于每次操作，计算并统计最大值即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123; &#125; void solve() &#123; int n; cin >> n; int sum = 0, num = 0; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur == 1)&#123; sum ++, num ++; ans = max(ans, num); &#125;else&#123; if(sum == 0) num = 0; else num = (sum + 1 + (1 - sum % 2)) / 2; ans = max(ans, num); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 怎么奇数的情况搞错了（（ C. The Very Beautiful Blanket题意定义美丽矩阵满足下面的要求： 规模 $4 \times 4$； $A{11} \oplus A{12} \oplus A{21} \oplus A{22} = A{33} \oplus A{34} \oplus A{43} \oplus A{44}$； $A{13} \oplus A{14} \oplus A{23} \oplus A{24} = A{31} \oplus A{32} \oplus A{41} \oplus A{42}$ 给定一个矩阵的规模，规模大于等于 $4 \times 4$，构造一个矩阵，使得所有 $4 \times 4$ 的子矩阵均为美丽矩阵，且不同元素的数量最大。输出不同数字的数量，以及对应的一个矩阵。 思路首先，值得留意的是：$4x \oplus (4x+1) \oplus (4x + 2) \oplus (4x + 3) = 0$。那么，我们不妨构造这样的子矩阵： $\left[ {\begin{array}{cccc} 4x &amp; 4x + 1 \ 4x + 2 &amp; 4x + 3 \end{array} } \right]$ 有趣的是，$4x \oplus (4x + t) \oplus 4y \oplus (4y + t) = 0$ （巧了我不会证），那么我们不妨按照上面的矩阵依次排满第一行，然后找到大于所用过的数的第一个为 $4$ 的倍数的数，继续按照上面的矩阵排列即可。那么，任意找出一个子矩阵，结果都为 $0$。 考虑到数据量，我们不妨让第 $i$ 行的起始数字为 $256(i - 1)$，会让程序更好写。 时间复杂度：$O(nm)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123; &#125; void solve() &#123; int n, m; cin >> n >> m; cout &lt;&lt; n * m &lt;&lt; '\n'; for(int i=0;i&lt;n/2;i++)&#123; int offset = i * 512; for(int j=0;j&lt;m/2;j++) &#123; cout &lt;&lt; offset &lt;&lt; ' ' &lt;&lt; (offset + 1) &lt;&lt; ' '; offset += 4; &#125; if(m % 2 == 1) cout &lt;&lt; offset &lt;&lt; ' '; cout &lt;&lt; '\n'; offset = i * 512 + 2; for(int j=0;j&lt;m/2;j++) &#123; cout &lt;&lt; offset &lt;&lt; ' ' &lt;&lt; (offset + 1) &lt;&lt; ' '; offset += 4; &#125; if(m % 2 == 1) cout &lt;&lt; offset &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; if(n % 2 == 1)&#123; int offset = n / 2 * 512; for(int j=0;j&lt;m/2;j++) &#123; cout &lt;&lt; offset &lt;&lt; ' ' &lt;&lt; (offset + 1) &lt;&lt; ' '; offset += 4; &#125; if(m % 2 == 1) cout &lt;&lt; offset &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 不会证，但会猜（（（ D. Buying gifts题意给定 $n$ 个商店，第 $i$ 个商店具有 $a_i, b_i$ 两个价格。规定每个商店均需要买一个商品，为 $A$ 买第 $i$ 个商店的物品花费 $a_i$ 元，为 $B$ 买第 $i$ 个商店的物品花费 $b_i$ 元。输出所有方案中为 $A$ 买的商品的最大价格 $max_A$ 和为 $B$ 买的商品的最大价格 $max_B$ 的差值的绝对值的最小值，即 $min{|max_A - max_B|}$。 思路首先，我们不可能去枚举所有的方案，那么我们至少需要一个 $O(nlogn)$ 复杂度的解法。 我们可以枚举为 $A$ 买的商品的最大值，也就是枚举所有的 $a_i$，将其作为当前的最大值，那么大于 $a_i$ 数对应的商品只能给 $B$。 接着，我们可以二分查找 去除第 $i$ 个商店后 剩余商店中的 所有 $b_i$ 中 和 $a_i$ 最近的两个数。若我们可以将这个数作为 $B$ 的最大值，也就是说，所有大于 $b_j$ 的数对应的 $a_j$ 不能大于 $a_i$，那么更新差值的最小值。当然，有可能两个数都不满足，但是当前 $B$ 中可以用的最大值依然可以和 $a_i$ 减，他是有可能作为答案的。 对数复杂度的删除和查询，最佳之选就是 $multiset$。 而为了让上述操作更方便，我们不妨按 $a_i$ 降序排序，那么，之前遍历过的 $a_i$ 一定是要放到 $B$ 里去的，而这些数也肯定不能在二分查找的范围内的，因而我们在遍历的时候，顺便记录前 $i$ 个商店中 $b_i$ 的最大值 $mx$，按照上面的分析执行即可。 时间复杂度：$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123; &#125; void solve() &#123; int n; cin >> n; multiset&lt;int> a; vector&lt;pii> q(n); for(int i=0;i&lt;n;i++) cin >> q[i].first >> q[i].second; sort(q.begin(), q.end()); for(auto e : q) a.emplace(e.second); a.emplace(inf); int ans = inf, mx = -inf; for(int i=n-1;i>=0;i--)&#123; ans = min(ans, abs(q[i].first - mx)); a.erase(a.find(q[i].second)); auto it = a.lower_bound(q[i].first); if(*it != inf) &#123; if (q[i].first >= mx) ans = min(ans, abs(*it - q[i].first)); &#125; if (it != a.begin() &amp;&amp; q[i].first > mx) ans = min(ans, abs(*(--it) - q[i].first)); mx = max(mx, q[i].second); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 整个人升华了（划掉]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 827 Div 4</title>
    <url>/blog/posts/3129987947/</url>
    <content><![CDATA[Practice. A. Sum题意给定三个数，输出是否可以找出一个数，满足其为另外两个数的和。 思路如题。 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; int a, b, c; cin >> a >> b >> c; cout &lt;&lt; (a + b == c || a + c == b || b + c == a ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 如题 B. Increasing题意给定一个序列，满足是否可以重新排列序列，使序列严格单调递增。 思路没有重复元素即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; int n; cin >> n; map&lt;int, bool> mp; bool f = true; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(mp[cur]) &#123; f = false; &#125; mp[cur] = true; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 说那么复杂干嘛（ C. Stripes题意给定一个 $8 \times 8$ 的矩阵，定义操作为将某一行全部涂成红色，或将某一列全部涂成蓝色，后面的颜色会覆盖前面的颜色。给定任意次操作后的矩阵，输出最后涂上的是什么颜色。 思路首先，既然存在覆盖，那么被覆盖的某行或某列一定不是在最后操作的。 那么，我们可以找出全为红色的行，或者全为蓝色的列，若能找到就为答案。不然，一定存在覆盖。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; vector&lt;string> s(8); for(int i=0;i&lt;8;i++) cin >> s[i]; bool f = false; for(int i=0;i&lt;8;i++)&#123; bool now = true; for(int j=0;j&lt;8;j++)&#123; if(s[i][j] == 'B') now = false; &#125; if(now)&#123; f = true; cout &lt;&lt; "R\n"; break; &#125; &#125; if(!f) for(int j=0;j&lt;8;j++)&#123; bool now = true; for(int i=0;i&lt;8;i++)&#123; if(s[i][j] == 'R') now = false; &#125; if(now)&#123; f = true; cout &lt;&lt; "B\n"; break; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 略微有点小思维 D. Coprime题意给定一个序列 $a$，找出 $i, j, i \neq j$，满足 $a_i, a_j$ 互质。输出满足条件的 $i + j$ 的最大值。 思路虽然整体数据量很大，但是需要留意的是 $a_i \leq 1000$。 因而，我们不妨记录出现过的数对应的下标最大值。然后，我们直接对 $1000$ 中出现过的数字遍历，统计出最大值即可。 时间复杂度：$O(1000 ^ 2 logx)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> int gcd(int a, int b)&#123; return a == 0 ? b : gcd(b % a, a); &#125; void solve()&#123; int n; cin >> n; vector&lt;int> a(1001); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; a[cur] = max(a[cur], i); &#125; int ans = -1; for(int i=1;i&lt;=1000;i++) for(int j=i;j&lt;=1000;j++)&#123; if(gcd(i, j) == 1 &amp;&amp; a[i] > 0 &amp;&amp; a[j] > 0) ans = max(ans, a[i] + a[j]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 来绕一个弯（（ E. Scuza题意给定一个上升台阶的所有相邻两层的高度差，对于 $q$ 个询问给定的腿长 $k_i$，输出能登上的台阶距离地面的最大高度。 思路首先，台阶上升，所以台阶距离地面的高度具有单调性。 那么，二分不就好了么。 时间复杂度：$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, q; cin >> n >> q; vector&lt;int> a(n + 1), s(n + 2); for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; a[i] += a[i - 1]; s[i] = max(s[i - 1], a[i] - a[i - 1]); &#125; s[n + 1] = inf; while(q--)&#123; int x; cin >> x; cout &lt;&lt; a[upper_bound(s.begin(), s.end(), x) - s.begin() - 1] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 考虑到lower_bound找不到会指向最后一个点，那么我们不妨在最后插一个无穷大 F. Smaller题意给定两个初始均为 $’a’$ 的字符串 $s, t$，定义操作为下面两种任选一： $1\ k\ x$，在 $s$ 后面循环拼接上 $k$ 个 $x$； $2\ k\ x$，在 $t$ 后面循环拼接上 $k$ 个 $x$。 对于每次操作，输出是否可以重新排列两个字符串，使 $s$ 的字典序小于 $t$。 思路我们不妨直接考虑怎么样才能让字典序较小： 既然可以重新排序，而且一开始两个字符串是一样的，且只有一种字母，那么，只要 $t$ 中出现了不是 $a$ 的字符，我们直接把他放到第一个，而 $s$ 的第一个直接放上 $a$，就一定可以满足 $s &lt; t$； 但是，若没有非 $a$ 字符，我们就只能统计有多少个 $a$，个数少的字典序自然小。 那么，我们只要按照上述思路，统计 $s, t$ 中是否出现了非 $a$ 字符，以及 $a$ 出现的次数即可。 最后，若 $s$ 出现了非 $a$ 字符而 $t$ 中没有出现，或者都没出现但 $s$ 的 $a$ 数量更多，那么输出 $NO$，否则为 $YES$。 时间复杂度：$O(nm)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int cnt1 = 1, cnt2 = 1; bool h1 = false, h2 = false; int q; cin >> q; while(q --)&#123; int d, k; cin >> d >> k; string s; cin >> s; for(char e : s)&#123; if(d == 1)&#123; if(e == 'a') cnt1 += k; else h1 = true; &#125; if(d == 2)&#123; if(e == 'a') cnt2 += k; else h2 = true; &#125; &#125; cout &lt;&lt; ((!h1 &amp;&amp; !h2 &amp;&amp; cnt1 >= cnt2) || (h1 &amp;&amp; !h2) ? "NO\n" : "YES\n"); &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 略微绕了一下（ G. Orray题意给定一个序列 $a$，定义 $b_i$ 为 $a$ 前 $i$ 个数按位或的值。将序列重新排序，满足 $b$ 的字典序最大。输出任意一种满足条件的方案。 思路首先，按位或一定是越或越大的，因而我们一定会把最大的数放在第一个。 接着，要让下个数尽可能大，我们当然希望找到一个数，对于当前的数的最高位 $0$，这个数的该位为 $1$。 我们可能找不到这个数，但是有趣的是，既然数据范围为 $1e9$，那么我们一定可以找出 $32$ 个以内的数，让按位或的值递增。 因而，我们不妨直接遍历 $32$ 次，找出剩下的让按位或的结果最大的数，输出该数即可。 而，当我们拿不出数字使按位或的结果变大时，就结束了。剩余的数随便输出即可。 时间复杂度：$O(32 n^2)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; vector&lt;int> ans; vector&lt;bool> vis(n); int tot = 0; for(int i=31; i>=0;i--)&#123; int idx = -1, now = 0; for(int j=0;j&lt;n;j++)&#123; if(vis[j]) continue; if((tot | a[j]) > now)&#123; now = tot | a[j]; idx = j; &#125; &#125; if(idx == -1) break; vis[idx] = true; ans.emplace_back(a[idx]); tot |= a[idx]; &#125; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; for(int i=0;i&lt;n;i++) if(!vis[i]) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 想不到就绕死了（]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 293</title>
    <url>/blog/posts/2378255232/</url>
    <content><![CDATA[Contestant. Rank 2467. Rating +89. A. Swap Odd and Even题意给定一个字符串，将所有 $2x$ 和 $2x+1$ 位字符交换位置，输出操作后的字符串。 思路模拟即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; string s; cin >> s; for(int i=0;i&lt;s.size()/2;i++)&#123; char t = s[2 * i]; s[2 * i ] = s[2 * i + 1]; s[2 * i + 1] = t; &#125; cout &lt;&lt; s; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 快速签到 B. Call the ID Number题意给定一个序列 $a$，对于第 $i$ 个元素，若 $i$ 没被标记，那么将 $a_i$ 标记。遍历序列后，输出剩余未标记的数。 思路模拟即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;bool> vis(n + 1); int cnt = n; for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; if(vis[i] || vis[cur]) continue; cnt --; vis[cur] = true; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i]) cout &lt;&lt; i &lt;&lt; ' '; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 依然快速签到 C. Make Takahashi Happy题意给定一个 $H \times W$ 的加权矩阵，规定一次移动只能向下或向右走，且不能超出矩阵范围。对于起点 $(1,1)$ 和终点 $(H, W)$，输出满足路径中无重复元素的路径数。 思路考虑到题给范围特别小，我们不妨直接 $Dfs$，用回溯搜索的方式记录当前元素出现了几次，若出现两次跳出搜索即可。 时间复杂度：$O(n^2)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[20][20], h, w, ans; map&lt;int, int> cnt; void init()&#123;&#125; void dfs(int x, int y)&#123; if(x == h &amp;&amp; y == w)&#123; ans ++; return; &#125; if(x + 1 &lt;= h &amp;&amp; cnt[a[x + 1][y]] == 0) &#123; cnt[a[x + 1][y]] ++; dfs(x + 1, y); cnt[a[x + 1][y]] --; &#125; if(y + 1 &lt;= w &amp;&amp; cnt[a[x][y + 1]] == 0) &#123; cnt[a[x][y + 1]] ++; dfs(x, y + 1); cnt[a[x][y + 1]] --; &#125; &#125; void solve() &#123; cin >> h >> w; for(int i=1;i&lt;=h;i++) for(int j=1;j&lt;=w;j++) cin >> a[i][j]; cnt[a[1][1]] ++; dfs(1, 1); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 就很暴力 D. Tying Rope题意定义一段绳子有两个端点，一端为红色，另一端为蓝色。对于 $k$ 次操作，将第 $A$ 个绳子颜色为 $B$ 的一端和第 $C$ 个绳子颜色为 $D$ 的一端连接。 特别地，满足一端绳子不会和两条及以上绳子连起来。 输出连通块中环和链的个数。 思路1首先，既然考虑到这个特别的条件，我们完全可以不管颜色，因为题目一定有解，对于一段绳子，它的一个端点只会出现在最多一次操作里。所以，在本次操作后，下一次再访问到这个绳子，一定是另一个点了。 为了读入数据方便，我们定义绳子左端点是红色的、右端点是蓝色的。 那么，按照上述方法，我们可以很简单地得到一条绳子它的左端点和右端点分别和哪条绳子连起来了。 接着，我们只需遍历所有绳子，对于第 $i$ 个绳子，若它未被访问到，那么他一定是新的连通块的一部分，我们向左和向右找寻边界。当我们遍历到端点未和其他点连接时，结束寻找，此时枚举到的所有点都是这个连通块的一部分。但，若我们遍历到了之前遍历过的绳子，那么很显然存在了环，所以我们直接统计个数并跳过这个连通块继续寻找。 在找寻边界的时候，因为读入数据的特殊性，对于 $A =&gt; B =&gt; C$，若 $B$ 的右端点和 $A$ 的右端点连接，那么会出现死循环，但是此时会出现回到上一个相邻点的情况，而且我们不难发现，只有这种特殊情况才会出现”回溯”。所以，我们只需记录前一个绳子 $A$，找到 $B$ 的左右端点中不是 $A$ 的那个点所连接的绳子 $C$ 即可。 时间复杂度：$O(m + n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; //规定左红右蓝 vector&lt;vector&lt;int>> ac(n + 1, vector&lt;int>(2, -1)); for(int i=1;i&lt;=m;i++)&#123; int a, b, c, d; char bc, dc; cin >> a >> bc >> c >> dc; b = bc == 'R' ? 0 : 1; d = dc == 'R' ? 0 : 1; ac[a][b] = c; ac[c][d] = a; &#125; vector&lt;bool> vis(n + 1); int ans1 = 0, ans2 = 0; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]) continue; int now, pre; vis[i] = true; pre = i, now = ac[i][0]; bool ok = false; if(now != -1)&#123; vis[now] = true; while(true)&#123; int tmp = now; now = ac[now][0] == pre ? ac[now][1] : ac[now][0]; pre = tmp; if(now == -1) break; if(vis[now])&#123; ans1 ++; ok = true; break; &#125; vis[now] = true; &#125; &#125; pre = i, now = ac[i][1]; if(!ok &amp;&amp; now != -1) &#123; vis[now] = true; while (true) &#123; int tmp = now; now = ac[now][1] == pre ? ac[now][0] : ac[now][1]; pre = tmp; if (now == -1) break; if (vis[now]) &#123; ans1++; ok = true; break; &#125; vis[now] = true; &#125; &#125; if(!ok) ans2 ++; &#125; cout &lt;&lt; ans1 &lt;&lt; ' ' &lt;&lt; ans2 &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 无脑模拟（（ 思路2本题也可以用并查集完成。 待补充 磕了半天居然磕出来了 E. Geometric Progression题意给定三个整数 $A, X, M$，输出 $(\sum^{X-1}_{i=0} A ^ i)\ \%\ M$。 思路首先，很明显这是等比数列求和公式，最后的答案就是 $\frac{A ^ X - 1}{A-1}\ \%\ M$。 但是，问题在于这个除法取模。 一般除法取模需要求逆元，但是本题的 $A, M$ 是任意的，所以 $M$ 不是质数并且 $A, M$ 不互质的时候，无法求出逆元。 但是，若我们对 $A^X - 1$ 因式分解，当 $A = 1$ 时一定是一个让式子为 $0$ 的根，也就是说可以提出 $A - 1$。 那么，$A - 1$ 就可以消掉了。 为了取模计算方便，我们不妨在求快速幂的时候，对 $M(A - 1)$ 取模，最后除掉 $A - 1$ 即可。 因而，最后我们可以得到一个式子：$\frac{A ^ X\ \%\ (M(A - 1)) - 1}{A-1}$。 当然，当 $A = 1$ 的时候需要特判，这只和 $X\ \%\ M$ 的奇偶性有关。 时间复杂度：有点复杂 注意M(A-1)会爆long long，需要用__int_128 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int __int128_t #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; int qp(int a, int b, int m) &#123; a %= m; int res = 1; while (b > 0) &#123; if (b &amp; 1) res = res * a % m; a = a * a % m; b >>= 1; &#125; return res; &#125; void solve() &#123; long long a, x, m; cin >> a >> x >> m; cout &lt;&lt; (a == 1 ? x % m : (((long long) qp(a, x, m * (a - 1)) - 1) / (a - 1)) % m) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 麻了，被逆元坑了]]></content>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 828 Div 3</title>
    <url>/blog/posts/3533911585/</url>
    <content><![CDATA[Practice. A. Number Replacement题意给定一个序列，一个字母可以映射到任意一个数字，但要求一个字母只能映射到一个数字，一个数字可以映射到多个字母。输出是否合法。 思路简单，我们用哈希即可。用 $map$ 即可解决本题。 时间复杂度：$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve() &#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; string s; cin >> s; map&lt;int, char> mp; bool f = true; for(int i=0;i&lt;n;i++)&#123; if(mp[a[i]] > 0 &amp;&amp; mp[a[i]] != s[i]) f = false; mp[a[i]] = s[i]; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while(t --) solve(); &#125; 水.jpg B. Even-Odd Increments题意给定一个序列，含有奇数和偶数，定义操作如下： $0\ x$ 表示将 $x$ 添加到所有偶数上； $1\ x$ 表示将 $x$ 添加到所有奇数上。 在每次操作后，输出总和。前面的操作会影响后面的值。 思路显然，我们只需统计当前序列有多少偶数即可。 设偶数的个数为 $cnt$，那么第一个操作即为将 $sum$ 加上 $even \times x$，第二个操作即为将 $sum$ 加上 $(n - even) \times x$。 显然，我们不需要在每次操作后遍历找偶数个数，而是考虑下面的规律： 偶数加奇数为奇数； 奇数加奇数为偶数。 因而，若出现将奇数加在奇数上的情况，那么 $even = n$，若出现将奇数加在偶数上的情况，那么 $even = 0$。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve() &#123; int n, q; cin >> n >> q; vector&lt;int> a(n); //注意一下偶数和奇数的相加即可 int even = 0, sum = 0; for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; sum += a[i]; if(a[i] % 2 == 0) even ++; &#125; while(q --)&#123; int t, v; cin >> t >> v; if(t % 2 == 0)&#123; //加到偶数上 sum += even * v; cout &lt;&lt; sum &lt;&lt; '\n'; if(v % 2 == 1) even = 0; //偶加奇 &#125;else&#123; //加到奇数上 sum += (n - even) * v; cout &lt;&lt; sum &lt;&lt; '\n'; if(v % 2 == 1) even = n; //奇加奇 &#125; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while(t --) solve(); &#125; 偏模拟的思维题 C. Traffic Light题意定义三种交通信号灯：$R,H,G$，只有位于 $G$ 的时间下才可过马路。交通信号灯的切换具有周期性，因而给定一个周期的信号灯切换情况 $s$，如 $s = RBRGG$，那么在执行五秒后，将会重新执行一次，构成 $RBRGGRBRGGRB…$。给定当前的信号灯种类 $c$，输出遇到下一个 $G$ 所间隔的最长时间。 思路如上，我们只需遍历所有 $c$，找出其和下一个 $G$ 的距离即可。 至于距离，数据范围貌似可以允许我们暴力往后搜，但后缀数组会出手。 我们维护后缀数组，$suf_i$ 表示 $i$ 及以后第一个出现的 $G$ 的位置。 那么，查询的复杂度即为 $O(1)$。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve() &#123; int n; char c; cin >> n >> c; string s; cin >> s; s = " " + s + s; n *= 2; vector&lt;int> suf(n + 1); suf[n] = -1; for(int i=n - 1;i>=1;i--)&#123; if(s[i] == 'g') suf[i] = i; else suf[i] = suf[i + 1]; &#125; int mx = 0; for(int i=0;i&lt;n;i++)&#123; if(s[i] == c) mx = max(mx, suf[i] - i); &#125; cout &lt;&lt; mx &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while(t --) solve(); &#125; 可能就真的能暴力（（ D. Divisibility by 2^n题意给定一个长度为 $n$ 的序列，定义一次操作为选取一个 $a_i$ 并将其改为 $a_i \times i$。输出最少的操作数，使最后的序列的乘积为 $2 ^ n$ 的倍数。 思路首先，乘上奇数绝对没什么用，所以我们只需考虑偶数。 观察偶数的递推性以及二进制下的规律，我们不难发现所有的偶数都是一个 $2 ^ t$ 乘上一个奇数得到的。 上述没必要乘上偶数，毕竟那就是 $2 ^ {t + 1}$ 的事情了，为何要考虑重复呢。 因而，我们自然希望我们能在一次操作中乘上尽可能多的 $2$，也就是让 $t$ 尽可能大。 这个 $t_{max}$ 是很容易求的，我们只需循环乘二直到不超过 $n$ 的最大值即可。 那么，我们不妨去枚举 $2 ^ t$ 的奇数倍，然后在超过 $n$ 后将 $t$ 递减，这样即可满足条件。 在加之前，我们判断一下当前能除多少个 $2$，和 $n$ 比较即可。 时间复杂度：$O(nt)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve() &#123; int n; cin >> n; int cnt = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; while(cur % 2 == 0)&#123; cur /= 2; cnt ++; &#125; &#125; int mx = 1, cur = 2; while(true)&#123; if(cur * 2 > n) break; mx ++; cur *= 2; &#125; int ans = 0; for(int i=mx;i>=1;i--)&#123; for(int j=1;pow(2, i)*j&lt;=n;j+=2)&#123; //奇数倍 if(cnt >= n) break; cnt += i; ans ++; &#125; if(cnt >= n) break; &#125; cout &lt;&lt; (cnt >= n ? ans : -1) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while(t --) solve(); &#125; 奇怪的清晰思路增加了 E1. Divisible Numbers (easy version) 详见E2，区别是本题的数据范围小 E2. Divisible Numbers (hard version)题意给定 $4$ 个整数 $a, b, c, d$，找出一对 $x, y$，满足 $x \in (a, c], y \in (b, d], xy$ 可以被 $ab$ 整除。 思路首先，我们不难发现，$y = k \times \frac{ab}{gcd(ab, x)}$，其中 $k$ 为常数，那么，我们可以很简单的用 $O(1)$ 的复杂度算出 $y$。 那么我们来考虑 $x$。显然，$x \neq 1$，所以 $x$ 就是 $gcd(ab, x)$ 的倍数，或者说，是 $ab$ 的因数的倍数。 那么，我们只需枚举所有的因数，然后，我们也可以用 $O(1)$ 的方法算出 $x$，和求 $y$ 的方法类似。 但是，枚举 $ab$ 的因数是不现实的，因为 $\sqrt{ab}$ 太大了。但是，既然我们可以将这个数分解为 $a, b$，那么它的所有因数就是 $a$ 的所有因数和 $b$ 的所有因数配对相乘。 因而，$\sqrt a$ 可以减到 $1e5$ 的复杂度，足以。 时间复杂度：$O(\sqrt a + \sqrt b + t ^ 2)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; vector&lt;int> fact(int x) &#123; vector&lt;int> facts; int sq = (int) sqrt(x); for (int i = 1; i &lt; sqrt(x); i++) &#123; if (x % i == 0) facts.emplace_back(i), facts.emplace_back(x / i); &#125; if (sq * sq == x) facts.emplace_back(sq); return facts; &#125; void solve() &#123; int a, b, c, d; cin >> a >> b >> c >> d; vector&lt;int> factA = fact(a), factB = fact(b); bool f = false; for (int i: factA) &#123; for (int j: factB) &#123; int bx = i * j, by = a * b / (i * j); int x = ((int) ceil((double) a / (double) bx) + (a % bx == 0 ? 1 : 0)) * bx, y = ((int) ceil((double) b / (double) by) + (b % by == 0 ? 1 : 0)) * by; if (x &lt;= c &amp;&amp; y &lt;= d) &#123; cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n'; f = true; break; &#125; &#125; if (f) break; &#125; if (!f) cout &lt;&lt; -1 &lt;&lt; ' ' &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while (t --) solve(); &#125; 一开始还想着贪心，似也做不出来，淦]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 856 Div 2</title>
    <url>/blog/posts/4284380403/</url>
    <content><![CDATA[Contestant. Rank 1886. Rating -17. A. Prefix and Suffix Array题意给定一个字符串的所有前缀和后缀，如 $a, ab, abc, bca, ca, a$，不包含其本身，判断原字符串是否是回文字符串。 思路既然是前后缀，并且回文字符串的判断只需比较 $[0, \frac{n}{2}]$ 和 $[n - \frac{n}{2} - 1, n - 1]$ 区间对应的子串即可，所以我们只需拿出长度为 $\frac{n}{2}$ 的两个字符串，将一个字符串反转后和另一个比较，相等即回文。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve()&#123; int n; cin >> n; vector&lt;string> s; for(int i=0;i&lt;2 * (n - 1); i++)&#123; string now; cin >> now; if(now.size() == n / 2) s.emplace_back(now); &#125; std::reverse(s[0].begin(), s[0].end()); cout &lt;&lt; (s[0] == s[1] ? "YES\n" : "NO\n"); &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 真是阴间时间下猪脑转不动了（ B. Not Dividing题意给定一个长度为 $n$ 的数组 $a$，定义操作为选择任意一个数字并将其加减 $1$，操作最多执行 $2n$ 次。输出一种方案操作后得到的数组，满足 $a_{i + 1}$ 不能被 $a_i$ 整除。 思路首先，不能出现 $1$，因为无论前面的数怎么改变，最后都会被 $1$ 整除，所以遇到 $1$ 改成 $2$。 其次，奇数不能被偶数整除，而偶数可以被奇数整除，但该偶数 $+1$ 就不会被该奇数整除了（具体证明不清楚）。 最后，我们得到下面的结论：遇到整除，将后者加一，除非遇到 $1$，此时将前者加一。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve()&#123; int n; cin >> n; int pre; cin >> pre; if(pre == 1) pre ++; cout &lt;&lt; pre &lt;&lt; ' '; for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur == 1) cur ++; if(cur % pre == 0)&#123; pre = cur + 1; &#125;else pre = cur; cout &lt;&lt; pre &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 当然不是简简单单的判奇偶啊… C. Scoring Subsequences题意定义一个不递减序列 $s$ 的 $cost$ 为 $\frac{s_1\cdot s_2\cdot \ldots \cdot s_d}{d!}$。给定一个长度为 $n$ 的序列，对于所有 $k \in [1, n]$，输出前 $k$ 个数的所有子序列的最大 $cost$ 对应的最大子序列长度。 思路首先，第一个数对应的答案一定是 $1$，这是毋庸置疑的。 那么，遍历到第二个数的时候，我们可以继续保持答案 $1$，也可以把答案更新为 $2$，此时对应为选第二个数或者都选，因为序列是不递减的。 那么，假设我们选了两个数，那么继续遍历到第三个数的时候，由于第二三两个数的乘积大于等于前两个数的乘积，所以答案是肯定大于等于 $2$ 的，我们唯一需要判断的就是前一个数能不能放进来。 为什么不用再往前考虑呢？因为之前我们已经判断过了，比如说第二次只选了一个数，那么 $a_2 \geq \frac{a_1 \times a_2}{2} =&gt; a_1 \leq 2$，也必定满足 $\frac{a_2 \times a_3}{2} \geq \frac{a_1 \times a_2 \times a_3}{2 \times 3} =&gt; a_1 \leq 3$。 因此，这道题就变得很好写了（ 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; void solve()&#123; int n; cin >> n; for(int i=1;i&lt;=n;i++) cin >> a[i]; vector&lt;int> ans(n + 1); ans[1] = 1; for(int i=2;i&lt;=n;i++)&#123; ans[i] = ans[i - 1]; if(a[i - ans[i]] > ans[i]) ans[i] ++; &#125; for(int i=1;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 想个半天，差点没看到给的序列不递减，淦 D. Counting Factorizations题意对于一个数 $m$，由算术基本定理可知，它可以分解为 $m=p_1^{e_1}\cdot p_2^{e_2}\cdot \ldots \cdot p_k^{e_k}$，现将所有底数和指数拿出来作为一个序列 $f(m) = {p_1, e_1, p_2, e_2, \ldots }$，定义如上。 现在，给定上述序列，长度为 $2n$，序列的顺序未知，输出所有可能的排序中，$m$ 的个数总和，$mod\ 998244353$。 思路特判首先，底数一定为不同的 $n$ 个质数，所以拿到数据后，我们应该先将所有不同的质数找出，若数量不够，直接输出 $0$。 指数的全排列问题否则，我们假设已经选好了 $n$ 个质数，来考虑一下指数怎么排。 这是一个含有重复数字的全排列问题，它有一个公式，套用在本题即为下面的称述： 我们定义 $b$ 为所有合数的数量的序列，遍历得到长度为 $s$，如 $2, 3, 4, 4$ 中，$s = 1, b_1 = 2$； 同理，$c$ 为所有质数的数量的序列，长度为 $t$； 考虑到有部分质数被拿走，作为了底数，所以部分 $c_i$ 会减少一定的值。因为底数不能重复，所以最多减少 $1$，我们定义 $c’$ 为所有质数扣去底数后的数量的序列； $ans = \frac{n!}{b_1!\:\:b_2!\ldots b_s!\:\:c’_1!\:\:c’_2!\ldots c’_t!}$ 那么，最后的答案即为所有 $ans$ 的和。 简化问题显然，$\frac{n!}{b_1!\:\:b_2!\ldots b_s!}$ 可以作为公因子提出，而剩余的数可以进行通分，提出 $\frac{1}{c_1!\:\:c_2!\ldots c_t!}$（注意这里是 $c$，不是 $c’$，能提出的原因是 $x! = x * (x - 1)!$），剩余的分子即为 $t$ 个数里面选 $n$ 个的所有组合的和，每个组合的值为其包含的元素的乘积。 因此，我们只需要在所有不同质数中挑选 $n$ 个，求出所选数字的乘积，最后所有不同选择算得的乘积总和乘上之前提出的公因子即为答案。 当然，我们可以递归枚举，但是这样复杂度未免太高了。 如何递推所有乘积的式子的元素顺序是不影响答案的，所以我们不妨按照序列的顺序将每个式子的元素排序。 如对于下面的序列，我们希望从这 $5$ 个元素中选 $3$ 个： 1 2 3 5 4 因为我们确定了元素的顺序，所以我们不妨来考虑一个特定的元素：$5$。 对于一个乘积式子 $? \times ? \times ?$，我们将第三位填上 $5$，那么可以得到这些式子：$1 \times 2 \times 5 + 1 \times 3 \times 5 + 2 \times 3 \times 5$， 也就是 $(1 \times 2 + 1 \times 3 + 2 \times 3) \times 5$。 也就是说，前面两项的选择只和 $5$ 前面的数有关。 我们还可以将上面的式子提取一下：$(1 \times 2 + (1 + 2) \times 3) \times 5$。 这时，$3$ 来到了第二位，它的结果和 $5$ 的运算大同小异。 而对于类似于 $1$ 在第 $3$ 项的情况，我们可以假想地在序列前加上几个 $0$，这样对结果毫无影响，但却让 $1$ 出现在了 $[1, n]$ 的每一位。 事实上，我们可以加上含 $0$ 的若干项，使所有数字均在 $[1, n]$ 的每一位出现，而如果这样，那么我们可以枚举每一个数字位于哪一位，然后将 上一位 的 前 $x - 1$ 个选择 所得的答案乘上这个数字，得到 前 $x$ 位的 前 $x$ 个选择的乘积。 显然，我们还需要加上不选这个数字的情况，也就是前一个数字的前 $x$ 个选择所推得的答案。 因而，上述思路可以用二维 $dp$ 实现，$dp[i][j]$ 表示前 $i$ 个数的前 $j$ 个选择的推算结果。 关于 $dp$ 部分，本思路正反递推都是可行的，下面给出正向递推的状态转移方程： $dp[i][j] = dp[i][j] + dp[i - 1][j - 1] \times c[i]$ 其中，$c$ 为所有不同的质数的数量的序列，下标从 $1$ 开始。 优化复杂度阶乘和阶乘逆元可以预处理得到，而质数的判断可以使用线性筛（欧拉筛），求逆元的话可以线性递推也可以快速幂。 时间复杂度：常数有点大的$O(n ^ 2)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; bool vis[N], is[N]; int pri[N], cnt; int fact[N], fact_inv[N]; int qp(int a, int b)&#123; int ans = 1; while(b > 0)&#123; if(b &amp; 1) ans = ((ans % mod) * (a % mod)) % mod; a = ((a % mod) * (a % mod)) % mod; b >>= 1; &#125; return ans; &#125; void init() &#123; for (int i = 2; i &lt;= 1e6; ++i) &#123; if (!vis[i]) &#123; pri[cnt++] = i; is[i] = true; &#125; for (int j = 0; j &lt; cnt; ++j) &#123; if (1ll * i * pri[j] > 1e6) break; vis[i * pri[j]] = true; if (i % pri[j] == 0) break; &#125; &#125; fact[0] = fact_inv[0] = 1; for(int i=1;i&lt;=1e6;i++)&#123; fact[i] = ((fact[i - 1] % mod) * (i % mod)) % mod; fact_inv[i] = qp(fact[i], mod - 2); &#125; &#125; void solve() &#123; int n; cin >> n; vector&lt;int> in(2 * n); map&lt;int, int> tot; for (int i = 0; i &lt; 2 * n; i++) &#123; cin >> in[i]; tot[in[i]]++; &#125; vector&lt;int> c; int el = fact[n]; for(auto e : tot)&#123; if (is[e.first]) c.emplace_back(e.second); el = ((el % mod) * (fact_inv[e.second] % mod)) % mod; &#125; if (c.size() &lt; n) &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; vector&lt;vector&lt;int>> dp(c.size() + 1, vector&lt;int>(n + 1, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= c.size(); i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; dp[i][j] = dp[i - 1][j]; if (j > 0) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * c[i - 1]) % mod; //这里的c初始下标是0 &#125; &#125; cout &lt;&lt; (el * dp[c.size()][n]) % mod &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 我人似了]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 855 Div 3</title>
    <url>/blog/posts/3115409144/</url>
    <content><![CDATA[Contestant(alt). Rank 3678. Rating +62(+262 -200). A. Is It a Cat?题意给定一个字符串，转化为小写字母后，判断其是否由 $m, e, o, w$ 组成，四个字母可以出现重复多个，但顺序不能改变，且每一个字母必须出现至少一次。如 $MeOooOW$。 思路如题，我们只需用一个变量存储当前遍历到了哪个字母，若比较到某一个字母的时候，遍历的下标越界，那么输出 $NO$。否则，在最后判断一下四个字母是否都出现了至少一次，若满足那么 $YES$，否则 $NO$。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int tp = 0; char up[4] = &#123;'M', 'E', 'O', 'W'&#125;, lo[4] = &#123;'m', 'e', 'o', 'w'&#125;; bool ok[4] = &#123;false&#125;; bool f = true; for(int i=0;i&lt;n;i++)&#123; while(tp &lt; 4 &amp;&amp; s[i] != up[tp] &amp;&amp; s[i] != lo[tp]) tp ++; if(tp >= 4)&#123; f = false; break; &#125; ok[tp] = true; &#125; cout &lt;&lt; (ok[0] &amp;&amp; ok[1] &amp;&amp; ok[2] &amp;&amp; ok[3] &amp;&amp; f ? "YES\n" : "NO\n"); &#125; &#125; 瞎模拟即可 B. Count the Number of Pairs题意给定一个字符串以及一个整数 $k$，规定同一个字母的大写和小写可以进行配对，一个字符只能出现在一对数中。定义一次操作为选择一个字符改变它的大小写，输出在小于等于 $k$ 次的操作后，最多有多少对数。 思路我们用两个数组解决这个问题： 令小写字母对应权值为 $1$，大写字母对应权值为 $-1$，那么加权后每种字母的总和的绝对值可以表征配对了多少对。我们记它为 $abs(ans[i])$。 统计每一种数出现的次数 $cnt[i]$。 那么，在不进行操作的前提下，我们易得最后的答案为 $\sum \frac{(cnt[i] - abs(ans[i])}{2}$。 若可以进行操作，那么对于一个字母剩余的数 $ans[i]$，我们可以配对 $\frac{ans[i]}{2}$ 个。 因此，最后的答案即为 $\sum \frac{(cnt[i] - abs(ans[i])}{2} + min(k, \sum \frac{ans[i]}{2})$。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n, k; cin >> n >> k; string s; cin >> s; int cnt[26]&#123;&#125;, ans[26]&#123;&#125;; for(int i=0;i&lt;n;i++)&#123; if(s[i] >= 'a' &amp;&amp; s[i] &lt;= 'z') &#123; cnt[s[i] - 'a'] ++; ans[s[i] - 'a'] ++; &#125;else&#123; cnt[s[i] - 'A'] ++; ans[s[i] - 'A'] --; &#125; &#125; int res = 0, left = 0; for(int i=0;i&lt;26;i++)&#123; res += (cnt[i] - abs(ans[i])) / 2; left += abs(ans[i]) / 2; &#125; cout &lt;&lt; res + min(k, left) &lt;&lt; '\n'; &#125; &#125; 总感觉类似的题哪里做过 C1. Powering the Hero (easy version) 详见C2，区别是C1的数据量更小一点 C2. Powering the Hero (hard version)题意给定 $n$ 个卡牌对应的数字，从前向后遍历，若数字不为 $0$，那么可以选择是否将该数放在堆顶，或者将其丢弃。对于所有为 $0$ 的数字，从堆顶拿出一个牌作为这个 $0$ 的加分值，并将这两个牌丢弃，若堆为空则不考虑。输出最后加分的最大值。 思路既然可以选择放或不放，那么我们一定可以让后面的 $cnt$ 个 $0$ 拿到前面的前 $cnt$ 大的数。 因而，我们直接用优先队列即可。 有趣的是，困难版的数据量也无碍。 时间复杂度：最坏$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; priority_queue&lt;int> q; int ans = 0; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; if(cur != 0) q.push(cur); else if(!q.empty()) ans += q.top(), q.pop(); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 赛时贪错了，吃了WA D. Remove Two Letters题意给定一个字符串，输出去掉连续的两个字母后，得到的所有字符串中不同的字符串的个数。 思路我们不妨取补集： 对于一个序列，若要出现重复的子串，那么需要满足 $s[i] == s[i + 2]$，这样的话，去掉 $s[i], s[i + 1]$ 和去掉 $s[i + 1], s[i + 2]$ 就是等价的了。 因而，我们统计出对数，用 $n - 1$ 减去即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int ans = 0, cnt = 1; char pre0 = s[0], pre1 = s[1]; for(int i=1;i&lt;n-1;i++)&#123; char cur0 = s[i], cur1 = s[i + 1]; if((pre0 == cur0 &amp;&amp; pre1 == cur1) || pre0 == cur1 &amp;&amp; pre1 == cur0)&#123; cnt ++; &#125;else&#123; ans += cnt - 1; cnt = 1; pre0 = cur0, pre1 = cur1; &#125; &#125; cout &lt;&lt; n - (ans + cnt - 1) - 1 &lt;&lt; '\n'; &#125; &#125; 赛时的代码居然还写的麻烦了一点（（ E1. Unforgivable Curse (easy version) 详见E2，区别是本题k=3 E2. Unforgivable Curse (hard version)题意给定两个长度相等的字符串 $s, t$，定义操作为交换 $i, i + k$ 或 $i, i + k + 1$ 上的数，在任意数量的操作后，输出是否可以将 $s$ 更改为 $t$。 思路首先，我们只需进行下面的操作即可将相邻数交换： $i, i + k + 1$ $i + k + 1, i + 1$ $i, i + k + 1$ 因而，只要可以进行上面的操作（或者向左），那么我们只需进行一定的操作，肯定可以将其换到我们需要的为止。 那么，我们也不难发现，若要向右交换，那么 $i &gt; k - n$，若要想左交换，那么 $i &lt; k$。 因而，只要 $[k, k - n]$ 内的字符相等，就一定有解。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; void solve()&#123; int n, k; cin >> n >> k; string s, t; cin >> s >> t; if(n &lt;= k) cout &lt;&lt; (s == t ? "YES\n" : "NO\n"); else&#123; bool f = true; if(2 * k > n)&#123; for(int i=n-k;i&lt;k;i++) if(s[i] != t[i]) f = false; &#125; if(f)&#123; sort(s.begin(), s.end()); sort(t.begin(), t.end()); f = s == t; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 比赛快结束的时候就懒得写了（其实还挺好写的 F. Dasha and Nightmares题意给定 $n$ 个字符串，输出有多少对字符串，满足下面的条件： 两个字符串的长度总和为奇数； 不同字母的个数为 $25$； 每种字母出现的次数为奇数。 思路首先，第一个条件可以忽略，因为偶数个奇数相加，一定是奇数。 其次，第二个条件即为排除掉一个字母，需要其余的字母均出现。 考虑到 $25$ 足够小，我们不妨用状压。 更具体地说，我们枚举不出现的字母 $x$，然后枚举所有字符串，对于字符串 $s_i$，它的所有字母的出现次数均可以预处理。但，因为我们只需考虑奇偶性，所以我们不妨令奇数状态为 $1$，偶数状态为 $0$，按照字母表顺序构建一个 $26$ 位二进制字符串，便可以得到这个字符串的”哈希”值。 那么，考虑到异或的可逆性，对于一个排除掉 $x$ 的拼接后的字符串，它的哈希值一定为形如 $111…0…111$，$0$ 位即为 $x$。那么，对于这个 $p = (1 &lt;&lt; 26)\ XOR\ (1 &lt;&lt; x)$，我们可以将其和 $s_i$ 的哈希值进行异或，得到需要和其配对的字符串的哈希值。 显然，对于第 $i$ 个字符串，我们只需遍历前 $i - 1$ 个字符串是否可以与其配对即可。那么，我们可以用 $map$ 存储一个哈希值对应的字符串有多少个，最后统计总和即可。 时间复杂度：$O(25n + m) = 1e7$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int odd[N], num[N]; void solve()&#123; int n; cin >> n; for(int i=0;i&lt;n;i++)&#123; string cur; cin >> cur; for(char e : cur)&#123; odd[i] ^= (1 &lt;&lt; (e - 'a')); num[i] |= (1 &lt;&lt; (e - 'a')); &#125; &#125; int ans = 0; for(int i=0;i&lt;26;i++)&#123; //不选i map&lt;int, int> cnt; int tot = ((1 &lt;&lt; 26) - 1) ^ (1 &lt;&lt; i); for(int j=0;j&lt;n;j++)&#123; if(!(num[j] &amp; (1 &lt;&lt; i)))&#123; ans += cnt[tot ^ odd[j]]; cnt[odd[j]] ++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t = 1; //cin >> t; while(t --) solve(); &#125; 我好若，居然想不到状压]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 144</title>
    <url>/blog/posts/1514977487/</url>
    <content><![CDATA[Contestant. Rank 1837. Rating +17. 开局天崩场 A. Typical Interview Problem题意对于一个数字，如果它是 $3$ 的倍数，那么它映射到字符串 $F$，如果它是 $5$ 的倍数，那么映射到 $B$，如果是 $15$ 的倍数，那么映射到 $FB$，否则映射到空字符串。给定一个字符串，输出它是否是一段连续区间内对应数字映射后拼接而成的。 思路显然，$15$ 一循环，且给定的字符串长度只有 $10$，所以我们只需暴力匹配即可。 有趣的是，$FB$ 拆开不影响答案。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0) &#123; int n = console.nextInt(); String s = "FBFFFBFFBFFBFBFFBFFBBFFBFBFFBFFB"; String x = console.next(); console.print(s.contains(x) ? "YES\n" : "NO\n"); &#125; console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; s开小了，倒大霉了属于是 B. Asterisk-Minor Template题意给定两个字符串，构造出一个模板，模板由 ‘*‘ 和字母组成，通配符 ‘*‘ 可以匹配自然数个任意字母。输出是否存在一种模板，使通配符的数量小于等于字母的数量。若存在，输出这个模板。 思路要满足题给条件，那么模板一定需要存在两个连续的字母。考虑到可以任意匹配，我们不妨只找出一对字母，在两个字符串中均出现，如 $ab$ 在 $aabc, xxxabz$ 中均出现，那么就可以在两边加上通配符，如构建为 *$ab$*。 当然，只要开头或结尾一样，一个字母加上一个通配符即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; string a, b; cin >> a >> b; if(a[0] == b[0]) cout &lt;&lt; "YES\n" &lt;&lt; a[0] &lt;&lt; '*' &lt;&lt; '\n'; else if(a[a.size() - 1] == b[b.size() - 1]) cout &lt;&lt; "YES\n" &lt;&lt; '*' &lt;&lt; a[a.size() - 1] &lt;&lt; '\n'; else&#123; bool f = false; for(int i=0;i&lt;a.size() - 1;i++)&#123; for(int j=0;j&lt;b.size() - 1;j++)&#123; if(a[i] == b[j] &amp;&amp; a[i + 1] == b[j + 1])&#123; cout &lt;&lt; "YES\n" &lt;&lt; '*' &lt;&lt; a[i] &lt;&lt; a[i + 1] &lt;&lt; '*' &lt;&lt; '\n'; f = true; break; &#125; &#125; if(f) break; &#125; if(!f) cout &lt;&lt; "NO\n"; &#125; &#125; &#125; 贪心一下~ C. Maximum Set题意给定两个整数 $l, r$，在 $[l, r]$ 内找一个递增不重复序列，满足相邻数可整除。输出序列的最大数量，以及该数量的方案数。方案数 $mod\ 998244353$。 思路首先，要让数量最多，且能整除，那么我们不妨将左端点循环乘二，得到一个不超过右端点的最大数，此时乘二的数量就是序列的最大数量 $- 1$。 更简洁地看，我们将上述过程转化为一个表达式：$l \times 2 \times 2 \times \ldots \times 2 = x\leq r$。 那么，显然 $\frac{r}{x}$ 是小于 $2$ 的，所以若要让某个倍数变大，即选择一个 $2$ 将其变大，那么我们只能将其改成 $3$。 那么，整道题就可以变为遍历所有满足上述表达式的 $l$，判断 $\frac{r}{x}$ 和 $1.5$ 的大小关系，若前者大，那么对于这个左边界，我们可以得到 $cnt_2$ 个方案，否则只有一个方案。 上述思路的复杂度较高，考虑到推算较为简单，我们不妨直接推导式子： 设 $\frac{x}{l} = p$，那么 $l’p \leq r$ 即 $l \leq l’ \leq \frac{r}{p}$。 同理，$l \leq l’’ \leq \frac{2r}{3p}$ 那么，答案即为 $(l’’ - l + 1) \times cnt + (l’ - l’’)$ 当然，我们也可以二分，问题不大（（ 时间复杂度：一般般 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); long mod = 998244353; long t = console.nextInt(); nxt: while(t -- > 0) &#123; long n = console.nextInt(), m = console.nextInt(); long x = n, ans1 = 1, p = 1; while(true)&#123; if(x * 2 > m) break; x *= 2; ans1 ++; p = (p * 2) % mod; &#125; boolean ok = false; long l1 = (long) Math.max(n - 1, (double) m * 2 / 3 / p), l2 = Math.max(l1 - 1, m / p); long ans2 = (((l1 - n + 1) * ans1 % mod) + (l2 - l1) % mod) % mod; console.print(ans1 + " " + ans2 + "\n"); &#125; console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; 暴力枚举左端点的铸币竟是我自己]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 854 Div 1 plus 2</title>
    <url>/blog/posts/2715179373/</url>
    <content><![CDATA[Contestant(alt). Rank 4431. Rating -40 (+310 -350). A. Recent Actions题意给定一个整数 $n$，以及 $n$ 的排列，给定 $m$ 个大于 $n$ 的数，若这个数不在序列里，那么将整个序列右移一位，删去多出的元素，并将第一个空位放入该数。输出原排列的每一个数在第几个数放入的时候被移除。 思路直接用 $map$ 或者数组存一下是否在序列里即可，然后统计即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n, m; cin >> n >> m; map&lt;int, bool> st; vector&lt;int> ans(n, -1); int r = n - 1; for(int i=0;i&lt;m;i++)&#123; int cur; cin >> cur; if(!st[cur] &amp;&amp; r >= 0)&#123; ans[r] = i + 1; r --; &#125; st[cur] = true; &#125; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; 题目怎么那么绕 B. Equalize by Divide题意给定一个数组 $a$，所有数均为正数，定义操作为选择两个不同的下标 $i, j$，将 $a_i$ 改为 $\lceil \frac{a_i}{a_j} \rceil$。输出一种方案，使所有数相等。若无方案输出无解。 思路首先，我们不可能将所有数都变为 $1$，除非原来就全是 $1$。所以我们不妨先特判是否所有数都相等，若都相等那么无需操作，否则，若数组中含有 $1$，就为无解。 否则，我们只需避免产生 $1$ 即可，也就是用当前序列的最小值将所有数除到比最小值小或者等于为止。 上述做法可以保证最后的答案一定是有解的，若第一次操作可以构建出一个 $[min, min, …, min]$ 的数组，那么就无需操作，否则最后的结果一定是 $[2, 2, …, 2]$。 时间复杂度：有点复杂 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++)cin >> a[i]; vector&lt;pii> ans(30 * n); int size = 0; bool h = true; while(true)&#123; bool f = false, have1 = false; int pre = -1, mn = 0; for(int i=0;i&lt;n;i++)&#123; if(pre == -1) pre = a[i]; if(pre != a[i]) f = true; if(a[i] == 1) have1 = true; if(a[mn] > a[i]) mn = i; &#125; if(!f) break; if(have1)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; h = false; break; &#125; for(int i=0;i&lt;n;i++)&#123; while(a[i] != a[mn])&#123; if(a[i] > a[mn])&#123; ans[size ++] = &#123;i, mn&#125;; a[i] = ceil((double) a[i] / (double) a[mn]); &#125;else&#123; ans[size ++] = &#123;mn, i&#125;; a[mn] = ceil((double) a[mn] / (double) a[i]); &#125; &#125; &#125; &#125; if(h) &#123; cout &lt;&lt; size &lt;&lt; '\n'; for (int i = 0; i &lt; size; i++) &#123; auto e = ans[i]; cout &lt;&lt; e.first + 1 &lt;&lt; ' ' &lt;&lt; e.second + 1 &lt;&lt; '\n'; &#125; &#125; &#125; &#125; 想到了一半，没想到这么暴力（（ C. Double Lexicographically Minimum 待补充 D1. Hot Start Up (easy version)题意给定两个 $CPU$，以及 $n$ 个程序的热启动和冷启动时间，当同一种程序连续运行的时候，第二次启动称为热启动，热启动时间低于冷启动。找出一种方案，使最后运行结束每个程序所用时间总和最短，并输出最短时间。 思路首先，考虑到递推关系，我们不妨考虑用 $dp$ 的方式。 最朴素的做法我们不妨建立一个二维 $dp$，$dp[i][j]$ 表示最后一次操作后第一个 $CPU$ 运行了程序 $i$，第二个 $CPU$ 运行了程序 $j$。 那么显然，最后的答案就是 $min(dp[i][a[n]])$ 或者 $min(dp[a[n]][j])$。 如何递推呢？对于一个新元素 $x$，以及任意一个 $CPU$（如第一块），它可以由两种情况推得： 上一个数和它不同，那么它将成为冷启动，我们遍历所有 $i \neq x$ 和 $j$，将 $dp[x][j]$ 更新为 $min(dp[i][j] + c[x])$。 上一个数和它相同，他么它将成为热启动，我们遍历所有 $j$，将 $dp[x][j]$ 更新为 $min(dp[x][j] + h[x])$。 时间复杂度：$O(n k ^ 2)$ 对应TLE代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e3 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; int a[N], h[N], c[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n, k; cin >> n >> k; for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=1;i&lt;=k;i++) cin >> c[i]; for(int i=1;i&lt;=k;i++) cin >> h[i]; vector&lt;vector&lt;int>> dp(k + 1, vector&lt;int>(k + 1)); for(int i=0;i&lt;=k;i++) for(int j=0;j&lt;=k;j++) dp[i][j] = inf; dp[0][0] = 0; for(int x=1;x&lt;=n;x++)&#123; vector&lt;vector&lt;int>> tmp(k + 1, vector&lt;int>(k + 1, inf)); for(int i=0;i&lt;=k;i++)&#123; if(i == a[x]) continue; for(int j=0;j&lt;=k;j++) tmp[a[x]][j] = min(tmp[a[x]][j], dp[i][j] + c[a[x]]); &#125; for(int j=0;j&lt;=k;j++) tmp[a[x]][j] = min(tmp[a[x]][j], dp[a[x]][j] + h[a[x]]); for(int j=0;j&lt;=k;j++)&#123; if(j == a[x]) continue; for(int i=0;i&lt;=k;i++) tmp[i][a[x]] = min(tmp[i][a[x]], dp[i][j] + c[a[x]]); &#125; for(int i=0;i&lt;=k;i++) tmp[i][a[x]] = min(tmp[i][a[x]], dp[i][a[x]] + h[a[x]]); dp = tmp; &#125; int ans = inf; for(int j=0;j&lt;=k;j++)&#123; if(j == a[n]) continue; ans = min(ans, dp[j][a[n]]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; Time limit exceed on test 3. 对朴素的优化显然，上述复杂度过高，我们希望能找出一种 $O(n)$ 的递推方法。 对于上述操作，我们并没有考虑哪个元素一定要放到哪个 $CPU$ 上去，也就是说它和 $CPU$ 并不绑定。 那么，我们不妨用下标记录一个 $CPU$ 的情况，另一个用 $dp$ 来递推。 更具体地说，我们可以记录一下上一次上个 $CPU$ 放了什么 ($pre$)，然后对于新加入的数 $x$，它可以由下面两种情况推算： $pre \neq x$，那么作为冷启动，它的状态可以由所有 $i \neq x, dp[i] + c[x]$ 推得，当然，我们需要顺便更新 $dp[i]$ 的值，这和朴素的做法一致。考虑到可以放置在不同的 $CPU$ 上，所以热启动依然可行，我们将 $dp[pre]$ 更新为其与 $dp[x] + h[x]$ 的最小值。最后，我们将 $pre$ 改为 $x$。 $pre = x$，那么和上述相同的是，依然存在冷热启动，只是在更新 $dp[i]$ 的时候，它可以热启动罢了。 时间复杂度：$O(nk)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e3 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; int a[N], h[N], c[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n, k; cin >> n >> k; for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=1;i&lt;=k;i++) cin >> c[i]; for(int i=1;i&lt;=k;i++) cin >> h[i]; vector&lt;int> dp(k + 1); for(int i=1;i&lt;=k;i++) dp[i] = inf; int pre = 0; for(int p=1;p&lt;=n;p++)&#123; int x = a[p]; vector&lt;int> tmp(k + 1, inf); if(x == pre)&#123; for(int i=0;i&lt;=k;i++)&#123; tmp[i] = min(tmp[i], dp[i] + h[x]); if(i != x) tmp[x] = min(tmp[x], dp[i] + c[x]); &#125; tmp[x] = min(tmp[x], dp[x] + h[x]); &#125;else&#123; for(int i=0;i&lt;=k;i++)&#123; tmp[i] = min(tmp[i], dp[i] + c[x]); if(i != x) tmp[pre] = min(tmp[pre], dp[i] + c[x]); &#125; tmp[pre] = min(tmp[pre], dp[x] + h[x]); pre = x; &#125; dp = tmp; &#125; int ans = inf; for(int i=0;i&lt;=k;i++) ans = min(ans, dp[i]); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 好难解释….]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 138</title>
    <url>/blog/posts/482042403/</url>
    <content><![CDATA[Practice. A. Cowardly Rooks题意给定 $n$ 个点的横纵坐标，输出是否可以将任意一个点移动，使每一行每一列都只有最多一个点。 思路我们可以先将原来的所有点对应的横坐标和纵坐标对应的行和列进行统计，之后若能找出任意一行或者任意一列没有点，那么就可以移动到那里去。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e3 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n, m; cin >> n >> m; int r[10]&#123;&#125;, c[10]&#123;&#125;; bool f = false; for(int i=0;i&lt;m;i++) &#123; int a, b; cin >> a >> b; r[a]++, c[b]++; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(r[i] == 0 || c[j] == 0)&#123; f = true; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; 给的代码写得略微麻烦了点（ B. Death’s Blessing题意给定 $n$ 个怪物的血量和能力 $a_i, b_i$，在干掉一个怪物的时候，该怪物将会把相邻的怪物的血量加上它的能力，怪物死亡后从序列中移除，第一个和最后一个怪物只有一个相邻的怪物。输出将所有怪物干掉需要扣除的血量最大值。 思路首先，答案可以拆分成原来所有怪物的血量和加上外加的血量，外加的血量只和操作顺序有关，所以我们可以试试贪心： 既然两侧的怪物能附加的血量只会影响到一个怪物，那么我们可以贪心地从两侧开始打，但这不够，考虑到只剩一个怪物的时候，这个怪物无法再将自己的能力附加到其他怪物上，所以我们可以将能力值最大的怪物放到最后。 可以很容易证明上述贪心思想成立。 时间复杂度：$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e3 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; int ans = 0; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; ans += cur; &#125; vector&lt;int> b(n); for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; b[i] = cur; ans += b[i]; &#125; sort(b.begin(), b.end()); cout &lt;&lt; ans - b[n - 1] &lt;&lt; '\n'; &#125; &#125; 简单的贪心捏 C. Number Game题意给定一个数组 $a$，选择任意回合数 $k$，在第 $i$ 个回合，$A$ 需要找出一个小于等于 $k - i + 1$ 的数，并将其删去，之后 $B$ 选择任意一个数，将其加上 $k - i + 1$。在两个人足够聪明的条件下，输出最大的 $k$，满足不存在某一个回合，数组不为空但 $A$ 无法删除。 思路显然，既然要让 $A$ 寄，那么 $B$ 一定会将当前的最小值加上 $k - i + 1$，因为所加的值是递减的。 考虑到数据范围特别小，我们不妨在每一局结束的时候将整个新数组排个序。 对于一个回合，我们可以用二分的方法，快速找出第一个大于 $k - i + 1$ 的数并将其前面一个数删去，也就是在每次操作时删去最大数，这样可以尽可能删除多一点的数。然后，将第一个数加上 $k - i + 1$ 即可。 数据量太小了，可以二分答案 $k$，也可以直接暴力枚举。 时间复杂度：$O(n^2 + n^2 log n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int k=n;k>=0;k--)&#123; vector&lt;int> tmp(a); sort(tmp.begin(), tmp.end()); bool f = true; for(int i=1;i&lt;=k;i++)&#123; int p = upper_bound(tmp.begin(), tmp.end(), k - i + 1) - tmp.begin(); if(p == 0) &#123; f = false; break; &#125; tmp[p - 1] = inf; tmp[0] += k - i + 1; sort(tmp.begin(), tmp.end()); &#125; if(f)&#123; cout &lt;&lt; k &lt;&lt; '\n'; break; &#125; &#125; &#125; &#125; 无脑暴力.jpg]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 829 Div 2</title>
    <url>/blog/posts/64163075/</url>
    <content><![CDATA[Practice. A. Technical Support题意给定一个由 $Q, A$ 组成的字符串，对于所有 $Q$，判断在下一次 $Q$ 出现或遍历到结束前，是否有至少一个 $A$ 与之对应。 思路如题，配对即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; string s; cin >> s; int cnt = 0; for(char e : s) &#123; cnt += e == 'Q' ? 1 : -1; if(cnt &lt; 0) cnt = 0; &#125; cout &lt;&lt; (cnt == 0 ? "Yes\n" : "No\n"); &#125; &#125; 别看错题（（ B. Kevin and Permutation题意给定整数 $n$，构建一个 $n$ 的排列，使相邻数的差值的最小值最大。 思路想要尽量让差值最大，那么我们只有相间地输出，或者说，若我们按 $\frac{n}{2} + i, i$ 的规律输出，就可以让所有差值尽量相等。 可以贪心地认为上述的思路是正确的，解法不唯一。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; for(int i=1;i&lt;=n/2;i++)&#123; cout &lt;&lt; n / 2 + i &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' '; &#125; if(n % 2 == 1) cout &lt;&lt; n; cout &lt;&lt; '\n'; &#125; &#125; 找规律+乱贪.jpg C1. Make Nonzero Sum (easy version) 详见C2，区别是C1给定的数组没有0 C2. Make Nonzero Sum (hard version)题意给定一个由 $-1, 0, 1$ 构成的数组，将数组分为任意若干段，相邻两段的左段右边界和右段左边界相差 $1$。输出是否存在一种分段，将所有段相间赋上运算符号 $+, -, +, - ,…$ 后，所有段的运算总和为 $0$。若存在，输出方案。 思路首先，我们不考虑运算符号的时候，将所有数加起来会得到一个结果 $ans$，若 $ans = 0$，那么我们只需将所有单个元素单独成段就可以无视运算符号了。否则，因为考虑到加减是一样的，我们不妨来考虑 $ans &gt; 0$ 的情况： 显然，若要让 $ans$ 减小，我们就只能让某一个 $1$ 和左相邻的数组合为一段，那么，整个 $ans$ 将会减少 $2$。可以发现，我们无法将 $ans$ 减少奇数值，所以我们可以先判断 $ans$ 的奇偶性。在运算的时候，需要变号的时候，变号的数一定但也只要让这个数位于某一段的偶数下标，所以，我们只需找两个相邻数，其中第一个数不需要变号，第二个数需要变号，那么将这两个数作为一段即可。 所以我们只需将 $1$ 全部找出，判断能找出多少对上述相邻数，和 $ans / 2$ 比较即可。 有趣的是，这种解法不用考虑是否包含 $0$。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; int ans = 0; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; ans += a[i]; &#125; if(abs(ans) % 2 == 1) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; int r = 0; vector&lt;pii> out; int left = ans / 2; if(left != 0) &#123; int x = left / abs(left); r = 1; for (int i = 1; i &lt; n; i++) &#123; if (a[i + 1] == x) &#123; out.emplace_back(i, i + 1); r = i + 1; i++; left -= x; if (left == 0) break; &#125; else &#123; out.emplace_back(i, i); r = i; &#125; &#125; &#125; for(int i=r+1;i&lt;=n;i++) out.emplace_back(i, i); if(left != 0) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; cout &lt;&lt; out.size() &lt;&lt; '\n'; for(auto e : out) cout &lt;&lt; e.first &lt;&lt; ' ' &lt;&lt; e.second &lt;&lt; '\n'; &#125; &#125; &#125; &#125; 想了半天不小心把两个难度一起做了（（]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 830 Div 2</title>
    <url>/blog/posts/1524713550/</url>
    <content><![CDATA[Practice. A. Bestie题意给定一个数组 $a$，定义操作为将 $a_i$ 改为 $gcd(a_i, i)$，代价为 $n - i + 1$，输出最小的操作代价总和，使所有数的最大公约数为 $1$。 思路首先，这里有一个结论：相邻数字的最大公约数一定为 $1$。 所以，最多只需两次操作，即可满足题意。 所以，我们只需考虑 $n$ 和 $n - 1$ 对应的元素是否需要进行操作，以及对应的代价总和的最小值。 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], b[N]; int gcd(int x, int y) &#123; while (y != 0) &#123; int tmp = x; x = y; y = tmp % y; &#125; return x; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) &#123; int n; cin >> n; int g = 0; for (int i = 1; i &lt;= n; i++) &#123; cin >> a[i]; g = gcd(g, a[i]); &#125; if (g == 1) cout &lt;&lt; 0 &lt;&lt; '\n'; else if (gcd(g, n) == 1) cout &lt;&lt; 1 &lt;&lt; '\n'; else if (gcd(g, n - 1) == 1) cout &lt;&lt; 2 &lt;&lt; '\n'; else cout &lt;&lt; 3 &lt;&lt; '\n'; &#125; &#125; 这结论一开始还真没想到… B. Ugu题意给定一个二进制字符串，定义操作为选定一个整数 $i$，将 $[i, n]$ 内的数全都取反，输出让整个字符串变为不递减的操作数的最小值。 思路考虑下面的模拟： $\begin{array}{l}&gt;&gt;01011001011 \ =&gt; 01100110100 \ =&gt; 01111001011 \ =&gt; 01111110100 \ =&gt; 01111111011 \ =&gt; 01111111100 \ =&gt; 01111111111\end{array}$ 也就是说，我们只考虑拐点，统计拐点个数即可。 当然，需要根据第一个数的情况来扣去 $1$ 或 $2$。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], b[N]; int gcd(int x, int y) &#123; while (y != 0) &#123; int tmp = x; x = y; y = tmp % y; &#125; return x; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) &#123; int n; cin >> n; string s; cin >> s; char pre = -1; int dif = 0; for(int i=0;i&lt;n;i++)&#123; if(pre == -1) pre = s[i]; else&#123; if(pre != s[i]) dif ++; pre = s[i]; &#125; &#125; dif ++; cout &lt;&lt; max(0ll, dif - (s[0] == '1' ? 1 : 2)) &lt;&lt; '\n'; &#125; &#125; 就这么模拟嘞 C1. Sheikh (Easy version)题意给定一个数组 $a$，定义子区间 $[l, r]$ 的代价 $f(l, r)$ 为总和和所有数异或值的差。对于 $q = 1$ 个询问，输出询问的 $[L, R]$ 内的子区间的代价最大值，以及对应的最短区间。 思路首先，对于一段区间，我们加上一个值 $x$，那么总和会改变 $x$，而异或值改变量不会超过 $x$，也就是说，$f(l, r) \leq f(l, r + 1)$。 因而，代价最大值一定是 $f(L, R)$，我们只需找出最短区间即可。 因为本题 $easy$ 难度的数据量低，所以我们不妨直接二分长度，然后枚举所有可行解即可。 使用前缀和和前缀异或优化复杂度。 时间复杂度：$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], sum[N], xo[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) &#123; int n, q; cin >> n >> q; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; sum[i] = sum[i - 1] + a[i]; xo[i] = xo[i - 1] ^ a[i]; &#125; while(q --)&#123; int l, r; cin >> l >> r; int ans = (sum[r] - sum[l - 1]) - (xo[r] ^ xo[l - 1]); int L = 1, R = r - l + 1, mid; int ansL = l, ansR = r; while(L &lt; R)&#123; mid = (L + R) >> 1; bool f = false; for(int i=l;i+mid-1&lt;=r;i++)&#123; if((sum[i+mid-1] - sum[i - 1]) - (xo[i+mid-1] ^ xo[i - 1]) == ans) &#123; if(mid &lt; ansR - ansL + 1)&#123; ansL = i, ansR = i + mid - 1; f = true; &#125; &#125; &#125; if(f) R = mid; else L = mid + 1; &#125; cout &lt;&lt; ansL &lt;&lt; ' ' &lt;&lt; ansR &lt;&lt; '\n'; &#125; &#125; &#125; 想不到结论就寄 C2. Sheikh (Hard Version) 待补充 D. Balance (Easy version)题意给定一个初始情况下只有一个元素 $0$ 的序列，对于下述两种询问，进行对应的操作： $+\ x$：将 $x$ 加入序列，满足 $x$ 原先不在序列里； $?\ x$：输出第一个能被 $x$ 整除且不在序列里的数。 思路我们先来考虑纯暴力：对于加上某个数，标记一下这个数已加入；对于查询，暴力枚举其倍数，第一个未被标记的数即为答案。 因为数据量过大，我们考虑用 $map$。 纯暴力是不可行的，但我们可以略微优化一下：另开一个 $map$，记录这个数的下一个没有被标记的数是什么，若这个数是 $0$，那么就是这个数本身，输出即可。 因而，在每次输出的时候，我们可以预处理之后的查询，从而降低复杂度。 对于 $easy$ 难度，到此即可过。 时间复杂度：不好说 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; map&lt;int, bool> mp; map&lt;int, int> to; while(q --)&#123; char op; int num; cin >> op >> num; mp[0] = true; if(op == '+') &#123; mp[num] = true; &#125;else &#123; while(mp[to[num]]) to[num] += num; cout &lt;&lt; to[num] &lt;&lt; '\n'; &#125; &#125; &#125; 数据结构题挺少见 D2. Balance (Hard version)题意给定一个初始情况下只有一个元素 $0$ 的序列，对于下述两种询问，进行对应的操作： $+\ x$：将 $x$ 加入序列，满足 $x$ 原先不在序列里； $-\ x$：将 $x$ 从序列中删除，满足 $x$ 原先在序列里； $?\ x$：输出第一个能被 $x$ 整除且不在序列里的数。 思路我们可以继续之前的优化，但这里需要考虑删除数以后，该数的因数 是否已经将 其 下一个未被标记的数 标为大于等于 这个数 的值了。 也就是说，删除以后，我们需要更新这些因数。 暴力枚举因数是不可行的，但考虑到这些因数都是后来加进来的，所以我们可以在上一题输出优化部分，加上 下一个未被标记的数的原数字是什么（也就是它的因子）。然后，在加减操作的时候，我们不妨遍历我们之前记录下来的因子，标记一下这个因子对应原数字有没有被删去。 最后，我们只需按之前的操作，找出该数字下一个未被标记的数，然后判断这个数的倍数有没有已被删去的数，有的话两个数取最小值即可。 时间复杂度：有点小复杂 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; map&lt;int, bool> mp; map&lt;int, int> to; map&lt;int, set&lt;int>> vis, del; mp[0] = true; while(q --)&#123; char op; int num; cin >> op >> num; if(op == '+') &#123; for(auto &amp;i : vis[num]) del[i].erase(num); mp[num] = true; &#125;else if(op == '-')&#123; for(auto &amp;i : vis[num]) del[i].insert(num); mp[num] = false; &#125;else&#123; while(mp[to[num]]) vis[to[num]].insert(num), to[num] += num; cout &lt;&lt; min(to[num], del[num].empty() ? inf : *del[num].begin()) &lt;&lt; '\n'; &#125; &#125; &#125; 数据结构题挺少见，这种简短的题更少见（（]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 291</title>
    <url>/blog/posts/1674521260/</url>
    <content><![CDATA[Contestant. Rank 1877. Rating +196. A. camel Case题意给定一个由一个大写字母和若干个小写字母组成的字符串，输出大写字母的位置。 思路如题，很签到。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); string s; cin >> s; for(int i=0;i&lt;s.size();i++)&#123; if(s[0] >= 'A' &amp;&amp; s[i] &lt;= 'Z')&#123; cout &lt;&lt; i + 1 &lt;&lt; '\n'; break; &#125; &#125; &#125; 无聊的签到题 B. Trimmed Mean题意给定 $5N$ 个评委的分数，去掉最大 $N$ 个和最小 $N$ 个评委的分数，输出剩余分数的平均数。 思路如题，排个序即可。 时间复杂度：O(nlogn) 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n; cin >> n; for(int i=0;i&lt;5 * n;i++) cin >> a[i]; sort(a, a + 5 * n); double ans = 0; for(int i=n;i&lt;5*n-n;i++) ans += (double) a[i]; cout &lt;&lt; (ans / ((double) 3 * n)) &lt;&lt; '\n'; &#125; 差点看成只各去掉一个（（ C. LRUD Instructions 2题意给定一个由 $L,R,U,D$ 组成的字符串，模拟点的移动，$L$ 表示横坐标减一，$R$ 表示横坐标加一，$D$ 表示纵坐标减一，$U$ 表示纵坐标加一。输出有多少点被经过了至少两遍。 思路如题，模拟即可。 可以用 $map$ 存有没有经过，或者开一个布尔数组。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); map&lt;pii, bool> mp; int n; cin >> n; string s; cin >> s; pii p = &#123;0, 0&#125;; mp[p] = true; bool f = false; for(int i=0;i&lt;n;i++)&#123; char now = s[i]; if(now == 'L')&#123; p.first --; &#125;else if(now == 'R')&#123; p.first ++; &#125;else if(now == 'U')&#123; p.second ++; &#125;else p.second --; if(mp[p])&#123; f = true; break; &#125; mp[p] = true; &#125; cout &lt;&lt; (f ? "Yes\n" : "No\n"); &#125; 捏马的，忘了在走过以后设标记了（（ D. Flip Cards题意给定 $n$ 张牌，牌的正反两面各印有一个数字，输出整个牌组满足条件的正反情况，满足相邻牌值不相等。 思路考虑到只需满足相邻牌值不相等，所以我们不妨采用 $dp$ 的方式，定义一个 $dp[i][j]$ 表示第 $i$ 位及以前的牌满足第 $i$ 张牌的正反情况满足 $j$ 的情况总数，$j=0$ 表示向上，否则向下。 那么，对于一个位置，它有两种递推的方式——从上一个为正面的牌的情况数和从上一个为反面的牌的情况数。两个递推的方式的和即为当前位置的值。 如，如果不考虑相邻牌不相等，那么 $dp[i][0] = dp[i - 1][0] + dp[i - 1]][1], dp[i][1] = dp[i - 1][0] + dp[i - 1][1]$。 考虑条件的话，我们用 $if$ 判断即可。 当然，初始情况下 $dp[1][0] = dp[1][1] = 1$。 时间复杂度：$O(2n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int dp[N][2]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n; cin >> n; int lastA, lastB; cin >> lastA >> lastB; dp[1][0] = 1, dp[1][1] = 1; for(int i=2;i&lt;=n;i++)&#123; int nowA, nowB; cin >> nowA >> nowB; if(nowA != lastA) dp[i][0] = (dp[i][0] + dp[i - 1][0]) % mod; if(nowA != lastB) dp[i][0] = (dp[i][0] + dp[i - 1][1]) % mod; if(nowB != lastA) dp[i][1] = (dp[i][1] + dp[i - 1][0]) % mod; if(nowB != lastB) dp[i][1] = (dp[i][1] + dp[i - 1][1]) % mod; lastA = nowA, lastB = nowB; &#125; cout &lt;&lt; (dp[n][0] + dp[n][1]) % mod &lt;&lt; '\n'; &#125; 其实只有两个的话完全可以用两个变量来存，使空间复杂度降低很多 E. Find Permutation题意给定 $n$ 个点以及 $m$ 组可重复的大小关系 $Ai, B_i$，构建一个排列 $p$，对于所有条件，均满足 $p{Ai} &lt; p{B_i}$。输出是否能唯一确定这个排列，若能唯一确定，输出这个排列。 思路首先，我们可以一眼看出这是求拓扑序。那么，这道题唯一的障碍就是怎么排除无法唯一确定的点，因为如果成环了，拓扑排序会自动找出。 那么，我们来考虑每次读取队列的时候的情况： 考虑到拓扑排序的算法，我们会将每次遍历的时候，将入度为 $0$ 的点全都放入队列，那么只要出现多个入度为 $0$ 的点，那么就一定会出现如 $a -&gt; b, a -&gt; c, b ? c$ 的情况，此时直接判 $No$ 即可。 时间复杂度：$O(m)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int n, m; vector&lt;int> G[N]; int in[N]; // 存储每个结点的入度 void topSort() &#123; vector&lt;int> L; queue&lt;int> q; for (int i = 1; i &lt;= n; i++) if (in[i] == 0) q.push(i); if(q.size() > 1)&#123; cout &lt;&lt; "No\n"; return; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); L.push_back(u); for (auto v : G[u]) &#123; if (--in[v] == 0) &#123; q.push(v); &#125; &#125; if(q.size() > 1) &#123; cout &lt;&lt; "No\n"; return; &#125; &#125; if (L.size() == n) &#123; cout &lt;&lt; "Yes\n"; vector&lt;int> ans(n); for(int i=0;i&lt;n;i++)&#123; ans[L[i] - 1] = i + 1; &#125; for (auto i : ans) cout &lt;&lt; i &lt;&lt; ' '; &#125; else &#123; cout &lt;&lt; "No\n"; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); cin >> n >> m; map&lt;pii, bool> mp; for(int i=0;i&lt;m;i++)&#123; int x, y; cin >> x >> y; if(mp[&#123;x, y&#125;]) continue; G[x].emplace_back(y); in[y] ++; mp[&#123;x, y&#125;] = true; &#125; topSort(); &#125; 有一说一，为什么入读和出度的配对不可以用来判呢？ F. Teleporter and Closed off题意给定 $n$ 个长度为 $m$ 的字符串 $s$，若 $s_{i,j} = 1$，那么可以使用这个传送点，从第 $i$ 个城市传送到第 $i+j$ 个城市。输出对于第 $[2, n - 2]$ 个城市，从第一个城市到最后一个城市，满足跳过这个城市的路径使用的传送点的最少数量。 思路首先，对于第 $i$ 个城市，它的状态是从前一个传送点推过来的，存在递推性，所以我们可以用 $dp$ 来实现。 对于第 $k$ 个城市，若要跳过它，那么我们一定得从 $i=k-x+1$ 个城市传送到 $j = i + x$ 个城市，所以我们可以枚举 $i \in [k - m + 1, k - 1], j \in [k + 1, i + m]$，找出对于所有城市 $i$ 前面用了多少传送点，城市 $j$ 后面用了多少传送点，最后的答案即为传送点数量之和 $+1$。 那么，我们可以从前往后 $dp$，再从后往前 $dp$，最后的值即为 $dp_0[i] + dp_1[j] + 1$。 而对于 $dp$，从前向后的时候，对于第 $i$ 个城市，我们可以枚举所有 $j \in [1, m]$，那么我们可以传送到所有满足条件的 $i + j$ 个城市。因而，这些城市的传送点数量即可用当前城市来更新。 从后往前是类似的。 时间复杂度：$O(nm)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 4e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int dp[N][2]; string a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, m; cin >> n >> m; for(int i=0;i&lt;n;i++)cin >> a[i]; memset(dp, 0x3f, sizeof dp); dp[0][0] = dp[n - 1][1] = 0; for(int i=0;i&lt;n;i++)&#123; for(int j=1;j&lt;=min(m, n - i);j++)&#123; if(a[i][j - 1] == '1') dp[i + j][0] = min(dp[i + j][0], dp[i][0] + 1); &#125; &#125; for(int i=n-1;i>=0;i--)&#123; for(int j=1;j&lt;=min(m, i - 1);j++)&#123; if(a[i - j][j - 1] == '1') dp[i - j][1] = min(dp[i - j][1], dp[i][1] + 1); &#125; &#125; for(int k=1;k&lt;n-1;k++)&#123; int ans = inf; for(int i=max(k - m + 1, 0ll);i&lt;k;i++)&#123; for(int j=k+1;j&lt;min(n, i+m+1);j++)&#123; if(a[i][j - i - 1] == '1') ans = min(ans, dp[i][0] + dp[j][1] + 1); &#125; &#125; cout &lt;&lt; (ans >= inf ? -1 : ans) &lt;&lt; ' '; &#125; &#125; dp老写错状态，淦]]></content>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 853 Div 2</title>
    <url>/blog/posts/2909166420/</url>
    <content><![CDATA[Contestant. Rank 1948. Rating +8. A. Serval and Mocha’s Array题意给定一个数组 $a$，将其重新排序，满足对于所有前缀，如前 $i$ 个数，满足它们的 $gcd \leq i$。 思路首先，最优的方法当然是互质，只要把互质的两个数放到第一个，那么后面的 $gcd$ 全都是 $1$ 了。 其次，前两个数可以有公约数 $2$，这是毋庸置疑的。但是，若我们继续下去，前 $3$ 个数可以有公约数 $3$，…，前 $6$ 个数可以有公约数 $6$。停，不对劲：既然有公约数 $2,3$，那么一定能被 $6$ 整除，那么前两个数的 $gcd$ 一定至少是 $6$ 了，产生了矛盾。 所以，我们只需找出一对数，满足 $gcd \leq 2$ 即可。 时间复杂度：$O(n ^ 2)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; int gcd(int x, int y) &#123; while (y != 0) &#123; int tmp = x; x = y; y = tmp % y; &#125; return x; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; bool f = false; for(int i=0;i&lt;n;i++) for(int j=i;j&lt;n;j++)&#123; if(gcd(a[i], a[j]) &lt;= 2) &#123; f = true; break; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; 为什么赛后反而思路这么清晰了（（ B. Serval and Inversion Magic题意给定一个二进制字符串，任选一个区间，将区间内的所有数取反，输出是否可以将整个字符串变为回文字符串。 思路考虑到回文串的对称性，我们只需修改 $[0, \frac{n}{2}]$ 内的数即可。 下面是一种模拟思路： 我们不妨从外向里遍历，比较 $i$ 和 $n - i - 1$ 对应的数，若出现了不同的数，记录当前下标开始需要取反，然后一直找到结束，或者出现相同的数。出现相同数后，我们标记一下已经进行过取反操作，当我们再次遇到不同数的时候，考虑到只能选一个区间，所以直接返回 $NO$。 否则，一定是有解的。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; string a; cin >> a; bool f = true, have = false, now = false; for(int i=0;i&lt;n/2;i++)&#123; if(a[i] == a[n - i - 1])&#123; if(now)&#123; now = false; have = true; &#125; &#125;else&#123; if(have)&#123; f = false; break; &#125; now = true; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; 我的评价是：比A题简单 C. Serval and Toxel’s Arrays题意给定一个无重复元素的数组 $a$，对于 $q$ 个操作给定的 $pi, v_i$，将 $a{p_i}$ 改为 $v_i$。每次操作后，将会得到一个新数组，新数组满足无重复元素。每次操作的对象为上次操作后的数组。对于所有数组（原数组 + 所有新数组），输出所有任意两个数组拼接后不同数字的个数的和。 思路显然，我们不可能去暴力计算，而相反地，我们可以将问题拆分为所有单个数字的贡献和。 具体地说，对于一个数字，若它自始至终未被修改，那么任意两个数组组合，都会留下它，那么它的贡献即为 $C_{m + 1}^2$。 若它被修改了，那么在它未出现的时候，它将毫无贡献。因此，我们需要减去这些无贡献的数组组合，也就是 $C{m - cnt + 1}^2$。因而，得到该条件下的总贡献：$C{m + 1}^2 - C_{m - cnt + 1}^2$。 当然，我们还需算出一个数的出现次数 $cnt$，考虑到无重复，所以我们只需模拟即可。 时间复杂度：$O(m+n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 4e5 + 10, inf = 0x3f3f3f3f; int cnt[N]; pii a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n, m; cin >> n >> m; for(int i=1;i&lt;=n+m;i++) cnt[i] = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i].first; a[i].second = 0; &#125; for(int i=1;i&lt;=m;i++)&#123; int p, v; cin >> p >> v; cnt[a[p].first] += i - a[p].second; a[p] = &#123;v, i&#125;; &#125; for(int i=1;i&lt;=n;i++) cnt[a[i].first] += m + 1 - a[i].second; int ans = 0; for(int i=1;i&lt;=n+m;i++)&#123; if(cnt[i] == 0) continue; if(cnt[i] > m) ans += m * (m + 1) / 2; else ans += (m * (m + 1) - (m - cnt[i]) * (m - cnt[i] + 1)) / 2; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 我蠢了]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 831 Div 1 plus 2</title>
    <url>/blog/posts/126870515/</url>
    <content><![CDATA[Practice. A. Factorise N+M题意给定一个质数，输出一个质数，使两者相加不是质数。 思路除 $2$ 之外，偶数都不是质数，所以直接加上 $3$ 即可。 若为 $2$，那么加上 $2$ 即可。 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; cout &lt;&lt; (n % 2 == 0 ? 2 : 3) &lt;&lt; '\n'; &#125; &#125; 水 B. Jumbo Extra Cheese 2题意给定 $n$ 个长方形，所有长方形必须有一条边在 $x$ 轴上，每个长方形至少需要和另一个长方形有公共边，输出周长最小值。 思路首先，贴靠在一起后，周长只和最高的高度和所有长方形贴靠在 $x$ 轴上的长度有关，所以我们希望让最高的高度降低，同时尽量将所有的长方形的短边贴靠在 $x$ 轴。 因此，我们可以贪心地直接将最高的方块横着放，其余竖着放即可。 但是我不会证 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; pii p[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++) &#123; int a, b; cin >> a >> b; p[i] = &#123;max(a, b), min(a, b)&#125;; &#125; sort(p, p + n, greater&lt;>()); int cnt = p[0].first; for(int i=1;i&lt;n;i++) cnt += p[i].second; cout &lt;&lt; 2 * (p[0].second + cnt) &lt;&lt; '\n'; &#125; &#125; 怎么证捏 C. Bricks and Bags题意给定一个数组 $a$，将所有数字任意分成 $3$ 组，不能出现空组。从三组中各拿出一个数字，使 $|w_1 - w_2| + |w_2 - w_3|$ 最小。将数字合理分配，使 $|w_1 - w_2| + |w_2 - w_3|$ 的最小值最大。 思路首先，假设我们确定了一个数，那么我们能决定的是将一个组合全部放入最小值或最大值，让这一部分的最小值固定，那么我们只要在一个组合里只放另一个数，要让其最小，肯定会拿出最靠近这个数的数字，因而我们也希望找出数值上相邻的两数，它们的差值最大。 所以，我们可以排序然后枚举这个数字，然后计算出最大值即可。 时间复杂度：$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a, a + n); int ans = 0; for(int i=1;i&lt;n;i++) ans = max(ans, max(2 * a[i] - a[i - 1] - a[0], a[i] + a[n - 1] - 2 * a[i - 1])); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 怎么就WA了那么多遍呢（]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 344 Div 2</title>
    <url>/blog/posts/641661849/</url>
    <content><![CDATA[Practice. 什么陈年老题目（（ A. Interview题意给定两个长度相等的序列，任选一段区间，输出区间内各序列值进行按位或之后的和。 思路考虑到数据范围，直接暴力即可。 时间复杂度：$O(n ^ 2)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], b[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;n;i++) cin >> b[i]; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int ca = 0, cb = 0; for(int j=i;j&lt;n;j++)&#123; ca |= a[j]; cb |= b[j]; ans = max(ans, ca + cb); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; 过于打卡 B. Print Check 中文版：题目详情 - 简单题 - FJNU (fjnuacm.top) 题意给定一个 $n \times m$ 的矩阵，对于 $q$ 个操作，输出操作后的矩阵。 定义操作为选择一行或一列，将该行或该列的值改为指定值，存在覆盖的情况。 思路首先，不可以模拟，只要 $n, m, q$ 够大，一定会 $tle$。 其次，对于一个点，它最后的值只和最后一次对它所在的行或列的操作有关。 因而，我们不妨记录每行的操作，以及操作时间，在最后输出的时候，判断涉及到该点的行操作和列操作的时间，并输出最后操作后的值。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; pii r[N], c[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, m, k; cin >> n >> m >> k; for(int i=1;i&lt;=k;i++)&#123; int x, p, a; cin >> x >> p >> a; if(x == 1) r[p] = &#123;i, a&#125;; else c[p] = &#123;i, a&#125;; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cout &lt;&lt; (r[i].first > c[j].first ? r[i].second : c[j].second) &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; &#125; 怎么就做到原题了（（ C. Report题意给定一个数组 $a$，输出操作后数组的结果。 定义一次操作为选择一个右端点 $r$，将 $[1, r]$ 内的数升序或降序排列，排列方式取决于输入，$1$ 为非降序，$0$ 为非升序。 思路剪枝首先，这些操作存在覆盖，也就是说，后面的操作可以使前面的操作无效。 对于最后一个操作，若前面的操作的区间比它小，那么这些操作均无效。推广可得，我们只需从后往前拿出包含最后一个操作且操作区间递增的操作，其余不考虑即可。 输出考虑到直接暴力排序的时间复杂度过大，我们不妨观察一下每次操作的特点： 当我们对大区间操作后，其与次大值区间的补集就唯一确定了，不会随着后续操作而改变，所以我们不妨直接从后往前放数字。 对于一个区间内的数，我们不妨直接将其升序排序，若这个补集需要非降序，那么把右端点的数字取出，否则把左端点的数字取出，依次放入这个补集所在的区域即可。 当然，最大的操作之后的数直接输出，不参与排序。 时间复杂度：$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; pii op[N], opt[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, tm, m = 0; cin >> n >> tm; for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;tm;i++) cin >> opt[i].second >> opt[i].first; int st = -1; for(int i=tm-1;i>=0;i--)&#123; if(st != -1 &amp;&amp; opt[i].first &lt;= st) continue; st = opt[i].first; op[m ++] = opt[i]; &#125; sort(op, op + m, greater&lt;>()); vector&lt;int> ans(n); for(int i=n-1;i>=op[0].first;i--) ans[i] = a[i]; sort(a, a + op[0].first); int l = 0, r = op[0].first - 1; for(int i=0;i&lt;m-1;i++)&#123; for(int j=op[i].first-1;j>=op[i+1].first;j--)&#123; if(op[i].second == 2) ans[j] = a[l ++]; else ans[j] = a[r --]; &#125; &#125; for(int j=op[m - 1].first-1;j>=0;j--)&#123; if(op[m - 1].second == 2) ans[j] = a[l ++]; else ans[j] = a[r --]; &#125; for(int i=0;i&lt;n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125; 能用数据结构么 D. Messenger题意定义对只有小写字母的字符串的一种压缩方式为选取任意连续相等的子序列，将其替换为 $个数 - 字母$。 如 $aaa$ 可替换为 $3-a$ ，也可以替换为 $1-a\ 2-a$。 给定两个压缩后的字符串 $s, t$，对于两者的原字符串，输出 $t$ 在 $s$ 中出现了几次。 思路首先，若要在 $O(n)$ 的复杂度内解出字符串的查找，我们需要用到 $KMP$ 算法。 其次，我们不能直接调用 $KMP$，因为可能出现开头或结尾的字母数量小于 $s$ 对应字母的数量的情况。如 $1 - a$ 和 $2 - a$。 但是，我们可以确定的是，去掉两端的字母，中间的序列是一定相同的，所以我们不妨去掉两端的字母后调用 $KMP$ 算法，找出所有满足条件的区间 $[l, r]$。 当然，考虑到字符串并未彻底压缩，会影响到查找，所以我们需要预处理，将 $1 - a\ 2 - a$ 之类压缩到最小。 不过，此时还有一个问题没有解决：类似于 $1 - a$ 和 $11 - a$ 的子串会被意外匹配，而它们的数量是不相同的。这时我们不妨在所有数字的起始处加一个特殊字符（如 $.$）。此时，形如 $1a12b3c$ 的字符串将会变为 $.1a.12b.3c$，即可避免意外匹配。 考虑到对于求得的区间，我们需要快速定位其左右端点对应的内容，所以我们需要用类似于 $map$ 的容器记录每个元素的起始位置对应的元素。此时，对于 $l$ 对应的元素的前一个元素和 $r + 1$ 对应的元素，我们只需比对其与 $t$ 字符串的两端的元素的字母是否相同、以及数量是否符合条件即可。 当然，上述操作针对的是预处理后 $t$ 只剩三个元素的情况，其余情况都可以暴力，只是元素为一个的时候，元素是可以在一个大区间内移动的，它的左右端点不像元素多的时候那样是固定的。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> class KMP &#123; //交一个套板子的（（ public: static vector&lt;int> prefix_function(string s) &#123; int n = (int) s.length(); vector&lt;int> pi(n); for (int i = 1; i &lt; n; i++) &#123; int j = pi[i - 1]; while (j > 0 &amp;&amp; s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; &#125; return pi; &#125; static vector&lt;pii > find_occurrences(const string &amp;text, const string &amp;pattern) &#123; string cur = pattern + '#' + text; int sz1 = text.size(), sz2 = pattern.size(); vector&lt;pii > v; vector&lt;int> lps = prefix_function(cur); for (int i = sz2 + 1; i &lt;= sz1 + sz2; i++) &#123; if (lps[i] == sz2) v.emplace_back(i - 2 * sz2, i - sz2 - 1); &#125; return v; &#125; &#125;; vector&lt;pair&lt;int, char>> merge(int tn, int &amp;n) &#123; vector&lt;pair&lt;int, char>> a; char pre = -1; int cnt = 0; while (tn--) &#123; string cur; cin >> cur; int x = 0, i = 0; while (cur[i] != '-') &#123; x = x * 10 + (cur[i] - '0'); i++; &#125; if (pre == -1) pre = cur[i + 1]; if (pre != cur[i + 1]) &#123; a.emplace_back(cnt, pre); n++; pre = cur[i + 1]; cnt = x; &#125; else cnt += x; &#125; a.emplace_back(cnt, pre); n++; return a; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int tn, tm, n = 0, m = 0; cin >> tn >> tm; vector&lt;pair&lt;int, char>> a = merge(tn, n), b = merge(tm, m); int cnt = 0; if (m >= 3) &#123; string origin, dest; map&lt;int, int> ind; for (int i = 0; i &lt; n; i++) &#123; ind[origin.size()] = i; origin += "$" + to_string(a[i].first); origin += a[i].second; &#125; for (int i = 1; i &lt; m - 1; i++) &#123; dest += "$" + to_string(b[i].first); dest += b[i].second; &#125; vector&lt;pii > oc = KMP::find_occurrences(origin, dest); for (auto e: oc) &#123; if (e.second + 1 >= origin.size()) continue; int x1 = ind[e.first], x2 = ind[e.second + 1]; if (x1 == 0) continue; if (a[x1 - 1].second == b[0].second &amp;&amp; a[x2].second == b[m - 1].second &amp;&amp; a[x1 - 1].first >= b[0].first &amp;&amp; a[x2].first >= b[m - 1].first) cnt++; &#125; &#125; else if (m == 2) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; if (a[i].second != b[0].second || a[i + 1].second != b[1].second) continue; if (a[i].first >= b[0].first &amp;&amp; a[i + 1].first >= b[1].first) cnt++; &#125; &#125; else &#123; for (int i = 0; i &lt; n; i++) &#123; if (a[i].second != b[0].second) continue; if (a[i].first >= b[0].first) cnt += a[i].first - b[0].first + 1; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; 有点难解释，反正大概做法是这样（（]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 832 Div 2</title>
    <url>/blog/posts/3447609703/</url>
    <content><![CDATA[Practice. A. Two Groups题意给定一个数组 $a$，可以为负数，从数组 $a$ 中取出某些数作为序列 $s_1$，剩余作为序列 $s_2$，输出 $|sum(s_1)| - |sum(s2)|$ 的最大值。序列可以为空。 思路考虑到 $|sum(s_1)| - |sum(s2)| \leq |sum(s_1) + sum(s2)| = |sum(a_i)|$，我们可以发现原数组的总和的绝对值即为最大值。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5+10; signed main()&#123; ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); int t; cin >> t; while(t --)&#123; int n; cin >> n; int ans = 0; for(int i=1;i&lt;=n;i++) &#123; int cur; cin >> cur; ans += cur; &#125; cout &lt;&lt; abs(ans) &lt;&lt; '\n'; &#125; &#125; 暴力枚举碰运气过了可还行 B. BAN BAN题意给定一个整数 $n$，对于由 $n$ 个 $BAN$ 组成的字符串，输出至少交换几次，使所有长度为 $3$ 的可不连续子序列不包含 $BAN$。 思路显然，我们希望 $B$ 能移到后面，$N$ 能移到前面，那么我们不妨将第 $i$ 个 $B$ 和第 $n - i + 1$ 个 $N$ 交换。 当然，若 $n$ 为奇数，中间的那个字符串直接反转即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5+10; signed main()&#123; ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); int t; cin >> t; while(t --)&#123; int n; cin >> n; cout &lt;&lt; n / 2 + n % 2 &lt;&lt; '\n'; for(int i=0;i&lt;n/2;i++) cout &lt;&lt; 1 + i * 3 &lt;&lt; ' ' &lt;&lt; 3 * n - (i * 3) &lt;&lt; '\n'; if(n % 2 == 1) cout &lt;&lt; 3 * (n / 2) + 1 &lt;&lt; ' ' &lt;&lt; 3 * (n / 2) + 3 &lt;&lt; '\n'; &#125; &#125; 纯纯找规律（（ C. Swap Game题意给定一个序列，规定每个玩家可以选择一个数，将其与第一个数交换，并将第一个数扣去 $1$。定义最后将 $0$ 交换到第一个位置上的玩家输，在 $Alice$ 先手的条件下，输出最后的赢家。 思路首先，若最小的数是第一个数，那么先手就会将最小的数放到后面，从而使后手具有必胜策略：我只需每次都挑大的数，那么对方就只能挑小的数，从而让对方最后只能取 $0$。反之同理。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f; signed main()&#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; int minn = inf, a0; cin >> a0; minn = min(minn, a0); for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; minn = min(minn, cur); &#125; cout &lt;&lt; (minn == a0 ? "Bob" : "Alice") &lt;&lt; '\n'; &#125; &#125; 当然和总和的奇偶性没关系 D. Yet Another Problem题意给定一个序列 $a$，定义一次操作为选定任意长度为奇数的区间，将区间内的数全都改为整个区间的异或值。对于每个区间询问，输出最小操作数，使区间的数都变为 $0$。无解输出 $-1$。 思路首先，若没有区间奇偶性的限制，我们直接预处理出前缀异或，然后用类似于前缀和的方式计算即可。 当然，也可以用一下前缀和，毕竟我们需要知道这个区间是否已经全为 $0$。 若查询的区间长度为偶数，那么我们只能挑选两个长度为奇数的区间。考虑到对一个子区间操作后，剩余的区间的异或值一定为 $0$，所以我们只需枚举所有长度为奇数的右端的子区间即可（左端也行）。 不过，我们不可以枚举，因为数据量实在太大了。所以，我们需要进行预处理。对于一个右端点，若它为偶数，那么以它为右端点的区间的左端点一定是奇数，从而我们可以进行递推，找到两个异或值相等且奇偶性不同的点即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; int a[N], xo[N], sum[N], pre[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, q; cin >> n >> q; vector&lt;map&lt;int, int>> mp(2); for (int i = 1; i &lt;= n; i++) &#123; cin >> a[i]; xo[i] = xo[i - 1] ^ a[i]; sum[i] = sum[i - 1] + a[i]; if(mp[1 - i % 2].count(xo[i])) pre[i] = mp[1 - i % 2][xo[i]]; mp[i % 2][xo[i]] = i; &#125; while (q--) &#123; int l, r; cin >> l >> r; if ((xo[r] ^ xo[l - 1]) != 0) &#123; cout &lt;&lt; -1 &lt;&lt; '\n'; continue; &#125; if (sum[r] - sum[l - 1] == 0) &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; &#125; else if ((r - l + 1) % 2 == 1) &#123; cout &lt;&lt; 1 &lt;&lt; '\n'; &#125; else &#123; if (a[r] == 0 || a[l] == 0) &#123; cout &lt;&lt; 1 &lt;&lt; '\n'; continue; &#125; cout &lt;&lt; (pre[r] >= l ? 2 : -1) &lt;&lt; '\n'; &#125; &#125; &#125; 二分半天不过…]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - CodeTON Round 3 Div 1 plus 2</title>
    <url>/blog/posts/3739927720/</url>
    <content><![CDATA[Practice. A. Indirect Sort题意给定一个排列 $a$，定义操作如下： 选择三个下标 $i, j, k$，满足 $1 \leq i &lt; j &lt; k \leq n$； 若 $a_i &gt; a_k$，将 $a_i$ 替换为 $a_i + a_j$，否则将 $a_j$ 和 $a_k$ 交换。 输出是否可以将排列变为一个不递减序列。 思路显然，当第一位不为 $1$ 的时候，第一位无法减小，而由于 $1$ 在序列的后面，所以一定存在一个递减的组合，而操作无法将选定的递减组合变为递增，所以无解。 相反地，当第一位为 $1$ 时，我们只需选 $i = 1$，那么每次均可实现交换，从而交换成为一个不递减序列。 时间复杂度：$O(1)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int a, tmp; cin >> a; for(int i=1;i&lt;n;i++) cin >> tmp; cout &lt;&lt; (a == 1 ? "YES\n" : "No\n"); &#125; &#125; 怎么会是呢，怎么想了那么久呢？ B. Maximum Substring题意给定一个二进制字符串，对于它的连续子串，统计 $0, 1$ 的个数为 $x, y$，那么代价 $t$ 满足： $x \cdot y$，如果 $x &gt; 0$ 并且 $y &gt; 0$； $x ^ 2$，如果 $x &gt; 0$ 并且 $y = 0$； $y ^ 2$，如果 $x = 0$ 并且 $y &gt; 0$。 输出所有子串中最大的代价。 思路显然，若我们想让代价最大，那么我们希望子串中 $0$ 或 $1$ 的个数尽量多，如果个数差不多，那么考虑两者的乘积。 所以，我们不妨找出所有连续相等的子串，然后计算个数的平方，记录该条件的最大值。 而假设不满足上述条件，那么我们就希望 $x$ 和 $y$ 的值足够大，也就是原字符串对应的代价。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int num = 0; for(char e : s) if(e == '1') num ++; int cnt = 0, pre = 0; for(int i=0;i&lt;n;i++)&#123; if(s[i] == s[pre]) continue; else&#123; cnt = max(cnt, i - pre); pre = i; &#125; &#125; cnt = max(cnt, n - pre); cout &lt;&lt; max(cnt * cnt, num * (n - num)) &lt;&lt; '\n'; &#125; &#125; 简单思维题 C. Complementary XOR题意给定两个长度相等的二进制字符串 $a, b$，定义操作为选择一段连续的区间，并将区间内的 $a$ 字符串的值取反，将区间外的 $b$ 字符串的值取反。输出一种操作数低于 $n + 5$ 的流程，使两个字符串所有位都变为 $0$。 思路显然，若 $a$ 与 $b$ 异或值为 $0$ 或者两者相等的时候才有解，否则考虑到操作的对称性，我们无法将它们变为 $0$。 其次，若 $a$ 与 $b$ 异或值为 $0$，那么我们只需选择整个区间进行一次操作，即可将 $a$ 变为 $b$。 那么，我们来考虑 $a = b$ 的情况。 不难发现，若我们遍历到了 $a_i$，满足 $a_i = 1$，那么我们只需选择 $[1, i]$ 和 $[1, i - 1]$ 进行操作，即可在将其余位的操作抵消的前提下，将 $1$ 变为 $0$ 了。 当然，右边界 $i - 1$ 要求 $i \geq 2$，若第一位有 $1$，那么我们考虑对 $[1, 1]$ 和 $[2, n]$ 进行操作，从而将整个 $a$ 取反。 按照上述输出，我们将会得到最多 $2n + 1$ 个操作，要使其降低一倍，我们不妨留意异或的性质，在同一个区间内进行两次操作后操作是无效的。所以，我们只需统计操作数的奇偶性，从而避免无效操作。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; int cnt[N]; signed main()&#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t, n; cin >> t; vector&lt;pii> ans; while(t --)&#123; ans.clear(); cin >> n; for(int i=0;i&lt;n;i++) cnt[i] = 0; string a, b; cin >> a >> b; bool ok = true; for(int i=0;i&lt;n;i++)&#123; if(a[i] != ('1' - b[i] + '0'))&#123; ok = false; break; &#125; &#125; if(a != b &amp;&amp; !ok)&#123; cout &lt;&lt; "NO\n"; &#125;else&#123; cout &lt;&lt; "YES\n"; if(a != b)&#123; ans.emplace_back(1, n); a = b; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i] == '1')&#123; if(i == 0)&#123; ans.emplace_back(1, n); ans.emplace_back(2, n); &#125;else&#123; cnt[i] ++; cnt[i - 1] ++; &#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(cnt[i] % 2 == 1) ans.emplace_back(1, i + 1); &#125; cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto x : ans) cout &lt;&lt; x.first &lt;&lt; ' ' &lt;&lt; x.second &lt;&lt; '\n'; &#125; &#125; &#125; 构造题有时候想到就感觉很妙啊（（]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Pinely Round 1 Div 1 plus 2</title>
    <url>/blog/posts/760099833/</url>
    <content><![CDATA[Practice. 代码略去了快读模板 A. Two Permutations题意给定三个整数 $n, a, b$，构建两个长为 $n$ 的排列，满足前 $a$ 个数和后 $b$ 个数一致。输出是否能构建出两个不同的排列。 特别地，当 $n = a = b$ 时，输出 $YES$。 思路如题。 时间复杂度：$O(1)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; int n = console.nextInt(), a = console.nextInt(), b = console.nextInt(); if(n == a &amp;&amp; b == a)&#123; console.println("YES"); continue; &#125; console.println(n - a - b >= 2 ? "YES" : "NO"); &#125; console.close(); &#125; &#125; 什么离谱的特判啊 B. Elimination of a Ring题意给定一个首尾相连的序列，序列中的相邻元素不相等。定义一次操作为删去任意元素，在每次删去后，若出现相邻元素相等，那么删去任意重复元素，直到没有相邻元素相等。 思路我们不妨来考虑下面的一种情况： 1 6 1 2 1 2 1 2 显然，对于这类相间的数，在剩余两个数之前，我们都是成对删除的（如删除 $1$ 后左边或右边的 $2$ 也将被删去）。 而若我们在里面添加任意数字，那么相间的环将会被打破，我们不难发现，我们只需删去添加的任意数的相邻数，即可避免删除数以后出现重复数字。 更具体地说，除了两个数字相间成环的情况，我们应该输出 $\frac{n}{2} + 1$ 外，其余情况均输出 $n$。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); if(n &lt;= 2 || n % 2 == 1) &#123; for(int i=0;i&lt;n;i++) console.nextInt(); console.println(n); &#125; else&#123; int a = console.nextInt(), b = console.nextInt(); boolean f = false; for(int i = 1;i&lt;n / 2;i++)&#123; if(console.nextInt() != a | console.nextInt() != b)&#123; if(f) continue; console.println(n); f = true; &#125; &#125; if(!f) console.println(n / 2 + 1); &#125; &#125; console.close(); &#125; &#125; 硬猜就完事了（ C. Set Construction题意给定一个二进制矩阵 $b$，构造 $n$ 个无重复数字的序列 $A$，满足矩阵对应的限制： $b{i, j} = 1$ 表示 $A_i\subsetneq A_j$，$b{i, j} = 0$ 则相反。 思路显然，序列是不唯一的，那么我们不妨来初始化 $A$，满足 $A_i$ 中一定包含 $i$。 那么，显然地，若 $A_i\subsetneq A_j$，那么 $A_j$ 中就一定有 $i$。 更简单地说，我们只需遍历输出的矩阵，若 $b_{i, j} = 1$，那么我们在 $A_j$ 里添加 $i$。 输出满足上述条件的序列即可。 时间复杂度：$O(n ^ 2)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0) &#123; int n = console.nextInt(); List&lt;List&lt;Integer>> ans = new ArrayList&lt;>(); for (int i = 0; i &lt; n; i++) &#123; List&lt;Integer> e = new ArrayList&lt;>(); e.add(i + 1); ans.add(e); &#125; for (int i = 1; i &lt;= n; i++) &#123; String s = console.next(); for (int j = 0; j &lt; n; j++) &#123; if(s.charAt(j) == '1') ans.get(j).add(i); &#125; &#125; for(int i=0;i&lt;n;i++)&#123; console.print(ans.get(i).size()); for(int j : ans.get(i)) console.print(" " + j); console.println(); &#125; &#125; console.close(); &#125; &#125; 好一个思维题…]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - SWERC 2022-2023 - Online Mirror</title>
    <url>/blog/posts/2576267679/</url>
    <content><![CDATA[Contestant. Rank 720. Unrated. 划水，打卡，三题，结束（（ A. Walking Boy题意给定一个升序排序的数组 $a$，$a_i \in [0, 1440]$，在数组第一位插入 $0$，最后一位插入 $1440$，输出是否有两个相邻数的差值大于等于 $120$。 思路如题。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; a[i] = min(a[i], 1440ll); &#125; int cnt = 0; a[n + 1] = 1440; for(int i=1;i&lt;=n + 1;i++) cnt += (a[i] - a[i - 1]) / 120; cout &lt;&lt; (cnt >= 2 ? "YES\n" : "NO\n"); &#125; &#125; 你怕是不想让我看懂（ H. Beppa and SwerChat题意给定两个时间段的好友列表，列表按照最后一条消息的时间降序排序。输出至少有多少人在两个时间段内发了消息。 思路很显然，若发送了消息，那么这个人是从当前位置移动到第一个位置的。 或者更具体地说，我们从后往前遍历 $b$ 数组，那么只需找到第一对相邻的数，满足在 $a$ 数组的位置不符合要求即可。 当然，我们可以记录 $a$ 中元素对应的下标来使查询复杂度降到 $O(1)$。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N], b[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; a[cur] = i; &#125; for(int i=1;i&lt;=n;i++) cin >> b[i]; int cnt = n; for(int i=n;i>=1;i--)&#123; cnt --; if(a[b[i - 1]] > a[b[i]]) break; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; &#125; 捏码，怎么就WA了 L. Controllers题意给定一个由 $+, -$ 符号组成的字符串，对于 $t$ 组询问，给定两个数 $a, b$，输出是否存在 $a, b$ 的一个序列，使其带入表达式后值为 $0$。 思路显然，我们有两个选择可以让最后的值为 $0$： 选择任意数，$+-$ 任意次后答案一定是 $0$； 将 $a, b$ 进行配对，用最小公倍数找出合法配对，进行“抵消”。 我们不妨统计 $+-$ 的个数，记 $pl$ 为个数的最小值，$mi$ 为个数的最大值，并令 $a$ 为 $max(a, b)$，$b$ 为 $min(a, b)$；然后，我们计算出 $lcm(a, b)$，那么 $lcm / a$ 个个数较少的符号和 $lcm / b$ 个个数较多的符号即可进行配对。 考虑到两种配对方法的个数较少，且无法确定需要配对几次，所以我们不妨直接枚举所有 $a, b$ 的配对，找出是否存在一种配对，使剩余的两种符号个数相同。若相同，我们直接选择第一种配对方式配对即可。 时间复杂度：$O(n)?$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int gcd(int a, int b) &#123; while (b != 0) &#123; int tmp = a; a = b; b = tmp % b; &#125; return a; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, q; string op; cin >> n >> op >> q; int pl = 0; for(char e : op) if(e == '+') pl ++; int mi = n - pl; int tmp = min(pl, mi); mi = max(pl, mi); pl = tmp; while(q --)&#123; int a, b; cin >> a >> b; tmp = min(a, b); a = max(a, b); b = tmp; if(pl == mi)&#123; cout &lt;&lt; "YES\n"; continue; &#125; int lcm = a * b / gcd(a, b); int pa = lcm / a, pb = lcm / b; int t = min(pl / pa, mi / pb); bool f = false; for(int i=1;i&lt;=t;i++)&#123; if(pl - i * pa == mi - i * pb)&#123; f = true; break; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; 人类的智慧（]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 290</title>
    <url>/blog/posts/348658234/</url>
    <content><![CDATA[Contestant. Rank 3650. Rating +66. A. Contest Result题意给定数组 $a, b$，输出 $a_{b_i}$ 的总和。 思路如题。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i = 1;i&lt;=n;i++) cin >> a[i]; int ans = 0; for(int i=0;i&lt;m;i++)&#123; int p; cin >> p; ans += a[p]; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; 太打卡了吧（（ B. Qual B题意给定一个由 $o, x$ 组成的字符串，将第 $k + 1$ 个及以后的 $o$ 替换成 $x$，输出字符串。 思路如题。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; string s; cin >> s; int cnt = 0; for(int i=0;i&lt;n;i++)&#123; if(s[i] == 'x') cout &lt;&lt; 'x'; else&#123; cnt ++; if(cnt > m) cout &lt;&lt; 'x'; else cout &lt;&lt; 'o'; &#125; &#125; &#125; 做的太慢了捏 C. Max MEX题意给定一个数组 $a$，找出一个长为 $k$ 的子串 $X$，满足 $MEX$ 值最大。 定义 $MEX(X)$ 为最大的 $m$ ，满足下面的条件： $[0, m)$ 都在 $X$ 内； $m$ 不在 $X$ 内 思路我们不妨将数组升序排序，去除所有的重复元素，然后从 $0$ 开始匹配，若能找到 $0, 1, \ldots, k$ ，那么输出 $k + 1$，否则找到最长的 $0, 1, \ldots, t$ ，输出 $t + 1$。 时间复杂度：$O(nlogn)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 3e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a, a + n); a[n] = inf; int l = 0; for(int i=0;i&lt;=n;i++)&#123; if(a[i] == l - 1) continue; if(a[i] == l) l ++; if(l >= m) break; &#125; cout &lt;&lt; l; &#125; 模拟不明白了（（ D. Marking题意对于 $t$ 个询问，给定三个整数 $n, d, k$，输出第 $k$ 次标记的点。 标记满足下面的规则： 第一次标记 $0$ 点； 重复下述操作 $n - 1$ 次，其中 $a$ 为前一次标记的下标： i. 令 $x = (a + d)\ mod\ N$； ii. 找到 $x$ 及以后第一个没标记的下标并标记 思路首先，很明显地，我们需要找出标记的周期，当完成一次周期后，我们需要移到下一位并继续循环，直至结束。 不难证明，周期是 $x = n / gcd(n, d)$，而我们只需要计算经过了多少个周期，然后将最后的答案加上这个值即可。 考虑到数据量不超过长整型，我们直接计算 $(d \times k)\ mod\ n$ 即可，然后按照上述操作加上 $k / x$ 即可。 时间复杂度：不会分析捏 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; private static long gcd(long a, long b) &#123; while(b != 0) &#123; long tmp = a; a = b; b = tmp % b; &#125; return a; &#125; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; long n = console.nextInt(), d = console.nextInt(), k = console.nextInt(); k --; console.println(d * k % n + k / (n / gcd(n, d))); &#125; console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; nnd，没考虑到类似于 $6, 9$ 的测试数据，寄]]></content>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 288</title>
    <url>/blog/posts/50897737/</url>
    <content><![CDATA[Contestant. Rank 3721. Rating +41. A. Many A+B Problems题意给定 $a, b$，输出 $a + b$。 思路如题 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0); int t; cin >> t; while(t --)&#123; int a, b; cin >> a >> b; cout &lt;&lt; a + b &lt;&lt; '\n'; &#125; return 0; &#125; 怎么会是呢 B. Qualification Contest题意给定 $n$ 个由小写字母组成的字符串，输出字典序升序排序的前 $k$ 个字符串。 思路考虑到 $sort$ 对字符串的排序就是按照字典序的，所以调函数输出即可。 时间复杂度：$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 110; string a[N]; signed main() &#123; ios::sync_with_stdio(0); int k, n; cin >> n >> k; for (int i = 0; i &lt; n; i++) cin >> a[i]; sort(a, a + k); for (int i = 0; i &lt; k; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; '\n'; &#125; return 0; &#125; 草，卡了半天发现调函数就好了（ C. Don’t be cycle题意给定一个无向有环图，输出最小删除边数，使整个图无环。 思路考虑到树的结构即为无向无环，所以我们不妨跑一遍最小生成树，剩余的边就是我们想要删去的边了。 时间复杂度：$O(e log_2 e)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010, M = 400010; int n, m; int f[N]; int u[M], v[M], ans = 0; int find(int x)&#123; return x == f[x] ? x : f[x] = find(f[x]); &#125; void kruskal()&#123; for(int i=0;i&lt;m * 2;i++)&#123; int eu = find(u[i]), ev = find(v[i]); if(eu != ev)&#123; ans ++; f[ev] = eu; &#125; &#125; &#125; signed main() &#123; ios::sync_with_stdio(0); cin >> n >> m; for(int i=1;i&lt;=n;i++) f[i] = i; for(int i=0;i&lt;m;i++)&#123; int a, b; cin >> a >> b; u[i &lt;&lt; 1] = a; v[i &lt;&lt; 1] = b; u[i &lt;&lt; 1 | 1] = b; v[i &lt;&lt; 1 | 1] = a; &#125; kruskal(); cout &lt;&lt; m - ans; return 0; &#125; 我蠢了，想了好一会儿]]></content>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 143</title>
    <url>/blog/posts/3290967404/</url>
    <content><![CDATA[Contestant. Rank 2199. Rating +10. A. Two Towers题意给定由两种不同颜色的元素叠成的塔，定义操作为将一个塔上的顶部元素移动到另一个塔，在若干次操作后，输出是否可以让两个塔的元素颜色相间。 思路显然，这个问题可以抽象为：给定一个元素序列，找出一个点，将序列分成两半，使分割后的序列颜色相间。 那么，我们需要满足两个条件： 序列内没有连续 $3$ 个及以上相同元素相邻； 序列内连续 $2$ 个及以上相同元素相邻的组的个数最多只有 $1$。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a, b; cin >> a >> b; string x, y; cin >> x >> y; reverse(y.begin(), y.end()); x += y; int n = a + b; char pre = -1; int cnt = 0; bool ans = true, found = false; for(int i=0;i&lt;n;i++)&#123; char cur = x[i]; if(cur == pre) &#123; cnt ++; if(cnt == 2)&#123; if(found)&#123; ans = false; break; &#125; found = true; &#125; if(cnt >= 3)&#123; ans = false; break; &#125; &#125;else cnt = 1; pre = cur; &#125; cout &lt;&lt; (ans ? "YES\n" : "NO\n"); &#125; return 0; &#125; 漏条件了，淦 B. Ideal Point题意给定 $n$ 个区间，判断是否能删去一些区间，让 $k$ 成为被最多数量的区间包含的点。 思路显然，若不希望让其他节点成为被最多数量的区间包含的点，我们就希望两个区间的交集为一个点，也就是说，我们只需删到最后只剩下 $[x, k], [k, y]$ 即可。 换句话说，我们只需找出这样的区间，满足左边界为 $k$ 或右边界为 $k$。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a, b; cin >> a >> b; string x, y; cin >> x >> y; reverse(y.begin(), y.end()); x += y; int n = a + b; char pre = -1; int cnt = 0; bool ans = true, found = false; for(int i=0;i&lt;n;i++)&#123; char cur = x[i]; if(cur == pre) &#123; cnt ++; if(cnt == 2)&#123; if(found)&#123; ans = false; break; &#125; found = true; &#125; if(cnt >= 3)&#123; ans = false; break; &#125; &#125;else cnt = 1; pre = cur; &#125; cout &lt;&lt; (ans ? "YES\n" : "NO\n"); &#125; return 0; &#125; nnd，一个水题卡半天 C. Tea Tasting题意给定 $n$ 壶茶和 $n$ 个品茶师，第 $i$ 壶茶有 $a_i$ 数量的茶，第 $i$ 位品茶师一次可以喝 $b_i$ 数量的茶。 规定有 $n$ 轮喝茶，第 $i$ 轮由 $[i, n]$ 内的品茶师喝 $[1, n - i + 1]$ 内的茶。 输出每位品茶师最后喝了多少。 思路首先，我们可以发现，对于第 $i$ 轮，我们考虑从第 $i$ 位开始求和后第一个超过 $a_i$ 的数的下标，此时我们就可以确定一轮下来有哪些品茶师喝了茶。 考虑到只有最后一个品茶师有可能喝到多余的茶，其余的品茶师喝的量都是次数乘上 $b_i$，那么我们不妨单独统计多余喝的量，其余的统计我们考虑使用差分。 当然，上述求和找下标的操作可以采用 前缀和+二分。 时间复杂度：$O(nlogn)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], b[N], sum[N], drunk[N], ans[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=1;i&lt;=n;i++) &#123; cin >> b[i]; drunk[i] = 0; ans[i] = 0; &#125; sum[0] = drunk[0] = ans[0] = 0; for(int i=1;i&lt;=n;i++) sum[i] = sum[i - 1] + b[i]; for(int i=1;i&lt;=n;i++) &#123; int x = lower_bound(sum + i, sum + n + 1, a[i] + sum[i - 1]) - sum - 1; //x为能吃的最后一个玩意儿 //if(x == 0) continue; int left = a[i] + sum[i - 1] - sum[x]; if(x &lt; n) ans[x + 1] += left; drunk[i] ++; drunk[x + 1] --; &#125; for(int i=1;i&lt;=n;i++)&#123; drunk[i] += drunk[i - 1]; ans[i] += drunk[i] * b[i]; cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; return 0; &#125; 过于模拟以至于思路很清晰也很单一 D. Triangle Coloring题意给定一个有 $\frac{n}{3}$ 个连通块的带权无向有环图，每个连通块的三点均有一条边相连，构成 $\frac{n}{3}$ 个三角形。将所有点染上两种颜色，满足两种颜色的点的个数相同，输出有多少方案让连接两个颜色不同的点的边的权值总和最大。 思路显然，我们需要考虑一个连通块内权值重复的边，而我们关注的是最大值和次大值的情况： 全都相等，$3$ 种选择； 次大值和最小值相等，$2$ 种选择； 次大值和最大值相等，$1$ 种选择； 没有一个相等，$0$ 种选择。 照上述讨论，我们可以发现一个连通块的解等于最小值和多少条边是相等的。 而考虑到两种颜色的个数要相同，我们相当于在 $t$ 个连通块中找出 $\frac{t}{2}$ 个连通块染成同一种颜色，所以最后的答案即为所有连通块解的乘积乘上 $C_{t}^{\frac{t}{2}}$。 时间复杂度：不会分析 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 3e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= (a / b) * x; return d; &#125; int Inv(int a) &#123; int x, y; exgcd(a, mod, x, y); return (x % mod + mod) % mod; &#125; int C(int m, int n) &#123; int a = 1, b = 1; if (m &lt; n) return 0; while (n) &#123; a = (a * m) % mod; b = (b * n) % mod; m--; n--; &#125; return a * Inv(b) % mod; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin >> n; for (int i = 1; i &lt;= n; i++) cin >> a[i]; int t = n / 3; int ans = C(t, t / 2); for (int i = 0; i&lt;=n/3-1;i++) &#123; int minn = min(a[i * 3 + 3], min(a[i * 3 + 1], a[i * 3 + 2])); int cnt = 0; for (int j = 1; j &lt;= 3; j++) if (a[i * 3 + j] == minn) cnt++; ans = (ans * cnt) % mod; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0; &#125; 数组不要开小了！！ E. Explosions?题意给定一个数组 $h$，$h_i$ 为第 $i$ 个怪物的血量。每次操作可以使用任意数量的 $MP$，使任意一个怪物的血量扣除对应数量的值。 若怪物在遭到攻击后血量小于等于 $0$，那么怪物死亡。 定义”爆炸”为一个死亡的怪物将相邻的怪物的血量扣去 $h_i - 1$，若相邻的怪物血量被扣到 $0$，那么继续循环。 规定只能让”爆炸”发生一次或不发生，输出让所有怪物死亡的 $MP$ 的最小值。 思路答案的推导首先，我们暂定爆炸的那个点下标为 $p$，之后再考虑 $p$ 的选择。那么，我们不妨在最后使用爆炸，这样可以在爆炸前将所有元素调整到最好，也就是在 $[0,p]$ 内严格单调递增，$[p,n]$ 内严格单调递减。 我们不妨用补集的思路，算出最后满足上述条件的数组 $h’$ 的最大总和 $sum$，那么答案即为 $(\sum h_i) - sum$。 总和的计算首先，不难发现对于 $[0,p]$ 和 $[p, n]$ 的操作是类似的，那么我们不妨只考虑 $[0, p]$ 内的 $sum’$。 “左边界”对于 $p - 1$ 点，假设该点满足 $h{p - 1} &gt; h p - 1$，若需要构成连续爆炸，那么我们需要将 $h{p - 1}$ 改为 $h_p - 1$。同理，可推得对于 $p - i$ 点，通式为 $h{p - i} &gt; h_p - i$。 显然，因为严格单调递增，那么 $hp &gt; i$ 是一定成立的，也就是说，$i \geq h_p$ 时到达边界。当然，按照上述的推导，$p - i &lt; 0$ 或 $h{p - i} \leq h_p - i$ 时也会到达边界。 所以，对于左边界 $j = p - i$，将 $i = p - j$ 和 $h_{p - i} \leq h_p - i$ 联立，得到 $h_j - j \leq h_p - p$。 当然，若没有 $j$ 满足上面的式子，那么我们将 $j$ 设为 $max(-1, i - h_i)$。 递推出总和注意一下推导左边界的条件：$h{p - 1} &gt; h p - 1$。这个条件有一个特点：我们目前所求得的”左边界”实际上是严格单调递增且相邻差值为 $1$ 的序列的左边界，若出现了”断层”，那么 $j$ 就有可能偏大了。 但是，不难发现 $j$ 的推导和 $p$ 后面的值是无关的，那么我们可以用递推的方式，先算出 $j$ 前面”严格单调递增且相邻差值为 $1$ 的序列”的总和，然后将这个总和加到 $sum’$ 中即可。 更具体地说，$dp[i]$ 为以 $i$ 点为右边界的”严格单调递增且相邻差值为 $1$ 的序列”的总和，那么只要 $j$ 对应的元素存在，我们就只需将 $dp[i]$ 加上 $dp[j]$ 。 有疑惑吗？请留意条件：$h{p - 1} \leq h p - 1$。$j$ 元素的值一定小于等于 $j + 1$ 元素的值，所以加上 $dp[j]$ 无额外条件。 计算综上，我们只需对每个”严格单调递增且相邻差值为 $1$ 的序列”求和即可，考虑到等差性，直接运用等差数列的求和公式即可。 因而， $dp[i] = (i - j) \times h_i - \frac{(i - j)(i - j - 1)}{2}$，$j$ 存在时 $dp[i] += dp[j]$。 “左边界”的低复杂度求法考虑到我们不可以在每次递推的时候都向前遍历满足条件的”左边界” $j$，因而我们需要一种更快的方法。 我们回归到条件 $h_j - j \leq h_p - p$。显然，我们需要找出满足该条件的 $j$ 的最大值，而该思路恰好可以用单调栈实现（先入后出的逻辑适合本题），那么我们只需套上板子即可。 最后的答案显然，上述操作是线性的，那么我们只需遍历所有的 $p$，然后输出最大值即可。 当然，因为 $dpL$ 和 $dpR$ 会有重叠，所以需要减去重叠的 $h_i$。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 3e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int hl[N], hr[N], dp[2][N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int sum = 0; for(int i=0;i&lt;n;i++) &#123; cin >> hl[i]; sum += hr[n - i - 1] = hl[i]; dp[0][i] = dp[1][i] = 0; &#125; for(int tp=0;tp&lt;2;tp++)&#123; int *h = tp == 0 ? hl : hr; stack&lt;pii> s; for(int i=0;i&lt;n;i++)&#123; while(!s.empty() &amp;&amp; s.top().first > h[i] - i) s.pop(); int j = max(-1LL, i - h[i]); if(!s.empty()) j = max(j, s.top().second); int len = i - j; dp[tp][i] = len * h[i] - len * (len - 1) / 2; if(j >= 0 &amp;&amp; len &lt; h[i]) dp[tp][i] += dp[tp][j]; s.emplace(h[i] - i, i); &#125; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; ans = max(ans, dp[0][i] + dp[1][n - i - 1] - hl[i] * 2); &#125; cout &lt;&lt; sum - ans &lt;&lt; '\n'; &#125; &#125; 好复杂.jpg]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 833 Div 2</title>
    <url>/blog/posts/1795773139/</url>
    <content><![CDATA[Practice. A. The Ultimate Square题意给定 $n$ 个方块，第 $i$ 个方块的宽度为 $1$，长度为 $\lceil \frac{i}{2} \rceil$。选取一些方块横向拼接成一个正方形，输出正方形的最大边长。 思路显然，当 $n$ 为奇数的时候，我们一定能将所有方块都用上，拼成一个长为 $\frac{n + 1}{2}$ 的正方形；当 $n$ 为偶数的时候，一个大方块将会多出来，而剩余的方块按照奇数的情况处理即可。 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; signed main()&#123; ios::sync_with_stdio(false); int t, n; cin >> t; while(t --)&#123; cin >> n; cout &lt;&lt; n / 2 + n % 2 &lt;&lt; '\n'; &#125; &#125; 猜测即可 B. Diverse Substrings题意给定一串数字 $a$，$a_i \in [0, 9]$，对于所有连续子串，输出满足下面条件的个数： 对于子串中出现次数最多的数字的次数 $maxx$ 以及不同数字的种数 $dif$，满足 $maxx \leq dif$。 思路考虑到满足条件的子串长度最多只有 $10 \times 10$，我们直接暴力枚举即可。 时间复杂度：$O(nm)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 20, inf = 0x3f3f3f3f, mod = 998244353; int cnt[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int ans = 0; for(int i=0;i&lt;n;i++)&#123; memset(cnt, 0, sizeof cnt); int dif = 0, maxx = 0; for(int j=i;j&lt;n&amp;&amp;j-i&lt;100;j++)&#123; if(cnt[s[j] - '0'] == 0) dif ++; cnt[s[j] - '0'] ++; maxx = max(maxx, cnt[s[j] - '0']); if(maxx &lt;= dif) ans ++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; return 0; &#125; 太暴力了，虽然双指针确实不可行 C. Zero-Sum Prefixes题意给定数组 $a$，定义操作为将任意一个值为 $0$ 的点替换成任意值，输出操作后所有前缀和中值为 $0$ 的个数。 思路考虑到修改一个元素，会影响到后面的元素的前缀和值，所以我们不妨直接从后面开始遍历。我们不妨从后往前找 $0$，当然，在找的过程中，记录 $0$ 后面的元素的前缀和的值的出现次数，然后，我们只需把 $0$ 改成出现次数最多的前缀和的值的相反数即可，该情况下答案加上最多的出现次数，这样不会影响到前面的答案，并且可以让后面前缀和为 $0$ 的数尽可能多。 时间复杂度：$O(n)?$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N], sum[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; sum[0] = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; sum[i] = sum[i - 1] + a[i]; &#125; int ans = 0; map&lt;int, int> mp; for(int i=n;i>=1;i--)&#123; mp[sum[i]] ++; if(a[i] == 0)&#123; int maxx = 0; for(auto &amp;e : mp) maxx = max(maxx, e.second); ans += maxx; mp.clear(); &#125; &#125; cout &lt;&lt; ans + mp[0]&lt;&lt; '\n'; &#125; return 0; &#125; 有点小贪心]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 834 Div 3</title>
    <url>/blog/posts/3651755215/</url>
    <content><![CDATA[Practice. A. Yes-Yes?题意给定一个字符串，判断其是否是 $YESYESYES…$ 的连续子串。 思路判断多出的前缀是否满足条件，若满足条件，以 $3$ 个字符为一组匹配 $YES$。剩余的后缀特判即可。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; string s; cin >> s; n = (int) s.size(); int i = 0; if(s[i] != 'Y')&#123; if(s[i] == 'e' &amp;&amp; (n == 1 || s[i + 1] == 's')) i = 2; else if(s[i] == 's') i = 1; else i = -1; &#125; if(i != -1) for(;i&lt;n;i+=3)&#123; if(s[i] == 'Y' &amp;&amp; (i + 1 >= n || s[i + 1] == 'e') &amp;&amp; (i +2 >= n || s[i + 2] == 's')) continue; i = -1; break; &#125; cout &lt;&lt; (i == -1 ? "NO\n" : "YES\n"); &#125; return 0; &#125; 读题即可 B. Lost Permutation题意给定一个丢失了部分元素的排列，丢失的元素的总和为 $s$，输出是否能补全该排列。 思路模拟即可。 我们遍历一遍，找出当前最大值之前的空位，去掉这些空位后，若 $s$ 还有剩余，那么继续从最大值 $+1$ 往下遍历，若能将 $s$ 恰好减为 $0$，输出 $YES$。 时间复杂度：$O(n)?$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; bool a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n, s; cin >> n >> s; memset(a, 0, sizeof a); int maxx = -1; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; a[cur] = true; maxx = max(maxx, cur); &#125; int tot = 0; for(int i=1;i&lt;=maxx;i++) if(!a[i]) tot += i; if(tot > s) cout &lt;&lt; "NO\n"; else&#123; int i = maxx + 1; while(tot &lt; s)&#123; tot += i ++; &#125; cout &lt;&lt; (tot == s ? "YES\n" : "NO\n"); &#125; &#125; return 0; &#125; 模拟就完事了 C. Thermostat题意给定一段区间 $[l, r]$，区间内有两个点 $a, b$，定义一次操作为将当前位置加上或减去 $p$，$p \geq x$，操作后的数需要落在区间内。输出从 $a$ 运动到 $b$ 需要的最少操作数。 思路显然，最多只需进行 $3$ 次操作。 考虑到对称性，我们不妨来考虑 $l \leq a \leq b \leq r$ 的情况，分类讨论一下： 无需操作，此时 $a = b$； 操作一次，此时应满足 $b - a \geq x$； 操作两次，此时我们可以向两端移动，只需任意一个满足即可。若向 $l$ 移动，那么向下移动需要满足 $a - l \geq x$，考虑到步数只需大于等于 $x$，我们可以直接移动到 $l$，然后移动到 $b$。因为 $l$ 到 $b$ 的距离大于 $l$ 到 $a$ 的距离，那么我们无需多考虑。而向 $r$ 移动时，在满足 $r - a \geq x$ 的前提下，还需满足能运动到 $b$，即 $r - a \geq x + min(b - a, x)$。 操作三次，相类似地，我们可以得到下面的式子：向 $r$ 移动，$r - a \geq x$ 、$b - l \geq x$；向 $l$ 移动，$a - l \geq x$，$r - b \geq x$。 时间复杂度：$O(1)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a, b, l, r, x; cin >> l >> r >> x >> a >> b; if(a == b) cout &lt;&lt; 0 &lt;&lt; '\n'; else if(abs(b - a) >= x) cout &lt;&lt; 1 &lt;&lt; '\n'; else if(a &lt; b)&#123; int ans1 = inf, ans2 = inf; if(a - l >= x || r - a >= x + min(b - a, x)) ans1 = 2; if((r - a >= x &amp;&amp; b - l >= x) || (a - l >= x &amp;&amp; r - b >= x)) ans2 = 3; cout &lt;&lt; (min(ans1, ans2) == inf ? -1 : min(ans1, ans2)) &lt;&lt; '\n'; &#125;else&#123; int ans1 = inf, ans2 = inf; if(r - a >= x || a - l >= x + min(a - b, x)) ans1 = 2; if((a - l >= x &amp;&amp; r - b >= x) || (r - a >= x &amp;&amp; b - l >= x)) ans2 = 3; cout &lt;&lt; (min(ans1, ans2) == inf ? -1 : min(ans1, ans2)) &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 讨论死我了 D. Make It Round题意给定两个整数 $n, m$，找出 $k \in [1, m]$，使 $n \times k$ 连续后缀 $0$ 的个数最多。若有多解，输出最大的；若无解，输出 $n \times m$。 思路考虑到 $10$ 的质因子为 $2, 5$，我们不妨将 $n$ 后面连续的 $0$ 都去掉，然后统计 $n$ 中因数 $2, 5$ 的个数，并尽量在答案中用对应的 $5, 2$ 与之配对，然后在答案最后尽可能拼上 $0$。最后得到的答案即为 $0$ 个数最多的，因为存在多解，我们将答案乘上 $m / ans$。 时间复杂度：不会分析 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long signed main()&#123; ios::sync_with_stdio(false); int t, n, m; cin >> t; while(t --)&#123; cin >> n >> m; int ans = 1, p = n; while(p % 10 == 0) p /= 10; while(p % 2 == 0 &amp;&amp; ans * 5 &lt;= m)&#123; p /= 2; ans *= 5; &#125; while(p % 5 == 0 &amp;&amp; ans * 2 &lt;= m)&#123; p /= 5; ans *= 2; &#125; while(ans * 10 &lt;= m) ans *= 10; cout &lt;&lt; m / ans * n * ans &lt;&lt; '\n'; &#125; &#125; 配对配对，贪一下嘛~ E. The Humanoid题意给定 $n$ 个人，每个人有能力值 $a_i$。对于一个初始攻击力为 $h$ 的怪物，它可以干掉所有 $a_i &lt; h$ 的人，并将自己的攻击力提高 $\lceil \frac{a_i}{2} \rceil$。怪物有两个道具，道具一总数为 $2$，可以将攻击力翻倍；道具二总数为 $1$，可以将攻击力变为原来的三倍。道具使用后消失。输出怪物可以干掉的最多人数。 思路显然，若想让后续能倍乘的基数变得更大，我们就可以贪心地按能力值升序排序人，这样在需要道具的时候，就能获得尽可能多的攻击力。 然而，使用哪个道具是不确定的，虽然 $3$ 翻的倍数最多，但放在前面还是后面是不确定的。 考虑到道具只有 $3$ 个，我们不妨枚举道具使用的顺序，然后用递归解决即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; int a[N], n; int cal(int b, int i, int use, int h)&#123; if(i == n) return 0; if(a[i] &lt; h) return cal(b, i + 1, use, h + a[i] / 2) + 1; else&#123; if(use == 3) return 0; return cal(b, i, use + 1, h * (b == use ? 3 : 2)); &#125; &#125; signed main()&#123; ios::sync_with_stdio(false); int t, h; cin >> t; while(t --)&#123; cin >> n >> h; for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a, a + n); int ans = 0; for(int i=0;i&lt;3;i++) ans = max(ans, cal(i, 0, 0, h)); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 一开始错在道具的使用顺序上了，不可以贪心地使用当前能用的最小的翻倍数]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 835 Div 4</title>
    <url>/blog/posts/3787113180/</url>
    <content><![CDATA[Practice A. Medium Number题意给定三个数，输出中位数。 思路排序，输出中间的。 时间复杂度：$O(1)$ (确信) 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a[3]; for(int i=0;i&lt;3;i++) cin >> a[i]; sort(a, a + 3); cout &lt;&lt; a[1] &lt;&lt; '\n'; &#125; return 0; &#125; 过于打卡 B. Atilla’s Favorite Problem题意给定一个字符串，输出最大字母在字母表的位置。 思路如题，暴力模拟 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int r = 0; for(char e : s)&#123; r = max(r, (int) (e - 'a')); &#125; cout &lt;&lt; r + 1 &lt;&lt; '\n'; &#125; return 0; &#125; 为啥不直接学一段区间内的呢（划掉 C. Advantage题意给定一个数组 $a$，对于所有 $a_i$，输出其与除它之外的元素中的最大值的差值。 思路如题，暴力模拟。 可以找出整个数组中的最大值和次大值，然后遍历到最大值时输出其与次大值的差即可，其余直接减去最大值。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int maxx = 0, smax = 0; for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; if(a[i] >= maxx)&#123; smax = maxx; maxx = a[i]; &#125;else if(a[i] >= smax) smax = a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i] == maxx) cout &lt;&lt; a[i] - smax &lt;&lt; ' '; else cout &lt;&lt; a[i] - maxx &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; return 0; &#125; 差点没读懂题（ D. Challenging Valleys题意给定一个数组 $a$，输出是否只有一组满足下面条件的 $l, r$： $0 \le l \le r \le n-1$ $al = a{l+1} = a_{l+2} = \dots = a_r$ $l = 0$ 或 $a{l-1} &gt; a{l}$ $r = n - 1$ 或 $ar &lt; a{r+1}$ 思路我们可以遍历整个数组，找出所有拐点，并记录其与其之后的单调性。 之后，我们可以遍历整个拐点数组，找出所有 “递减，递增” 和 “递减，不变，递增” 段，统计数量。 特别地，考虑到条件 $3, 4$ 的特殊性，我们还需找出下面的情况： 整个数组单调 第一段单调区间值不变，第二段单调区间单调递增 最后一段单调区间值不变，倒数第二段单调区间单调递减 统计数量，判断数量是否为 $1$ 即可。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int pre; cin >> pre; if(n == 1) &#123; cout &lt;&lt; "YES\n"; continue; &#125; vector&lt;int> trend; int inc = -1, cnt = 0; for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; if(pre &lt; cur &amp;&amp; inc != 1) &#123; inc = 1; trend.emplace_back(inc), cnt ++; &#125;else if(pre == cur &amp;&amp; inc != 2)&#123; inc = 2; trend.emplace_back(inc), cnt ++; &#125;else if(pre > cur &amp;&amp; inc != 0)&#123; inc = 0; trend.emplace_back(inc), cnt ++; &#125; pre = cur; &#125; if(cnt == 1)&#123; cout &lt;&lt; "YES\n"; &#125; else &#123; int ans = 0; if ((trend[0] == 2 &amp;&amp; trend[1] == 1) || trend[0] == 1) ans++; if ((trend[cnt - 1] == 2 &amp;&amp; trend[cnt - 2] == 0) || trend[cnt - 1] == 0) ans++; for (int i = 0; i &lt; cnt; i++) &#123; if (trend[i] == 0) &#123; if(i + 1 &lt; cnt &amp;&amp; trend[i + 1] == 1) ans ++; if(i + 2 &lt; cnt &amp;&amp; trend[i + 1] == 2 &amp;&amp; trend[i + 2] == 1) ans ++; &#125; &#125; cout &lt;&lt; (ans == 1 ? "YES\n" : "NO\n"); &#125; &#125; return 0; &#125; 无脑模拟题，纯纯费时间 E. Binary Inversions题意给定一个二进制数组，定义操作为将任意元素 $x$ 改为 $1 - x$，在操作最多只能执行一次的情况下，输出逆序对个数的最大值。 思路显然，我们可以贪心地认为，我们只需找出最后一个 $1$ 和第一个 $0$，判断不执行操作以及只对这两个元素执行操作后的结果的最大值。 对于找逆序对，我们可以维护一个前缀 $1$ 个数的数组 $pre$ 和后缀 $0$ 个数的数组 $suf$，然后遍历所有的 $0$，统计 $1$ 个数即可。 对于最后一个 $1$ 的替换，价值为其前面 $1$ 的个数，代价为后面 $0$ 的个数。对第一个 $0$ 的替换同理。 当然，需要特判整个数组只有一种元素的情况，根据上面的逻辑，输出 $n - 1$ 即可。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], pre[N], suf[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; pre[0] = 0; //前面的1 suf[n + 1] = 0; //后面的0 int one = -1, zero = -1; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; pre[i] = pre[i - 1]; if(a[i] == 1) &#123; pre[i] ++; one = i; &#125;else if(zero == -1) zero = i; &#125; int ans = 0; for(int i=n;i>=1;i--)&#123; suf[i] = suf[i + 1]; if(a[i] == 0) &#123; suf[i] ++; ans += pre[i]; &#125; &#125; if(one == -1 || zero == -1) cout &lt;&lt; n - 1 &lt;&lt; '\n'; else &#123; int d1 = suf[zero] - 1 - pre[zero], d0 = pre[one] - 1 - suf[one]; cout &lt;&lt; max(ans, ans + max(d1, d0)) &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 依然是模拟（ F. Quests题意给定 $n$ 个操作，操作 $i$ 可以获得 $a_i$ 个硬币，每隔 $k$ 时间可以进行一次重复的操作。给定硬币的需求 $c$ 和限定的时间 $d$，输出在限定时间内满足硬币需求的最大 $k$。 若不存在该 $k$，输出 $impossible$；若 $k$ 无穷大，输出 $infinity$。 思路考虑到 $k$ 越大，能在 $d$ 天内获得的硬币数量会减小，存在单调性，因而我们不妨考虑二分答案。 我们可以贪心地认为，我们只需每隔 $k$ 输出降序排序后的前 $k$ 个数，因为一次性能获得的硬币更多，我们能间隔的时间就越长。 所以，我们只需 $check$ 一下按上述操作获得的 $d$ 天内的硬币数，进行二分即可。 当然，若最后的答案落在左边界，输出 $impossible$，落在右边界输出 $infinity$。 时间复杂度：$O(n log n + t log n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n, c, d; cin >> n >> c >> d; for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a, a + n, greater&lt;>()); int l = 0, r = d + 2, mid; while(l &lt;= r)&#123; mid = (l + r + 1) >> 1; if(mid == 0) break; int tot = 0; for(int i=0;i&lt;d;i++) if(i % mid &lt; n) tot += a[i % mid]; if(tot >= c) l = mid + 1; else r = mid - 1; &#125; if(r == d + 2) cout &lt;&lt; "Infinity\n"; else if(l == 0) cout &lt;&lt; "Impossible\n"; else cout &lt;&lt; r - 1 &lt;&lt; '\n'; &#125; return 0; &#125; 二分一下就好简单（（ G. SlavicG’s Favorite Problem题意给定一个带权值的无向无环图，给定两个点 $a, b$，定义 $x = 0$，从 $a$ 开始向子节点走，到达节点 $i$ 就会将 $x$ 修改为 $x\ XOR\ {w_i}$ 。在任意节点，可以选择传送到除 $b$ 外的任意节点，并继续走。输出是否存在一种路径，使到达 $b$ 后 $x = 0$。 思路考虑到异或的性质，我们不妨跑两遍 $Dfs$，用回溯搜索即可，每次搜索的起始 $x$ 值均为 $0$。 第一次搜索，我们从 $a$ 节点开始走，计算所有 $x$ 的可能值，用 $map$ 记录下来； 第二次搜索，我们从 $b$ 节点开始走，判断当前的 $x$ 和 $0$ 异或的值是否被记录过，若被记录过，那么我们一定可以用传送的方式使这两条路径联通，且最后答案符合要求。 当然，我们可以用邻接表存边。 时间复杂度：不会分析 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; struct Node&#123; int to, w; &#125;; vector&lt;Node> e[N]; bool vis[N], ans; map&lt;int, bool> mp; int n, a, b; void add(int u, int v, int w)&#123; e[u].push_back(&#123;v, w&#125;); e[v].push_back(&#123;u, w&#125;); &#125; void dfs1(int r, int v)&#123; if(vis[r] || r == b) return; vis[r] = true; mp[v] = true; for(auto x : e[r])&#123; dfs1(x.to, v ^ x.w); &#125; vis[r] = false; &#125; void dfs2(int r, int v)&#123; if(vis[r]) return; vis[r] = true; if(r != b &amp;&amp; mp[v ^ 0])&#123; ans = true; return; &#125; for(auto a : e[r])&#123; dfs2(a.to, v ^ a.w); &#125; vis[r] = false; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; cin >> n >> a >> b; for(int i=1;i&lt;=n;i++) e[i].clear(), vis[i] = false; for(int i=1;i&lt;n;i++)&#123; int u, v, w; cin >> u >> v >> w; add(u, v, w); &#125; mp.clear(); dfs1(a, 0); ans = false; dfs2(b, 0); cout &lt;&lt; (ans ? "YES\n" : "NO\n"); &#125; return 0; &#125; 简简单单的思维 + dfs]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 836 Div 2</title>
    <url>/blog/posts/959544692/</url>
    <content><![CDATA[Practice. A. SSeeeeiinngg DDoouubbllee题意给定一个字符串，将字符串复制一遍后拼接在一起得到一个新的字符串，将该字符串重新组合，输出一种回文组合。 思路倒着拼到末尾。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; String s = scanner.next(); System.out.println(s + new StringBuilder(s).reverse()); &#125; &#125; &#125; 过于无脑 B. XOR = Average题意给定一个整数 $n$，构造一个长度为 $n$ 的无重复元素的数组 $a$，满足 $1 \leq a \leq 10 ^ 9$ 以及所有数的异或值等于平均值，即 $a_1 \oplus a_2 \oplus \dots \oplus a_n = \frac{a_1 + a_2 + \dots + a_n}{n}$。 输出数组的任意一种构造。 思路我们来考虑奇偶性： $n$ 为奇数时，我们只需输出 $n$ 个 $1$，此时恰好满足条件； $n$ 为偶数时，考虑到 $1, 3$ 的平均数为 $2$，异或值也为 $2$，而偶数个相同数的异或值为 $0$，所以我们不妨输出 $1,3$，以及 $n - 2$ 个 $2$，即可满足条件。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); if(n % 2 == 1)&#123; for(int i=0;i&lt;n;i++) System.out.print("1 "); System.out.println(); &#125;else&#123; System.out.print("1 3 "); for(int i=0;i&lt;n-2;i++) System.out.print("2 "); System.out.println(); &#125; &#125; &#125; &#125; 小的就足矣 C. Almost All Multiples题意给定整数 $n, x$，构建一个字典序最小的排列 $p$，满足下面的条件： $p_1 = x, p_n = 1$； $p_i \% i = 0$。 思路显然，若不考虑条件，那么我们肯定会输出一个递增的排列。 当我们考虑条件后，我们不难发现 $n$ 多余了，而 $x$ 所在的原位置留空了。 但是，我们不可以直接将 $x$ 的位置放上 $n$，因为我们需要考虑下面的两个条件： $p_x = n =&gt; n \% x$； 字典序最小 对于条件 $1$，若不满足，输出 $NO$ 即可。 对于条件 $2$，我们不难发现，当 $n$ 的因数比较多的时候，满足 $n \% kx$ 的 $k$ 可以有好多个，此时若 $x$ 位置放上 $n$，所得到的字典序不一定是最小的。 我们来举一个例子： 1 12 2 此时，字典序最小的应为下述输出： 2 4 3 12 5 6 7 8 9 10 11 1 因此，我们不妨循环操作，对于 $x$，找出第一个满足 $n \% kx, k \geq 2$ 的 $k$，将 $p_i$ 修改为 $kx$、$x$ 的值替换为 $kx$ ，然后继续循环，直到 $x \geq x$。 时间复杂度：不知道 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n, x; cin >> n >> x; if(n % x != 0) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; vector&lt;int> ans(n); for(int i=1;i&lt;n-1;i++) ans[i] = i + 1; ans[n - 1] = 1; ans[0] = x; while(x &lt; n)&#123; for(int i=x*2;i&lt;=n;i+=x) &#123; if(n % i == 0)&#123; ans[x - 1] = i; x = i; break; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 一开始还真想着去直接交换了（ D. Range = √Sum题意给定一个整数 $n$，构建一个无重复元素的数组 $a$，满足 $1 \leq a_i \leq 10 ^ 9$，以及下面的式子： $\max(a_1, a_2, \dots, a_n) - \min(a_1, a_2, \dots, a_n)= \sqrt{a_1 + a_2 + \dots + a_n}$。 思路我们来讨论 $n$ 的奇偶性： 当 $n$ 为偶数的时候，我们只需构建一个 $[n / 2, n / 2 + 1, \ldots, n - 1, n + 1, n + 2, \ldots, 3n / 2]$ 即可。 当 $n$ 为奇数的时候，我们按照上述逻辑构建一个中间值为 $n$，向两端递减 $1$ 的数组，此时，左边为 $n$，右边为 $\sqrt {n (n + 1)}$。 那么，我们希望构建一个数组，满足左右两边均为 $n + 1$。 我们执行下面的操作： ① 整个数组 $+1$； ② 左边界 $-1$，右边界 $+1$； ③ 倒数第二个数 $+1$。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; if(n % 2 == 0) &#123; for(int i=n/2;i&lt;=n-1;i++) cout &lt;&lt; i &lt;&lt; ' '; for(int i=n+1;i&lt;=3*n/2;i++) cout &lt;&lt; i &lt;&lt; ' '; &#125; else &#123; vector&lt;int> ans(n); iota(ans.begin(), ans.end(), (n + 5) / 2); ans[0]--; ans[n - 1]++; ans[n - 2]++; for (int i = 0; i &lt; n; i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; return 0; &#125; 好一个思维 + 构造]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Polynomial Round 2022 Div 1 plus 2</title>
    <url>/blog/posts/266401019/</url>
    <content><![CDATA[Practice. 代码略去了快读模板 A. Add Plus Minus Sign题意给定一个长度为 $n$ 的二进制字符串，输出 $n-1$ 个加减运算符，满足最后的结果的绝对值最小。 思路无视第一位，配对 $1,1$，对每一对输出 $-,+$，剩余的 $1$ 输出 $-$，剩余的 $0$ 输出任意符号。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; int n = console.nextInt(); char[] input = console.next().toCharArray(); int pre = -1, now = input[0] - '0'; char[] ans = new char[n - 1]; if(now == 1) pre = -2; for(int i=0;i&lt;n-1;i++)&#123; now = input[i + 1] - '0'; if(now == 0) ans[i] = '+'; else&#123; if(pre == -1) pre = i; else&#123; if(pre != -2) ans[pre] = '+'; ans[i] = '-'; pre = -1; &#125; &#125; &#125; if(pre != -1 &amp;&amp; pre != -2) ans[pre] = '+'; console.println(String.valueOf(ans)); &#125; console.close(); &#125; &#125; 略微简单的打卡题 B. Coloring题意给定 $m$ 种颜色的数量，总量为 $n$，将长度为 $n$ 的序列染上色，满足所有长度为 $k$ 的连续子序列内没有相同的颜色，输出方案是否存在。 思路我们不妨开一个数组记录所有的数量，然后降序排序。 显然，若一个颜色 $p$ 在 $x$ 位置出现了，那么在 $[x + 1, x + k - 1]$ 内都不能出现 $p$，那么我们不妨将序列按 $k$ 分段，那么段数即为 $d = \lceil \frac{n}{k} \rceil$。 遍历排序后的数组，若 $a_i &gt; d$，那么就是无解的，输出 $NO$ 即可，否则，我们只需将剩余的最少的颜色取出来和它一起配对为一个长为 $d$ 的组合。 当然，配对次数过多时，我们会发现段数会减少 $1$，此时若能满足条件，就可以直接输出 $YES$ 了。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; int n = console.nextInt(), m = console.nextInt(), k = console.nextInt(); Integer[] a = new Integer[m]; for(int i=0;i&lt;m;i++) a[i] = console.nextInt(); Arrays.sort(a, Comparator.comparingInt(o -> -o)); int d = n / k + (n % k == 0 ? 0 : 1), l = n % k; boolean ans = true; for(int i=0;i&lt;n;i++)&#123; int cur = a[i]; if(cur > d) &#123; ans = false; break; &#125; if(l == 0) break; l --; if(l == 0) d --; &#125; console.println(ans ? "YES" : "NO"); &#125; console.close(); &#125; &#125; 有点小贪心，因为不用考虑拿什么出来组合 C. Ice and Fire题意对于 $n$ 个选手，选手 $i$ 的能力值为 $i$。给定一个长为 $n - 1$ 的二进制字符串 $s$，$s_i$ 表示第 $i$ 次比赛的输赢判定，$0$ 则能力值低者胜，否则高者胜。对于所有 $x \in [2,n]$，输出选择不超过 $x$ 个选手进行比赛，最后有多少个选手有机会成为胜者。 比赛机制为选择任意两个选手进行比赛，直至剩余最后一人，判定该选手为胜者。 思路显然地，最后的获胜情况和最后一个输赢判定有直接关系。 更进一步地说，最后一段相同连续区间的长度决定了胜者的数量。 举一个例子，若 $s$ 为 $\ldots,1,0,0,0,0$，那么能力值最大的三个选手一定不可能成为赢家，而恰好剩余的选手经过一定的排序都可以成为赢家。 因而，我们唯一关心的就是从后往前第一个不同的字符出现的位置，对于所有 $x$，输出数量即可。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; int n = console.nextInt(); char[] in = console.next().toCharArray(); int p0 = 1, p1 = 1; for(int i=1;i&lt;n;i++)&#123; int now = in[i - 1] - '0'; if(now == 0)&#123; p0 = i + 1; console.print(p1 + " "); &#125;else&#123; p1 = i + 1; console.print(p0 + " "); &#125; &#125; console.println(); &#125; console.close(); &#125; &#125; 想通了就很简单的思维题]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 139</title>
    <url>/blog/posts/1807504053/</url>
    <content><![CDATA[Practice. A. Extremely Round题意给定一个整数 $n$，输出 $[1,n]$ 内只有一位非 $0$ 的数的个数。 思路显然，对于 $t$ 位，有 $9$ 个满足要求的数，我们只需考虑到何时停下枚举即可。 时间复杂度：$O(log_{10} n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int a = n, tot = 0; while(a >= 10) a /= 10, tot ++; cout &lt;&lt; tot * 9 + a &lt;&lt; '\n'; &#125; return 0; &#125; 简单打卡题 B. Notepad#题意给定一个长为 $n$ 且由小写字母构成的字符串，输出是否存在两段及以上长度大于等于 $2$ 的相同连续子序列。 思路我们不妨只寻找长为 $2$ 的重复子串，也就是说我们只需记录 $n - 1$ 对子序列的情况。我们可以边记录边向后遍历，并判断当前字母以及前一个字母是否在之前被记录过，若记录过则输出存在即可。 此处我们需要排除如下情况：$hhh$，此处不满足题意但会被误判为 $YES$，因而我们可以记录该子串在当前状态之前最近被统计的位置，然后判断位置是否和当前位置出现了交集即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 30; int a[N][N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; string cur; cin >> cur; cur = ' ' + cur; memset(a, 0, sizeof a); bool ok = false; for(int i=1;i&lt;n;i++)&#123; int o1 = cur[i] - 'a', o2 = cur[i + 1] - 'a'; if(a[o1][o2] != 0 &amp;&amp; a[o1][o2] != i - 1) &#123; ok = true; break; &#125; if(a[o1][o2] == 0) a[o1][o2] = i; &#125; cout &lt;&lt; (ok ? "YES" : "NO") &lt;&lt; '\n'; &#125; return 0; &#125; WA了好几遍捏 C. Hamiltonian Wall题意给定一个长为 $n$，宽为 $2$ 的矩阵，矩阵元素为 $B$ 或 $W$，输出是否可以从最左边列的某个元素 $B$ 开始一笔画，在不重复经过同一个元素以及不经过元素 $W$ 的前提下连接所有元素 $B$。不可以沿对角线连接。 思路我们可以直接模拟，判断前者的入口在何处，若出现冲突就直接输出 $NO$。 具体按照下面的方法模拟： 找出第一个不是 $BB$ 的列； 将入口更新为 $B$ 出现的位置； 若相邻出现 $WB,BW$ 或 $BW,WB$，输出 $NO$; 若出现多个 $BB$，根据奇偶性判断之后的入口； 遇到 $WW$ 直接输出 $NO$。 无冲突输出 $YES$。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; bool a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; char c; cin >> t; while(t --)&#123; cin >> n; for(int i=0;i&lt;n;i++)&#123; cin >> c; a[i] = c == 'B'; &#125; bool f = false, ans = true; int pre; cin >> c; if(a[0] &amp;&amp; c == 'B') pre = 2, f = true; else if(a[0]) pre = 0; else if(c == 'B') pre = 1; else pre = -1; for(int i=1;i&lt;n;i++)&#123; cin >> c; if(!ans) continue; int now; if(a[i] &amp;&amp; c == 'B') now = 2; else if(a[i]) now = 0; else if(c == 'B') now = 1; else now = -1; if(f &amp;&amp; now == 2) continue; f = false; if((pre == -1 &amp;&amp; now != -1) || (pre == 0 &amp;&amp; now == 1) || (pre == 1 &amp;&amp; now == 0))&#123; ans = false; continue; &#125; if(now == 2) now = 1 - pre; pre = now; &#125; cout &lt;&lt; (ans ? "YES" : "NO") &lt;&lt; '\n'; &#125; return 0; &#125; 太模拟了，不过貌似一笔画不止可以暴力模拟（]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 852 Div 2</title>
    <url>/blog/posts/185684192/</url>
    <content><![CDATA[Contestant(alt). Rank 6738. Rating -86 (+414 -500). A. Yet Another Promotion题意定义两天内提供购物服务，每天的货物价格分别为 $a, b$，在第一天存在促销活动，购买 $m$ 个货物后会赠送一个。输出购买 $n$ 个货物的最少花费。 思路对于 $m+1$ 个所需货物，$m \times a $ 和 $(m + 1) \times b$ 分别为第一天和第二天的价格，那么我们只需分类讨论即可： 前者小，那么我们将能参与促销的货物全都在第一天购买，也就是总共有 $\lfloor \frac{n}{m + 1} \rfloor \times m$ 个货物是参与了促销。此时，我们得到了 $\lfloor \frac{n}{m + 1} \rfloor \times (m + 1)$ 个货物，那么剩余的货物就作为正常购买，我们用 $min(a,b)$ 购买即可； 后者小，直接全都在第二天买即可。 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a, b, n, m; cin >> a >> b >> n >> m; cout &lt;&lt; min(n * b, (n / (m + 1)) * m * a + (n - (n / (m + 1)) * (m + 1)) * min(a, b)) &lt;&lt; '\n'; &#125; return 0; &#125; 一个大铸币没看懂题卡了半天 B. Fedya and Array题意给出如下定义： 若一个元素的相邻元素都比它大，那么定义其为 local minimum；若一个元素的相邻元素都比它小，那么定义其为 local maximum。 给定一个首尾相连的序列中 local maximum 的总和和 local minimum 的总和 $x, y$，构建该序列，满足相邻数相差 $1$，且长度最短。 思路显然，$y, y-1, \ldots , x , x + 1 , \ldots, y - 1$ 一定是一个符合条件的序列，下面我们来证明一下可行性： 若 $a_i$ 和 $b_i$ 为相邻的 local maximum 和 local minimum ，那么对于 $a_i$，想要得到 $b_i$，就必须得有 $a_i - b_i$ 个数字，因而我们可以得到下面的式子： $len = (a_1 - b_1) + (a_2 - b_1) + (a_2 - b_2) + \ldots + (a_k - b_k) + (a_1 - b_k)$ 化简即可得到 $2(x - y)$，证毕。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(0); int t, x, y; cin >> t; while(t --)&#123; cin >> x >> y; vector&lt;int> ans; for(int i=x;i>y;i--) ans.emplace_back(i); for(int i=y;i&lt;x;i++) ans.emplace_back(i); cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto &amp;i : ans) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; return 0; &#125; 好妙的做法 C. Dora and Search题意给定一个排列，输出一段连续区间的左右端点的下标，满足两个端点既不是区间内的最大值，也不是区间内的最小值。 思路我们可以用类似双指针的方法，从两侧开始夹逼，只要去除区间外的点后，最大值和最小值都不在端点，那就直接输出。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(0); int t, n; cin >> t; while(t --)&#123; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; int l = 0, r = n - 1, vl = 1, vr = n; while(l &lt;= r)&#123; if(a[l] == vl) l ++, vl ++; else if(a[l] == vr) l ++, vr --; else if(a[r] == vl) r --, vl ++; else if(a[r] == vr) r --, vr --; else break; &#125; if(l &lt;= r) cout &lt;&lt; l + 1 &lt;&lt; ' ' &lt;&lt; r + 1 &lt;&lt; '\n'; else cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; return 0; &#125; 不是排列的话就只有找拐点了]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 851 Div 2</title>
    <url>/blog/posts/989416061/</url>
    <content><![CDATA[Contestant. Rank 2691. Rating +7. A. One and Two题意给定一个包含 $1$ 和 $2$ 的数组，输出最小的 $k$，满足 $a1 \cdot a_2 \cdot \ldots \cdot a_k = a{k+1} \cdot a_{k+2} \cdot \ldots \cdot a_n$。 思路维护一个后缀和，统计前面和后面的 $2$ 的个数，输出第一个 $k$，满足 $2$ 的个数一致。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; int a[N], suf[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; memset(a, 0, sizeof a); memset(suf, 0, sizeof suf); for(int i=1;i&lt;=n;i++)cin >> a[i]; for(int i=n;i>=1;i--) &#123; suf[i] = suf[i + 1]; if(a[i] == 2) suf[i] ++; &#125; int tot = 0; bool f = true; for(int i=1;i&lt;n;i++)&#123; if(a[i] == 2) tot ++; if(tot == suf[i + 1])&#123; cout &lt;&lt; i &lt;&lt; '\n'; f = false; break; &#125; &#125; if(f) cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; return 0; &#125; 你一个大铸币是怎么会想着纯模拟的啊（（ B. Sum of Two Numbers题意给定一个整数 $n$，定义 $f(x) = x十进制下每位之和$，输出任意两个数 $x,y$，满足 $x + y = n, |f(x)-f(y)| \leq 1$。 思路1我们不妨除以 $2$，此时，若 $n$ 为偶数，直接输出。 若 $n$ 为奇数，则不可避免会出现十位不相同的情况（进位了）。此时，我们不妨遍历所有 $i$，将大的数减 $5$，小的数加 $5$，那么最后一定可以找到一组满足条件的数。 对上述思路的证明我们令除 $2$ 之后较小的数为 $a$，较大的数为 $b$。 首先，我们只需考虑 $n$ 的个位为 $9$ ，且十位为奇数的情况，此时 $a+1$ 存在向前进位。那么，我们希望能尽量让 $a$ 的高位总和降低，并让 $b$ 的高位总和提高。 考虑到个位为 $9$，那么我们不妨先让 $a$ 和 $b$ 的个位分别变为 $4$ 和 $5$，这样我们只需让高位的所有数之和相等，或者 $a$ 的高位之和比 $b$ 的高位之和大 $1$。 那么，我们来考虑高位的情况： 若 $n$ 的十位小于 $9$，不难发现，我们只需让 $a$ 的十位变为 $b$ 的十位加一，这样可以让 $a,b$ 的所有位之和相等，也就是说，只要输出 $a+5,b-5$ 即可； 若 $n$ 的十位为 $9$，那么事态发生了微妙的变化：存在进 $2$ 位的情况了。但，只要百位不是奇数，我们依然可以按照情况 $1$ 找出一个答案； 若 $n$ 的十位为 $9$，百位为奇数，且千位不为 $9$ 时，那么按照上述操作后，$a+5$ 存在进 $1$ 位的情况，方案不成立了； 此时，有趣的现象出现了：$a+5$ 和 $b-5$ 恰好差了 $9$，那么我们不妨把个位改为 $9, 0$，此时，我们可以构造出 $a+10,b-10$，满足差值为 $1$； 当千位、乃至更高位都为 $9$ 时，差值会更大，但根据打表我们不难发现，$a+5$ 和 $b-5$ 的差值均为 $9$ 的倍数，那么我们只要让高位的差值降低，最后一定能得到解。 时间复杂度：懒得分析 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; int a[N], suf[N]; int cal(int x)&#123; int res = 0; while(x > 0)&#123; res += x % 10; x /= 10; &#125; return res; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; int p = n / 2, q = n - p; while(abs(cal(p) - cal(q)) > 1) p += 5, q -= 5; cout &lt;&lt; p &lt;&lt; ' ' &lt;&lt; q &lt;&lt; '\n'; &#125; return 0; &#125; 思路2按照上述证明的思路，我们可以找出一个规律： 首先，偶数直接输出 $\frac{n}{2},\frac{n}{2}$； 其次，个位不是 $9$，直接输出 $\frac{n}{2},n-\frac{n}{2}$； 否则，从证明思路，我们可以发现，以 $10$ 为单位枚举从 $9$ 开始的所有数，需要加减 $5$ 的次数每隔 $20,200,2000 \ldots$ 会变为一个特定值，该值我们可以打表找出，记该数组为 $ans$。 因此，对于该情况，我们只需从低位向高位枚举，找出第一个不是 $9$ 的位置 $cnt$，以及该位置的数 $val$。若 $val$ 为偶数，那么加减 $ans[cnt-1] \times 5$，否则加减 $ans[cnt] \times 5$。 时间复杂度：$O(log_{10} n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; int ans[10] = &#123;0, 1, 2, 10, 18, 100, 180, 1000, 1800, 10000&#125;; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; if(n % 2 == 0) cout &lt;&lt; n / 2 &lt;&lt; ' ' &lt;&lt; n / 2 &lt;&lt; '\n'; else if(n % 10 != 9) cout &lt;&lt; n / 2 &lt;&lt; ' ' &lt;&lt; n - n /2 &lt;&lt; '\n'; else&#123; int p = n / 2, q = n - p; int cnt = 0; while(n % 10 == 9) n /= 10, cnt ++; int val = n % 10; if(val == 0) val = 9, cnt --; if(val % 2 == 0) cout &lt;&lt; p + ans[cnt - 1] * 5 &lt;&lt; ' ' &lt;&lt; q - ans[cnt - 1] * 5 &lt;&lt; '\n'; else cout &lt;&lt; p + ans[cnt] * 5 &lt;&lt; ' ' &lt;&lt; q - ans[cnt] * 5 &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 我好蠢 C. Matching Numbers题意给定一个整数 $n$，配对 $1,2n$ 内的所有数，使 $n$ 对数的和按照升序排列后单调递增，且相邻数相差 $1$。输出一种配对。 思路我们不难发现，若是偶数的话，我们是找不出这个序列的，可以通过计算验证。 对于奇数的话，我们可以根据等差公式算出中间的值 $2n+1$，而对于右边的数，我们不妨将小的数加上 $2$，大的数减去 $1$，这样就可以满足差值为 $1$，那么，如果中间的那对数为 $1,2n$，那么刚好右边可以组成 $\frac{n}{2}$ 对，而剩下的数，我们恰好可以得到两对连续的数字，将小的和大的相加，恰好就是我们想要的。 输出即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; int a[N], suf[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; if(n % 2 == 0) cout &lt;&lt; "No\n"; else&#123; cout &lt;&lt; "YES\n"; for(int i=1;i&lt;=n/2+1;i++)&#123; cout &lt;&lt; i * 2 - 1 &lt;&lt; ' ' &lt;&lt; 2 * n - i + 1 &lt;&lt; '\n'; &#125; for(int i=1;i&lt;=n/2;i++)&#123; cout &lt;&lt; i * 2 &lt;&lt; ' ' &lt;&lt; 2 * n - i - n / 2 &lt;&lt; '\n'; &#125; &#125; &#125; return 0; &#125; md，思路很清晰但wa了一发 D. Moving Dots题意给定 $n$ 个数轴上升序排序的点，所有点在同一时刻以相同的速度向与相邻数差值最小的数的方向移动（若差值相同，向左移动），两点相遇则停止移动。对于所有可不连续的子序列，统计每个子序列最后汇聚的点的个数，并输出总数。 思路我们将问题转化为：对于所有 $[i,j]$ 内让点汇聚到两个及以上点的区间，排除这个区间内的所有数，剩下的数一定会汇聚到一个点，那么对于每个点，有选与不选两种情况，因此最后输出 $2^p$，$p$ 为剩余的数的数量。 那么，对于这个区间的确定，我们不妨来考虑下面的两种情况： 对于汇聚到左边的点，最左边的点 $i$ 应该向右边移动，那么我们找出从 $i$ 开始，往前找第一个向左移动的即可，也就是说，应满足 $k &lt; x_i, x_i - k \leq x_j - x_i$。 同理，满足 $k &gt; x_j,k - x_j &lt; x_j - x_i$。 综上，$2x_i - x_j \leq k &lt; 2x_j - x_i$。 考虑到单调性，我们可以用二分查找。 时间复杂度：$O(n^2 log n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 3010; int x[N], pows[N], mod = 1e9 + 7; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin >> n; pows[0] = 1; for(int i=1;i&lt;=n;i++) &#123; //Awesome but strange solution from the official tutorial. cin >> x[i]; pows[i] = (pows[i - 1] * 2) % mod; &#125; int ans = 0; for(int i=1;i&lt;n;i++) for(int j=i+1;j&lt;=n;j++) &#123; int l = lower_bound(x + 1, x + n + 1, 2 * x[i] - x[j]) - (x + 1), r = lower_bound(x + j + 1, x + n + 1, 2 * x[j] - x[i]) - x; ans = (ans + pows[n - r + l + 1]) % mod; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0; &#125; 妙啊]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 140</title>
    <url>/blog/posts/1562475734/</url>
    <content><![CDATA[Practice. A. Cut the Triangle题意给定三个点，判断是否存在水平或数值的切割线，能将三个点所构成的三角形切割成两个三角形。 思路很显然，我们只需判断是否存在直角三角形即可。 因为我们不知道哪个是直角，所以我们不妨找出所有 $x$ 轴值相等的点和 $y$ 轴相等的点。 更具体地说，我们统计一下满足上述条件的点，若为 $1$ 个及以下，那么就可行，否则不可行。 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 110; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int x1, y1, x2, y2, x3, y3; cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3; cout &lt;&lt; ((x1 == x2 || x2 == x3 || x1 == x3) &amp;&amp; (y1 == y2 || y2 == y3 || y1 == y3) ? "NO" : "YES") &lt;&lt; '\n'; &#125; return 0; &#125; 简简单单打卡题 B. Block Towers题意给定 $n$ 个柱子，定义操作为选定两个大小不相等的柱子，并将大的柱子的一个方块移到小的柱子上。在任意次操作后，输出第一个柱子可能的最大方块数量。 思路我们不妨直接排个序，然后找出第一个柱子的位置，并模拟。 当然，找位置可以用二分。 时间复杂度：$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; int a0 = a[0]; sort(a, a + n); int t = upper_bound(a, a + n, a0) - a; for(int i=t;i&lt;n;i++)&#123; if(a[i] > a0) a0 += (a[i] - a0 + 1) / 2; &#125; cout &lt;&lt; a0 &lt;&lt; '\n'; &#125; return 0; &#125; 好模拟 C. Count Binary Strings题意给定一个数字 $n$，以及指定的约束，构造一个二进制字符串。 对于 $n$ 行输入，第 $i$ 行有 $n - i + 1$ 个数字。 第 $i$ 行第 $j$ 列元素的值表示 $[i+j-1, n]$ 区间内容满足下面的约束： 值为 $1$，那么区间内所有元素必须一致； 值为 $2$，那么区间内至少存在一个数和其他数不同； 值为 $0$，无约束。 输出在上述约束下能构造多少个字符串。 思路我们不难发现，要构造出不同的字符串，那么该位必须可以选 $0$ 和 $1$。 又或者说，对于点 $i$，我们需要知道 $[1,i-1]$ 之间有多少和 $i$ 不同的值。 考虑到前者的约束会影响后者，我们不妨考虑 $dp$。 我们可以枚举所有 $i$，与其不同的元素位于 $j$（当然，如果没有这个元素，$j=0$ 即可），那么我们可以找出下面两种情况： 当前位和前一位相同，那么 $dp[i+1][j]\ += dp[i][j]$； 当前位和前一位不同，那么 $dp[i+1][i]\ += dp[i][j]$。 接下来，我们来考虑约束： 对于约束右区间为 $i$： 首先，对于情况 $1$，我们不能让 $j$ 前面的约束存在 $1$，也不能让后面的约束存在 $2$，这样我们可以判断 $dp[i][j]$ 是否可行，也可以判断 $dp[i+1][j]$ 是否成立。 其次，对于情况 $2$，我们也不能让 $i$ 之前的约束存在 $1$，否则 $dp[i+1][i]$ 不成立。 满足上述条件后，对于递推的结果，枚举所有不同的点，右区间为 $n$，求和即可。 时间复杂度：$O(n^3)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 110, mod = 998244353; int a[N][N], dp[N][N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin >> n; for(int i=0;i&lt;n;i++) for(int j=i;j&lt;n;j++) cin >> a[i][j]; if(a[0][0] != 2) dp[1][0] = 2; for(int i=1;i&lt;n;i++) for(int j=0;j&lt;i;j++)&#123; bool f = true; for(int k=0;k&lt;j;k++)&#123; if(a[k][i] == 1) f = false; &#125; for(int k=j;k&lt;=i;k++)&#123; if(a[k][i] == 2) f = false; &#125; if(f) dp[i + 1][j] = ((dp[i + 1][j] % mod) + (dp[i][j] % mod)) % mod; f = a[i][i] != 2; if(f) for(int k=0;k&lt;i;k++)&#123; if(a[k][i] == 1) f = false; &#125; if(f) dp[i + 1][i] = ((dp[i + 1][i] % mod) + (dp[i][j] % mod)) % mod; &#125; int ans = 0; for(int i=0;i&lt;n;i++) ans = (ans % mod + dp[n][i] % mod) % mod; cout &lt;&lt; ans; //好绕 return 0; &#125; 难死了，md D. Playoff题意给定一个整数 $n$，对于一个任意 $2^n$ 的排列，存在 $n$ 场比赛，$2i$ 和 $2i+1$ 进行比赛，满足下述比赛规则，获胜者进入下一轮，直到决出最后的胜利者。输出对于任意排列，胜利者会是哪些人。 规则：给定一个长度为 $n$ 的二进制字符串，第 $i$ 位决定了第 $i$ 场比赛的输赢。若值为 $0$ ，那么数值小的一方获胜，否则数值大的一方获胜。 思路我们不妨先来找规律： 对于题例数据，我们不难发现，统计一下 $1$ 的个数 $x$ 和 $0$ 的个数 $y$，答案即为 $[2^x,2^n-2^y+1]$ 内的所有数。 下面给出证明： 首先，我们不难发现，交换字符串某两位的位置，对最后两端的输赢是无影响的，只会决定最后的赢家； 并且，当值为 $1$ 的时候，一定是大一点的值获胜，为 $0$ 时一定时小一点的值获胜。 换句话说，决定了 $1$ 和 $0$ 的个数后，升序排序下两端一定范围内的值是一定不会取到的，因为在多场比赛后，一定会被筛去。 而正好相反地，除去这些一定会被筛去的值，剩余值一定有一种排列可以使它们成为赢家，因此证明了结论的正确性。 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin >> n; int x = 0, y = 0; for(int i=0;i&lt;n;i++)&#123; char now; cin >> now; if(now == '1') x ++; else y ++; &#125; for(int i=(1 &lt;&lt; x);i&lt;=((1 &lt;&lt; n) - (1 &lt;&lt; y) + 1);i++) cout &lt;&lt; i &lt;&lt; ' '; return 0; &#125; 妥妥一个找规律（（]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 光棍新生欢乐赛</title>
    <url>/blog/posts/137870688/</url>
    <content><![CDATA[Rank 1. AC 4/9. 因为11.11为四根棍，所以注定只能写四题 A. 乘方 CSP 2022 T1题意比较 $a ^ b$ 和 $10 ^ 9$ 的大小关系。 思路1 try-catch用大数算法直接算，如果算得出来，那就比较；算不出来，也就是溢出了，那么一定是大于 $1e9$ 的，利用语言特性，捕获这个异常然后输出 $-1$ 即可。 对应AC代码import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); try&#123; BigInteger a = new BigInteger(scanner.next()); int b = scanner.nextInt(); BigInteger ans = a.pow(b); if(ans.compareTo(BigInteger.valueOf(1000000000L)) > 0) System.out.println(-1); else System.out.println(ans); &#125;catch(Throwable e)&#123; System.out.println(-1); //投机取巧.jpg &#125; &#125; &#125; 思路2很简单，我们只需要循环 $b$ 次把 $a$ 乘上自己，判断一下是否大于 $1e9$ 即可。 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(), b = scanner.nextInt(); long ans = 1L; for(int i=0;i&lt;b;i++) &#123; ans *= a; if(ans > 1000000000L) &#123; System.out.println(-1); return; &#125; &#125; System.out.println(ans); &#125; &#125; 对思路2的优化可以使用快速幂降低时间复杂度。 注意：可能会爆long long，用大数解。 对应AC代码import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); BigInteger weight = BigInteger.valueOf(scanner.nextLong()); int b = scanner.nextInt(); BigInteger ans = BigInteger.ONE; while(b > 0)&#123; if(b % 2 == 1) &#123; //二进制非递归快速幂 ans = ans.multiply(weight); if(ans.compareTo(BigInteger.valueOf(1000000000L)) > 0) &#123; System.out.println(-1); return; &#125; &#125; weight = weight.multiply(weight); //这里在测试点9会爆long b >>= 1; &#125; System.out.println(ans); &#125; &#125; 怎么能叫投机取巧呢（ B. 解密 CSP 2022 T2题意对于方程组 $n = p q$ , $ed = (p - 1) (q - 1) + 1$，给定 $n, d, e$，解方程并输出 $p, q$。 思路 化简第二个式子得到 $p + q = n - e d + 2$，设其为 $m$. 由第一个式子得到 $p = \frac{n}{q}$. 由1和2，$\frac{n}{q} + q = m =&gt; q ^ 2 - m q + n = 0$. 求 $\triangle = m ^ 2 - 4 n$，$\triangle &lt; 0$ 即为无解的第一种情况. 运用求根公式求出 $p, q$，$p$ 和 $q$ 不为整数为无解的第二种情况，为整数就输出. 注意点： 肉眼可见会爆 $int$，用长整型. 不要用 $java$，会 $tle$. 对应AC代码#include &lt;bits/stdc++.h> using namespace std; int main()&#123; int k; long long n, d, e; scanf("%d", &amp;k); for(int w=0;w&lt;k;w++)&#123; scanf("%lld %lld %lld", &amp;n, &amp;d, &amp;e); long long m = n + 2 - e * d; long long delta = m * m - 4 * n; if(delta &lt; 0) printf("NO\n"); else &#123; double p = (m - sqrt(delta)) / 2, q = (m + sqrt(delta)) / 2; if((int) p != p || (int) q != q) printf("NO\n"); else printf("%d %d\n", (int) p, (int) q); &#125; &#125; &#125; 简简单单数学题 C. 报数 NOIP 2021 提高组题意 某数字为 $x$ 的倍数， $x$ 的特点是至少有一位有 $7$ (与 $7$ 相关)，则该数字不能被报出。 报到与 $7$ 相关的数，输出 $-1$，否则输出下一个非 $7$ 相关的数。 思路做一个类似于埃氏筛的预处理。 我们用类似于埃氏筛的思路，筛掉与 $7$ 相关的数的倍数。 开一个数组，记录下一个非 $7$ 相关的数，否则赋值为自己（或者可以是任意非正数）。 读它。 值得注意的是，$1e7$ 后面第一个非 $7$ 相关的数是 $10000010$，所以我们不妨开 $1e7+11$ 大小的数组，防止溢出。 对应AC代码import java.util.*; public class Main&#123; private static boolean relate(int x)&#123; //是否与7相关 while(x > 0)&#123; if(x % 10 == 7) return true; x /= 10; &#125; return false; &#125; private static int[] preTreat()&#123; int[] next = new int[10000011]; for(int i=1;i&lt;10000011;i++)&#123; if(next[i] == 0 &amp;&amp; relate(i))&#123; //类似于埃氏筛 for(int j=1;i*j&lt;10000011;j++) next[i * j] = 1; &#125; &#125; int last = 1; for(int i=2;i&lt;10000011;i++)&#123; if(next[i] == 0)&#123; next[last] = i; last = i; &#125; else next[i] = i; //反正只要后面可以特判就行 &#125; return next; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); int[] next = preTreat(); for(int w=0;w&lt;t;w++)&#123; int cur = scanner.nextInt(); System.out.println(next[cur] == cur ? -1 : next[cur]); &#125; &#125; &#125; 算是第一次接触数论了（ D. 逻辑表达式 CSP 2022 T3题面在编程语言中，存在逻辑表达式“短路”的现象，如：当判断 $\&amp;$ 时，若前面为 $false$，那么后面的条件直接不判断了。 给定一个由 $0$、$1$、$\&amp;$ 、 $|$ 和括号组成的逻辑表达式，其中 $1$ 和 $0$ 分别表示真与假。输出表达式的结果，以及形如 $a \&amp; b$ 和 $a | b$ 的短路各出现了几次。 思路1 expr可以用类似于求中缀表达式的值的思路来做。 中缀表达式转后缀表达式 建立表达式树 计算并统计 这个方法码量有点大，dfs有点深，只能上cpp了（ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; struct Node&#123; int val, left, right; &#125;; int ansAnd = 0, ansOr = 0, nodeSize = 0; vector&lt;Node> nodes; //expr 中缀转后缀 vector&lt;int> toSuffix(const string&amp; mid) &#123; vector&lt;int> ex; stack&lt;char> ts; map&lt;char, int> pri; pri['&amp;'] = 4; pri['|'] = 3; pri['('] = 2; for (char each : mid) &#123; if (each == '@') &#123; while (!ts.empty()) ex.push_back(pri[ts.top()]), ts.pop(); break; &#125; else if (each >= '0' &amp;&amp; each &lt;= '9') ex.push_back(each - '0'); else &#123; if (each == '(') ts.push(each); else if (each == ')') &#123; while (ts.top() != '(') ex.push_back(pri[ts.top()]), ts.pop(); ts.pop(); //弹出左括号 &#125; else &#123; while (!ts.empty() &amp;&amp; pri[ts.top()] >= pri[each]) ex.push_back(pri[ts.top()]), ts.pop(); ts.push(each); &#125; &#125; &#125; return ex; &#125; //建表达式树 void build(const vector&lt;int>&amp; suffix)&#123; stack&lt;int> index; for(int each : suffix)&#123; if(each == 0 || each == 1)&#123; nodes.push_back(&#123;each, -1, -1&#125;); index.push(nodeSize ++); &#125;else&#123; int r = index.top(); index.pop(); int l = index.top(); index.pop(); nodes.push_back(&#123;each, l, r&#125;); index.push(nodeSize ++); &#125; &#125; &#125; int dfs(int index) &#123; if (nodes[index].val == 0 || nodes[index].val == 1) return nodes[index].val; int l = dfs(nodes[index].left); if (l == 0 &amp;&amp; nodes[index].val == 4) &#123; ansAnd++; return 0; &#125; if (l == 1 &amp;&amp; nodes[index].val == 3) &#123; ansOr++; return 1; &#125; return dfs(nodes[index].right); //既然不断路，那么值一定只和右边的值有关 &#125; int main() &#123; string mid; cin >> mid; mid += "@"; build(toSuffix(mid)); printf("%d\n", dfs(nodeSize - 1)); printf("%d %d\n", ansAnd, ansOr); &#125; 思路2 分治 对于一个表达式，我们会先去找没有括号的优先级最高的符号，然后计算左右两边的值，这便是中缀表达式的直观求法。 由 $1$ 所述，我们可以将表达式分层，并从优先级最高的那个符号开始左右分治求解，同时特判左边的值即可。 显然，我们不可能在每次求左右表达式的时候都遍历一遍字符串找符号，这肯定会 $tle$。于是乎，我们需要一个预处理，将当前位置之前该层最近的符号找出并记录它的下标。这样我们只要每次读取一下记录的下标是否在区间内即可。 对应AC代码#include &lt;bits/stdc++.h> using namespace std; int nowAnd[1000010], nowOr[1000010], lastAnd[1000010], lastOr[1000010]; string mid; int ansAnd, ansOr; int dc(int l, int r) &#123; if (nowOr[r] >= l) &#123; //or的优先级更高 int left = dc(l, nowOr[r] - 1); if (left == 1) &#123; ansOr++; return 1; &#125; return left | dc(nowOr[r] + 1, r); &#125; else if (nowAnd[r] >= l) &#123; int left = dc(l, nowAnd[r] - 1); if (left == 0) &#123; ansAnd++; return 0; &#125; return left &amp; dc(nowAnd[r] + 1, r); &#125; else if (mid[l] == '(' &amp;&amp; mid[r] == ')') return dc(l + 1, r - 1); return mid[l] - '0'; &#125; int main() &#123; cin >> mid; int n = mid.size(), layer = 0; mid = " " + mid; for (int i = 1; i &lt; n + 1; i++) &#123; //预处理 switch (mid[i]) &#123; case '(': layer++; break; case ')': layer--; break; case '|': lastOr[layer] = i; break; case '&amp;': lastAnd[layer] = i; break; &#125; nowAnd[i] = lastAnd[layer]; nowOr[i] = lastOr[layer]; &#125; printf("%d\n", dc(1, n)); printf("%d %d\n", ansAnd, ansOr); &#125; 怎么比赛里面还有码农题（ E. 音量调节 HAOI 2012题意给定一个初始值 $beginLevel$ 以及最大值 $maxLevel$，对于一个数组 $c$，在第 $i$ 次操作时，可选择将当前的值加上或减去 $c_i$，或不操作。输出最后的最大值。 思路一眼丁真，鉴定为 分组背包 不会做的去看背包九讲 题目特点：每个 $c$ 都要选上，可以 $+c$ 可以 $-c$，有范围限定。 分组：分成 $c$ 组，每组为 $c$ 和 $-c$。 我们可以用 $boolean$ 类型的 $dp$ 数组存储当前音量能否达到，对此，有如下状态转移方程:$dp[i][v] = dp[i][v] || dp[i - 1][v ± c]$ 套模板即可。 对应AC代码import java.util.*; //快乐分组背包呀 public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int N = scanner.nextInt(), begin = scanner.nextInt(), V = scanner.nextInt(); boolean[][] dp = new boolean[N + 1][V + 1]; dp[0][begin] = true; for(int i=1;i&lt;=N;i++)&#123; int c = scanner.nextInt(); for(int v = V;v>=0;v--)&#123; if(v - c >= 0) dp[i][v] |= dp[i - 1][v - c]; if(v + c &lt;= V) dp[i][v] |= dp[i - 1][v + c]; &#125; &#125; for(int v=V;v>=0;v--) if(dp[N][v])&#123; System.out.println(v); return; &#125; System.out.println(-1); &#125; &#125; 略微变化了一下的分组背包 F. 上升点列 CSP 2022 T4题意给定 $n$ 个点坐标，可添加 $k$ 个任意坐标，求出最长单调欧几里得距离序列。 思路这道题如果联想到最长上升子序列就迎刃而解了。 用二维dp做，前 $i$ 个点插入 $j$ 个点的最长长度。 观察欧几里得距离可发现，若要使i~j序列可取，那么需要加上 $d$ 个点， $d = xi - xj + yi - yj + 1$。 类似于最长上升子序列，得到状态转移方程： $dp[i][p] = max(dp[i][p], dp[j][p - d] + d + 1), p∈[d, k] $。 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), k = scanner.nextInt(); int[][] data = new int[n + 1][2]; for(int i=1;i&lt;=n;i++) &#123; data[i][0] = scanner.nextInt(); data[i][1] = scanner.nextInt(); &#125; Arrays.sort(data, 1, n + 1, (o1, o2) -> o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0]); int[][] dp = new int[n + 1][k + 1]; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=k;j++) dp[i][j] = j + 1; //差了j个那就塞上j个 for(int i=2;i&lt;=n;i++)&#123; for(int j=i-1;j>=1;j--)&#123; //i状态由j状态推得 if(data[j][1] > data[i][1]) continue; //因为i状态由j状态推得，所以需要至少d个点才能满足欧几里得距离 int d = data[i][0] - data[j][0] + data[i][1] - data[j][1] - 1; for(int p=d;p&lt;=k;p++) dp[i][p] = Math.max(dp[i][p], dp[j][p - d] + d + 1); //最长上升子序列模板 &#125; &#125; int ans = 0; for(int i=1;i&lt;=n;i++) ans = Math.max(ans, dp[i][k]); System.out.println(ans); &#125; &#125; 想不到就废了（悲 G. 星球大战 JSOI 2008题意给定一个无向图，输出断开指定边后图中联通块的数量。 思路 首先是建立无向图，可以使用邻接表的方式存储。 标记这些需要断开的边，然后依次遍历各个边，若端点的根节点一样，那么就处于同一个连通块了。 因为至少存在 $n$ 条边，那么连通块最多为 $n-k$ 个。 综合 $2$ 和 $3$ 可知，答案即为 $n - k - cnt$，其中 $cnt$ 为满足 $2$ 条件的个数。 至于要输出每次打击后的值，我们可以逆向思维，将最后的状态还原到最初状态即可。 优化我们可以使用并查集算法来优化。 没有解释地很清楚哈，还是有点难写的 对应AC代码#include &lt;bits/stdc++.h> using namespace std; typedef struct&#123; int a, b; //两点 int to; &#125;Edge; int parent[400010]; Edge edges[400010]; int tot = 0; int head[400010], broken[400010], ans[400010]; bool visited[400010]; //并查集查询，返回父节点id并将child全设为父节点直属下司( int findParent(int child) &#123; int ground = child, father = child; while (father != parent[father]) father = parent[father]; //更新father while (ground != parent[ground]) &#123; int tmp = ground; ground = parent[ground]; parent[tmp] = father; &#125; return father; &#125; //联通两个子树的爸爸即可(把一个爸爸设为另一个爸爸的直属下司 void unionIt(int x, int y) &#123; parent[findParent(x)] = findParent(y); &#125; void addEdge(int a, int b)&#123; edges[++tot].a = a; edges[tot].b = b; edges[tot].to = head[a]; head[a] = tot; &#125; int main() &#123; int n, m, u, v, k; long long w; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) parent[i] = i; //初始化并查集，我是我爸爸 for (int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; scanf("%d", &amp;k); for(int i=1;i&lt;=k;i++)&#123; scanf("%d", &amp;broken[i]); visited[broken[i]] = true; &#125; int united = n - k; for (int i = 0; i &lt; 2 * m; i++) &#123; if (!visited[edges[i].a] &amp;&amp; !visited[edges[i].b] &amp;&amp; findParent(edges[i].a) != findParent(edges[i].b)) &#123;//爸爸不一样，由union函数的写法可以看出俩玩意儿没联通 united --; unionIt(edges[i].a, edges[i].b); &#125; &#125; ans[k + 1] = united; for(int i=k;i>=1;i--)&#123; int x = broken[i]; visited[x] = false; united ++; for (int j = head[x]; j != 0; j = edges[j].to) &#123; int nowB = edges[j].b; if(!visited[nowB] &amp;&amp; findParent(x) != findParent(nowB))&#123; united --; unionIt(x, nowB); &#125; &#125; ans[i] = united; &#125; for(int i=1;i&lt;=k+1;i++) printf("%d\n", ans[i]); &#125; 反着想有时候会更简单 H. 虚拟内存 HNOI 2005题意设计一个程序完成题面所指的算法。 太模拟了，建议看原题（ 思路一道逻辑很清楚但是不好写的模拟题。 我们很明显能发现，不可以 $O(mn)$，会寄，想想有序性，不难发现可以用优先队列。 我们需要存一下当前某一页的状态，方便找空页，我们可以用 $map$。 模拟 如果使用HashMap，对于某些如java的语言需要重写一下类的hashCode()和equals()方法，不然会像我一样WA。 当然，最好用cpp写，其他语言容易卡到tle和mle 对应AC代码import java.util.*; public class Main&#123; private static class Page&#123; int id, cnt, time; Page(int id, int cnt, int time) &#123; this.id = id; this.cnt = cnt; this.time = time; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; Page page; //java版本低，用ide自动生成的还得改改（（（ if (!(o instanceof Page)) return false; page = (Page) o; return id == page.id &amp;&amp; cnt == page.cnt &amp;&amp; time == page.time; &#125; @Override public int hashCode() &#123; return Objects.hash(id, cnt, time); &#125; &#125; private static class Pair&lt;A, B>&#123; A A; B B; Pair(A a, B b) &#123; A = a; B = b; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; Pair&lt;?, ?> pair; if (!(o instanceof Pair&lt;?, ?>)) return false; pair = (Pair&lt;?, ?>) o; return Objects.equals(A, pair.A) &amp;&amp; Objects.equals(B, pair.B); &#125; @Override public int hashCode() &#123; return Objects.hash(A, B); &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); //优先队列 int n = scanner.nextInt(), m = scanner.nextInt(); Map&lt;Integer, Pair&lt;Integer, Integer>> data = new HashMap&lt;>(); PriorityQueue&lt;Page> least = new PriorityQueue&lt;>(((o1, o2) -> o1.cnt == o2.cnt ? o1.time - o2.time : o1.cnt - o2.cnt)); int ans = 0; for (int i = 0; i &lt; m; i++) &#123; int query = scanner.nextInt(); if(data.containsKey(query))&#123; int cnt = data.get(query).A, time = data.get(query).B; least.remove(new Page(query, cnt, time)); least.offer(new Page(query, cnt + 1, time)); data.put(query, new Pair&lt;>(cnt + 1, time)); ans ++; &#125;else if(data.size() &lt; n)&#123; data.put(query, new Pair&lt;>(1, i)); least.offer(new Page(query, 1, i)); &#125;else&#123; Page page = least.poll(); data.remove(page.id); data.put(query, new Pair&lt;>(1, i)); least.offer(new Page(query, 1, i)); &#125; &#125; System.out.println(ans); &#125; &#125; 题目读半天… I. 泡泡堂 ZJOI 2008题意给定两个队的选手的实力，在分配最好和最坏的情况下，分别输出 $ZJ$ 队的分数。 思路 田忌赛马 1. 田忌最快的马比齐王最快的马快，比之 2. 田忌最快的马比齐王最快的马慢，用田忌最慢的马跟齐王最快的马比 3. 田忌最快的马的速度与齐王最快的马速度相等 ①田忌最慢的比齐王最慢的快，比之。 ②田忌最慢的比齐王最慢的慢，田忌慢马 $VS$ 齐王快马 ③田忌最慢的与齐王最慢的相等，田忌慢马 $VS$ 齐王快马 不予证明。 更具体地说维护双指针$ head$ 和 $end$, 按上述思路写 对应AC代码import java.util.*; public class Main&#123; //md，一个贪心想了我好久 private static long judge(int n, long[] a, long[] b)&#123; int score = 0; int headA = 0, headB = 0, endA = n - 1, endB = n - 1; //双指针？ while(headA &lt;= endA &amp;&amp; headB &lt;= endB)&#123; if(a[headA] > b[headB])&#123; score += 2; headA ++; headB ++; &#125;else if(a[endA] > b[endB])&#123; score += 2; endA --; endB --; &#125; else &#123; if(a[headA] == b[endB]) score ++; headA ++; endB --; &#125; &#125; return score; &#125; //我就猜一猜 public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); long[] zj = new long[n], sb = new long[n]; for(int i=0;i&lt;n;i++) zj[i] = scanner.nextLong(); for(int i=0;i&lt;n;i++) sb[i] = scanner.nextLong(); Arrays.sort(zj); Arrays.sort(sb); System.out.printf("%d %d\n", judge(n, zj, sb), 2L * n - judge(n, sb, zj)); //有个小技巧（（（ &#125; &#125; md，一个贪心想了我好久]]></content>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 第四场世纪大战 - 带佐的回家路</title>
    <url>/blog/posts/1494271354/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/contest/p/29?tid=635bad6e691055e12dce5282 题意带佐在数轴上。$0$ 时刻，带佐位于 $0$ 处。在时刻 $i−1$ 和 $i$ 之间的时间段中，带佐要么待在当前位置，要么向左或向右跳 $i$ 个单位长度。输出带佐最早在哪个时刻可以到达 $X$。 思路首先，结论是：首项为 $1$，公差为 $1$ 的等差数列的前 $n$ 项和满足 $S_n &gt; x$ 的最小 $n$ 即为答案。 下面给出证明思路： 上述结论的做法是： 令 $m = 满足条件的最小 n$，$t = Sm - x$，则只需在 $t$ 时刻停留即可保证最后一步恰好走到 $x$。 上述结论的合理性： ① 我们不可能折回，因为折回后如果直接返回，只能前进 $1$，代价大于在 $t$ 时刻停留的代价（可以根据等差数列理解，列方程来严格证明），而停留后返回代价明显更大（停留需要很长时间，而折回后返回前进的距离远没有这么长）。 ② 我们不可以停留太久，显然停留一次比停留多次代价小。 因此，用一个 $while$ 轻松解决。 值得注意的是，上述证明不严密。 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); long x = scanner.nextLong(), t = 0, i = 1; while(t &lt; x)&#123; t += i; i ++; &#125; System.out.println(i - 1); &#125; &#125; 暴力就完事了]]></content>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 模拟 - Air Conditioner</title>
    <url>/blog/posts/3649205289/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/P1304C 空调凉凉~ 题意一个餐馆中有个空调，给定空调的初始温度为 $m$，每分钟可以选择上调或下调 $1$ 个单位的温度，或选择不变。 给定 $n$ 个食客的到达时间 $t_i$ 以及所能适应的温度范围 $[l_i, r_i]$，每个食客只会在 $t_i$ 时刻逗留。 如果温度不在食客的适应范围内，他就会不舒服。输出空调能否使得所有食客都感到舒服。 思路当初第一反应是维护一个温度值，根据食客的需求改变温度。但这里存在问题：对于有限的操作，最后能落在温度区间的温度是不唯一的。如果是这样，很多种可能叠加，不难发现会超时。 也许我们可以贪心地认为只要满足最低条件即可，但我们不能保证下一个本因可行的区间可能被判为不可行（如一直递增的温度区间）。 单个值失败了，那就多个值呗。 我们只要维护一个区间，让每次所有的可行解落在该区间。然后，对于每一个区间，将其与后面的区间进行区间重叠运算。 对于重叠的区间，有四种可能： 1.可行区间 $cur$ 和后一个温度区间没有重叠 2.两区间左侧或右侧部分重叠 3.可行区间 $cur$ 包含于后一个温度区间 4.可行区间 $cur$ 被包含于后一个温度区间 对应AC代码import java.util.*; public class Main &#123; static class Person&#123; long t, l, h; Person(long t, long l, long h)&#123; this.t = t; this.l = l; this.h = h; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int q = scanner.nextInt(); g:for(int i=0;i&lt;q;i++)&#123; int n = scanner.nextInt(), m = scanner.nextInt(); Person[] p = new Person[n]; for(int j=0;j&lt;n;j++) p[j] = new Person(scanner.nextLong(), scanner.nextLong(), scanner.nextLong()); long left = m - p[0].t, right = m + p[0].t; //以第一个人的到达时间划分初始区间 for(int j=0;j&lt;n;j++)&#123; Person cur = p[j]; if(cur.h &lt; left || cur.l > right)&#123; System.out.println("NO"); continue g; &#125;else if(j == n - 1)&#123; //如果是最后一个，只要有交集就已经成功 System.out.println("YES"); continue g; &#125; if(cur.l >= left &amp;&amp; cur.h &lt;= right)&#123; //包含关系 left = cur.l; right = cur.h; &#125;else if(cur.l >= left) left = cur.l; //右侧有区间重叠 else if(cur.h &lt;= right) right = cur.h; //左侧有区间重叠 left -= p[j + 1].t - cur.t; right += p[j + 1].t - cur.t; &#125; &#125; &#125; &#125; 第一次写题解，可能交代的不是很清楚。]]></content>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 图论 - 车站分级</title>
    <url>/blog/posts/1900600766/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/532?tid=6363a9a5691055e12dd288dc 其实如果没有给出是图论题的话，这题就难在想不想得到拓扑了。 题意 定义”要求“：对于任意停靠的车站，存在优先级，需要满足其余大于等于该车站优先级的车站必须停靠的条件。 给出满足”要求“的几条线路，求出需要划分的最少优先级数量。 思路 首先，我们确定一下每条线路需要处理的车站：从起点到终点这一段路上的所有车站。 对于”优先”这个概念，我们可以联系到图论中的父子关系，也就是建立有向边。 对于有向边，当我们将优先级小的车站作为父节点、优先级大的作为子节点时，就可以采用拓扑排序的逻辑。在每次 $push$ 的时候，我们只需存入当前节点的优先级，依次迭代并记录优先级的最大值即可。 对于建立有向边，我们可以遍历这条线路上所有非停靠站，将所有车站依次连到各个非停靠车站上即可。 对应AC代码import java.util.*; public class Main&#123; private static class Point&#123; //防止构建泛型数组 int inDegree; List&lt;Integer> edges = new ArrayList&lt;>(); &#125; //实现cpp里面的pair private static class Pair&lt;A, B>&#123; A A; B B; public Pair(A a, B b) &#123; A = a; B = b; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Pair&lt;?, ?> pair = (Pair&lt;?, ?>) o; if (!Objects.equals(A, pair.A)) return false; return Objects.equals(B, pair.B); &#125; @Override public int hashCode() &#123; int result = A != null ? A.hashCode() : 0; result = 31 * result + (B != null ? B.hashCode() : 0); return result; &#125; &#125; static int n, ans; static Point[] points; static boolean[][] edgeVisited; static void addEdge(int x, int y)&#123; if(points[x] == null) points[x] = new Point(); if(points[y] == null) points[y] = new Point(); points[x].edges.add(y); points[y].inDegree ++; &#125; static void topSort() &#123; //拓扑排序 Queue&lt;Pair&lt;Integer, Integer>> queue = new LinkedList&lt;>(); for (int i = 1; i &lt;= n; i++) if (points[i] != null &amp;&amp; points[i].inDegree == 0) &#123; //多余的站不用管了 queue.offer(new Pair&lt;>(i, 1)); //入度为零，优先级最低为1 &#125; while (queue.size() > 0) &#123; Pair&lt;Integer, Integer> x = queue.poll(); for (int y : points[x.A].edges) &#123; if (--points[y].inDegree == 0) &#123; queue.offer(new Pair&lt;>(y, x.B + 1)); //当所有能遍历到y的点都经过了，那就可以can can y了(不然会有重复 ans = Math.max(ans, x.B + 1); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); n = scanner.nextInt(); int m = scanner.nextInt(); points = new Point[n + 1]; edgeVisited = new boolean[n + 1][n + 1]; for(int w=0;w&lt;m;w++)&#123; int s = scanner.nextInt(); List&lt;Integer> stations = new ArrayList&lt;>(); boolean[] isStation = new boolean[n + 1]; for(int i=0;i&lt;s;i++) &#123; int now = scanner.nextInt(); stations.add(now); isStation[now] = true; &#125; for(int i=stations.get(0); i&lt;=stations.get(s - 1);i++)&#123; //非车站作为车站的爸爸建有向边 if(isStation[i]) continue; for(int j : stations)&#123; if(!edgeVisited[i][j])&#123; edgeVisited[i][j] = true; addEdge(i, j); &#125; &#125; &#125; &#125; topSort(); System.out.println(ans); &#125; &#125; 这题也可以用邻接表。 要交题的话还是建议cpp，java有点卡时间了。]]></content>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 图论 - Sorting it all out</title>
    <url>/blog/posts/3592285520/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/542?tid=6363ac4a691055e12dd289de 最短路题单，但是可以用拓扑（ 题意给定 $A - Z$ 中前 $n$ 个字母的大小顺序，且都为小于关系，共有 $m$ 个条件，从前往后判断满足所有条件的序列是否存在且唯一。 对于从前往后的 $t$ 次遍历中，若能确定最后输出，则略过后面的输入。 有唯一解，输出 $Sorted \ sequence \ determined \ after \ t \ relations: yyy…y.$ 有多解（冲突），输出 $Inconsistency \ found \ after \ t \ relations.$ 无解（没有给全所有点的条件），输出 $Sorted \ sequence \ cannot \ be \ determined.$ 思路因为题面提到需要整个序列的顺序输出，而联想到拓扑排序，它可以将一个有向图转换成一个有先后顺序的序列，这正是我们需要的。 一切都一样，只是我们的有向图多了一个条件： 除了根和叶外，其他节点都是入度和出度为 $1$ 的。 联想到拓扑排序的实现，若我们在每次循环的时候都判断一下队列的元素个数，大于 $1$ 标记有多解，即可满足上述条件了。 当然，为了计算 $t$，跑一遍拓扑是不够的，我们要在加边的同时拓扑，来判断在加入这个条件后是否出现了多解或者无解。 考虑到入度的计算，不采用先加完边再跑拓扑的做法。 翻车实录 注意输出的优先级，如果冲突且无解，应该输出冲突。 $POJ$ 远端题，不要用万能头和 $for-each$ 语句。 对应AC代码#include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> using namespace std; int n, m, inDegree[30], copyInDegree[30], visited[30][30]; vector&lt;int> edges[30], ans; bool addEdge(int x, int y) &#123; //在邻接表中添加一条有向边 if(visited[x][y]) return true; visited[x][y] = true; edges[x].push_back(y); inDegree[y]++; return false; &#125; int topSort() &#123; //拓扑排序 queue&lt;int> q; memset(copyInDegree, 0, sizeof copyInDegree); //每次拓扑后入度不能被修改呢 for (int i = 0; i &lt; n; i++) &#123; if (inDegree[i] == 0) q.push(i); copyInDegree[i] = inDegree[i]; &#125; ans.clear(); bool inc = false; while (!q.empty()) &#123; if(q.size() > 1) inc = true; int x = q.front(); ans.push_back(x); q.pop(); for(int i=0;i&lt;edges[x].size();i++)&#123; int y = edges[x][i]; if (--copyInDegree[y] == 0) &#123; q.push(y); &#125; &#125; &#125; if(ans.size() &lt; n) return 2; if(inc) return 3; return 1; &#125; int main() &#123; scanf("%d %d", &amp;n, &amp;m); while (n != 0 || m != 0) &#123; memset(inDegree, 0, sizeof inDegree); memset(visited, 0, sizeof visited); memset(edges, 0, sizeof edges); bool skip = false; int t = 0, result = 3; for (int i = 1; i &lt;= m; i++) &#123; char input[4] = &#123;0&#125;; scanf("%s", input); if (addEdge(input[0] - 'A', input[2] - 'A')) continue; if (skip) continue; //跳过也得读完呐... result = topSort(); t++; if (result == 3) continue; //无解了 skip = true; //冲突和求出唯一解是只需判断一次的，后面直接跳过即可 &#125; if (result == 1) &#123; printf("Sorted sequence determined after %d relations: ", t); for (int i = 0; i &lt; ans.size(); i++) printf("%c", ans[i] + 'A'); printf(".\n"); &#125; else if (result == 2) printf("Inconsistency found after %d relations.\n", t); else printf("Sorted sequence cannot be determined.\n"); scanf("%d %d", &amp;n, &amp;m); &#125; &#125; 找个时间写写floyd的思路]]></content>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 树型dp - 三色二叉树</title>
    <url>/blog/posts/3903312395/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/512?tid=633d6550d2fe705a3c4684c7 之所以来写这个题解，是因为思路真的太清晰啦（（ 题意给定一段由 $0, 1, 2$ 组成的二叉树序列 $S$，序列由下面三种元素构成： $0$：表示该树没有节点； $1 S_1$：表示该数有一个节点，$S_1$ 为其子树的二叉树序列； $2 S_1 S_2$：表示该树有两个子节点，$S_1$ 和 $S_2$ 分别表示其两个子树的二叉树序列。 根据上述序列建树，并标上红蓝绿三种颜色，相邻颜色不能重复，子节点颜色不能重复，求出这棵树中绿色节点的最大和最小数量。 思路我们考虑下面的两个问题。 如何建树根据题给条件，在给出根节点后，后面将会有一段数字作为根节点的子树，而其子树又可向右找到他的子树，以此类推。 但我们要如何确定下一个节点从哪里开始呢？显然，在上一个子节点遍历完后，下一个下标即为另一个子节点的开始下标。 于是乎，我们可以记录一下当前的下标在哪个位置，然后….. 这里也有两种写法。 递归写法我们只需向下一次调用传递当前下标的位置，并返回处理结束后的下标位置（也可以开一个全局变量存储下标，效果是一样的）即可。 对应代码void buildTree(int father)&#123; if(curIndex == inputTree.size()) return; cnt[father] = inputTree[curIndex ++] - '0'; for(int i=0;i&lt;cnt[father];i++) &#123; nodes[father][i] = ++tot; buildTree(tot); &#125; &#125; STL写法我们不妨这么想，在找到根节点后，我们需要寻找它的两个子节点，而因为需要建树，我们需要知道这两个子节点对应的父节点是什么。 所以，我们可以使用一个数据结构存储这个根节点，在嵌套寻找的时候能正确获取上一个根节点，并能在两个子节点处理完后移除这个根节点。 这个数据结构满足一个特点：先进先出。 没错，就是栈结构。 对应代码void buildTree() &#123; stack&lt;pair&lt;int, int>> root; //index, sum int cur = 0; root.push(pair&lt;int, int>(++tot, inputTree[0] - '0')); while (!root.empty()) &#123; pair&lt;int, int> father = root.top(); root.pop(); int now = inputTree[++cur] - '0'; father.second--; nodes[father.first][cnt[father.first]++] = ++tot; //建树 if (father.second > 0) root.push(father); if (now > 0) root.push(pair&lt;int, int>(tot, now)); &#125; &#125; 如何dp 在说之前，先吐槽一句我的代码，它看起来好蠢 我们不妨用状态机的写法，开一个二维 $dp$ 数组第一维为下标，第二维为当前节点的一个状态。 显然，作为一个节点，他有三种状态——红蓝绿。 初始状态将叶节点的所有状态赋值 $1$. 状态转移 首先，如果一个父节点要成为绿色，那么他的子节点一定是红色、蓝色，或者蓝色、红色。当然如果只有一个子节点，那么这个子节点就是蓝色或者红色。 所以，对于一个父节点，对于一种颜色，它总会有两种取法，而又因为两种取法不影响父节点的颜色，所以 $dp$ 的最大值就是两种情况的最大值，最小值同理。 这是最直接的思路，而按照这么写，代码会很冗长。 对应代码void dfs(int root) &#123; for (int i = 0; i &lt; cnt[root]; i++) dfs(nodes[root][i]); if (cnt[root] == 0) &#123; dpMax[root][1] = 1; dpMin[root][1] = 1; &#125; else if (cnt[root] == 1) &#123; dpMax[root][0] = max(dpMax[nodes[root][0]][1], dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1], dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][1]); &#125; else if (cnt[root] == 2) &#123; dpMax[root][0] = max(dpMax[nodes[root][0]][1] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][1] + dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][1], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][1] + dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][1], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][1]); &#125; &#125; 是不是很蠢，我看着就想笑 最终结果根节点分别为红蓝绿时，所记录下来的最大值和最小值即为答案。 对应AC代码 (递归)#include &lt;bits/stdc++.h> using namespace std; //你问我啥用cpp写，因为Java栈溢出了 int tot; int nodes[500010][2], dpMin[500010][3], dpMax[500010][3]; //0是红，1是绿，2是蓝，dp的值是绿色点的个数 int cnt[500010]; string inputTree; int curIndex = 0; void buildTree(int father)&#123; if(curIndex == inputTree.size()) return; cnt[father] = inputTree[curIndex ++] - '0'; for(int i=0;i&lt;cnt[father];i++) &#123; nodes[father][i] = ++tot; buildTree(tot); &#125; &#125; void dfs(int root) &#123; //好蠢 for (int i = 0; i &lt; cnt[root]; i++) dfs(nodes[root][i]); if (cnt[root] == 0) &#123; //断子绝孙 dpMax[root][1] = 1; dpMin[root][1] = 1; &#125; else if (cnt[root] == 1) &#123; //一个节点 dpMax[root][0] = max(dpMax[nodes[root][0]][1], dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1], dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][1]); &#125; else if (cnt[root] == 2) &#123; dpMax[root][0] = max(dpMax[nodes[root][0]][1] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][1] + dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][1], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][1] + dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][1], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][1]); &#125; &#125; int main() &#123; cin >> inputTree; buildTree(++ tot); dfs(1); cout &lt;&lt; max(dpMax[1][0], max(dpMax[1][1], dpMax[1][2])) &lt;&lt; " " &lt;&lt; min(dpMin[1][0], min(dpMin[1][1], dpMin[1][2])); &#125; 对应AC代码 (STL)#include &lt;bits/stdc++.h> using namespace std; //你问我啥用cpp写，因为Java栈溢出了 int tot; int nodes[500010][2], dpMin[500010][3], dpMax[500010][3]; //0是红，1是绿，2是蓝，dp的值是绿色点的个数 int cnt[500010]; string inputTree; void buildTree() &#123; stack&lt;pair&lt;int, int>> root; //index, sum int cur = 0; root.push(pair&lt;int, int>(++tot, inputTree[0] - '0')); while (!root.empty()) &#123; pair&lt;int, int> father = root.top(); root.pop(); int now = inputTree[++cur] - '0'; father.second--; nodes[father.first][cnt[father.first]++] = ++tot; //建树 if (father.second > 0) root.push(father); if (now > 0) root.push(pair&lt;int, int>(tot, now)); &#125; &#125; void dfs(int root) &#123; //好蠢 for (int i = 0; i &lt; cnt[root]; i++) dfs(nodes[root][i]); if (cnt[root] == 0) &#123; //断子绝孙 dpMax[root][1] = 1; dpMin[root][1] = 1; &#125; else if (cnt[root] == 1) &#123; //一个节点 dpMax[root][0] = max(dpMax[nodes[root][0]][1], dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1], dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][1]); &#125; else if (cnt[root] == 2) &#123; dpMax[root][0] = max(dpMax[nodes[root][0]][1] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][1] + dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][1], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][1] + dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][1], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][1]); &#125; &#125; int main() &#123; cin >> inputTree; buildTree(); dfs(1); cout &lt;&lt; max(dpMax[1][0], max(dpMax[1][1], dpMax[1][2])) &lt;&lt; " " &lt;&lt; min(dpMin[1][0], min(dpMin[1][1], dpMin[1][2])); &#125; 其实递归是写本题解的时候想到的，而有趣的是它反而是最优解。]]></content>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 树和堆 - 合并果子</title>
    <url>/blog/posts/2422309672/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/369?tid=6301e681027d8fe886628d9d 感觉之前写得太蠢了就重新写一下（ 题意每次把最小的两个拿出来合并并将数量作为本次体力消耗，输出最小体力消耗值。 思路1显然，我们只需边枚举边排序，考虑到数据范围够小，暴力是完全可行的。 时间复杂度：$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; int d[20001]; int main() &#123; int n; cin >> n; for(int i=0;i&lt;n;i++) cin >> d[i]; sort(d, d + n); int ans = 0; for(int i=1;i&lt;n;i++)&#123; d[i] += d[i - 1]; ans += d[i]; sort(d + i, d + n); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; 思路2不难发现，上面暴力的做法无非就是两个步骤：①排序 ②取最小两个加起来放回去 很巧的是，这些步骤完全可以使用封装好的堆结构来实现。 时间复杂度和上述暴力方法完全一致。 时间复杂度：$O(nlogn)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); PriorityQueue&lt;Integer> queue = new PriorityQueue&lt;>(); int n = scanner.nextInt(); for(int i=0;i&lt;n;i++) queue.offer(scanner.nextInt()); int ans = 0; while(true)&#123; if(queue.isEmpty()) break; int a = queue.poll(); if(queue.isEmpty()) break; int b = queue.poll(); queue.offer(a + b); ans += a + b; &#125; System.out.println(ans); &#125; &#125; 堆 = 暴力（暴论]]></content>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 搜索剪枝策略 - 靶形数独</title>
    <url>/blog/posts/1232478877/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/491?tid=633184a5ea0e1b063194593d 杰尼龟刚刚接触了信息学竞赛，有一天它遇到了这样一个题：靶形数独。 “简单！”杰尼龟心想，同时很快就写出了一份程序，可是测试时却出现了错误。 题意完成一个每格具有分数的数独，使分数和最大。 铺垫先来看看这题 数独 - 洛谷. 显然，我们只需要用 $dfs$ 就可以了。 我们传递两个参数，代表当前我们搜索的点。 然后我们判断一下列有没有超出最大值，有的话跳到下一行即可。 不过需要注意的是，我们没有必要嵌套两个 $for$ (你喜欢的话记得 $break$ )，只需在传递参数的时候把当前列 $+1$ 即可。 思路首先，我们很容易想到直接套数独的模板，然后记录一下最高分即可。 这没有错，但你会喜提 $2tle$。 为什么呢？你可以试试用你的思维来解数独。 当拿到一个数独的时候，你的第一反应是什么？ 没错，自然是从空格最少的行填起。 这里就存在一个剪枝：对行排序。 我们可以用桶排序的方式，记录下排序后下标对应原行的下标即可。 还有一件事，你会如何算这个分数呢？ 用空间换时间，即数组 int k[10][10]=&#123; 0,0,0,0,0,0,0,0,0,0, 0,6,6,6,6,6,6,6,6,6, 0,6,7,7,7,7,7,7,7,6, 0,6,7,8,8,8,8,8,7,6, 0,6,7,8,9,9,9,8,7,6, 0,6,7,8,9,10,9,8,7,6, 0,6,7,8,9,9,9,8,7,6, 0,6,7,8,8,8,8,8,7,6, 0,6,7,7,7,7,7,7,7,6, 0,6,6,6,6,6,6,6,6,6 &#125;; 整出来一个公式：$10 - max(abs(i - 4), abs(j - 4))$ 对应AC代码import java.util.*; public class Main &#123; static int[][] data = new int[10][10]; static boolean[][] rowVisited = new boolean[10][10], columnVisited = new boolean[10][10], squareVisited = new boolean[10][10]; static Integer[] reflectRow = new Integer[9]; static int ans = -1; private static void dfs(int x, int y)&#123; if(x == 9)&#123; int now = 0; for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; now += data[i][j] * (10 - Math.max(Math.abs(i - 4), Math.abs(j - 4))); &#125; ans = Math.max(ans, now); return; &#125; if(y == 9)&#123; dfs(x + 1, 0); return; &#125; int realX = reflectRow[x]; if(data[realX][y] != 0) dfs(x, y + 1); else &#123; int squareId = realX / 3 * 3 + y / 3; for (int i = 1; i &lt;= 9; i++) &#123; if (!rowVisited[realX][i] &amp;&amp; !columnVisited[y][i] &amp;&amp; !squareVisited[squareId][i]) &#123; rowVisited[realX][i] = true; columnVisited[y][i] = true; squareVisited[squareId][i] = true; data[realX][y] = i; dfs(x, y + 1); rowVisited[realX][i] = false; columnVisited[y][i] = false; squareVisited[squareId][i] = false; data[realX][y] = 0; //好久没写回溯了 &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); for(int i=0;i&lt;9;i++) reflectRow[i] = i; int[] cnt = new int[9]; for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; data[i][j] = scanner.nextInt(); rowVisited[i][data[i][j]] = true; columnVisited[j][data[i][j]] = true; squareVisited[i / 3 * 3 + j / 3][data[i][j]] = true; if(data[i][j] > 0) cnt[i] ++; &#125; Arrays.sort(reflectRow, (o1, o2) -> cnt[o2] - cnt[o1]); dfs(0, 0); System.out.println(ans); &#125; &#125; 好久不玩数独了]]></content>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 模拟 - 立体图</title>
    <url>/blog/posts/1619629406/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/464?tid=62e26edd3a711450d9b817c5 题意小渊很懒，给你各个位置的高度，让你画立体图。 思路首先，根据题单名称，我们可以知道要模拟。 方块之间的前后视觉遮挡问题首先，我们来考虑这个本题最难的点。 显然，对于斜二测画法的立体图，后面靠左的区域会被前者覆盖。那么我们自然会发现，从前往后画，覆盖问题会变得很复杂（不过也不是不能做）。 所以，我们不妨试试从俯视视角的左上角开始画。 我们以一个方块为一个单位开始画图。这里我们定义一个 $char$ 二维数组来存储一个方块，并用题给的 $.$ 符号来表示空区域。 char[][] one = &#123; "..+---+".toCharArray(), "./ /|".toCharArray(), "+---+ |".toCharArray(), "| | +".toCharArray(), "| |/.".toCharArray(), "+---+..".toCharArray() &#125;; 然后，对于每一个新加入的方块，我们只要对 $one$ 进行行列的遍历，如果不为 $.$，就将前者对应位置覆盖。 定位每个方块的大小是 $6 \times 7$，格子的数目也给出了范围，此处我们可以开一个存储数据的容量为 $500 \times 500$ 的数组（其实是随便输的，可能还不满足最大的容量，只能说测试数据不够全面，反正开大一点就好啦~），那么右下角的点坐标就为 $(499, 499)$。 好的，那我们先拿几个图来推一下坐标的式子。 此处定义每个格子的坐标为 $(i, j, h)$ 注：为了更加形象一点，我就直接定义 $h$ 下标从 $1$ 开始，而 $i$ 和 $j$ 仍从 $0$ 开始。 对于左下角的高度为1的方块（即坐标为 $(m - 1, 0, 1)$ 的方块），他的左上顶点位于 $(494, 0)$。 对于 $(m - 2, 1, 1)$ 的方块，他的左上顶点位于 $(492, 2)$。 可见对于横纵坐标的改动，会有以 $2$ 为倍数的改变，在高度为 $1$ 时，我们可以推出下面的坐标式子： $(494 - 2(m - i - 1), 4j + 2(m - i - 1))$ 高度变化对坐标的影响是显而易见的。每当高度加 $1$，横坐标会减少 $3$（不能理解的话可以对照一下题面中两个方块上下相邻的图）。因此我们完善一下式子如下： $(497 - 2(m - i - 1) - 3h, 4j + 2(m - i - 1))$ 然后我们只需从俯视视角的左上角开始循环添加方块就 $ok$ 了。 如何输出在每次添加方格的时候，我们可以记录一下上区间和右区间，上区间就是所有左上顶点的纵坐标最小值，右区间就是所有右上顶点横坐标最大值。 对应AC代码 (java)import java.util.*; public class Main &#123; static char[][] one = &#123; "..+---+".toCharArray(), "./ /|".toCharArray(), "+---+ |".toCharArray(), "| | +".toCharArray(), "| |/.".toCharArray(), "+---+..".toCharArray() &#125;; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); char[][] ans = new char[500][500]; //开数组 for(int i=0;i&lt;500;i++) for(int j=0;j&lt;500;j++) ans[i][j] = '.'; //空位置填上占位符"." int m = scanner.nextInt(), n = scanner.nextInt(); int[][] height = new int[m][n]; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) height[i][j] = scanner.nextInt(); int top = 500, right = 0; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) for(int h=1;h&lt;=height[i][j];h++)&#123; //从左上角画起，存到数组底部，到时候记录最高和最右的位置即可 int startI = 497 - 2 * (m - i - 1) - 3 * h, startJ = 4 * j + 2 * (m - i - 1); top = Math.min(top, startI); right = Math.max(right, startJ + 6); for(int p=0;p&lt;6;p++) for(int q=0;q&lt;7;q++)&#123; if(one[p][q] != '.') ans[startI + p][startJ + q] = one[p][q]; &#125; &#125; for(int i=top;i&lt;=499;i++) &#123; for(int j=0;j&lt;=right;j++) System.out.print(ans[i][j]); System.out.println(); &#125; &#125; &#125; 对应AC代码 (cpp)#include &lt;bits/stdc++.h> using namespace std; char one[6][8] = &#123; "..+---+", "./ /|", "+---+ |", "| | +", "| |/.", "+---+.." &#125;; char ans[500][500]; //开数组 int height[52][52]; int main() &#123; for (int i = 0; i &lt; 500; i++) for (int j = 0; j &lt; 500; j++) ans[i][j] = '.'; //空位置填上占位符"." int m, n; scanf("%d %d", &amp;m, &amp;n); for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) scanf("%d", &amp;height[i][j]); int top = 500, right = 0; for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) for (int h = 1; h &lt;= height[i][j]; h++) &#123; //从左上角画起，存到数组底部，到时候记录最高和最右的位置即可 int startI = 497 - 2 * (m - i - 1) - 3 * h, startJ = 4 * j + 2 * (m - i - 1); top = min(top, startI); right = max(right, startJ + 6); for (int p = 0; p &lt; 6; p++) for (int q = 0; q &lt; 7; q++) &#123; if (one[p][q] != '.') ans[startI + p][startJ + q] = one[p][q]; &#125; &#125; for (int i = top; i &lt;= 499; i++) &#123; for (int j = 0; j &lt;= right; j++) printf("%c", ans[i][j]); printf("\n"); &#125; &#125; 过于模拟]]></content>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 838 Div 2</title>
    <url>/blog/posts/1762526761/</url>
    <content><![CDATA[Practice. A. Divide and Conquer题意给定一个数组 $a$，定义操作为选定一个元素并将其除 $2$ 后向下取整，输出最少操作数，使整个数组的和为奇数。 思路考虑到数据量比较小，我们不妨直接用“分治”的方法，考虑每个元素需要多少次才能改变奇偶性，然后找出操作数最少的元素，对应的操作数就是我们想要的答案。 当然，本来就是奇数的话就直接输出 $0$。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 60, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; memset(a, 0, sizeof a); cin >> n; int sum = 0, mn = inf; for(int i=0;i&lt;n;i++)&#123; int cnt = 0, x; cin >> x; a[i] = x; sum += a[i]; while(x % 2 == a[i] % 2 &amp;&amp; x > 0)&#123; cnt ++; x /= 2; &#125; mn = min(mn, cnt); &#125; if(sum % 2 == 0) cout &lt;&lt; 0 &lt;&lt; '\n'; else cout &lt;&lt; mn &lt;&lt; '\n'; &#125; return 0; &#125; 真就“分治”呗 B. Make Array Good题意给定一个数组 $b$，定义操作为将任意元素加上不超过其本身的自然数，操作数量不限，输出一种操作方案，使得对于任意的 $i, j$，有 $min(b_i, b_j) | max(b_i, b_j)$。 思路既然操作数量不限，那么我们不妨把所有数加到 $2$ 的倍数。 更具体地说，我们只需加到每个元素最近的 $2$ 的次幂即可。 时间复杂度：$O(n log_2 n)?$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 60, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; cout &lt;&lt; n &lt;&lt; '\n'; for(int i=1;i&lt;=n;i++)&#123; int x; cin >> x; int to = 1; while(to &lt; x) to *= 2; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; to - x &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 限次数就难搞了 C. Binary Strings are Fun题意在二进制数组的条件下给出两个定义： 如果对于一个长度为奇数的数组，对于它的所有奇数下标 $i$，满足 $b_i$ 是 $[1,i]$ 内出现次数至少占总数的一半的数，那么这个数组是好的。 若对于一个长度为 $k$ 的数组 $a$ 和一个长度为 $2k-1$ 的数组 $b$，满足对于任意 $i \in [1,k]$，有 $ai = b{2i-1}$，那么称 $b$ 是 $a$ 的拓展数组。 现在，给定一个二进制数组 $s$，对于 $s$ 的所有前缀，统计其 好的 拓展数组 的数量之和，并输出。 思路首先，我们不难发现，若前两位是不相同的，那么我们可选的拓展值是唯一确定的，也就是说，想要让两个元素之间的拓展值有两种取法，那么这两个元素一定是相同的。 其次，若我们遇到了连续相同的一段，但后面被打断之后，那么我们就不得不在相同的这一段填上与之相反的值，否则无法满足后面的条件，所以我们应寻找后缀连续相同段的长度。 我们不妨记这个长度为 $len$，那么方案数即为 $2^{len-1}$。 显然，我们可以直接从左向右遍历，此时我们对应地判断+更新 $len$ 与答案即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 60, inf = 0x3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; char pre = ' '; int ans = 1, tot = 0; for(int i=1;i&lt;=n;i++)&#123; char now; cin >> now; if(now == pre) ans = (ans * 2) % mod; else ans = 1; pre = now; tot = (tot + ans) % mod; &#125; cout &lt;&lt; tot &lt;&lt; '\n'; &#125; return 0; &#125; 算是想出来了一大半（]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 841 Div 2</title>
    <url>/blog/posts/4132653795/</url>
    <content><![CDATA[Practice. A. Joey Takes Money题意给定一个包含 $n$ 个 $\geq 1$ 的元素的数组 $a$，定义操作为： 选定 $i, j, i \neq j$； 选两个 $\geq 1$ 的正整数 $x, y$，满足 $x \cdot y = a_i \cdot a_j$； 将 $a_i, a_j$ 改为 $x, y$。 输出任意次操作后数组的和的最大值 x2022。 思路显然，对于 $a_i, a_j$，$1 + a_i \cdot a_j$ 一定是所有操作中最大的和，那么我们可以依次从左到右将所有数都执行一遍该操作，得到 $1, 1, 1, \ldots, \prod a_i$，求和即可。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t-- > 0)&#123; int n = scanner.nextInt(); long[] a = new long[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); for(int i=0;i&lt;n-1;i++)&#123; a[n - 1] = a[n - 1] * a[i]; a[i] = 1; &#125; System.out.println(2022 * ((long) (n - 1) + a[n - 1])); &#125; &#125; &#125; 简单思维题 &amp; 2022x1 B. Kill Demodogs题意给定一个 $n \times n$ 的矩阵，$(i, j)$ 位置的元素值为 $i \times j$。定义人物从 $(1, 1)$ 走到 $(n, n)$，期间人物只能向下或向右移动一格，输出到达终点后经过的元素的值的总和的最大值。 思路显然，我们走对角线是最优的，此时横坐标和纵坐标的值最相近。 此时，我们可以得到下面的式子： $1 \times 1 + 1 \times 2 + 2 \times 2 + \ldots + (n - 1) \times n + n \times n$。 我们将其拆成两个式子： $1 \times 1 + 2 \times 2 + \ldots + n \times n$； $1 \times 2 + 2 \times 3 + \ldots + (n - 1) \times n$。 对于上述两个式子，我们套用公式即可。 最后，我们可以得到下面的式子： $\frac{n (n + 1) (2n + 1)}{6} + \frac{(n - 1) n (n + 1)}{3}$。 此时，我们有两个选择：大数或者逆元。任选其一即可。 时间复杂度：$O(1)?$ 对应AC代码import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(), mod = 1000000007; while(t -- > 0)&#123; long n = scanner.nextInt(); System.out.println((2022 * ((BigInteger.valueOf(n).multiply(BigInteger.valueOf(n + 1)).multiply(BigInteger.valueOf(2 * n + 1)).divide(BigInteger.valueOf(6)).mod(BigInteger.valueOf(mod)).longValue() + BigInteger.valueOf(n - 1).multiply(BigInteger.valueOf(n)).multiply(BigInteger.valueOf(n + 1)).divide(BigInteger.valueOf(3)).mod(BigInteger.valueOf(mod)).longValue()) % mod)) % mod); &#125; &#125; &#125; 大数yyds C. Even Subarrays题意给定一个长度为 $n$ 的数组 $a$，$1 \leq a_i \leq n$，输出连续的子序列的个数，子序列需满足子序列的异或值有偶数个因数。 思路这里需要用到一个性质：只有完全平方数的因数数量是奇数。 所以，我们不妨找完全平方数，然后取一个补集即可。 考虑到异或的交换性，我们不妨用答案来枚举。 更具体地说，我们不妨从前向后遍历，$cur$ 为前 $i$ 个元素的异或值，我们用 $m$ 数组存储这些异或值出现的次数，然后，我们枚举所有可能的答案，算出 $cur$ 需要和 前面的哪一段区间的异或值 进行异或后得到完全平方数，用类似于前缀和的方式记录答案。 考虑到 $a_i$ 的范围，我们只需枚举 $2n$ 及以下的完全平方数即可。 时间复杂度：$O(n \sqrt n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); long[] m = new long[2 * n]; int cur = 0; long cnt = 0; m[cur] = 1; for(int i=0;i&lt;n;i++)&#123; cur ^= a[i]; for(int j=0;j*j&lt;2*n;j++)&#123; int now = cur ^ (j * j); if(now &lt; 2 * n) cnt += m[now]; &#125; m[cur] ++; &#125; System.out.println((long) n * (n - 1) / 2 + n - cnt); &#125; &#125; &#125; 异或的性质太多力]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 840 Div 2</title>
    <url>/blog/posts/1344553303/</url>
    <content><![CDATA[Practice A. Absolute Maximization题意给定一个数组 $a$，定义操作为选择两个元素 $a_i, a_j$，并交换它们二进制下的第 $b$ 位。输出任意次操作后的 $max(a) - min(a)$ 的最大值。 思路既然可以无限次交换，那么我们只要找出最高位，从最高位开始往下找，只要有一个元素该位存在 $1$，那么我们就拿过来构建新的数字，这样即可得到最大值。反之同理。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); for(int w=0;w&lt;t;w++)&#123; int n = scanner.nextInt(); int[] min = new int[12], max = new int[12]; for(int i=0;i&lt;12;i++)&#123; min[i] = 1; max[i] = 0; &#125; int maxLen = 0; String[] input = new String[n]; for(int i=0;i&lt;n;i++) &#123; input[i] = Integer.toBinaryString(scanner.nextInt()); maxLen = Math.max(maxLen, input[i].length()); &#125; for(int i=0;i&lt;n;i++) &#123; while(input[i].length() != maxLen) input[i] = "0" + input[i]; for(int j=0;j&lt;maxLen;j++) &#123; int now = input[i].charAt(j) - '0'; max[j] = Math.max(max[j], now); min[j] = Math.min(min[j], now); &#125; &#125; int maxx = 0, minn = 0; for(int i=0;i&lt;maxLen;i++) &#123; maxx = maxx * 2 + max[i]; minn = minn * 2 + min[i]; &#125; System.out.println(maxx - minn); &#125; &#125; &#125; 简单思维题 B. Incinerate题意给定 $n$ 个怪物的生命值 $h_i$ 以及攻击力 $p_i$，主角的攻击力为 $k$，定义一次攻击为将所有怪物扣去 $k$ 点生命值，生命值小于等于 $0$ 的怪物死亡，剩余攻击力最低的怪物将会将主角的攻击力削减到 $k - p_i$。输出是否可以将怪打完。 思路模拟。 我们可以先按照生命值升序排序，维护一个存活的怪物的开始下标 $index$，那么想要快速获取到存活的怪物中攻击力最低的，我们可以维护一个后缀数组，存储 $index$ 及以后的 $p_{min}$。 时间复杂度：$O(nlogn)$ 对应AC代码import java.util.*; public class Main &#123; private static class Monster&#123; int h, p; Monster(int h)&#123; this.h = h; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); for(int w=0;w&lt;t;w++)&#123; int n = scanner.nextInt(), k = scanner.nextInt(); Monster[] m = new Monster[n]; for(int i=0;i&lt;n;i++) m[i] = new Monster(scanner.nextInt()); for(int i=0;i&lt;n;i++) m[i].p = scanner.nextInt(); Arrays.sort(m, Comparator.comparingInt(o -> o.h)); int[] suf = new int[n + 1]; suf[n] = Integer.MAX_VALUE; for(int i=n-1;i>=0;i--) suf[i] = Math.min(suf[i + 1], m[i].p); int index = 0, attack = 0; while(k > 0)&#123; for(int i=index;i&lt;n;i++)&#123; if(m[i].h - attack > k) break; index ++; &#125; if(index >= n) break; attack += k; k -= suf[index]; &#125; System.out.println(k > 0 ? "YES" : "NO"); &#125; &#125; &#125; 略微暴力但又不暴力（ C. Another Array Problem题意给定一个数组 $a$，定义操作为选择 $i, j,i \neq j$，将所有 $a_k, k \in [i, j]$ 修改为 $|a_i - a_j|$。在任意次操作后，输出数组的总和的最大值。 思路我们来考虑一下 $4$ 个及以上的情况： 在这个情况里，我们不妨找出最大值所在的下标 $imax$，然后用类似下面的思路完成： $\begin{array}{l}&gt;&gt;1\ 2\ 4\ 3 \ =&gt; 1\ 1\ 4\ 3 \ =&gt; 0\ 0\ 4\ 3 \ =&gt; 4\ 4\ 4\ 3 \ =&gt; 4\ 4\ 1\ 1 \ =&gt; 4\ 4\ 0\ 0 \ =&gt; 4\ 4\ 4\ 4\end{array}$ 也就是说，我们只需找出最大的值，最后一定有方案将所有数全都改为最大值。 那么 $3$ 个数呢？此时存在局限性，若最大值在两端，那么和上述一致，但最大值在中间时，我们就只能找出两端的 $min,max$，然后取 $a[1]-min$ 和 $max$ 的最大值。 同上，两个数的时候，最大值即为两个元素的差。 当然，我们也可以不操作，所以需要取一下操作后的答案和原总和的最大值。 时间复杂度：$O(n)?$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); for(int w=0;w&lt;t;w++)&#123; int n = scanner.nextInt(); long[] a = new long[n]; int maxIndex = 0; long sum = 0; for(int i=0;i&lt;n;i++)&#123; a[i] = scanner.nextLong(); sum += a[i]; maxIndex = a[maxIndex] &lt; a[i] ? i : maxIndex; &#125; long ans; if(n == 2) &#123; ans = Math.abs(a[1] - a[0]) * 2; &#125;else if(n == 3)&#123; if(maxIndex == 0 || maxIndex == 2) ans = a[maxIndex] * n; else&#123; long min = Math.min(a[0], a[2]), sMin = Math.max(a[0], a[2]); ans = Math.max(a[maxIndex] - min, sMin) * 3; &#125; &#125;else ans = a[maxIndex] * n; System.out.println(Math.max(sum, ans)); &#125; &#125; &#125; 很巧妙的思维题]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 839 Div 3</title>
    <url>/blog/posts/3095280907/</url>
    <content><![CDATA[Practice. A. A+B?题意给定一个形如 $a+b$ 的字符串，输出答案。$a, b \in [0, 9]$。 思路模拟。 时间复杂度：$O(1)$ import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; String[] a = scanner.next().split("\\+"); System.out.println(Integer.parseInt(a[0]) + Integer.parseInt(a[1])); &#125; &#125; &#125; 过于签到，应该有语言可以一行解决吧 B. Matrix Rotation题意给定一个 $2 \times 2$ 的矩阵，定义操作为将矩阵旋转 $90°$，输出任意次操作后，能否使矩阵满足下面的条件： 每一行的第一个元素小于第二个元素； 每一列的第一个元素小于第二个元素。 思路模拟。 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt: while(t -- > 0)&#123; int a = scanner.nextInt(), b = scanner.nextInt(), c = scanner.nextInt(), d = scanner.nextInt(); for(int i=0;i&lt;4;i++)&#123; if(a &lt; b &amp;&amp; b &lt; d &amp;&amp; a &lt; c &amp;&amp; c &lt; d)&#123; System.out.println("YES"); continue nxt; &#125; int tmp = b; b = a; a = c; c = d; d = tmp; &#125; System.out.println("NO"); &#125; &#125; &#125; 模拟就完事了 C. Different Differences题意给定两个整数 $k, n$，构造长度为 $k$ 且严格递增的数组 $a$，其中 $a{k - 1} \leq n$。输出一种构造，使数组 $[a_2 - a_1, a_3 - a_2, \ldots a_k - a{k - 1}]$ 内不相同的元素数量最大。 思路若数组无长度和大小限制，那么我们只需输出以 $1$ 为首项和公差的等差数列的前 $n$ 项和即可。 考虑到限制，我们在输出第 $i$ 项的时候，还因考虑它的最大值 $i + n - k$，取一个最小值即可。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int k = scanner.nextInt(), n = scanner.nextInt(); int a = 1; for(int i=1;i&lt;=k;i++)&#123; System.out.printf("%d ", Math.min(a, i + n - k)); a += i; &#125; System.out.println(); &#125; &#125; &#125; 简单构造题 D. Absolute Sorting题意给定一个数组 $a$，所有元素均为正整数。输出一个 $x$，满足将所有数减掉 $x$ 后取绝对值后的序列不递减。若无解，输出 $-1$。 思路由题意，我们需要满足 $|ai - x| \leq |a{i + 1} - x|$。 我们不妨先来考虑 $ai &lt; a{i + 1}$ 的情况： $x \leq ai$，那么原式化为 $a_i \leq a{i + 1}$，恒成立； $x \geq a{i + 1}$，那么原式化为 $a_i \geq a{i + 1}$，不成立； $ai &lt; x &lt; a{i + 1}$，那么原式化为 $x - ai \leq a{i + 1} - x$，即 $x \leq \lfloor \frac{ai + a{i + 1}}{2} \rfloor$。 综上所述，$x \le \lfloor \frac{ai + a{i+1}}{2} \rfloor$。 同理，当 $ai &gt; a{i + 1}$ 时，$x \ge \lceil \frac{ai + a{i+1}}{2} \rceil$。 因而，我们只需求出左端点的最大值 $l$ 和右端点的最小值 $r$，然后判断 $l \leq r$ 是否成立即可。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int pre = scanner.nextInt(); int l = 0, r = Integer.MAX_VALUE; for(int j = 1; j &lt; n; j++) &#123; int cur = scanner.nextInt(); if(pre > cur) l = Math.max(l, (pre + cur + 1) / 2); if(pre &lt; cur) r = Math.min(r, (pre + cur) / 2); pre = cur; &#125; System.out.println(l &lt;= r ? l : -1); &#125; &#125; &#125; 简单的拆绝对值分类讨论]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - TypeDB Forces 2023 Div 1 plus 2</title>
    <url>/blog/posts/1090672605/</url>
    <content><![CDATA[Contestant. Rank 3808. Rating +17. A. Exponential Equation题意给定整数 $n$，输出一对 $x, y$，满足 $x ^ y \cdot y + y ^ x \cdot x = n$。 思路不妨令 $x = 1$，那么 $y = n / 2$。 显然，当 $n$ 为奇数的时候，一定是无解的，因为 $x ^ y \cdot y$ 和 $y ^ x \cdot x$ 的奇偶性一定是一致的。 所以，$n$ 为偶数的时候，输出 $1, n / 2$。 时间复杂度：$O(1)$ 对应AC代码import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt: while (t-- > 0) &#123; int n = scanner.nextInt(); if(n % 2 == 1) System.out.println(-1); else System.out.printf("%d %d\n", 1, n / 2); &#125; &#125; &#125; 你说我怎么就这么蠢 B. Number Factorization题意给定一个整数 $n$，构建数组 $a, p$，使 $n = \prod a_i^{p_i}$。其中，$a_i$ 必须为不相同的质数的乘积。 输出 $\sum a_i \cdot p_i$ 的最大值。 思路显然，$a_i ^ {p_i} = a_i \cdot a_i \cdot \ldots$，那么我们不妨直接拆开，令所有 $p_i = 1$。 那么，我们只需分解质因数，分别将出现次数 $\geq 1$ 次、$\geq 2$ 次 … 的数相乘后求和即可。 时间复杂度：不会分析 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 500010, inf = 0x3f3f3f3f; #define int long long vector&lt;int> primes; bool vis[N]; void init() &#123; for (int i = 2; i &lt;= N; ++i) &#123; if (!vis[i]) &#123; primes.emplace_back(i); &#125; for (int j : primes) &#123; if (1ll * i * j > N) break; vis[i * j] = true; if (i % j == 0) break; &#125; &#125; &#125; vector&lt;tuple&lt;int, int, bool>> fact(int x) &#123; vector&lt;tuple&lt;int, int, bool>> f; for (int i : primes) &#123; if(i > x) break; if (x % i == 0) &#123; int cnt = 0; while (x % i == 0) x /= i, cnt ++; if(cnt != 0) f.emplace_back(i, cnt, false); &#125; &#125; if (x != 1) &#123; f.emplace_back(x, 1, false); &#125; return f; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t, n; cin >> t; while(t --) &#123; cin >> n; vector&lt;tuple&lt;int, int, bool>> f = fact(n); int ans = 0, cnt = f.size(); while(cnt > 0)&#123; int now = 1; for(auto &amp;e : f)&#123; int x, p, ok; tie(x, p, ok) = e; if(ok) continue; now *= x; p --; if(p == 0) get&lt;2>(e) = true, cnt --; get&lt;1>(e) = p; &#125; ans += now; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 写得好乱 C. Remove the Bracket题意给定一个数组 $a$ 以及一个整数 $s$，对于所有 $i \in [2, n- 1]$，有 $x_i+y_i=a_i$ 且 $(x_i - s)(y_i - s) \geq 0$。 构造 $x_i, y_i$，让下列式子的值最小，并输出这个值 $F = a1 \cdot x_2+y_2 \cdot x_3+y_3 \cdot x_4 + \ldots + y{n - 2} \cdot x{n-1}+y{n-1} \cdot a_n$ 思路我们不妨来单独考虑 $x_i,y_i$： 将其放入式子，我们可以得到 $\ldots+ y{i-1}\cdot x_i+y_i\cdot x{i+1}+\ldots$。在这段式子里，若 $xi + 1,y_i - 1$，那么整个式子将会减少 $x{i + 1} - y_{i - 1}$。 也就是说，我们希望 $x_i$ 或 $y_i$ 取到 $s$，因为只有在边界才能找到最值。 因而，我们可以用 $dp$ 枚举所有我们希望的情况中的最小值。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(), s = console.nextInt(); long[] min = new long[n + 1], max = new long[n + 1]; for(int i=1;i&lt;=n;i++)&#123; int cur = console.nextInt(); if(i == 1 || i == n)&#123; min[i] = max[i] = cur; &#125;else if(cur &lt;= s)&#123; min[i] = 0; max[i] = cur; &#125;else&#123; min[i] = Math.min(s, cur - s); max[i] = Math.max(s, cur - s); &#125; &#125; long[][] dp = new long[n + 1][2]; for(int i=2;i&lt;=n;i++)&#123; dp[i][0] = Math.min(dp[i - 1][0] + max[i - 1] * min[i], dp[i - 1][1] + min[i - 1] * min[i]); dp[i][1] = Math.min(dp[i - 1][0] + max[i - 1] * max[i], dp[i - 1][1] + min[i - 1] * max[i]); &#125; console.println(dp[n][0]); &#125; console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; 论想不到dp于是乱找规律这件事]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 849 Div 4</title>
    <url>/blog/posts/752853425/</url>
    <content><![CDATA[Contestant. Rank 3392. Rating -15. 代码略去了快读模板 A. Codeforces Checking题意给定一个字符，判断是否在 $codeforces$ 字符串中出现。 思路数组记录 + 读数组。 时间复杂度：$O(1)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); boolean[] have = new boolean[26]; for(char each : "codeforces".toCharArray()) have[each - 'a'] = true; while(t -- > 0)&#123; console.println(have[console.next().toCharArray()[0] - 'a'] ? "YES" : "NO"); &#125; console.close(); &#125; &#125; 语法题 x1 B. Following Directions题意给定一个由 $U,D,L,R$ 组成的字符串，分别代表向上、下、左、右移动一个单位距离。输出从原点开始移动，途中是否经过 $(1,1)$。 思路模拟。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); String step = console.next(); int x = 0, y = 0; for(char each : step.toCharArray())&#123; if(each == 'L') x --; else if(each == 'R') x ++; else if(each == 'U') y ++; else y --; if(x == 1 &amp;&amp; y == 1)&#123; console.println("YES"); continue nxt; &#125; &#125; console.println("NO"); &#125; console.close(); &#125; &#125; 语法题 x2 C. Prepend and Append题意给定一个二进制字符串，定义操作为在字符串左端拼接上 $0$ 并在右端拼接上 $1$，或者在字符串左端拼接上 $1$ 并在右端拼接上 $0$。给定的字符串为一个原字符串经过多次操作后得到的。输出最小的原字符串。 思路遍历，找到第一个位置，满足两端的值相同。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); String in = console.next(); int cnt = 0; for(int i=0;i&lt;n/2;i++)&#123; if((in.charAt(i) == '0' &amp;&amp; in.charAt(n - i - 1) == '1') || (in.charAt(i) == '1' &amp;&amp; in.charAt(n - i - 1) == '0')) cnt ++; else break; &#125; console.println(n - cnt * 2); &#125; console.close(); &#125; &#125; 签到题 x3 D. Distinct Split题意给定一个字符串，将字符串分割为两个字符串，第一个字符串中不同字母的数量和第二个字符串中不同字母的数量之和最大，并输出这个最大值。 思路维护一个前缀不同字母数量和后缀不同字母数量，然后枚举每一位，求 $pre[i] + suf[i + 1]$ 的最大值。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); char[] s = console.next().toCharArray(); boolean[] ok1 = new boolean[26], ok2 = new boolean[26]; int[] pre = new int[n + 2], suf = new int[n + 2]; for(int i=1;i&lt;=n;i++)&#123; char e = s[i - 1]; pre[i] = pre[i - 1]; if(!ok1[e - 'a']) pre[i] ++; ok1[e - 'a'] = true; &#125; for(int i=n;i>=1;i--)&#123; char e = s[i - 1]; suf[i] = suf[i + 1]; if(!ok2[e - 'a']) suf[i] ++; ok2[e - 'a'] = true; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; ans = Math.max(ans, pre[i] + suf[i + 1]); &#125; console.println(ans); &#125; console.close(); &#125; &#125; 略微有点不签到起来了（（ E. Negatives and Positives题意给定一个数组 $a$，定义操作为选两个相邻的元素并将它们都取相反数。输出任意次操作后数组的总和的最大值。 思路首先，因为操作数量不限制，我们不妨来考虑选几个连续的相邻元素。 举个例子，如 $[a,b,c,d,e]$，我们从第一位开始操作到倒数第二位，操作看起来是这样的： $\begin{array}{l} &gt;&gt; [-a, -b, c, d, e] \ =&gt; [-a, b, -c, d, e] \ =&gt; [-a, b, c, -d, e] \ =&gt; [-a, b, c, d, -e]\end{array}$ 显然，只要是连续的操作，那么每次操作等效于移动负号的位置。 或者，换句话说，我们完全不需要考虑 “相邻” 这个条件，跳着操作是完全可行的。 那么，我们只需升序排序，然后将负数一对一对取反。 当然，若负数的数量为奇数，那么对于最后剩余的那个奇数，我们只需将其和最小的非负数比较绝对值即可。若负数的绝对值较大，那么直接把负数和最小非负数的符号交换一下即可。 时间复杂度：$O(nlogn)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); long[] a = new long[n]; long sum = 0; int cnt = 0; for(int i=0;i&lt;n;i++)&#123; int cur = console.nextInt(); sum += cur; a[i] = cur; if(a[i] &lt; 0) cnt ++; &#125; Arrays.sort(a); for(int i=0;i&lt;cnt/2*2;i++) sum -= 2 * a[i]; if(cnt % 2 == 1)&#123; int p = cnt / 2 * 2; if(p + 1 &lt; n)&#123; if(-a[p] > a[p + 1])&#123; sum -= 2 * a[p]; sum -= 2 * a[p + 1]; &#125; &#125; &#125; console.println(sum); &#125; console.close(); &#125; &#125; 简单思维题，但是也可以dp~ F. Range Update Point Query题意给定一个数组 $a$ 以及 $q$ 个询问，询问为下列情况任选其一： 给定 $l, r$，将 $[l,r]$ 内的所有数更新为每个数 十进制下每一位的和； 给定 $x$，输出 $a_x$。 输出询问所要求的内容。 思路首先，询问 $1$ 的操作具有收敛性，在 $1e9$ 的范围内，第一次操作后的最大值只有 $8 \times 9 = 72$，那么我们不难发现，对于一个数，我们最多只能操作 $3$ 次，超过 $3$ 次后值一定不变。 我们定义一个数组 $b$，$b_i$ 表示第 $i$ 位已经操作了多少遍。 因而，我们只需考虑一个问题：怎么让区间更新和单点查询效率更高呢？ 没错，就是线段树。 不难发现，我们只需套上线段树的板子，然后略微修改即可。 时间复杂度：不会分析 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long int n, a[200005][4], d[600000], b[600000]; void update(int l, int r, int c, int s, int t, int p) &#123; if (l &lt;= s &amp;&amp; t &lt;= r) &#123; d[p] += (t - s + 1) * c, b[p] += c; // 如果区间被包含了，直接得出答案 return; &#125; int m = s + ((t - s) >> 1); if (b[p]) d[p &lt;&lt; 1] += b[p] * (m - s + 1), d[(p &lt;&lt; 1) | 1] += b[p] * (t - m), b[p &lt;&lt; 1] += b[p], b[(p &lt;&lt; 1) | 1] += b[p]; b[p] = 0; if (l &lt;= m) update(l, r, c, s, m, p &lt;&lt; 1); // 本行和下面的一行用来更新p*2和p*2+1的节点 if (r > m) update(l, r, c, m + 1, t, (p &lt;&lt; 1) | 1); d[p] = d[p &lt;&lt; 1] + d[(p &lt;&lt; 1) | 1]; // 计算该节点区间和 &#125; int getsum(int l, int r, int s, int t, int p) &#123; if (l &lt;= s &amp;&amp; t &lt;= r) return d[p]; int m = s + ((t - s) >> 1); if (b[p]) d[p &lt;&lt; 1] += b[p] * (m - s + 1), d[(p &lt;&lt; 1) | 1] += b[p] * (t - m), b[p &lt;&lt; 1] += b[p], b[(p &lt;&lt; 1) | 1] += b[p]; b[p] = 0; int sum = 0; if (l &lt;= m) sum =getsum(l, r, s, m, p &lt;&lt; 1); // 本行和下面的一行用来更新p*2和p*2+1的答案 if (r > m) sum += getsum(l, r, m + 1, t, (p &lt;&lt; 1) | 1); return sum; &#125; signed main() &#123; ios::sync_with_stdio(0); int t; cin >> t; while(t --) &#123; memset(a, 0, sizeof a); memset(d, 0, sizeof d); memset(b, 0, sizeof b); int q; cin >> n >> q; for (int i = 1; i &lt;= n; i++) &#123; int cur; cin >> cur; a[i][0] = cur; for(int j=1;j&lt;=3;j++)&#123; int x = a[i][j - 1]; while(x > 0)&#123; a[i][j] += x % 10; x /= 10; &#125; &#125; &#125; while (q--) &#123; int i1; cin >> i1; if(i1 == 1)&#123; int l, r; cin >> l >> r; update(l, r, 1, 1, n, 1); &#125;else&#123; int w; cin >> w; int t = getsum(w, w, 1, n, 1); t = min(3ll, t); cout &lt;&lt; a[w][t] &lt;&lt; '\n'; &#125; &#125; &#125; return 0; &#125; 不可以用Set的lower_bound来略微优雅一点地暴力，会炸 G1. Teleporters (Easy Version)题意给定一个数组 $a$ 以及一个整数 $c$，$c$ 为硬币的总数量，$a_i$ 表示该传送点需要的硬币数量。定义每自主移动一步会扣除 $1$ 个硬币，传送点是否使用是可选的，若使用传送点，将会使人物传送到原点，同时消耗对应数量的硬币。初始状态下，人物一定在原点，输出可使用传送点的最大数量。 思路将 $a$ 数组的所有数加上离原点的距离，升序排序 $a$ 然后枚举即可。 时间复杂度：$O(nlogn)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(), c = console.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = console.nextInt() + (i + 1); Arrays.sort(a); int cnt = 0; for(int i=0;i&lt;n;i++)&#123; c -= a[i]; if(c &lt; 0) break; cnt ++; &#125; console.println(cnt); &#125; console.close(); &#125; &#125; 略微有点么签到 G2. Teleporters (Hard Version)题意在 $G1$ 的基础上，传送点可以传送到原点 $0$ 或 $n + 1$，但人物的初始位置一定是原点。 思路显然，我们一定得枚举，若讨论的话，会特别复杂。 我们考虑存储 $a_i$ 加上离两端距离的最小值，以及其加上离原点的最大值，按照前者升序排序。 然后，我们枚举所有点，对于所枚举到的点 $a_i$，我们将其视为第一个使用的传送点，那么剩余的硬币数量即为 $c - a[i][1]$。 也许我们可以像前一题那样直接遍历，但那样显然太复杂了。 我们不妨用前缀和 + 二分的方式，这样便可快速找出最大的满足条件的数量了。 当然，使用前缀和要考虑排除当前作为第一个传送点的点。 时间复杂度：$O(nlogn)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(), c = console.nextInt(); long[][] a = new long[n][2]; for(int i=0;i&lt;n;i++) &#123; int cur = console.nextInt(); a[i] = new long[]&#123;cur + Math.min(i + 1, n - i), cur + i + 1&#125;; &#125; Arrays.sort(a, Comparator.comparingLong(o -> o[0])); long[] pre = new long[n + 1]; for(int i=1;i&lt;=n;i++) pre[i] = pre[i - 1] + a[i - 1][0]; long cnt = 0; for(int i=0;i&lt;n;i++)&#123; long nc = c - a[i][1]; int l = 0, r = n, mid, max = 0; while(l &lt;= r)&#123; mid = (l + r) >> 1; if(pre[mid] - ((mid > i) ? a[i][0] : 0) &lt;= nc)&#123; max = Math.max(mid + (mid > i ? 0 : 1), max); l = mid + 1; &#125;else r = mid - 1; &#125; cnt = Math.max(cnt, max); &#125; console.println(cnt); &#125; console.close(); &#125; &#125; 草，赛时一直在分类讨论，快死了]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 850 Div 2</title>
    <url>/blog/posts/2626568649/</url>
    <content><![CDATA[Contestant. Rank 540. Rating +126. 代码略去了快读模板 A1. Non-alternating Deck (easy version)题意给定 $n$ 个颜色相同的卡片，取卡片顺序为 $A,B,B,A,A,B,B,A,A,B,B,…$，每次取卡片的数量依次递增，当无法继续取的时候，按照正常顺序，下一个取卡片的人取完所有卡片。输出 $A,B$ 各取了多少卡片。 思路暴力模拟。 时间复杂度：$O(\sqrt n)?$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt() - 1; int w = 2; boolean who = false; int a = 1, b = 0, cnt = 0; while(n >= w)&#123; if(who) a += w; else b += w; n -= w; w ++; cnt ++; if(cnt == 2) &#123; who = !who; cnt = 0; &#125; &#125; if(who) a += n; else b += n; console.print(a + " " + b + "\n"); &#125; console.close(); &#125; &#125; 快速打卡 A2. Alternating Deck (hard version)题意给定 $n$ 个颜色相间的卡片，第一个为白色，取卡片顺序为 $A,B,B,A,A,B,B,A,A,B,B,…$，每次取卡片的数量依次递增，当无法继续取的时候，按照正常顺序，下一个取卡片的人取完所有卡片。输出 $A,B$ 各取了多少白色卡片和多少黑色卡片。 思路暴力模拟。 多加几个变量标记即可。 时间复杂度：$O(\sqrt n)?$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt() - 1; int w = 2; boolean who = false; int a1 = 1, b1 = 0, a2 = 0, b2 = 0, cnt = 0; while(n >= w)&#123; if(who) &#123; a1 += w / 2 + w % 2; a2 += w / 2; &#125; else &#123; b1 += w / 2; b2 += w / 2 + w % 2; &#125; n -= w; w ++; cnt ++; if(cnt == 2) &#123; who = !who; cnt = 0; &#125; &#125; if(who) &#123; a1 += n / 2 + n % 2; a2 += n / 2; &#125; else &#123; b1 += n / 2; b2 += n / 2 + n % 2; &#125; console.print(a1 + " " + a2 + " " + b1 + " " + b2 + "\n"); &#125; console.close(); &#125; &#125; 依然是快速打卡 B. Cake Assembly Line题意给定 $n$ 个蛋糕的中心点 $a$ 以及 $n$ 个巧克力酱的固定涂抹范围的中心点 $b$，蛋糕的大小为 $[a_i - w, a_i + w]$，巧克力酱的涂抹范围为 $[b_i - h, b_i + h]$。所有蛋糕均在传送带上，且相对位置不变。输出是否可以移动传送带，让所有的巧克力酱都涂在蛋糕上。 思路我们设 $a_l = a[i] - w, a_r = a[i] + w, b_l = b[i] - h, b_r = b[i] + h$。 显然，我们不可能模拟移动，因为数据范围太大了。 考虑到每一个蛋糕都有对应的最小和最大移动距离，那么我们只需枚举所有蛋糕，更新最小移动距离的最大值和最大移动距离的最小值即可，这样操作之后，$[min,max]$ 内的所有移动距离都可以满足条件了。 我们以左边界为参考点，那么对于一个蛋糕，移动距离的最小值为 $br - ar$，最大值为 $bl - al$。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(), w = console.nextInt(), h = console.nextInt(); long[] a = new long[n], b = new long[n]; for(int i=0;i&lt;n;i++) a[i] = console.nextInt(); for(int i=0;i&lt;n;i++) b[i] = console.nextInt(); long min = Long.MIN_VALUE, max = Long.MAX_VALUE; for(int i=0;i&lt;n;i++)&#123; long al = a[i] - w, ar = a[i] + w, bl = b[i] - h, br = b[i] + h; min = Math.max(min, br - ar); max = Math.min(max, bl - al); &#125; console.println(min &lt;= max ? "YES" : "NO"); &#125; console.close(); &#125; &#125; 只要一个参考点就够了 C. Monsters (easy version)题意给定一个序列 $a$，定义两种操作为： 选择任意一个非 $0$ 数，将其减 $1$； 将整个序列所有非 $0$ 数减 $1$，若减完后出现至少一个数为 $0$，那么本操作循环执行。 输出让整个序列为 $0$ 的操作 $1$ 的最小数量。 思路显然，我们只需升序排序序列，然后构造一个不递减，相邻数之差 $\leq 1$ 的序列即可。 如 $1,1,1,4,4,5$，将其构造为 $1,1,1,2,2,3$。 答案即为原序列和该序列的差。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = console.nextInt(); Arrays.sort(a); long cnt = 0, w = 0; for(int i=0;i&lt;n;i++)&#123; if(a[i] != w)&#123; w ++; cnt += a[i] - w; &#125; &#125; console.println(cnt); &#125; console.close(); &#125; &#125; 逾越丁真，鉴定为不开long long D. Letter Exchange题意给定 $m$ 个由 $w,i,n$ 构成的长度为 $3$ 的字符串，定义一次操作为指定两个人互换他们的任意一个字符。输出操作数的最小值以及对应的操作方案。 思路思维+模拟。 首先，由于题给限制，方案一定是存在的，那么互换字符会出现两种可能： $A$ 缺了 $a$，但多了 $b$；$B$ 缺了 $b$，但多了 $a$；那么 $A,B$ 交换一下； $A$ 缺了 $a$，但多了 $c$；$B$ 缺了 $c$，但多了 $b$；$C$ 缺了 $b$，但多了 $a$；那么三者互换一下。 对于上述操作，操作 $1$ 的交换次数是 $1$，操作 $2$ 的交换次数是 $2$。 显然，若只执行上面的两个操作，只要不出现无意义操作，操作数一定是最小的。 那么，我们可以执行完所有操作 $1$ 后再执行操作 $2$，因为配对是最容易的，而且配对结束后，剩下的字符一定是满足操作 $2$ 的条件的。 那么我们可以用数组存储所有 多 $a$ 少 $b$ 的数量，然后略微暴力模拟一下即可。 时间复杂度：懒得分析 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); List&lt;List&lt;Integer>> a = new ArrayList&lt;>(); for(int i=0;i&lt;6;i++) a.add(new ArrayList&lt;>()); //0 wi, 1 wn, 2 iw, 3 in, 4 nw, 5 ni for(int i=1;i&lt;=n;i++)&#123; String now = console.next(); int[] cnt = new int[3]; for(int j=0;j&lt;3;j++)&#123; char e = now.charAt(j); if(e == 'w') cnt[0] ++; else if(e == 'i') cnt[1] ++; else cnt[2] ++; &#125; if(cnt[0] == 1 &amp;&amp; cnt[1] == 1 &amp;&amp; cnt[2] == 1) continue; if(cnt[0] == 3) &#123; a.get(0).add(i); a.get(1).add(i); &#125;else if(cnt[1] == 3)&#123; a.get(2).add(i); a.get(3).add(i); &#125;else if(cnt[2] == 3)&#123; a.get(4).add(i); a.get(5).add(i); &#125;else if(cnt[0] == 2 &amp;&amp; cnt[1] == 0)&#123; a.get(0).add(i); &#125;else if(cnt[0] == 2 &amp;&amp; cnt[2] == 0)&#123; a.get(1).add(i); &#125;else if(cnt[1] == 2 &amp;&amp; cnt[0] == 0)&#123; a.get(2).add(i); &#125;else if(cnt[1] == 2 &amp;&amp; cnt[2] == 0)&#123; a.get(3).add(i); &#125;else if(cnt[2] == 2 &amp;&amp; cnt[0] == 0)&#123; a.get(4).add(i); &#125;else if(cnt[2] == 2 &amp;&amp; cnt[1] == 0)&#123; a.get(5).add(i); &#125; &#125; int cnt = Math.min(a.get(0).size(), a.get(2).size()) + Math.min(a.get(1).size(), a.get(4).size()) + Math.min(a.get(3).size(), a.get(5).size()); int left = Math.max(a.get(0).size(), a.get(2).size()) + Math.max(a.get(1).size(), a.get(4).size()) + Math.max(a.get(3).size(), a.get(5).size()) - cnt; cnt += left / 3 * 2; console.println(cnt); for(int i=0;i&lt;Math.min(a.get(0).size(), a.get(2).size());i++)&#123; console.println(a.get(0).get(i) + " w " + a.get(2).get(i) + " i"); &#125; for(int i=0;i&lt;Math.min(a.get(1).size(), a.get(4).size());i++)&#123; console.println(a.get(1).get(i) + " w " + a.get(4).get(i) + " n"); &#125; for(int i=0;i&lt;Math.min(a.get(3).size(), a.get(5).size());i++)&#123; console.println(a.get(3).get(i) + " i " + a.get(5).get(i) + " n"); &#125; if(left > 0) &#123; boolean b1 = a.get(0).size() > a.get(2).size(), b2 = a.get(1).size() > a.get(4).size(), b3 = a.get(3).size() > a.get(5).size(); for (int i = 0; i &lt; left / 3; i++) &#123; if(b1 &amp;&amp; !b2 &amp;&amp; b3)&#123; console.println(a.get(0).get(a.get(2).size() + i) + " w " + a.get(3).get(a.get(5).size() + i) + " i"); console.println(a.get(4).get(a.get(1).size() + i) + " n " + a.get(3).get(a.get(5).size() + i) + " w"); &#125;else&#123; console.println(a.get(2).get(a.get(0).size() + i) + " i " + a.get(1).get(a.get(4).size() + i) + " w"); console.println(a.get(5).get(a.get(3).size() + i) + " n " + a.get(1).get(a.get(4).size() + i) + " i"); &#125; &#125; &#125; &#125; console.close(); &#125; &#125; 依托答辩，但是Accepted.]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 6</title>
    <url>/blog/posts/3918832662/</url>
    <content><![CDATA[Rank 663/3064. AC 7/12. A. 阿宁的签到题题意根据分数输出等级。 思路一门编程语言的基础之基础。 时间复杂度：$O(1)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long x = scanner.nextLong(); if(1 &lt;= x &amp;&amp; x &lt;= 7) System.out.println("very easy"); else if(x &lt;= 233) System.out.println("easy"); else if(x &lt;= 10032) System.out.println("medium"); else if(x &lt;= 114514) System.out.println("hard"); else if(x &lt;= 1919810) System.out.println("very hard"); else System.out.println("can not imagine"); &#125; &#125; 送分还不写快点啊（（ B. 阿宁的倍数题意给定一个长度为 $n$ 的数组 $a$，下标从 $1$ 开始，对于 $q$ 次操作，输出需要输出的内容。 操作分为两种： 修改操作：数组末尾增加一个数 $x$。 询问操作：对于所有 $i&gt;x$，输出有多少 $a_i$ 是 $a_x$ 的倍数。 思路我们考虑维护两个数组 $tot,pre$。 其中，$tot[a[i]]$ 表示整个序列有多少数是 $a[i]$ 的倍数，$pre[i]$ 表示 $[0, i]$ 区间内有多少数是 $a[i]$ 的倍数。 那么，对于每次查询的 $x$，输出 $tot[a[x]]-pre[x]$ 即可。 我们来考虑一下这两个数组如何构建： 我们可以从前往后遍历，枚举 $a[i]$ 的所有因数 $j$，将所有 $tot[j]$ 加上 $1$，那么我们可以保证最后得到的 $tot$ 是我们想要的数组，与此同时， 按照上述遍历方法，$tot[a[i]]$ 就是 $pre[i]$ 的值。 在修改操作时，我们只需在加入新加的数 $x$ 的同时，更新 $tot,pre$ 即可。 时间复杂度：$O(n \sqrt n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 400010; int a[N], tot[N], pre[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, q; cin >> n >> q; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; for(int j=1;j&lt;=a[i]/j;j++)&#123; if(a[i] % j == 0)&#123; tot[j] ++; if(j != a[i] / j) tot[a[i] / j] ++; &#125; &#125; pre[i] = tot[a[i]]; &#125; while(q --)&#123; int op, x; cin >> op >> x; if(op == 1)&#123; a[++ n] = x; for(int j=1;j&lt;=a[n]/j;j++)&#123; if(a[n] % j == 0)&#123; tot[j] ++; if(j != a[n] / j) tot[a[n] / j] ++; &#125; &#125; pre[n] = tot[a[n]]; &#125;else cout &lt;&lt; tot[a[x]] - pre[x] &lt;&lt; '\n'; &#125; return 0; &#125; 比较暴力但又不太暴力的做法 C. 阿宁的大背包题意给定背包的数量 $n$，$n$ 个背包的大小构成一个 $n$ 的排列，按照将相邻背包合成一个新的大背包的方式，经过 $n-1$ 次合并，得到一个大背包。输出一个排列，满足最终背包最大，并输出值。 合并方式：$[a, b, c, d] =&gt; [a + b , b + c , c + d]$ 思路我们直接来考虑 $5$ 个物品时的合并结果： $\begin{array}{l}&gt;&gt;[a, b, c, d, e] \ =&gt; [a + b, b + c, c + d, d + e] \ =&gt; [a + 2b + c, b + 2c + d, c + 2d + e] \ =&gt; [a + 3b + 3c + d, b + 3c + 3d + e] \ =&gt; [a + 4b + 6c + 4d + e] \end{array}$ 我们不妨留意一下从第二次合并后每项的系数，没错，就是杨辉三角。 于是，构建数组就非常明显了：我们只要按 中间向两侧递减 排列即可。 接着，考虑到数据范围并不大，于是下列两种方法均可行： 暴力合并； 计算出杨辉三角，作为系数和数组相乘。 考虑到暴力合并更不用脑子，这边采取方案 $1$。 时间复杂度：$O(n ^ 2)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int n = console.nextInt(); long mod = 1000000007; int[] a = new int[n]; for(int i=0;i&lt;n/2;i++) a[i] = i * 2 + 1; if(n % 2 == 1) a[n / 2] = n; for(int i=0;i&lt;n/2;i++) a[n - i - 1] = (i + 1) * 2; List&lt;Integer> ans = new ArrayList&lt;>(); for(int i=0;i&lt;n;i++) ans.add(a[i]); for(int t=n;t>=2;t--)&#123; List&lt;Integer> now = new ArrayList&lt;>(); for(int i=0;i&lt;t-1;i++) now.add((int)(((long) ans.get(i) + ans.get(i + 1)) % mod)); ans = now; &#125; console.println(ans.get(0)); for(int i=0;i&lt;n;i++) console.print(a[i] + " "); console.close(); &#125; //快读模板，此处略去 //public static class Console implements Closeable &#123;&#125; &#125; 优雅的暴力 D. 阿宁的毒瘤题题意给定一个字符串 $s$，修改任意一个字符为其他字符，让子序列 $udu$ 的数量最小，子序列不一定连续。输出修改后的 $s$。 思路不是 $dp$ !!!! 首先，如果不删掉字符的话，做法就是很简单的 $dp$，但这题如果用 $dp$ 解的话，会特别麻烦，~且我无法证明正确性~。 反而，这题是一道偏模拟的前缀和。 我们分别考虑删掉一个 $d$ 和删掉一个 $u$ 的代价： 对于一个 $d$，它的价值为 $u{pre} \times u{suf}$； 对于一个 $u$，它的价值为 $ud{pre} + du{suf}$。 于是，我们可以考虑前缀和的方法，统计正方向第 $i$ 位前面有多少 $u$，反方向后面有多少 $u$ 即可。 注意，不止有 $u,d$ 这两个字符，不要偷懒不写 $else\ if$。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010, inf = 0x3f3f3f3f; int pre[N], ps[N], ss[N]; string s; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> s; int n = s.length(); int cu = 0; for(int i=0;i&lt;n;i++) if(s[i] == 'u') cu ++; int maxx = 0, maxi = 0; for(int i=0;i&lt;n;i++)&#123; if(i > 0) &#123; pre[i] = pre[i - 1]; ps[i] = ps[i - 1]; &#125; if(s[i] == 'u')&#123; pre[i] ++; &#125;else if(s[i] == 'd')&#123; if(maxx &lt; pre[i] * (cu - pre[i]))&#123; maxx = pre[i] * (cu - pre[i]); maxi = i; &#125; ps[i] += pre[i]; &#125; &#125; for(int i=n-1;i>=0;i--)&#123; ss[i] = ss[i + 1]; if(s[i] == 'd') ss[i] += (cu - pre[i]); else if(s[i] == 'u')&#123; if(maxx &lt; ps[i] + ss[i])&#123; maxx = ps[i] + ss[i]; maxi = i; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) cout &lt;&lt; (maxi == i ? 'a' : s[i]); &#125; 做了一个小时dp，最后10分钟才大彻大悟，人快哭出来力 E. 阿宁的生成树 待补充 F. 阿宁的二进制题意给定一个长度为 $n$ 的数组 $a$，下标从 $1$ 开始，定义 $F(x)=cnt_1\ of\ binary\ x$。如 $F(5)=2$。 对于独立的 $q$ 次询问，定义一次操作为选定任意一个 $i$，执行 $a_i=F(a_i)$。给定操作数 $k$ ，输出 整个数组的最大值 的最小值。 每次询问输出答案后，数组 $a$ 恢复原样。 思路我们不妨来考虑 $1e9$ 范围内二进制下 $1$ 最多的数，它总共有 $30$ 个 $1$。 对于最大值 $30$，我们可以知道，第二次操作后最多只会有 $4$ 个 $1$。 继续操作，剩下最多 $2$ 个 $1$； 继续操作，剩下 $1$ 个 $1$。 也就是说，对于任意 $1e9$ 范围内的数，我们最多也只能进行 $4$ 次操作，之后值就为固定的 $1$。 换句话说，题给 $k$ 的范围是唬人的，真正 $k$ 的范围应为 $8 e 5$。 那么，我们不妨先将所有询问都读入，然后桶排序一下，再枚举操作 $p$ 次后的答案，若次数和询问相同，那么记录答案。我们不妨用大根堆来存储，让时间复杂度降到 $klogk$。 时间复杂度：$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010; pair&lt;int, int> qs[N]; int ans[N]; int F(int x) &#123; int cnt = 0; while (x != 0) &#123; if ((x &amp; 1) == 1) cnt++; x >>= 1; &#125; return cnt; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, q; cin >> n >> q; priority_queue&lt;int> pq; for(int i=0;i&lt;n;i++) &#123; int t; cin >> t; pq.emplace(t); &#125; for(int i=0;i&lt;q;i++)&#123; int t; cin >> t; qs[i] = &#123;t, i&#125;; &#125; sort(qs, qs + q, [](pair&lt;int, int> o1, pair&lt;int, int> o2)&#123;return o1.first &lt; o2.first;&#125;); int i = 0, to = 0; while(to &lt; q)&#123; int t = pq.top(); if(t == 1) break; pq.pop(); i ++; pq.push(F(t)); while(to &lt; q &amp;&amp; qs[to].first == i) ans[qs[to ++].second] = pq.top(); &#125; for(int t=0; t &lt; q; t++) &#123; if(ans[t] == 0) cout &lt;&lt; 1 &lt;&lt; '\n'; else cout &lt;&lt; ans[t] &lt;&lt; '\n'; &#125; &#125; 自从上次做过某题后，老想着会不会可以收敛（（ G. 阿宁的整数配对题意给定一个长度为 $n$ 的数组 $a$，选出 $k$ 对整数，输出每对整数相乘并求和的最大值。 思路排一个序，从两端取即可。 时间复杂度：$O(nlogn)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), k = scanner.nextInt(); long[] a = new long[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); int l = 0, r = n - 1; long ans = 0; for(int i=0;i&lt;k;i++)&#123; if(a[l] * a[l + 1] > a[r] * a[r - 1])&#123; ans += a[l] * a[l + 1]; l += 2; &#125;else&#123; ans += a[r] * a[r - 1]; r -= 2; &#125; &#125; System.out.println(ans); &#125; &#125; 打卡打卡~ H. 阿宁讨伐虚空题意给定 $x$ 个敌人，在 $[L,R]$ 内随机选一个 $y$ ，若 $y &lt; x$，那么敌人能被攻击到。输出能被攻击到的概率。 思路如题，分类讨论算一下概率即可。 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 100010; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int x, l, r; cin >> x >> l >> r; if(l > x - 1) cout &lt;&lt; 0; else if(r &lt; x) cout &lt;&lt; 1; else cout &lt;&lt; ((double) (x - l) / (double) (r - l + 1)); &#125; 简简单单签到题 I. 阿宁前往沙城题意给定一个无向图，定义操作为选定两条边，将一条边删除，并将另一条边的长度改为 $1$。在 操作可在任意时间可执行无限次 的条件下，输出 $1$ 到 $n$ 的最短路。 思路很显然，从第二条路开始，我们直接把前面的路毁掉即可。 所以我们不妨直接把所有边改成 $1$，用 $dijkstra$ 跑一遍最短路即可。 但得到的答案会出现一种特殊情况：最短路将所有边都覆盖了。 在该情况下，第一条只能用原来的长度替代了。 因此，直接套板子然后略微修改一下即可。 时间复杂度：$O(nlogn)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010; struct edge &#123; int v, w; &#125;; struct node &#123; int dis, u; bool operator>(const node&amp; a) const &#123; return dis > a.dis; &#125; &#125;; vector&lt;edge> e[N]; int dis[N], vis[N], cnt[N]; priority_queue&lt;node, vector&lt;node>, greater&lt;> > q; void dijkstra(int s) &#123; memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; q.push(&#123;0, s&#125;); while (!q.empty()) &#123; int u = q.top().u; q.pop(); if (vis[u]) continue; vis[u] = 1; for (auto ed : e[u]) &#123; int v = ed.v, w = ed.w; if (dis[v] > dis[u] + w) &#123; dis[v] = dis[u] + w; cnt[v] = cnt[u] + 1; q.push(&#123;dis[v], v&#125;); &#125; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; int minn = 0x3f3f3f3f; for(int i=0;i&lt;m;i++)&#123; int u, v, w; cin >> u >> v >> w; if(u == 1 || v == 1) minn = min(minn, w); e[u].push_back(&#123;v, 1&#125;); e[v].push_back(&#123;u, 1&#125;); &#125; dijkstra(1); cout &lt;&lt; (cnt[n] &lt; m ? cnt[n] : dis[n] + minn - 1); &#125; oi-wiki的板子真好用（划掉 J. 阿宁指指点点 待补充 K. 阿宁大战小红 待补充 L. 阿宁睡大觉题意给定一个 $n$ 行 $n-i+1$ 列的地图（正方形的左上角），每行的最后一个格子是美梦格子，除 $m$ 个噩梦格子外，其余格子都可以通过，输出从 $(1,1)$ 走到美梦格子的方案总数。 注意，$m \leq 10$。 思路这题有一个很明显的特点：障碍数远小于总格子数。 不考虑噩梦格子的话，总方案数很好求，即为 $2^{n-1}$。但若用类似于 $dfs$ 的方法去枚举能走的路径，显然是过于复杂的。 有没有一种算法，可以用类似于取补集的方法来大大降低时间复杂度呢？ 也许我们可以枚举不能走的路径，但暴力枚举也是不行的。 这里需要用到 容斥 。 对于两个噩梦格子，它们之间的方案数可以用组合数来求： 每条路径的节点数量是一致的，为 $(\triangle x - 1) + (\triangle y - 1)$，而每条路径一定会有 $\triangle x - 1$ 个节点是在 $x$ 轴方向移动的，所以方案数即为 $C_{\triangle x + \triangle y - 2}^{\triangle x - 1}$。 于是，我们只需枚举所有选择即可，这里我们可以考虑用二进制进行状态压缩，直接用二进制位是否是 $1$ 来考虑这个噩梦节点是否选上。当然也可以无脑递归套 $for$，但状压会更好写。 还有一个问题，若我们每次都算一遍两个节点的方案数，未免有些复杂，所以我们可以用 $O1$ 复杂度的组合数求法。 容斥我们来考虑三个集合，它们两两相交，且有一部分三个相交在一起，如下图： 对，这是一个韦恩图，而且我们可以很容易的得到下面这个式子： $|A \cup B \cup C| = |A| + |B| + |C| - |A \cap B| - |B \cap C| - |C \cap A| + |A \cap B \cap C|$ 推广之后，对于 $n$ 个集合的并集，我们只需按上述式子写，其中符号取决于选了几个集合，奇数为正偶数为负。 因而，对于所有噩梦格子的走法，利用容斥即可解决。 线性复杂度的组合数求法显然，当数据量过大的时候，每次都用一遍 $for$ 循环是不合理的，那么我们可以考虑预处理阶乘。 由于存在除法取模，我们需要用到乘法逆元，将除法取模转化为乘法取模。 逆元有一个很简单的求法，即费马小定理：对于 $ab \equiv 1\ (mod\ p)$，乘法逆元 $b = a ^ {p - 2}$。 但每次用一遍快速幂也会提高时间复杂度，因而我们考虑线性求逆元，用到如下递推式： $inv[i] = (mod - mod / i) \times inv[mod\%i] \ \%mod$ 对于阶乘的逆元，满足 $facInv[i] = facInv[i - 1] \times inv[i]\ \% mod$ 满足上述条件后，$C_n^m = fac[n] \times facInv[m]\ \% mod \times facInv[n - m]\ \% mod$。 线性求逆元的证明 时间复杂度：$O(m \times 2 ^ m)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 400010, mod = 1e9 + 7; pii a[N], b[N]; int n, m, inv[N], fac[N], facInv[N], pow2[N]; //O1复杂度求组合数 int c(int n, int m)&#123; return fac[n] * facInv[m] % mod * facInv[n - m] % mod; &#125; signed main() &#123; ios::sync_with_stdio(0); cin >> n >> m; for(int i=0;i&lt;m;i++) cin >> a[i].first >> a[i].second; inv[1] = fac[0] = fac[1] = facInv[0] = facInv[1] = pow2[0] = 1; for(int i=2;i&lt;=n*2;i++)&#123; inv[i] = (mod - mod / i) * inv[mod % i] % mod; fac[i] = fac[i - 1] * i % mod; facInv[i] = facInv[i - 1] * inv[i] % mod; &#125; for(int i=1;i&lt;=n;i++) pow2[i] = pow2[i - 1] * 2 % mod; int ans = pow2[n - 1]; for(int i=1;i&lt;(1 &lt;&lt; m);i++)&#123; int t = 0; b[t ++] = &#123;1, 1&#125;; int sign = 1; for(int j=0;j&lt;m;j++)&#123; if((i >> j) &amp; 1)&#123; b[t ++] = a[j]; sign = -sign; &#125; &#125; sort(b, b + t); int now = pow2[n - 1 - (b[t - 1].first + b[t - 1].second - 2)]; for(int j=1; j &lt; t; j++)&#123; if(b[j - 1].second &lt;= b[j].second)&#123; int x = b[j].first - b[j - 1].first + 1, y = b[j].second - b[j - 1].second + 1; now = now * c(x + y - 2, x - 1) % mod; &#125;else&#123; now = 0; break; &#125; &#125; ans += sign * now; &#125; ans = (ans % mod + mod) % mod; cout &lt;&lt; ans &lt;&lt; '\n'; return 0; &#125; 有点震撼的说…]]></content>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 848 Div 2</title>
    <url>/blog/posts/1674252080/</url>
    <content><![CDATA[Contestant. Rank 2756. Rating +40. A. Flip Flop Sum题意给定一个只包含 $1,-1$ 的序列，要求必须进行一次操作，将任意 $i$ 对应的 $ai,a{i+1}$ 的值取反，输出操作后序列总和的最大值。 思路显然，若序列是 $1,-1,1,-1,…$ ，那么操作对总和无影响。 当序列中存在 $-1,-1$ 时，总和加 $4$。 其余情况，即序列中全是 $1$，总和减 $4$。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int sum = 0, pre = scanner.nextInt(); sum += pre; boolean f1 = false, f2 = false; for(int i=1;i&lt;n;i++)&#123; int a = scanner.nextInt(); sum += a; if(a == pre)&#123; if(!f1) &#123; if (a == -1)&#123; sum += 4; f1 = true; &#125; &#125; &#125;else f2 = true; pre = a; &#125; if(!f1 &amp;&amp; !f2) sum -= 4; System.out.println(sum); &#125; &#125; &#125; 别看错题啊喂 B. The Forbidden Permutation题意给定长度为 $n$ 的排列 $p$、长度为 $m$ 的数组 $a$、以及一个正整数 $d$，其中数组 $a$ 无重复元素，且对于任意 $ai$ 满足 $a_i \in [1,n]$ 。定义一次操作为交换相邻元素，输出最少的操作数，满足存在 $i \in [1,m)$，有 $p[a_i] \geq p[a{i+1}]$ 或 $p[a_{i+1}] &gt; p[a_i] + d$。 思路显然，我们令 $b[i]=p[a_i]$，那么只要数组 $b$ 是非递增的，就无需操作。 否则，我们可以执行下面的两个操作： 找出数组 $b$ 中相邻差值最小的两个元素，将它们交换位置； 找出数组 $b$ 中相邻差值最大的两个元素，将小的元素向左移，大的元素向右移，直至距离大于 $d$。 因为我们无需考虑最后数组的情况，所以我们只需计算一下即可： 对于操作 $1$，$cnt=dist_{min}$； 对于操作 $2$，$cnt=d-dist_{max}+1$。 显然，当 $d$ 过大时，我们无法将元素的距离扩大到 $d$，此时只能执行操作 $1$。 时间复杂度：$O(m)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0) &#123; int n = scanner.nextInt(), m = scanner.nextInt(), d = scanner.nextInt(); int[] p = new int[n + 1]; for(int i=1;i&lt;=n;i++) p[scanner.nextInt()] = i; int[] a = new int[m + 1]; int minDist = Integer.MAX_VALUE, maxDist = 0; for(int i=1;i&lt;=m;i++)&#123; a[i] = scanner.nextInt(); a[i] = p[a[i]]; if(i >= 2)&#123; minDist = Math.min(minDist, a[i] - a[i - 1]); maxDist = Math.max(maxDist, a[i] - a[i - 1]); &#125; &#125; if(minDist &lt;= 0 || maxDist > d) System.out.println(0); else&#123; if(d - maxDist + 1 > n - maxDist - 1) System.out.println(minDist); else System.out.println(Math.min(minDist, d - maxDist + 1)); &#125; &#125; &#125; &#125; 分类讨论呐 C. Flexible String题意给定两个字符串 $a,b$，满足字符串 $a$ 最多只有 $10$ 种不同的字母，定义一次操作为： 选择一个 $i$，将 $a_i$ 放入集合 $Q$； 任意挑选一个字母，将其放入 $a_i$。 其中，集合 $Q$ 内需要满足最多只有 $k$ 个不同的字母。 寻找操作方案，让 $a[l,r]=b[l,r],1 \leq l \leq r \leq n$ 的数量最大，并输出这个最大值。 $x_1[l,r]=x_2[l,r]$ 表示对于 $x1,x2$，它们在 $[l,r]$ 区间内的所有字符都一样。 思路首先，我们只需考虑选 $k$ 种不同的字母然后将其标记，最后遍历一遍计算答案即可。 因为数据量较小，且我们无需考虑选择字母的先后，那么 $Dfs$ 可行。 更具体地说，我们只需找出所有满足 $a[i] \neq b[i]$ 的 $a[i]$ 的字母种类 $cnt$，然后枚举所有长度为 $k$ 的组合并计算答案的最大值即可。 暴力即可。 时间复杂度：$O(C_{cnt}^k \times n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 100010; int n, k; char a[N], b[N]; bool same[N]; char cnt[26]; int ans; vector&lt;int> w; bool use[26]; void dfs(int p, int t)&#123; if(t == k)&#123; int tot = 0, cur = 0; for(int i=0;i&lt;n;i++)&#123; if(same[i] || use[a[i] - 'a']) tot ++; else&#123; cur += (tot + 1) * tot / 2; tot = 0; &#125; &#125; if(tot != 0) cur += (tot + 1) * tot / 2; ans = max(ans, cur); &#125;else&#123; for(int i=p+1;i&lt;w.size();i++)&#123; use[w[i]] = true; dfs(i, t + 1); use[w[i]] = false; &#125; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while (t--) &#123; memset(cnt, 0, sizeof cnt); cin >> n >> k >> a >> b; for (int i = 0; i &lt; n; i++) &#123; if (a[i] == b[i]) same[i] = true; else cnt[a[i] - 'a']++, same[i] = false; &#125; w.clear(); int sum = 0; for (int i = 0; i &lt; 26; i++) &#123; if (cnt[i]) &#123; w.emplace_back(i); sum ++; &#125; &#125; if (k == 0) &#123; int tot = 0, cur = 0; for (int i = 0; i &lt; n; i++) &#123; if (same[i]) tot++; else &#123; cur += (tot + 1) * tot / 2; tot = 0; &#125; &#125; if (tot != 0) cur += (tot + 1) * tot / 2; cout &lt;&lt; cur &lt;&lt; '\n'; &#125; else &#123; if (sum - k &lt;= 0) &#123; cout &lt;&lt; (n + 1) * n / 2 &lt;&lt; '\n'; &#125; else &#123; ans = 0; for (int i = 0; i &lt;= sum - k; i++) &#123; use[w[i]] = true; dfs(i, 1); use[w[i]] = false; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; &#125; &#125; 不要忘了初始化啊啊啊啊，在功亏一篑中屈服.jpg]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 5</title>
    <url>/blog/posts/1889400236/</url>
    <content><![CDATA[Rank 379/3037. AC 7/12. A. 小沙の好客题意给定 $n$ 个商品，对于 $Q$ 个询问，挑选最多 $k$ 个价值不大于 $x$ 的商品，输出价值和的最大值。 思路二分前缀和。 或者使用 $stl$ 里的 $upperbound$。 时间复杂度：$O(n+logn)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), q = scanner.nextInt(); long[] a = new long[n + 1]; for(int i=1;i&lt;=n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); long[] sum = new long[n + 1]; for(int i=1;i&lt;=n;i++) sum[i] = sum[i - 1] + a[i]; while(q -- > 0)&#123; int k = scanner.nextInt(), x = scanner.nextInt(); int l = 1, r = n, mid; while (l &lt;= r) &#123; mid = (l + r) >> 1; if (a[mid] &lt;= x) l = mid + 1; else r = mid - 1; &#125; if(r >= k) System.out.println(sum[r] - sum[r - k]); else System.out.println(sum[r]); &#125; &#125; &#125; 二分别忘了咋写啊草 B. 小沙の博弈题意两个很聪明的人进行博弈，每个人面前有无数多个格子，每个格子可以放无限个石子。给定 $n$ 个石子，两个人交替操作，每次操作可以从这对石子里拿出任意数量的石子并放入第一个没有石子的格子里。 胜负取决于两人面前格子的字典序大小，字典序小的人获胜。 思路显然，要让字典序小，聪明的人绝对会只拿 $1$ 个，那么整个问题就简化为对 $n$ 的奇偶性判断了。 $n$ 为奇数的时候，后手赢，$n$ 为偶数的时候，平局。 先手没有必胜策略。 时间复杂度：$O(1)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); System.out.println(n % 2 == 0 ? "win-win!" : "Yaya-win!"); &#125; &#125; 你这先手怎么这么菜啊.jpg C. 小沙の不懂题意对于两个可能含有前导 $0$ 的数字 $a,b$，以及一个长度为 $10$ 且从 $0$ 开始的排列 $p$，给定 $a,b$ 按照排列 $p$ 进行映射操作后的数，数字可能也有前导 $0$，判断能否确定原数 $a,b$ 的大小关系。 注：映射操作指 $ti=p{a_i}$ 思路分类讨论题。 我们设给定的数为 $n,m$，对应于 $a,b$。 若 $n$ 和 $m$ 的长度相同：若它们完全一致，那么 $a$ 和 $b$ 相等；否则无法判断。 若 $n$ 的长度大于 $m$，那么我们先考虑将 $n$ 和 $m$ 右对齐后多出来的部分 $t$，因为考虑到前导 $0$，若 $t$ 中有至少两个不同的数字，那么 $t$ 对应的原数部分一定有一个数不是 $0$，那么 $n$ 的位数一定比 $m$ 多，$n&gt;m$；否则，我们设 $t$ 中唯一出现的数为 $x$ ，那么我们只要判断 $n$ 剩下部分的最高位和 $m$ 的最高位是否都是 $x$ 即可，如果是的话就无法判断，否则 $n$ 依旧大于 $m$。 反之同理。 时间复杂度：懒得分析 对应AC代码import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String a = scanner.next(), b = scanner.next(); int la = a.length(), lb = b.length(); if(a.equals(b)) System.out.println("="); else if(la > lb)&#123; char p = a.charAt(0); boolean f = false; for(int i=1;i&lt;la-lb;i++) &#123; if(a.charAt(i) != p)&#123; f = true; break; &#125; &#125; if(f) System.out.println(">"); else&#123; if(b.charAt(0) == p &amp;&amp; a.charAt(la - lb) != p) System.out.println(">"); else System.out.println("!"); &#125; &#125; else if(lb > la)&#123; char p = b.charAt(0); boolean f = false; for(int i=1;i&lt;lb-la;i++) &#123; if(b.charAt(i) != p)&#123; f = true; break; &#125; &#125; if(f) System.out.println("&lt;"); else&#123; if(a.charAt(0) == p &amp;&amp; b.charAt(lb - la) != p) System.out.println("&lt;"); else System.out.println("!"); &#125; &#125;else System.out.println("!"); &#125; &#125; 题目太阅读理解了 D. 小沙の赌气题意两个人打游戏，打下一关需要满足前一关通关。对于每一个人，每轮会给定 $1$ 个 $[l,r]$ 区间，只要 $l-1$ 关已通关，那么 $[l,r]$ 内的所有关都瞬间通关，区间可保留到后面使用。输出每一轮的领先情况以及领先数量。 思路对于一个人的通关情况，我们可以用一个数 $num$ 来表示，对于每一个区间，我们可以判断它的左边界和 $num+1$ 的大小关系，若大于，那么无法合并区间，我们将其存下来，否则，我们用右边界更新 $num$。 在每次 $num$ 更新后，因为我们有区间存下来，所以我们需要判断是否可以继续合并。于是，我们可以维护一个左边界的小根堆，将所有左边界 $\leq num+1$ 的区间全都更新一遍即可。 于是乎，我们比较 $num$ 即可。 时间复杂度：$O(nlogk)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.AtomicInteger; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[][] x = new int[n][2], y = new int[n][2]; for(int i=0;i&lt;n;i++) x[i] = new int[]&#123;scanner.nextInt(), scanner.nextInt()&#125;; for(int i=0;i&lt;n;i++) y[i] = new int[]&#123;scanner.nextInt(), scanner.nextInt()&#125;; AtomicInteger num1 = new AtomicInteger(0), num2 = new AtomicInteger(0); PriorityQueue&lt;int[]> q1 = new PriorityQueue&lt;>(Comparator.comparingInt(o -> o[0])), q2 = new PriorityQueue&lt;>(Comparator.comparingInt(o -> o[0])); for(int i=0;i&lt;n;i++)&#123; work(x[i], num1, q1); work(y[i], num2, q2); System.out.println(num1.get() == num2.get() ? "win_win!" : (num1.get() > num2.get() ? "sa_win!" : "ya_win!")); System.out.println(Math.abs(num1.get() - num2.get())); &#125; &#125; private static void work(int[] now, AtomicInteger num, PriorityQueue&lt;int[]> q)&#123; if(now[0] > num.get() + 1)&#123; q.offer(now); &#125;else&#123; int r = Math.max(num.get(), now[1]); while(!q.isEmpty())&#123; int[] c = q.peek(); if(c[0] &lt;= r + 1)&#123; q.poll(); r = Math.max(r, c[1]); &#125;else break; &#125; num.set(r); &#125; &#125; &#125; woc怎么这么简单 E. 小沙の印章 待补充 F. 小沙の串串题意给定一个字符串 $n$，定义一次操作为任意选择一个字符并将其移到最后，输出 $k$ 次操作后字典序最大的字符串。 思路因为考虑到字典序的贪心性：只要比较第一个不相同的字符即可判断字典序的大小。 也就是说，我们只需让前几位尽可能大即可。 那么，若两个字母之间存在比他们小的数，我们就可以考虑维护一个 $l$，将 $l+k$ 内的所有元素都移到后面。 对于字符串的输出，我们可以用三个字符串分开存储，最后拼接在一起。 更具体地说，我们可以从大到小枚举所有字母，并从前往后枚举 $[l,l+k]$ 内的该字母，将这些字母全都移到后面，并更新 $l,k$。更新之后，可能存在剩余未移到后面的字母，因而在上一个操作前，我们可以直接把 $l$ 之前的字母删除。 时间复杂度：$O(n)?$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 100010; queue&lt;int> q[30]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, k; cin >> n >> k; string s, s1, s2, s3; cin >> s; for(int i=0;i&lt;n;i++)&#123; q[s[i] - 'a'].emplace(i); &#125; int l = 0, l1 = 0; while(k)&#123; for(int i=25;i>=0;i--)&#123; while(!q[i].empty() &amp;&amp; q[i].front() &lt; l) q[i].pop(); if(!q[i].empty() &amp;&amp; q[i].front() &lt;= l + k)&#123; int t = q[i].front(); q[i].pop(); k -= t - l; while(l &lt; t) s2 += s[l ++]; s1 += s[l ++]; l1 ++; break; &#125; &#125; if(l == n) break; &#125; for(int i=l;i&lt;n;i++) s3 += s[i]; while(!s1.empty() &amp;&amp; k)&#123; s2 += s1[l1 -- - 1]; s1.pop_back(); k --; &#125; sort(s2.rbegin(), s2.rend()); cout &lt;&lt; (s1 + s3 + s2); &#125; 草，这题很好听懂但很难说明白思路 G. 小沙の编码 待补充 H. 小沙の店铺题意给定初始价格 $x$，每卖出去 $k$ 件，单价上涨 $y$ 元。给定 $n$ 个客户，第 $i$ 个客户的购买 $n - i + 1$ 个商品，单价在每一个客户买完后才会变化。若接待完 $n$ 个客户都没有卖出去至少 $T$ 元货物，输出 $-1$，否则输出卖出的价钱。 思路纯模拟打卡题 时间复杂度：$O(n)?$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 1010; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int x, y, k, n, t; cin >> x >> y >> k >> n >> t; int cnt = 0, tot = 0, now = 0; while("If the world love me")&#123; cnt ++; tot += n * (x + now / k * y); now += n; if(tot >= t) &#123; break; &#125; if(n - 1 &lt;= 0)&#123; cnt = -1; break; &#125; n --; &#125; cout &lt;&lt; cnt; &#125; 差点打卡题卡了一会儿 I. 小沙の金银阁题意给定 $m$ 个灵石，在 $n$ 次猜测中，给出灵石数量的猜测，猜错会扣除相同数量的灵石，规定只有一次会猜对，输出猜测的最优方案。 思路乱猜，从 $m$ 开始除 $2$ 向上取整，剩余数放到第一位。 时间复杂度：$O(log_2 m)?$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long n = scanner.nextLong(), m = scanner.nextLong(); //1e15约2e50 if(n > 51 || m &lt; (1L &lt;&lt; (n - 1))) System.out.println(-1); else&#123; long[] out = new long[60]; for(int i=1;i&lt;n;i++)&#123; out[i] = m / 2 + m % 2; m /= 2; &#125; System.out.printf("%d ", m); for(int i=(int)n-1;i>0;i--) System.out.printf("%d ", out[i]); &#125; &#125; &#125; 正常一点的题解 乱猜就完事了（（ J. 小沙の最短路 待补充 K. 小沙の抱团 easy题意给定 $n$ 个人，定义一个指令为要求以 $x$ 人为单位抱团，落单的人淘汰，在所有操作都能被所有抱团的人认可的情况下，输出最少操作数。 思路要让操作被所有人认可，那么应该满足少数服从多数的原则，因而我们可以以 $ \lfloor \frac{n}{2} \rfloor + 1$ 为一组，让这样可以让留下的人最少。 暴力模拟求操作数即可 时间复杂度：$O(log_2 n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long n = scanner.nextLong(); long cnt = 0; while(n > 2)&#123; cnt ++; n = n / 2 + 1; &#125; System.out.println(cnt); &#125; &#125; 怎么感觉还是乱猜（（ L. 小沙の抱团 hard题意在上一题的基础上，指令是给定的，且每个指令有对应的代价，但每个指令可以被重复使用。输出让剩余人数最少的最小代价。 思路考虑到代价以及重复使用，我们可以用类似于完全背包的写法。 当剩余 $2$ 人时，一定无法让人数继续减少，所以我们可以从 $n$ 个人的状态枚举到 $2$ 个人的状态。 对于当前剩余 $i$ 个人的情况下，我们枚举所有指令 $(b,x)$，每个指令执行后剩余的人数即为 $i - i \% x$，因而我们可以得到下面的状态转移方程： $dp[i - i \% x[i]] = min(dp[i - i \% x[i]], dp[i] + b[i])$ 当没有一个指令可行的时候，或者剩余 $2$ 人时，输出结果。 时间复杂度：$O(nm)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 100010, M = 510, inf = 10000000000ll; struct sb&#123; int b, x; &#125;o[M]; int dp[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i=0;i&lt;m;i++) cin >> o[i].b >> o[i].x; for(int i=2;i&lt;n;i++) dp[i] = inf; bool ok = false; for(int i=n;i>2;i--)&#123; if(dp[i] == inf) continue; bool f = true; for(int j=0;j&lt;m;j++)&#123; int mod = i % o[j].x; if(mod == 0 || i &lt;= o[j].x) continue; dp[i - mod] = min(dp[i - mod], dp[i] + o[j].b); f = false; &#125; if(f) &#123; cout &lt;&lt; dp[i]; ok = true; break; &#125; &#125; if(!ok) cout &lt;&lt; dp[2]; &#125; 简单的dp]]></content>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 4</title>
    <url>/blog/posts/127583546/</url>
    <content><![CDATA[Rank 445/3193. AC 6/13. A. 清楚姐姐学信息论题意给定 $a$ 进制和 $b$ 进制，用该进制下的一定数量的号码牌表示数字。输出用哪个进制可以用 $a \times b$ 张号码牌表示更多的数。 思路显然，我们只需比较 $a ^ b$ 和 $b ^ a$ 的大小，但我们无需模拟计算，因为只有 $2,3$ 组合的时候，$2 &lt; 3,2 ^ 3 &lt; 3 ^ 2$，其余情况均为 $a &lt; b , a ^ b &gt; b ^ a$。所以对该情况特判即可。 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(), b = scanner.nextInt(); if ((a == 2 &amp;&amp; b == 3) || (a == 3 &amp;&amp; b == 2)) System.out.println(3); else System.out.println(Math.min(a, b)); &#125; &#125; 淦，还有特判，被坑了 B. 清楚姐姐学构造题意给定数组 $c$ 和质数 $m$，构造两个数组 $a,b$，满足下面的同余方程组： $\left{\begin{aligned}ai \equiv a{N-i-1}\ (mod\ m) \bi \equiv -b{N-i-1}\ (mod\ m) \c_i \equiv a_i+b_i\ (mod\ m)\end{aligned}\right.$ 若可构造，输出 $YES$ 以及一种构造，否则输出 $NO$。 一句话题意在模系下构造两个数列，一个满足奇函数性质，另一个满足偶函数性质，两个数列的和为任意给定数列。 思路考虑到对称性，我们不妨设 $ai=a{N-i-1}=x,bi=m-b{N-i-1}=y$。 那么，$ai+b_i=x+y,a{N-i-1}+b_{N-i-1}=x+m-y$。 代入第三个式子，我们可以得到 $x+y \equiv ci\ (mod\ m),x-y \equiv c{N-i-1}\ (mod\ m)$。 两式相加，$2x \equiv ci+c{N-i-1}\ (mod\ m)$，即 $x=\frac{ci+c{N-i-1}+km}{2},k \in Z$。 因而，我们只需判断分子的奇偶性，然后即可计算出 $x$。 同理可得 $y$。 若数组的长度为奇数，那么将会多出来一项 $N/2$，观察可得 $a_i=c_i+km,b_i=0,k \in Z$ 符合题意。 遍历输出即可。 时间复杂度：$O(\frac{n}{2})$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 100010; #define int long long int a[N], b[N], c[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i=0;i&lt;n;i++) cin >> c[i]; for(int i=0;i&lt;n/2;i++)&#123; int k1 = c[i] + c[n - i - 1], k2 = c[i] - c[n - i - 1], x, y; if(k1 % 2 == 0)&#123; if(m == 2) &#123; x = m + k1; y = m + k2; &#125; else &#123; x = m * 2L + k1; y = m * 2L + k2; &#125; &#125;else&#123; if(m == 2)&#123; cout &lt;&lt; "NO\n"; return 0; &#125;else &#123; x = m + k1; y = m + k2; &#125; &#125; x /= 2; y /= 2; a[i] = a[n - i - 1] = x; b[i] = y; b[n - i - 1] = m - y; &#125; if(n % 2 == 1) &#123; a[n / 2] = c[n / 2]; b[n / 2] = 0; &#125; cout &lt;&lt; "YES\n"; for(int i=0;i&lt;n;i++) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; for(int i=0;i&lt;n;i++) cout &lt;&lt; b[i] &lt;&lt; ' '; &#125; 不会有人暴力吧（（ C. 清楚姐姐学01背包(Easy Version)题意给定 $n$ 个物品以及总容量 $m$，第 $i$ 个物品的体积为 $wi$，价值为 $v_i$。任选若干个物品放入背包，满足物品总体积小于容量 $m$，运用 $01$ 背包求出最大价值 $Val{max}$。 现在，枚举每个物品，将该物品去除后，得到最大价值 $Val’i$，若$Val’_i&lt;Val{max}$，那么该物品必选，输出 $0$；否则输出 $x$，满足该物品加上价值 $x$ 后该物品必选。 $N,M$ 均不超过 $100$。 思路鉴于本题数据量很小，我们可以直接按照题面进行暴力模拟，对每个物品去掉后的情况进行 $01$ 背包，若非必选，那么再以去掉该物品后的容量为总容量跑一遍 $01$ 背包，将结果与 $Val_{max}$ 做差 $+1$ 即可得到答案。 时间复杂度：$O(nnm)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 110, inf = 0x3f3f3f3f; #define int long long int n, m; int w[N], v[N], dp[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> n >> m; for(int i=1;i&lt;=n;i++)&#123; cin >> w[i] >> v[i]; &#125; for (int i = 1; i &lt;= n; i++) for (int l = m; l >= w[i]; l--) &#123; dp[l] = max(dp[l], dp[l - w[i]] + v[i]); &#125; int maxx = dp[m]; for(int i=1;i&lt;=n;i++)&#123; memset(dp, 0, sizeof dp); for (int p = 1; p &lt;= n; p++) &#123; int cw = p == i ? 0 : w[p], cv = p == i ? 0 : v[p]; for (int l = m; l >= cw; l--) &#123; dp[l] = max(dp[l], dp[l - cw] + cv); &#125; &#125; if(maxx > dp[m]) cout &lt;&lt; 0 &lt;&lt; '\n'; else&#123; memset(dp, 0, sizeof dp); for (int p = 1; p &lt;= n; p++) &#123; int cw = p == i ? 0 : w[p], cv = p == i ? 0 : v[p]; for (int l = m - w[i]; l >= cw; l--) &#123; dp[l] = max(dp[l], dp[l - cw] + cv); &#125; &#125; cout &lt;&lt; maxx - dp[m - w[i]] - v[i] + 1 &lt;&lt; '\n'; &#125; &#125; &#125; 令人感慨 D. 清楚姐姐学01背包(Hard Version)题意同 $C$ 题，但 $N,M$ 不超过 $5000$。 思路暴力解决不了问题了。 我们回到 $01$ 背包的二维实现：枚举所有物品，以及所有可能的最大容量，取 该状态的价值 和 前一个状态加上当前物品的价值 的最大值。 那么，我们自然可以发现，只要将 $C$ 题的代码改成二维背包，那么至少最后一个 $for$ 循环是不必要的，因为对于前 $i-1$ 个物品，以 $m-w[i]$ 为最大容量的 $dp$ 值 我们已经 在前面 以 $O(n^2)$ 的复杂度 推得了。 那么 $i$ 后面物品的怎么办？从上面的分析我们可以知道，任意小于 $m$ 的背包容量对应的答案均可通过 $O(n^2)$ 的“预处理”得到，那么我们不妨从后往前跑一遍 $01$ 背包，于是乎，对于第一维为 $n-i$ 的 $dp$ 数组，我们只需枚举容量即可。 更具体地 从前往后跑一遍 $01$ 背包，得到二维数组 $dpz$；再从后往前跑一遍 $01$ 背包，得到二维数组 $dpf$； 枚举每一个物品：维护对于 $dpz$ 的 $i$ 前一位的状态下容量的前缀最大值数组 $mxz$，对于 $dpf$ 的 $i$ 后一位的状态下容量的后缀最大值数组 $mxf$。然后，遍历前 $i-1$ 个的最大容量 $j$，剩余的分给去掉前 $i$ 个物品后剩下物品的最大容量，那么，$mxz[j]+mxf[m-j]$ 的最大值即为 去掉 $i$ 后的最大价值 $Val’_i$。 综合步骤 $2$ 和暴力做法的最后一个 $for$ 循环，我们只需将 前 $i-1$ 个物品，第 $i$ 个物品，剩下的物品 抽象为三个物品，然后利用 $01$ 背包的第二层循环计算出必须将 $i$ 选中的最大值 $Val’_p$。 输出 $max(0,Val’_i-Val’_p+1)$ 即可。 时间复杂度：$O(nm)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 5010; #define int long long int n, m; int w[N], v[N], dpz[N][N], dpf[N][N], mxz[N], mxf[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> n >> m; for (int i = 1; i &lt;= n; i++) &#123; cin >> w[i] >> v[i]; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) &#123; dpz[i][j] = dpz[i - 1][j]; dpf[i][j] = dpf[i - 1][j]; if (j >= w[i]) dpz[i][j] = max(dpz[i][j], dpz[i - 1][j - w[i]] + v[i]); if (j >= w[n - i + 1]) dpf[i][j] = max(dpf[i][j], dpf[i - 1][j - w[n - i + 1]] + v[n - i + 1]); &#125; for (int i = 1; i &lt;= n; i++) &#123; memset(mxz, 0, sizeof mxz); memset(mxf, 0, sizeof mxf); for (int j = 1; j &lt;= m; j++) &#123; mxz[j] = max(mxz[j - 1], dpz[i - 1][j]); mxf[j] = max(mxf[j - 1], dpf[n - i][j]); &#125; int vi = 0, vp = 0; for (int j = 0; j &lt;= m; j++) &#123; vi = max(vi, mxz[j] + mxf[m - j]); if (m - j >= w[i]) vp = max(vp, max(mxz[j] + mxf[m - j - w[i]] + v[i], mxf[j] + mxz[m - j - w[i]] + v[i])); &#125; cout &lt;&lt; max(0ll, vi - vp + 1) &lt;&lt; '\n'; &#125; &#125; 居然有点想出来了，毕竟背包就是贪心嘛 E. 清楚姐姐打怪升级题意给定 $N$ 只怪物，第 $i$ 只怪物的生命值上限为 $h_i$，生命恢复速度为 $v_i$。主角的攻击间隔为 $t$，攻击力为 $a$。 对于每个怪物，每个时刻初，恢复 $v_i$ 点生命值，直至上限 $h_i$。 在 $1+k \times t$ 时刻末，主角挑选一只怪物，扣除 $a$ 点生命值，若剩余生命值为非正数，则判定怪物死亡。 输出在哪个时刻末可杀死所有怪物。若永远无法杀死则输出 $-1$。 思路贪心。 我们采取将一只怪物杀死再去杀另一只的做法，使每只需要杀死的怪物能恢复的生命值最小。 显然，在下次攻击前，怪物能恢复 $v_i \times t$ 点血量，如果恢复的血量大于主角攻击力 $a$，那么直接输出 $-1$。 否则： 如果一击秒杀，时刻 $+1$； 否则，在每次砍怪物之后，有效扣血为 $a - v \times t$，将其与第一次剩余的血量 $h-a$ 进行除法运算即可。注意需要特判可能出现的一次砍完的情况。 因最后一只怪物的计算会多出一个单位等待时间，所以我们将其减去。 时间复杂度：$O(n)$ 对应AC代码import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long n = scanner.nextLong(), t = scanner.nextLong(), a = scanner.nextLong(); long tick = 0; for(int i=0;i&lt;n;i++)&#123; long h = scanner.nextLong(), v = scanner.nextLong(); if(h &lt;= a) &#123; tick ++; continue; &#125; if(v * t >= a)&#123; System.out.println(-1); return; &#125;else &#123; if ((h - a) % (a - v * t) == 0) tick += ((h - a) / (a - v * t) + 1); else tick += ((h - a) / (a - v * t) + 2); &#125; &#125; System.out.println((tick - 1) * t + 1); &#125; &#125; 模拟+贪心呐 F. 清楚姐姐学树状数组题意构建一个 $2^k$ 的树状数组对应的二叉树，二叉树的中序遍历为节点编号，如下图： 给定 $q$ 个查询，输出询问的节点在前、中、后序遍历中分别是第几个。 思路$Dfs$。 我们从 $2^k$ 开始向下遍历，根据树状数组的特性，我们可以知道下一个需要遍历的点的值： 若向左，$nxt=now-\frac{lowbit(now)}{2}$；若向右，$nxt=now+\frac{lowbit(now)}{2}$。 接着，我们先来看前序遍历的规律：对于下一个节点，若向左子树移动，那么前序遍历的值会 $+1$，否则会 $+lowbit(now)$。 而对于后序遍历，类似于前序：对于下一个节点，若向右子树移动，那么后序遍历的值会 $-1$，否则会 $-lowbit(now)$。 特别地，在后续遍历中，从 $2^k$ 移动到 $2^{k-1}$ 时，后序遍历只相差 $1$，特判即可。 注： 当然，我们也可以用递推的方式，初始化数组后按照找对称点的方式解题。 时间复杂度：$O(qlog_2x)$ #include &lt;bits/stdc++.h> using namespace std; #define int long long int ans, maxx, x; int lb(int x)&#123; return x &amp; (-x); &#125; void dfs(int now, bool inc) &#123; if (now == x) return; if (now > x) &#123; if (inc) ans++; else ans -= (now == maxx ? 1 : lb(now)); dfs(now - lb(now) / 2ll, inc); &#125; else &#123; if (inc) ans += lb(now); else ans--; dfs(now + lb(now) / 2ll, inc); &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int k, q; cin >> k >> q; maxx = (1ll &lt;&lt; k); while(q --)&#123; cin >> x; ans = 1; dfs(maxx, true); cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; x &lt;&lt; ' '; ans = maxx; dfs(maxx, false); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 你说你这个蠢人怎么连找规律都找不出来呢.jpg G. 清楚姐姐逛街(Easy Version)题意给定一个迷宫，终点按照固定方式移动，以题给字符确定方向。给定多个查询，包括一个起点，输出从起点开始到可变终点的最短路。 思路考虑到查询数量很少，我们采用暴力的做法： 从起点开始 $Bfs$，确定能到达的每个点的最短路径长度。 模拟终点移动，若遍历到的点存在路径长度小于等于当前终点移动的长度，那么输出答案。 时间复杂度：$O(nmq)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 810; #define int long long char mp[N][N]; int dis[N][N], dx[4] = &#123;0, 0, -1, 1&#125;, dy[4] = &#123;-1, 1, 0, 0&#125;; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m, xs, ys, Q; cin >> n >> m >> xs >> ys >> Q; for(int i=0;i&lt;n;i++) cin >> mp[i]; memset(dis, 0x3f, sizeof dis); queue&lt;pair&lt;int, int>> q; q.emplace(xs, ys); dis[xs][ys] = 0; while(!q.empty())&#123; auto t = q.front(); q.pop(); int px = t.first, py = t.second; for(int i=0;i&lt;4;i++)&#123; int x = px + dx[i], y = py + dy[i]; if(x >= 0 &amp;&amp; x &lt; n &amp;&amp; y >= 0 &amp;&amp; y &lt; m &amp;&amp; mp[x][y] != '#' &amp;&amp; dis[x][y] > dis[px][py] + 1) &#123; dis[x][y] = dis[px][py] + 1; q.emplace(x, y); &#125; &#125; &#125; while(Q --)&#123; int x, y, ans, step = 1; cin >> x >> y; while(true)&#123; char cur = mp[x][y]; if(cur == 'L' &amp;&amp; mp[x][y - 1] != '#') y --; else if(cur == 'R' &amp;&amp; mp[x][y + 1] != '#') y ++; else if(cur == 'U' &amp;&amp; mp[x - 1][y] != '#') x --; else if(cur == 'D' &amp;&amp; mp[x + 1][y] != '#') x ++; else &#123; if(dis[x][y] == -1) &#123; ans = -1; break; &#125; &#125; if(dis[x][y] &lt;= step) &#123; ans = step; break; &#125; step ++; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 为啥BFS要这么写才对捏 H. 清楚姐姐逛街(Hard Version) 待补充，倍增+二分答案 I. 清楚姐姐采蘑菇 待补充，莫队+单调性 J. 清楚姐姐学排序题意给定数组 $a$ 的 $M$ 对元素大小关系，求顺序确定的位置和该位置的元素。 即对于位置 $k$，若确定位置在第 $i$ 位，那么 $b_k=i$，否则 $b_k=-1$。输出顺序数组 $b$。 思路显然，如果对于一个数，有 $a$ 个数小于它，$b$ 个数大于它，那么如果满足 $a+b+1=n$，该数的位置就一定唯一确定。 因此，我们直接枚举每个点即可。因为可能存在包含关系 $a&lt;b,b&lt;c,a&lt;c$，所以我们需要 $Dfs$。 时间复杂度：$O(nm)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 1010; #define int long long vector&lt;int> e[N][2]; int res[N], vis[N]; int dfs(int x, int t)&#123; if(vis[x]) return -1; vis[x] = true; int ans = 0; for(int each : e[x][t])&#123; ans += dfs(each, t) + 1; &#125; return ans; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i=0;i&lt;m;i++)&#123; int x, y; cin >> x >> y; e[x][0].emplace_back(y); e[y][1].emplace_back(x); &#125; memset(res, -1, sizeof res); for(int i=1;i&lt;=n;i++)&#123; memset(vis, 0, sizeof vis); int cntl = dfs(i, 1); vis[i] = false; int cntr = dfs(i, 0); if(cntl + cntr == n - 1) res[cntl + 1] = i; &#125; for(int i=1;i&lt;=n;i++) cout &lt;&lt; res[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; 不该不做这题… K. 清楚姐姐玩翻翻乐 待补充 L. 清楚姐姐的三角形I题意对于 $\triangle ABC$，顶点对应的边分别为 $l_a, l_b, l_c$。记 $V_A=l_b+l_c,V_B=l_a+l_c,V_C=l_a+l_b$，给定 $V_A,V_B,V_C$，输出 $l_a,l_b,l_c$。无解输出 $NO$。 思路显然，$l_a=\frac{V_B+V_C-V_A}{2},l_b=\frac{V_A+V_C-V_B}{2},l_c=\frac{V_A+V_B-V_C}{2}$，那么我们只需判断两边之和大于第三边以及分子是否为偶数即可。 时间复杂度：$O(1)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 500010, inf = 0x3f3f3f3f; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, va, vb, vc; cin >> t; while(t -- > 0)&#123; cin >> va >> vb >> vc; int la = vb + vc - va, lb = va + vc - vb, lc = va + vb - vc; if(la % 2 == 1 || lb % 2 == 1 || lc % 2 == 1)&#123; cout &lt;&lt; "NO\n"; &#125;else&#123; la /= 2; lb /= 2; lc /= 2; if(la + lb > lc &amp;&amp; la + lc > lb &amp;&amp; lb + lc > la)&#123; cout &lt;&lt; "YES" &lt;&lt; '\n' &lt;&lt; la &lt;&lt; ' ' &lt;&lt; lb &lt;&lt; ' ' &lt;&lt; lc &lt;&lt; '\n'; &#125;else cout &lt;&lt; "NO\n"; &#125; &#125; &#125; 怎么可以暴力呢 M. 清楚姐姐的三角形II题意给定数组长度 $N$，构造一个数组，满足相邻三个数不能构成三角形。 思路$1,1,2,1,1,2,1,1,2,1,…$ 输出即可 时间复杂度：$O(n/3)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 500010, inf = 0x3f3f3f3f; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n; cin >> n; for(int i=0;i&lt;n/3;i++)&#123; cout &lt;&lt; "1 1 2 "; &#125; if(n % 3 == 1) cout &lt;&lt; "1"; if(n % 3 == 2) cout &lt;&lt; "1 1"; &#125; 差点斐波那契（（]]></content>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 847 Div 3</title>
    <url>/blog/posts/3800321871/</url>
    <content><![CDATA[Practice. A. Polycarp and the Day of Pi题意将输入与 “$314159265358979323846264338327$” 比对，输出从头开始匹配成功的最大数量。 思路模拟即可。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; String a = "314159265358979323846264338327"; String b = scanner.next(); int n = b.length(), cnt = 0; for(int i=0;i&lt;n;i++)&#123; if(a.charAt(i) != b.charAt(i)) break; cnt ++; &#125; System.out.println(cnt); &#125; &#125; &#125; 题例有给圆周率的值，草 B. Taisia and Dice题意给定 $3$ 个整数 $n, s, r$，构造一个数组 $a$，满足最大值为 $s - r$，数组的长度为 $n$，总和为 $s$。 思路从大到小放入能放的最大数即可，上限需要考虑后面是否可以放 $1$。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; int s, r; cin >> n >> s >> r; int maxx = s - r; cout &lt;&lt; maxx &lt;&lt; ' '; s -= maxx; for(int i=n-2;i>=0;i--)&#123; int cur = min(6ll, max(1ll, min(maxx, s - i))); cout &lt;&lt; cur &lt;&lt; ' '; s -= cur; &#125; cout &lt;&lt; '\n'; &#125; &#125; 反正别用DFS就行 C. Premutation题意给定 $n$ 的一种排列分别去掉每一位后构成的 $n-1$ 个子序列，输出原排列。 思路考虑第一位即可。 第一位中出现次数最多的数即为原排列的第一个数，而出现最少的数所在子序列即为原排列去掉第一个数后的子序列，拼起来即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 110; int a[N][N]; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --) &#123; memset(a, 0, sizeof a); cin >> n; int h1, h2, c1 = 0, c2 = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n - 1; j++) &#123; cin >> a[i][j]; &#125; if(c1 == 0 || h1 == a[i][0]) h1 = a[i][0], c1 ++; else h2 = a[i][0], c2 ++; &#125; int h = c1 > c2 ? h1 : h2; for(int i=0;i&lt;n;i++)&#123; if(a[i][0] != h)&#123; cout &lt;&lt; h &lt;&lt; ' '; for(int j=0;j&lt;n-1;j++) cout &lt;&lt; a[i][j] &lt;&lt; ' '; break; &#125; &#125; cout &lt;&lt; '\n'; &#125; &#125; 找规律就行力 D. Matryoshkas题意给定一个数组 $a$，将其拆分成任意数量的子序列，满足子序列升序排序后相邻元素相差 $1$，且无重复元素，输出子序列的最小数量。 思路我们可以考虑模拟的做法，将所有子序列抽象为序列中最大的数，作为几堆候选区域： 在升序排序数组 $a$ 后，我们依次将元素 $a_i$ 放入，放入前，我们先拿出候选中数值最小的，然后分类讨论： 如果满足 $+1$ 后和$a_i$ 相同，那么我们直接将元素放入该候选区域； 如果两数相同，那么两数均可作为下一个数的可能候选区域，所以新建一个区域并放入该数； 否则，那么这个候选区域无法再进行匹配，直接取出并计数。 最后，剩下的堆数加上被取出的堆数即为答案。 当然，为了降低复杂度，考虑使用优先队列。 时间复杂度：$O(ntlogt),t为队列长度$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); int[] a = new int[n]; PriorityQueue&lt;Integer> q = new PriorityQueue&lt;>(Comparator.comparingInt(o -> o)); for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); int cnt = 0; for(int i=0;i&lt;n;i++)&#123; boolean ok = false; while(!q.isEmpty())&#123; int now = q.poll(); if(now + 1 == a[i]) &#123; q.offer(a[i]); ok = true; break; &#125;else if(now == a[i])&#123; q.offer(a[i]); q.offer(a[i]); ok = true; break; &#125; else cnt ++; &#125; if(!ok) q.offer(a[i]); &#125; System.out.println(cnt + q.size()); &#125; &#125; &#125; 其实可以不用这么模拟，太模拟了（（ E. Vlad and a Pair of Numbers题意给定一个整数 $n$，满足 $a \oplus b = \frac{a+b}{2}=n$，输出满足条件的任意一组 $a,b$。 思路我们先来考虑 $a \oplus b = a+b=t$： 对于任意二进制数 $t$，当我们从高位向低位遍历时，若遇到 $1$，那么我们不妨在 $a$ 的该位填上 $1$，在 $b$ 的该位上填上 $0$，这样即可满足异或运算和加法运算的值一致。 而对于 $a \oplus b = \frac{a+b}{2}=n$： 我们注意到有除 $2$ 的运算，该操作等效于将 $a+b$ 的二进制结果向低位移动一位，此时，若按照上述做法，我们会发现 $1$ 的位置恰好差了一位，那么我们就希望能出现进位的操作。 考虑到对于二进制运算，$11+01=100$，那么我们不妨在上述做法的基础上，在 $1$ 后面一位对应的 $a,b$ 位置上分别填上 $1,0$，这样就可以满足我们的需求了。 而显而易见，当 $1$ 出现在最后一位（奇数），或者有连续的 $1$ 存在时，即为无解。 时间复杂度：$O(log_2n)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt: while (t-- > 0) &#123; int n = scanner.nextInt(); //有连着的1就不行 if(n % 2 == 1)&#123; System.out.println(-1); continue nxt; &#125; int a = 0, b = 0; boolean f = false; for(char e : Integer.toBinaryString(n).toCharArray())&#123; int p = e - '0'; if (f) &#123; if (p == 1) &#123; System.out.println(-1); continue nxt; &#125; else &#123; a = a * 2 + 1; b = b * 2 + 1; f = false; &#125; &#125; else &#123; f = p == 1; a *= 2; b *= 2; if(f) a ++; &#125; &#125; System.out.printf("%d %d\n", a, b); &#125; &#125; &#125; 真的不是找规律题么（（ F. Timofey and Black-White Tree题意对于一个 $n$ 个点 $n-1$ 个边的无向无环图，给定操作顺序，将 $n$ 个点按照顺序涂成黑色，输出从第 $2$ 个操作开始，对于每次操作后，所有任意两个黑点的距离的最小值。 思路我们可以考虑树形 $dp$ 的写法，其中 $dp[i]$ 表示第 $i$ 个点 在涂色前 该点的所有子节点中 黑色的点到该点的最短距离。 难道我们要把子节点全都遍历一遍吗？显然不用。 这是一个无向无环图，那么显然一个点只有一个父节点，只要根节点确定了，我们构建一个数组即可。 因此，我们不妨从要涂色的点开始，向上 $Dfs$ 到根节点，在遍历的同时记录当前已经遍历的边数 $st$。在遍历到节点 $i$ 时，我们以这个点为跳板，用 $dp[i]+st$ 更新最终答案，并将 $dp[i]$ 更新为 $min(dp[i],st)$ 即可。 深搜剪枝 根节点的确定：在绝大多数情况下，取子节点最多的点作为根节点是更优的，这样可以让链条结构更多，从而一定程度降低时间复杂度； 只遍历父节点 $st&gt;=ans$ 时，结束遍历：显然，我们需要求答案的最小值，那么就算我们继续遍历，最后更新的 $dp$ 值是一定大于等于 $ans$ 的，因而我们就没必要 让其他将要涂黑的点 以这个点为跳板 来更新 $ans$ 了。而恰恰因为我们至少遍历了 $ans-1$ 个，可以保证 最小路径所在边 一定被我们遍历过了，因而答案没有问题。 整体来看 确定根节点； 从根节点开始向下 $Dfs$ 一遍，求出每个点的父节点； 依次遍历要涂黑的点，向上 $Dfs$ 并更新 $dp$ 值。 时间复杂度：不会分析 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 200010, inf = 0x3f3f3f3f; #define int long long vector&lt;int> e[N]; int dp[N], c[N], root, ans, vis[N], f[N];//cut2: 只遍历爹，因为爹只有一个（无环 void dfs1(int fa)&#123; for(int p : e[fa])&#123; if(vis[p]) continue; vis[p] = true; f[p] = fa; dfs1(p); &#125; &#125; void dfs2(int child, int st)&#123; if(st >= ans) return; //cut3: 步数那么多就没必要继续走，防止每次都被卡O(n) if(dp[child] != inf) ans = min(ans, dp[child] + st); dp[child] = min(st, dp[child]); if(child != root) dfs2(f[child], st + 1); &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --) &#123; cin >> n >> c[0]; for(int i=1;i&lt;n;i++) &#123; cin >> c[i]; dp[i] = inf; vis[i] = false; e[i].clear(); &#125; dp[n] = inf; vis[n] = false; e[n].clear(); int maxx = -1; root = 1; //cut1: 根节点选分支最多的 for(int i=1;i&lt;n;i++)&#123; int u, v; cin >> u >> v; e[u].emplace_back(v); e[v].emplace_back(u); int s1 = e[u].size(), s2 = e[v].size(); if(max(s1, s2) > maxx) &#123; maxx = max(s1, s2); root = s1 > s2 ? u : v; &#125; &#125; dfs1(root); ans = inf; dfs2(c[0], 0); for(int i=1;i&lt;n;i++)&#123; dfs2(c[i], 0); cout &lt;&lt; ans &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; &#125; 我趣，怎么一遍过]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 844 Div 1 plus 2</title>
    <url>/blog/posts/405635716/</url>
    <content><![CDATA[Contestant. Rank 4776. Rating -70 (+30 -100). A. Parallel Projection题意给定一个长方体，在长方体的顶部和底部各取一个点，一只蚂蚁只能在平面上向平行于边的方向移动，求出蚂蚁从一个点移动到另一个点的最短路径。 思路从四个方向分别模拟一下求最小值即可。 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int w = scanner.nextInt(), d = scanner.nextInt(), h = scanner.nextInt(); int a = scanner.nextInt(), b = scanner.nextInt(), f = scanner.nextInt(), g = scanner.nextInt(); int p1 = Math.min(a + f + Math.abs(g - b), b + g + Math.abs(f - a)); a = w - a; b = d - b; f = w - f; g = d - g; int p2 = Math.min(a + f + Math.abs(g - b), b + g + Math.abs(f - a)); System.out.println(h + Math.min(p1, p2)); &#125; &#125; &#125; 还是用蚂蚁理解更加经典（（ B. Going to the Cinema题意给定数组 $a$，对于任意 $i$，提出一个要求：“我只在 不算上我的前提下 至少有 $a_i$ 个人陪我一起去 的前提下去电影院，否则我会难过。” 注意考虑逆否命题：“我不去电影院，而且只有不到 $a_i$ 个人抛下我去电影院，我依然是开心的，否则我也会难过。” 输出所有不让任何人伤心的安排的总数。 思路首先，显然我们一定得让 $a_i=0$ 的人全都去电影院，不然逆否命题一定不成立。 接着，我们遍历剩下按升序排序的 $a_i$，同理找出必须去的人，在找出第一个不一定要去的人的时候停止遍历。 然后，我们遍历后面可以不选上的人，并在选上后判断后者是否必须去。 最后，所有可以不选上的人的个数即为答案，因为若在递增序列里间隔选人，会导致命题不成立。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) a[i] = scanner.nextInt(); Arrays.sort(a); int c = 0, i = 0, ans = 0; for(;i&lt;n;i++)&#123; if(a[i] == 0) c ++; else if(a[i] &lt;= c) c ++; else break; &#125; ans++; while (i++ &lt; n) &#123; c++; if (a[i] &lt;= c) &#123; ans++; while (i &lt; n &amp;&amp; a[i] &lt;= c) &#123; i++; c++; &#125; &#125; &#125; System.out.println(ans); &#125; &#125; &#125; 云里雾里 C. Equal Frequencies题意给定一个字符串 $s$，定义一次操作为替换 $s_i$ 为任意其他字母，输出操作数最少的结果，使结果中所有字母出现的次数均相同。 思路考虑到小写字母只有 $26$ 个，我们不妨枚举所有可能的段数，找出操作数最少的情况然后输出即可。 如何判断操作数最少呢？对于每个字母 $c$，我们不难发现：$min(\frac{n}{k},freq_c)$ 即为当前需要保留的数量。因此，去除保留的数量，剩余即为操作数。 确定段数之后，我们先将字符串中各个字母按照出现次数降序排序，然后从头开始遍历每一个字母，若字母数量过多，那么将多出来的位置留空，如果过少，那么在留空的位置填上缺少的字母。最后将序列输出即可。 时间复杂度：$O(n^2)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); char[] o = scanner.next().toCharArray(); List&lt;Pair&lt;Integer, List&lt;Integer>>> f = new ArrayList&lt;>(); for(int i=0;i&lt;26;i++) f.add(new Pair&lt;>(i, new ArrayList&lt;>())); for(int i=0;i&lt;n;i++) f.get(o[i] - 'a').B.add(i); f.sort(Comparator.comparingInt(o1 -> -o1.B.size())); int best = 0, cnt = 1, cur; for(int i=1;i&lt;=26;i++)&#123; if(n % i > 0) continue; cur = 0; for(int j=0;j&lt;i;j++) cur += Math.min(n / i, f.get(j).B.size()); if(best &lt; cur)&#123; best = cur; cnt = i; &#125; &#125; System.out.println(n - best); List&lt;Integer> extra = new ArrayList&lt;>(); char[] res = new char[n]; for(int i=0;i&lt;cnt;i++)&#123; for(int j=0;j&lt;n/cnt;j++)&#123; if(j &lt; f.get(i).B.size())&#123; res[f.get(i).B.get(j)] = (char) ('a' + f.get(i).A); &#125;else&#123; extra.add(f.get(i).A); &#125; &#125; &#125; int p = 0; for(int i=0;i&lt;n;i++)&#123; System.out.printf("%c", res[i] == 0 ? (char) ('a' + extra.get(p ++)) : res[i]); &#125; System.out.println(); &#125; &#125; //实现cpp里的pair 此处略去 //public static class Pair&lt;A, B>&#123;&#125; &#125; 没想到暴力直接取段数 D. Many Perfect Squares题意给定数组 $a$，输出将整个数组加上任意非负数 $x$ 后完全平方数的最多个数。 思路首先，答案绝对是 $\geq1$ 的，那么我们来考虑 $&gt; 1$ 的情况，也就是在该情况下枚举所有 $a_i,a_j$，满足 $a_i+x=p^2,a_j+x=q^2$，然后再枚举所有数，统计完全平方数个数即可。 那么我们来考虑下如何枚举 $x$： 显然，$a_j - a_i = q^2 - p^2 = (q - p)(q + p)$，那么 $q-p$ 即为 $a_j-a_i$ 的因数，因为数据范围不大，直接暴力枚举所有因数是可行的。 设因数为 $d$，我们可以得到下面的式子 $\begin{cases} q - p = d \ q + p = \frac{a_j - a_i}{d} \end{cases}$ 继续化简，得到 $\begin{cases} p = \frac{1}{2}(\frac{a_j - a_i}{d} - d) \ q = \frac{1}{2}(\frac{a_j - a_i}{d} + d) \ \end{cases}$ 也就是说，只要括号内的式子是偶数，那么 $d$ 即为一种可行解。 时间复杂度：$O(n^2f(x)),f(x)为差值的因数个数$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 500010; #define int long long int a[60]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; int ans = 1; for(int i=0;i&lt;n-1;i++) for(int j=i+1;j&lt;n;j++) &#123; int d = a[j] - a[i], x; for (int p=1;p&lt;=d/p;p++) &#123; if(d % p == 0)&#123; if((d / p - p) % 2 == 1 || (d / p + p) % 2 == 1) continue; x = ((d / p - p) / 2) * ((d / p - p) / 2) - a[i]; if(x &lt; 0) continue; int cnt = 0; for(int e=0;e&lt;n;e++)&#123; int s = floor(sqrt(a[e] + x)); if(s * s == a[e] + x) cnt ++; &#125; ans = max(ans, cnt); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 好一个暴力枚举]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 845 Div 2 and ByteRace 2023</title>
    <url>/blog/posts/1008203407/</url>
    <content><![CDATA[Practice. A. Everybody Likes Good Arrays!题意给定一个数组 $a$，定义一次操作为将奇偶性相同的相邻元素相乘并合并为一个元素，输出让数组 $a$ 满足所有相邻数奇偶性不同的最小操作数量。 思路显然，奇偶性相同的两个数相乘后奇偶性是不变的，那么我们只需统计有多少组相邻元素的奇偶性相同即可。 时间复杂度：$O(n)$ 对应AC代码import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int cur = scanner.nextInt() % 2; int cnt = 0; for(int i=1;i&lt;n;i++)&#123; int a = scanner.nextInt(); if(a % 2 == cur) cnt ++; else cur = a % 2; &#125; System.out.println(cnt); &#125; &#125; &#125; 还是挺简单的思维题 B. Emordnilap题意给定一个整数 $n$，对于所有 $n$ 的排列，分别将各个排列镜像复制到右边，输出所有新数对的逆序对的总数量。 思路可以证明，对于任意一个排列，所有大于 $1$ 的数字 $t$ 总能在其右边找到总共为 $2 \times (t-1)$ 个比它小的数，从而构成对应数量的逆序对。因而，对于一个长度为 $n$ 的排列，进行镜像复制后，逆序对总数为 $2 \times (1+2+…+(n-1))=n \times (n-1)$。 显然，对于 $n$，总共有 $A_n^n$ 种排列，与上式相乘即可。 时间复杂度：$O(n)$ 对应AC代码import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; long n = scanner.nextInt(); long fact = 1L, mod = 1000000007; for(long i=2;i&lt;=n;i++) fact = (fact * (i % mod)) % mod; System.out.println((((fact * (n % mod)) % mod) * ((n - 1) % mod)) % mod); &#125; &#125; &#125; 难得B题想的这么快 C. Quiz Master题意给定数组 $a$，选择任意可不连续的子序列 $b$，满足对于任意 $t \in [1,m]$，有 $bi\ mod\ t = 0$，输出满足条件的子序列中 $b{max}-b_{min}$ 的最小值。 思路双指针，类似于滑动窗口的解法。 我们考虑用双指针维护一个 $[l,r]$ 的满足题意的区间，在向右移动 $r$ 的同时，找出满足条件的 $l$ 的最小值即可。 更具体地说，我们可以开一个数组 $cnt$ ，在向右移动 $r$ 之前，我们先将 $a[r]$ 的所有因子 $f[a[r]]$ 对应的 $cnt[f[a[r]]] +1$，并在加之前判断值是否为 $0$，如果是，那么这个因数是第一次出现，因此即可统计 $[1,m]$ 是否被完全覆盖。向右移动 $l$ 之前的操作与上述操作类似。 时间复杂度：$O(n \times f(x)),f(x)为x的因数数量$ 对应AC代码import java.math.BigInteger; import java.util.*; public class Main&#123; static int N = 100010; private static List&lt;List&lt;Integer>> init()&#123; List&lt;List&lt;Integer>> res = new ArrayList&lt;>(); for(int i=0;i&lt;=N;i++) res.add(new ArrayList&lt;>()); for(int i=1;i&lt;=N;i++) for(int j=i;j&lt;=N;j+=i)&#123; res.get(j).add(i); &#125; return res; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); List&lt;List&lt;Integer>> f = init(); int t = scanner.nextInt(); nxt: while(t -- > 0)&#123; int n = scanner.nextInt(), m = scanner.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); int l = 0, r = 0, best = Integer.MAX_VALUE, now = 0; int[] cnt = new int[N]; while(r &lt; n)&#123; for(int each : f.get(a[r]))&#123; if(each > m) break; if(cnt[each] == 0) now ++; cnt[each] ++; &#125; while(now == m)&#123; best = Math.min(a[r] - a[l], best); for(int each : f.get(a[l]))&#123; if(each > m) break; if(cnt[each] == 1) now --; cnt[each] --; &#125; l ++; &#125; r ++; &#125; System.out.println(best == Integer.MAX_VALUE ? -1 : best); &#125; &#125; &#125; 妙啊.jpg]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 846 Div 2</title>
    <url>/blog/posts/871658605/</url>
    <content><![CDATA[Contestant. Unrated, with problem C removed. A. Hayato and School题意给定一个数组 $a$，输出一对下标，满足下标对应的元素的和为奇数。保证数组 $a$ 至少有 $3$ 个元素。 思路分类讨论： 奇数元素数量大于 $3$，直接输出前三个奇数。 偶数只有 $1$ 个，或者没有奇数，无解。 输出一对”奇，偶，偶“即可。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 310; pair&lt;int, int> a[N], b[N]; #define ll long long int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int o = 0, e = 0; for(int i=1;i&lt;=n;i++)&#123; int p; cin >> p; if(p % 2 == 0) a[e ++] = &#123;p, i&#125;; else b[o ++] = &#123;p, i&#125;; &#125; if(o >= 3)&#123; cout &lt;&lt; "YES" &lt;&lt; '\n'; cout &lt;&lt; b[0].second &lt;&lt; " " &lt;&lt; b[1].second &lt;&lt; " " &lt;&lt; b[2].second &lt;&lt; '\n'; &#125;else if(o == 0 || e == 1)&#123; cout &lt;&lt; "NO" &lt;&lt; '\n'; &#125;else&#123; cout &lt;&lt; "YES" &lt;&lt; '\n'; cout &lt;&lt; b[0].second &lt;&lt; " " &lt;&lt; a[0].second &lt;&lt; " " &lt;&lt; a[1].second &lt;&lt; '\n'; &#125; &#125; &#125; 这么签的题居然WA了，淦 B. GCD Partition题意给定一个数组 $a$，将数组 $a$ 切割为任意数量的连续段，满足相邻区间头尾没有交集，对每段分别求和，输出求和后所有和的最大公约数的最大值。 思路可以证明，分隔为两段后可以保证取到 $gcd_{max}$，因此我们枚举即可。 若需略微证明，因求出的 $gcd$ 一定是 $sum_a / d$ ($d$ 是段数) 的因数，显然 $d$ 越小，能遍历到的因数就更多，所以分两段即可。 既然分两段，暴力即可。 时间复杂度：$O(n \times f(x)),f(x)指gcd函数复杂度$ 对应AC代码import java.math.BigInteger; import java.util.*; public class Main&#123; private static long gcd(long a, long b) &#123; while(b != 0) &#123; long tmp = a; a = b; b = tmp % b; &#125; return a; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); long tot = 0; long[] a = new long[n + 1]; for(int i=1;i&lt;=n;i++) tot += a[i] = scanner.nextInt(); long ans = 1, sum = 0; for(int i=1;i&lt;n;i++)&#123; sum += a[i]; ans = Math.max(ans, gcd(sum, tot - sum)); &#125; System.out.println(ans); &#125; &#125; &#125; 怎么还会去想分段怎么分呢，真是，淦 D. Bit Guessing Game题意互动游戏，对于一个未知数 $n$，有最多 $30$ 次的猜测机会。对于每次给出的二进制下 $n$ 中 $1$ 的个数，允许减去一个值 $x$，使 $n=n-x$，$n$ 值得改变会影响下一轮数量的给出。若能确定答案，输出即可。 思路我们考虑到题给范围为 $10^9$，此时二进制的最大位数恰好为 $30$，那么我们不妨枚举所有位的情况。 首先，对于一个二进制数，我们引入一个结论： 若某一位为 $1$，我们将该位减去后，一定可以保证 $1$ 的数量恰好 $-1$； 而若某一位为 $0$，则恰好相反，我们找不出有一种情况满足 $1$ 的数量恰好 $-1$。 因此，我们可以从低位向高位枚举，若满足条件，那么将目标数字的该位标为 $1$，否则，在下一次猜测的时候，我们需要减去原先被我们减去的值，以达到反悔的目的。而显然，无论我们减去多少原先的值，最后剩下的数一定大于 $0$，因此方案可行。 时间复杂度：$O(log_2n)$ 对应AC代码import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int cnt = scanner.nextInt(); int ans = 0, b = 0, on = 0; while(cnt > 0)&#123; System.out.printf("- %d\n", (1 &lt;&lt; on) - b); System.out.flush(); int now = scanner.nextInt(); if(now == -1) return; //wa了... if(cnt - now == 1) &#123; b = 0; cnt = now; ans += 1 &lt;&lt; on; &#125; else b += (1 &lt;&lt; on) - b; on ++; &#125; System.out.printf("! %d\n", ans); System.out.flush(); &#125; &#125; &#125; 我跟自己写的代码玩游戏.jpg]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 843 Div 2</title>
    <url>/blog/posts/1640782794/</url>
    <content><![CDATA[Contestant. Rank 6984. Rating -84 (+16 -100). A1. Gardener and the Capybaras (easy version)题意给定一个由 $a$ 和 $b$ 构成的字符串，将其分成三部分 $a,b,c$，输出一种分法，让 $b$ 成为三者中的最值。 对于两个字符串 $x$，$y$，若 $x &lt; y$，当且仅当下面任意一个条件成立： $x$ 是 $y$ 的前缀，但$x \neq y$； $x_1=’a’,y_1=’b’$。 思路我们分成两个情况考虑： 遍历 $[2,n-1]$，若出现 $a$，那么让 $’a’$ 单独成为中间的字符，这样中间的字符一定是最小的，直接输出即可。 如果不存在，那么我们让 $[2,n-1]$ 的所有字符作为中间的字符串，因为第一位为 $b$，且足够长，一定可以保证其为最大。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t -- > 0)&#123; char[] a = scanner.next().toCharArray(); int n = a.length; for(int i=1;i&lt;n-1;i++)&#123; if(a[i] == 'a')&#123; for(int j=0;j&lt;i;j++)&#123; System.out.print(a[j]); &#125; System.out.print(" a "); for(int j=i+1;j&lt;n;j++)&#123; System.out.print(a[j]); &#125; System.out.println(); continue nxt; &#125; &#125; System.out.printf("%c ", a[0]); for(int i=1;i&lt;n-1;i++) System.out.print(a[i]); System.out.printf(" %c", a[n - 1]); System.out.println(); &#125; &#125; &#125; 怎么会是呢，简单思维题怎么能想那么久呢 A2. Gardener and the Capybaras (hard version)题意参见 $A1$ 题。差别是数据量更大。 思路参见 $A1$ 题。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; public class Main &#123; public static void main(String[] args) throws Throwable&#123; Console console = new Console(); int t = console.nextInt(); nxt:while(t -- > 0)&#123; char[] a = console.next().toCharArray(); int n = a.length; for(int i=1;i&lt;n-1;i++)&#123; if(a[i] == 'a')&#123; for(int j=0;j&lt;i;j++)&#123; console.print(a[j]); &#125; console.print(" a "); for(int j=i+1;j&lt;n;j++)&#123; console.print(a[j]); &#125; console.println(); continue nxt; &#125; &#125; console.print(a[0] + " "); for(int i=1;i&lt;n-1;i++) console.print(a[i]); console.print(" " + a[n - 1]); console.println(); &#125; console.close(); &#125; //快读模板 此处省略 //public static class Console implements Closeable &#123;&#125; &#125; java在输入多的时候记得用快读 B. Gardener and the Array题意给定数组 $c$，输出 是否有两个可不连续的不同子序列 满足 将 序列的所有数 进行 或运算 后得到的数相等。 思路将每个数转为二进制，记录二进制下每一位有多少个数为 $1$。 遍历所有数，若有一个数每一位都出现了不止 $2$ 次，那么这个数可以被删去，从而和整个序列的或运算值相等。 若没有一个数满足上面的条件，输出 $NO$。 不宜开二维数组。 时间复杂度：$O(nk)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; int main() &#123; int T, n, k, p; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); vector&lt;vector&lt;int>> c(n); map&lt;int, int> cnt; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;k); for (int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;p); c[i].push_back(p); cnt[p]++; &#125; &#125; bool res = false; for (int i=0;i&lt;n;i++) &#123; bool f = true; for (int j=0;j&lt;c[i].size();j++) &#123; if (cnt[c[i][j]] &lt; 2) f = false; &#125; if (f) &#123; res = true; break; &#125; &#125; printf(res ? "Yes\n" : "No\n"); &#125; &#125; 既然不好用二维数组，那就果断vector C. Interesting Sequence题意给定两个数 $n,x$，输出满足 $n\&amp;(n+1)\&amp;(n+2)\&amp;…\&amp;m=x$ 的 $m$ 值，若不存在，输出 $-1$。 思路首先，观察可得，我们无法让 $n$ 变大，因为随着 $n$ 的递增，较低位会出现 $0$，从而使整个数减小。 其次，我们只能让一些低位变成 $0$，所以我们可以遍历每一位，此处可以分类讨论： $n$ 中是 $0$ ，但 $x$ 中是 $1$ ：无解，结束遍历； $n$ 中是 $1$ ，但 $x$ 中是 $0$ ：标记此点，且该点以后若 $x$ 中出现 $1$，那么为无解，结束遍历； $n$ 中是 $0$ ，且 $x$ 中是 $0$ ：若未遇到 $2$ 类情况，那么记录下最后一个满足本情况的点 $last0$； $n$ 中是 $1$ ，且 $x$ 中是 $1$ ：既然匹配，那么 $last0$ 应标为 $-1$，否则会影响整体的值。 最后，对于 $n$，在 $last0$ 的位置将其改为 $1$，并把 $last0$ 后的位置改为 $0$，转换为十进制输出即可。 时间复杂度：$O(n)$左右 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt: while (t-- > 0) &#123; long a = scanner.nextLong(), b = scanner.nextLong(); if (a == b) &#123; System.out.println(a); continue; &#125; if (b % 2 != 0) &#123; System.out.println(-1); continue; &#125; int[] ba = new int[64], bb = new int[64]; int la = 0, lb = 0; while (a > 0) &#123; ba[la++] = (int) (a % 2); a /= 2; &#125; if (b == 0) &#123; long ans = 1; for (int i = 0; i &lt; la; i++) ans *= 2; System.out.println(ans); continue; &#125; while (b > 0) &#123; bb[lb++] = (int) (b % 2); b /= 2; &#125; if (lb != la) &#123; System.out.println(-1); continue; &#125; int last0 = -1; boolean f = false; for (int i = 0; i &lt; la; i++) &#123; int ta = ba[la - i - 1], tb = bb[lb - i - 1]; if (ta == tb) &#123; if (!f &amp;&amp; ta == 0) last0 = la - i - 1; if(ta == 1) last0 = -1; continue; &#125; if (ta == 0 &amp;&amp; tb == 1) &#123; System.out.println(-1); continue nxt; &#125; if (ta == 1 &amp;&amp; tb == 0) f = true; &#125; if (last0 == -1) &#123; System.out.println(-1); &#125; else &#123; long ans = 0; for (int i = la - 1; i > last0; i--) ans = ans * 2 + ba[i]; ans = ans * 2 + 1; for (int i = last0 - 1; i >= 0; i--) ans *= 2; System.out.println(ans); &#125; &#125; &#125; &#125; 写得有点过度码农了]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 141</title>
    <url>/blog/posts/707152960/</url>
    <content><![CDATA[Contestant. Rank 3946. Rating +15 (+165 -150). A. Make it Beautiful题意给定一个数组 $a$，将其重新排列，使其满足对于任意 $ai$，均满足前缀和 $sum{i-1} \neq a_i$。 思路将数组降序排列即可。 需要特判一种情况，当降序排列后，第一个数和第二个数重复，那么需要向后枚举，找到第一个不一样的数，将其和第一个数交换即可。若没有这个数，输出 $NO$。 时间复杂度：最坏$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t -- > 0)&#123; int n = scanner.nextInt(); int[] sum = new int[n + 1]; Integer[] a = new Integer[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a, (o1, o2) -> o2 - o1); if(a[0] != a[1])&#123; System.out.println("YES"); for(int i=0;i&lt;n;i++) System.out.printf("%d ", a[i]); System.out.println(); continue nxt; &#125; boolean flag = false; for(int i=2;i&lt;n;i++)&#123; if(a[i] != a[1])&#123; int tmp = a[i]; a[i] = a[1]; a[1] = tmp; flag = true; break; &#125; &#125; if(flag)&#123; System.out.println("YES"); for(int i=0;i&lt;n;i++) System.out.printf("%d ", a[i]); System.out.println(); &#125;else System.out.println("NO"); &#125; &#125; &#125; 签到签到，简单的贪心 B. Matrix of Differences题意给定矩阵的规模 $n$，构造一个 $n \times n$ 的矩阵，使所有相邻的 $x,y$ 的 $|x-y|$ 值中不同的数值的个数最大。 思路既然要让不同的差值出现，那么我们可以按照 $1,n-1,2,n-2,…$ 的方式排列，为了让这个排列的数字能相邻，最简单的方法就是按蛇形排布，输出这个排列即可。 时间复杂度：$O(n^2)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t -- > 0)&#123; int n = scanner.nextInt(); int[][] a = new int[n][n]; int now = 1; boolean flag = true; int l = 1, r = n * n; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; int p = i % 2 == 0 ? j : n - j - 1; a[i][p] = flag ? l ++ : r --; flag = !flag; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++)&#123; System.out.printf("%d ", a[i][j]); &#125; System.out.println(); &#125; &#125; &#125; &#125; 怎么赛时就是想了那么久呢… C. Yet Another Tournament题意给定数组 $a$，规定自己和其他的对手的输赢取决于准备时间，如果将要打败的对手的等待时间总和小于等于 $m$ ，那么判定为获胜。而其他的对手之间的输赢取决于下标，$i&gt;j$ 时 $i$ 赢。在允许出现同名次的条件下，打败的对手越多，排名越靠前，输出自己的排名。 思路我们把这两个类型拆分成两个问题，最后合并在一起： 升序排序准备时间，统计能打败多少人，记为 $ans$； 因为 $ans+1 &gt; ans$，所以 $ans+1$ 的排名会更高，所以我们需要将 $ans+1$ 对应的值替换过来，否则排名会向后移一位。所以我们需要判断 $ans+1$ 在排序前数组中对应的值是否可以替换掉 $ans$ 在排序后数组中对应的值，如果不可以，那么将排名后移。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t -- > 0) &#123; int n = scanner.nextInt(), m = scanner.nextInt(); int[] a = new int[n + 2], b = new int[n + 1]; for (int i = 1; i &lt;= n; i++) a[i] = b[i] = scanner.nextInt(); Arrays.sort(b, 1, n + 1); int ans = 0, sum = 0; for (int i = 1; i &lt;= n; i++) &#123; if(sum + b[i] > m) break; sum += b[i]; ans ++; &#125; if (sum + a[ans + 1] - b[ans] > m) System.out.println(n - ans + 1); else System.out.println(Math.max(n - ans, 1)); &#125; &#125; &#125; 题目要看清]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 142</title>
    <url>/blog/posts/3006209530/</url>
    <content><![CDATA[Contestant. Rank 2570. Rating +70. A. GamingForces题意给定一个数组 $a$，定义操作可任选其一： 将其中两个元素减 $1$ 将某个元素减为 $0$ 输出最少的操作数，使 $a$ 的所有元素都减为 $0$。 思路将所有为 $1$ 的元素配对，扣去偶数个 $1$ 后，剩下的元素全都执行操作 $2$ 即可。 时间复杂度：最坏$O(n)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int cnt = 0; for(int i=0;i&lt;n;i++) if(scanner.nextInt() == 1) cnt ++; System.out.println(n - cnt / 2); &#125; &#125; &#125; 简单签到题 B. Stand-up Comedian题意给定整数 $a_1$，$a_2$，$a_3$，$a_4$，$4$ 个整数代表了四个类型对应的笑话数量： $A$ 和 $B$ 都喜欢 $A$ 喜欢，$B$ 不喜欢 $B$ 喜欢，$A$ 不喜欢 $A$ 和 $B$ 都不喜欢 初始状态下，两人的心情值都为 $0$，对于喜欢的笑话，心情会 $+1$，否则会 $-1$。 输出最多能讲多少个笑话。 思路模拟+思维 首先，我们先把类型 $1$ 讲完，如果 $a_1=0$，直接判 $1$ 个。 接着，我们讨论 $|a_2-a_3|$ 和 $a_1$ 的大小关系，若 $a_1$ 较小，那么笑话是讲不完的，只有 $2 \times (a_1+min(a_2,a_3)) + 1$ 个笑话可以讲。 否则，将 $|a_2-a_3|$ 讲完后，判断剩余的可以讲多少个 $a_4$ 即可。 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int[] a = new int[4]; for(int i=0;i&lt;4;i++) a[i] = scanner.nextInt(); if(a[0] == 0)&#123; System.out.println(1); continue; &#125; int n = Math.min(a[1], a[2]), ans = 0; ans += a[0] + n * 2; int m = Math.max(a[1] - n, a[2] - n); if(a[0] &lt; m)&#123; System.out.println(2 * (a[0] + n) + 1); &#125;else&#123; ans += m; ans += Math.min(a[0] - m + 1, a[3]); System.out.println(ans); &#125; &#125; &#125; &#125; 思路好乱 C. Min Max Sort题意给定一个排列 $p$，定义一次操作为任选两个元素，将其从原排列中取出，将较小元素放至排列头部，较大元素放至排列尾部，输出最小的操作数，使最后的排列升序。 思路逆向思维 显然，我们需要对形如 $[i,n-i+1]$ 的元素对进行操作。 考虑到一个不需要移动的元素对，应满足三个条件： $i$ 在 $n-i+1$ 前面 $i$ 在 $i+1$ 前面 $n-i$ 在 $n-i+1$ 前面 筛出所有不需要移动的元素对并取补集即可。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); int[] w = new int[n + 1]; int ans = n / 2; for (int i = 1; i &lt;= n; i++) w[scanner.nextInt()] = i; for (int i = n / 2; i >= 1; i--) &#123; //排除不用移动的 if (w[i] &lt; w[i + 1] &amp;&amp; w[n - i + 1] > w[n - i] &amp;&amp; w[i] &lt; w[n - i + 1]) ans--; else break; &#125; System.out.println(ans); &#125; &#125; &#125; 反着想简单多了 D. Fixed Prefix Permutations题意给定整数 $n$ 和 $m$，定义两个排列 $p$，$q$ 的乘积为一个新的排列 $r$，其中 $rj=q{p_j}$。给定长度为 $m$ 的 $n$ 个排列，对于每一个排列，输出其与所有 $n$ 个排列的乘积构成的排列的最大美丽值。其中美丽值定义为满足 $p_1=1,p_2=2,…,p_k=k$ 的 $k$ 的最大值（$p_1 \neq 1$时美丽值为 $0$）。 思路显然，对于给定的排列 $p$ 和 $q$，若已知 $q$，那么所构造出来的 $r$ 和 $p$ 是一一对应的。所以，我们可以将问题转化一下： 对于所有 $q$，先预处理构造出满足 $k=m$ 的排列 $p_t$ ，然后对于每一个 $p$ ，在所有 $p_t$ 中依次匹配，输出从第一个开始最大的连续匹配数量。 为了让匹配的复杂度降到最低，我们可以采用字典树。 时间复杂度：$O(nm)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 50010; int n, m; int a[N][20], tmp[20]; class Trie &#123; private: vector&lt;Trie*> children; public: Trie() : children(12)&#123;&#125; void insert() &#123; Trie* node = this; for (int i=0;i&lt;m;i++) &#123; int ch = tmp[i]; if (node->children[ch] == nullptr) &#123; node->children[ch] = new Trie(); &#125; node = node->children[ch]; &#125; &#125; int find(int index) &#123; Trie* node = this; int dep = 0; for (int i=0;i&lt;m;i++) &#123; int ch = a[index][i]; if (node->children[ch] == nullptr) &#123; return dep - 1; &#125; node = node->children[ch]; dep ++; &#125; return dep; &#125; &#125;; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; Trie root = *new Trie(); cin >> n >> m; for(int i=0;i&lt;n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cin >> a[i][j]; tmp[a[i][j]] = j; &#125; root.insert(); &#125; for(int i=0;i&lt;n;i++)&#123; cout &lt;&lt; root.find(i) &lt;&lt; " "; &#125; cout &lt;&lt; '\n'; &#125; &#125; 题目真的很难看懂…]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 842 Div 2</title>
    <url>/blog/posts/3350941822/</url>
    <content><![CDATA[Contestant. Rank 7746. Rating -14 (+186 -200). A. Greatest Convex题意给定 $k$，输出满足条件的 $x$，使 $x!+(x-1)!$ 为 $k$ 的倍数。 思路$x!+(x-1)!=(x-1)!(x+1)$，显然，令 $x+1=k$ 即可，答案即为 $k-1$。 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; System.out.println(scanner.nextInt() - 1); &#125; &#125; &#125; 怎么会有这么签到的题 B. Quick Sort题意给定整数 $k$ 以及一个排列 $p$，定义一次操作为选择 $k$ 个数并将其升序移至排列末尾。输出最少操作数，使整个排列升序。 思路显然，最后的排列一定是 $1,2,3,…$，那么，我们不妨先来考虑单个元素是否需要移至后面。 对于一个元素 $t$，如果它的前面没有出现 $t-1$，那么显然我们只有将他移动至最后才能让排列成功构造出来，否则我们就无需操作。 所以，我们只需统计需要移动的元素数量 $sum$，然后输出 $\lfloor \frac{sum}{k} \rfloor$ 即可，因为每次移动我们可以选多个。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(), k = scanner.nextInt(); boolean[] a = new boolean[n + 1]; int sum = 0; for(int i=0;i&lt;n;i++)&#123; int cur = scanner.nextInt(); a[cur] = true; if(cur != 1)&#123; if(!a[cur - 1]) &#123; a[cur] = false; sum ++; &#125; &#125; &#125; System.out.println((int) Math.ceil((double) sum / k)); &#125; &#125; &#125; 从一个推向多个是否合理呢 C. Elemental Decompress题意给定数组 $a$ 以及其长度 $n$，规定 $1 \leq a_i \leq n$。构造两个排列 $p$，$q$，满足 $max(p_i,q_i)=a_i$。若能构造，输出 $YES$ 以及其中一种构造，否则输出 $NO$。 思路1显然，一个数不能出现三次及以上，否则无法构造。 并且，我们可以发现，排序后的数组，若出现元素满足 $a_i&lt;i$，那么也无法构造（可以使用反证法） 那么，我们可以降序排序数组，并执行下面的两个操作： 遍历数组，将重复两次的数分散到两个数组内，做拆分（此时可排除出现三次及以上的数）； 遍历数组，如果 $a_i$ 在 $p$ 内，那么寻找不在 $q$ 中的最大值，将其放入 $q$，反之亦如此。 遍历结束后，若全都填满了就是有解，输出即可。 时间复杂度：$O(nlogn)$ 对应AC代码import java.io.*; import java.math.*; import java.util.*; public class Main &#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt:while(t -- > 0)&#123; int n = console.nextInt(); int[][] a = new int[n + 1][2]; boolean[] inp = new boolean[n + 1], inq = new boolean[n + 1]; for(int i=1;i&lt;=n;i++) a[i] = new int[]&#123;i, console.nextInt()&#125;; Arrays.sort(a, 1, n + 1, Comparator.comparingInt(o -> -o[1])); int[] p = new int[n + 1], q = new int[n + 1]; for(int i=1;i&lt;=n;i++)&#123; int k = a[i][0], v = a[i][1]; if(inp[v] &amp;&amp; inq[v])&#123; console.println("NO"); continue nxt; &#125; if(inp[v])&#123; q[k] = v; inq[v] = true; &#125;else&#123; p[k] = v; inp[v] = true; &#125; &#125; int rp = n, rq = n; for(int i=1;i&lt;=n;i++)&#123; int k = a[i][0]; if(p[k] == 0)&#123; while(inp[rp]) rp --; inp[rp] = true; if(rp > q[k])&#123; console.println("NO"); continue nxt; &#125; p[k] = rp --; &#125;else&#123; while(inq[rq]) rq --; inq[rq] = true; if(rq > p[k])&#123; console.println("NO"); continue nxt; &#125; q[k] = rq --; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!inp[i] &amp;&amp; !inq[i])&#123; console.println("NO"); continue nxt; &#125; &#125; console.println("YES"); for(int i=1;i&lt;=n;i++) console.print(p[i] + " "); console.println(); for(int i=1;i&lt;=n;i++) console.print(q[i] + " "); console.println(); &#125; console.close(); &#125; //快读模板，此处略去 //public static class Console implements Closeable &#123;&#125; &#125; 思路2首先，这种思路无法通过 $Test3$。 若未考虑到 思路$1$ 中第二个结论，那么我们可以考虑使用链表的方式，遍历排序后的数组的时候，我们可以把求得的解对应的元素删去，从而获取到我们想要的元素。 时间复杂度约为$O(n^2)$，无法通过 对应AC代码 在赛时可以思考能否得出一些特定的结论出来]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Hello 2023</title>
    <url>/blog/posts/3186977285/</url>
    <content><![CDATA[Contestant. Rank 3574. Rating +50 (+400 -350). A. Hall of Fame题意给定一个只有 $L$ 和 $R$ 的长度为 $n$ 的字符串，对于第 $i$ 个字符，$L$ 表示将 $[1,i-1]$ 照亮，$R$ 表示将 $[i+1,n]$ 照亮。对于该字符串，允许选择一个 $i$，将 $i$ 和 $i+1$ 对应的字符交换，该操作最多可执行一次。判断是否可以将所有点照亮。若无需交换，输出 $0$；若交换后才满足条件，输出 $i$；若无法满足条件，输出 $-1$。 思路很显然，只要出现 $R,…,L$ 的排列，就一定可以满足条件。 那么，我们首先可以寻找第一个 $R$ 之后有没有 $L$，只要找到了 $L$ 就直接输出 $0$ 即可。 否则，我们就需要寻找 $LR$，并将其交换，并输出 $L$ 对应的下标。 否则，输出 $-1$ 即可。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t-- > 0)&#123; int n = scanner.nextInt(); char[] a = scanner.next().toCharArray(); int l = 0, r = 0, lr = -1; boolean preR = false; for(int i=0;i&lt;a.length;i++)&#123; if(i &lt; a.length - 1 &amp;&amp; lr == -1 &amp;&amp; a[i] == 'L' &amp;&amp; a[i + 1] == 'R') lr = i + 1; if(a[i] == 'R') preR = true; else if(preR)&#123; System.out.println(0); continue nxt; &#125; &#125; System.out.println(lr); &#125; &#125; &#125; 简单思维题 B. MKnez’s ConstructiveForces Task题意给定数组的长度 $n$，构造一个非零数组 $s$，满足对于任何 $i \in [1,n)$，有 $s1+s_2+…+s_n=s_i+s{i+1}$。若不可构造，输出 $NO$，否则输出 $YES$，以及所构造的数组。 思路将等式右边移到左边，那么我们只需满足任意取出两个数后数组的和都为 $0$ 即可。那么很显然，当 $n$ 为偶数时，我们只需构造一个 $1,-1,1,-1,…$ 的数组即可。 而当 $n$ 为奇数的时候，既然等式左边有 $n$ 项，而右边有 $2$ 项，若仍然考虑相邻数的和相等的构造方式的话，我们不妨让这个相等的和为 $1$，这样的话，式子将会变为 $s_x+\frac{n}{2}=1$，那么多出来的项 $s_x$ 即为 $1-\frac{n}{2}$ 。因而，令 $w=\frac{n}{2}$，我们只需构造 $1-w,w,1-w,w,1-w,…$ 即可。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t-- > 0)&#123; int n = scanner.nextInt(); if(n == 3) System.out.println("NO"); else&#123; System.out.println("YES"); if(n % 2 == 0)&#123; for(int i=0;i&lt;n/2;i++) System.out.print("1 -1 "); &#125;else&#123; int w = n / 2; System.out.printf("%d ", 1 - w); for(int i=0;i&lt;n/2;i++) System.out.printf("%d %d ", w, 1 - w); &#125; System.out.println(); &#125; &#125; &#125; &#125; 既然是成对的，那就让和也成对呗 C. Least Prefix Sum题意给定一个数组 $a$，定义一次操作为任取一个数并将其改为它的相反数。输出最少的操作数，使 $a$ 的前 $m$ 项和为 $a$ 的所有前 $k$ 项和（$k \in [1,n]$）中的最小值。 思路对于题给式子 $a_1+a_2+…+a_k \geq a_1+a_2+…+a_m$， 当 $k \leq m$ 时，将不等式左边移到右边，我们可以得到第一个条件：以 $m$ 为结尾的不包括 $a_1$ 的后缀和均为非正数。 同理，当 $k \geq m$ 时，将不等式右边移到左边，我们可以得到第二个条件：以 $m+1$ 为第一项的前缀和均为非负数。 因为上述两者差不多，我们不妨来考虑前者。 显然，在遍历所有后缀和的时候，我们不可以在发现某一项不满足时直接把这一项取相反数，因为我们不能保证后面的项比这一项小，而将最大值取反才是最优解。 因此，为了每次查询的复杂度降到一个合理的值，我们可以采用优先队列。 时间复杂度：$O(nlogn)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t-- > 0) &#123; int n = scanner.nextInt(), m = scanner.nextInt(); long[] a = new long[n + 1]; for(int i=1;i&lt;=n;i++) a[i] = scanner.nextInt(); PriorityQueue&lt;Long> positive = new PriorityQueue&lt;>((o1, o2) -> Math.toIntExact(o2 - o1)); PriorityQueue&lt;Long> negative = new PriorityQueue&lt;>(Comparator.comparingLong(o -> o)); long cnt = 0, sum = 0; for(int i=m;i>=2;i--)&#123; sum += a[i]; if(a[i] > 0) positive.offer(a[i]); while(sum > 0) &#123; sum -= 2 * positive.poll(); cnt ++; &#125; &#125; sum = 0; for(int i=m + 1;i&lt;=n;i++)&#123; sum += a[i]; if(a[i] &lt; 0) negative.offer(a[i]); while(sum &lt; 0) &#123; sum -= 2 * negative.poll(); cnt ++; &#125; &#125; System.out.println(cnt); &#125; &#125; &#125; 优先队列yyds]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 3</title>
    <url>/blog/posts/2583580825/</url>
    <content><![CDATA[Rank 196/3562. AC 7/11. 这标题显然是参考了arcaea的final verdict包的剧情，对吧 A. 不断减损的时间题意给定一个数组，数值可以为负数。对于无限次的操作，你可以任选一个偶数并将其除以 $2$，输出最后总和的最大值。 思路将所有正偶数暴力除到奇数为止，并求和即可。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); long ans = 0; for(int i=0;i&lt;n;i++)&#123; int a = scanner.nextInt(); if(a &lt;= 0) ans += a; else&#123; while(a % 2 == 0) a /= 2; ans += a; &#125; &#125; System.out.println(ans); &#125; &#125; 快速签到 B. 勉强拼凑的记忆题意给定 $n$ 块矩形积木，积木的大小为 $1 \times k$，$k$ 可在 $[1,\lceil \frac{n}{2} \rceil ]$ 内任意选择，若能使用所有积木搭成正方形，输出最大的边长，否则输出 $-1$。 思路很难说思路，因为可以打表打出规律（（ 前 $30$ 个根据打表得到 $1,-1,2,2,3,4,5,5,6,6,$ $7,8,9,9,10,10,11,12,13,13,$ $14,14,15,16,17,17,18,18,19,20$ 很容易就可以得到一个通式 $ans=\frac{(q \times 2 + q \ \%\ 2)}{3}$ 至于为什么会这样，我们可以考虑 $6$ 以上的数，因为横放几个最长的方块，然后再竖着放一个方块，最后在最后一行填满方块，即为 $6 -11$ 之间的规律，而 $12$ 以上，我们就可以发现最底下还可以再塞一行，然后在右边再放上一个方块依然是可行的，以此类推… 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; long q = scanner.nextLong(); if(q == 2) System.out.println(-1); //下面式子会算成0... else System.out.println((q * 2 + q % 2) / 3); &#125; &#125; &#125; 打表好累.jpg C. 忽远忽近的距离题意构造一个排列，满足 $2 \leq |a_i-i| \leq 3$。 思路打表，暴力找规律即可。 可以发现是 $4$ 个为一块有规律输出的，处理结尾数字即可。 时间复杂度：$O(1)$ （确信 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define ll long long int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n; cin >> n; if(n &lt; 4) cout &lt;&lt; -1 &lt;&lt; '\n'; else if(n == 4) cout &lt;&lt; "3 4 1 2\n"; else if(n == 5) cout &lt;&lt; "4 5 1 2 3\n"; else if(n == 6) cout &lt;&lt; "4 5 6 1 2 3\n"; else if(n == 7) cout &lt;&lt; -1 &lt;&lt; '\n'; else if(n == 8) cout &lt;&lt; "3 4 1 2 7 8 5 6\n"; else if(n == 9) cout &lt;&lt; "3 4 1 2 7 8 9 5 6\n"; //狠狠地打表 else &#123; int i = 0; if (n % 4 == 3) for (; i &lt; n / 4 - 2; i++) cout &lt;&lt; i * 4 + 3 &lt;&lt; " " &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " "; else for (; i &lt; n / 4 - 1; i++) cout &lt;&lt; i * 4 + 3 &lt;&lt; " " &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " "; if (n % 4 == 0) cout &lt;&lt; i * 4 + 3 &lt;&lt; " " &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2; else if (n % 4 == 1) cout &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 5 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " " &lt;&lt; i * 4 + 3; else if (n % 4 == 2) cout &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 5 &lt;&lt; " " &lt;&lt; i * 4 + 6 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " " &lt;&lt; i * 4 + 3; else cout &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 5 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " " &lt;&lt; i * 4 + 3 &lt;&lt; " " &lt;&lt; i * 4 + 9 &lt;&lt; " " &lt;&lt; i * 4 + 10 &lt;&lt; " " &lt;&lt; i * 4 + 11 &lt;&lt; " " &lt;&lt; i * 4 + 6 &lt;&lt; " " &lt;&lt; i * 4 + 7 &lt;&lt; " " &lt;&lt; i * 4 + 8; &#125; &#125; 打表好累.jpeg D. 宿命之间的对决题意给定一个正整数 $n$，小红和小紫轮流取当前数的因子 $x$ ，使当前数减少 $x$ 。如果小红获胜，则输出 “$kou$”，否则输出 “$yukari$” 思路简单的博弈题。 我们先假设每个人都只拿 $1$ 个，那么最后一定是第一次拿的时候当前数为偶数的一方获胜。 然而，输的一方肯定想要获胜，那么他一定要拿掉偶数个才行，而无论他怎么拿，获胜方都可以只拿掉奇数来使他只能从奇数的因数中取，从而不可能取到偶数，因而必输。 所以，判奇偶即可。 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println(scanner.nextLong() % 2 == 1 ? "yukari" : "kou"); &#125; &#125; 次世代の宿命之红砍光光（？ E. 公平守望的灯塔题意给定在平面直角坐标系的整点 $A(x_A,y_A)$ 和 $B(x_B,y_B)$ ，输出一个整点 $C$ ，使得 $\triangle ABC$ 为以 $AB$ 为斜边的 等腰$Rt\triangle$。 思路“K型全等”，找出中点后用全等即可解出。 当 $A$ 和 $B$ 横坐标的差值和纵坐标的差值的奇偶性不一致时，$C$ 点一定会有小数 $0.5$ 存在，因此该条件无解。 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long xa = scanner.nextLong(), ya = scanner.nextLong(), xb = scanner.nextLong(), yb = scanner.nextLong(); if(Math.abs(xa - xb) % 2 == Math.abs(ya - yb) % 2)&#123; //初中数学？ long mid2x = xa + xb, mid2y = ya + yb; System.out.printf("%d %d\n", (mid2x + mid2y) / 2 - ya, (mid2y - mid2x) / 2 + xa); &#125;else System.out.println("No Answer!\n"); &#125; &#125; 画个图，不就是个初中数学题嘛 F. 迎接终结的寂灭题意输出 $42$。 思路输出 $42$。 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; System.out.println(42); &#125; &#125; 怎么会是呢 G. 严肃古板的秩序题意给定一个运算式，其中等式左边的符号全都被替换成 $?$，等式右边只有一个数字，符号只有三种可能：$+$，$-$， #，其中定义$a$#$b=a^a\ mod\ b,a&gt;0且b&gt;0$，三个符号的优先级相同，输出一个合法的式子，否则输出 $-1$。 思路暴力 $Dfs$ 即可，其中模幂运算需要使用快速幂。 时间复杂度：$O(3^xlogn),x \leq 12$ 对应AC代码import java.math.BigInteger; import java.util.*; public class Main&#123; static int n; static long ans; static long[] nums; static char[] op; static boolean ok = false; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String[] s = scanner.next().split("\\?"); n = s.length; nums = new long[n]; for(int i=0;i&lt;n-1;i++) nums[i] = Long.parseLong(s[i]); nums[n - 1] = Long.parseLong(s[n - 1].split("=")[0]); ans = Long.parseLong(s[n - 1].split("=")[1]); op = new char[n - 1]; dfs(0, nums[0]); if(!ok) System.out.println(-1); &#125; private static void dfs(int index, long last)&#123; if(index == n - 1)&#123; if(last == ans) &#123; ok = true; print(); &#125; return; &#125; if(ok) return; op[index] = '+'; dfs(index + 1, last + nums[index + 1]); if(ok) return; op[index] = '-'; dfs(index + 1, last - nums[index + 1]); if(ok || last &lt;= 0 || nums[index + 1] &lt;= 0) return; op[index] = '#'; dfs(index + 1, BigInteger.valueOf(last).modPow(BigInteger.valueOf(last), BigInteger.valueOf(nums[index + 1])).longValue()); &#125; private static void print()&#123; System.out.printf("%d", nums[0]); for(int i=1;i&lt;n;i++)&#123; System.out.printf("%c%d", op[i - 1], nums[i]); &#125; System.out.printf("=%d\n", ans); &#125; &#125; 很经典的回溯搜索 H. 穿越万年的轮回 待补充 I. 灵魂碎片的收集题意定义 $S(n)$ 为 $n$ 的所有不包括 $n$ 的因数的和，给定正整数 $x$，输出满足 $S(n)=x$ 的正整数 $n$，否则输出 $-1$。 限制对于输入的 $x$，有以下限制： $x\%2=0$，则 $x-1$ 和 $x-3$ 之间一定有一个是质数。 $x\%2=1$，则无限制 思路我们可以直接从限制入手： 若 $x$ 为偶数，且 $x-1$ 是质数，那么显然只有一种分解 $S(n)=1+(x-1)=x$，那么 $n=(x-1)^2$。 若 $x$ 为偶数，且 $x-3$ 是质数，那么也只有一种分解 $S(n)=1+2+(x-3)=x$，那么 $n=2(x-3)$。 若 $x$ 为奇数，因为 $1$ 一定是其中一个因子，那么剩下的一定是偶数。因为所有偶数都可以分解为两个质数之和，那么我们可以直接暴力，枚举出一种可能即可。 当然，为了判定素数方便，我们采取用线性筛打表的方式来让查询的复杂度降到 $O(1)$。 时间复杂度：懒得分析 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 1000010; #define ll long long vector&lt;int> primes; bool vis[N + 1], isPrime[N + 1]; void init() &#123; for (int i = 2; i&lt;= N; ++i) &#123; if (!vis[i]) &#123; primes.emplace_back(i); isPrime[i] = true; &#125; for (int &amp;j : primes) &#123; if (1ll * i * j > N) break; vis[i * j] = true; if (i % j == 0) break; &#125; &#125; &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t; ll x; cin >> t; int ans[] = &#123;0, -1, -1, 4, 9, -1, 25, 8&#125;; while (t--) &#123; cin >> x; if(x &lt;= 7) cout &lt;&lt; ans[x] &lt;&lt; '\n'; else &#123; if (x % 2 == 0) &#123; if (isPrime[x - 1]) cout &lt;&lt; (x - 1) * (x - 1) &lt;&lt; '\n'; else cout &lt;&lt; 2 * (x - 3) &lt;&lt; '\n'; &#125; else &#123; for (int i = 2; i &lt;= x; i++) &#123; if(isPrime[i] &amp;&amp; isPrime[x - i - 1]) &#123; cout &lt;&lt; (ll)i * (x - i - 1) &lt;&lt; '\n'; break; &#125; &#125; &#125; &#125; &#125; &#125; 赛时眼瞎了没看到限制 J. 无法磨灭的悔恨 待补充 K. 永恒守候的爱恋题意假设 $p_1,p_2,…,p_n$ 为前 $n$ 个素数，定义 $S$ 为 $a_i$ 个 $p_i$ 组成的多重集合 $(i \in [1,n])$。 例如，多重集{2,2,3,3,3,7}可以表示为： $n=4,a=[2,3,0,1]$。 定义$f(i)$ 为一个数组前 $i$ 个元素的乘积的因子数量，给定 $n$ 和数组 $a$，他表示了一个大小为 $size=\sum{i=1}^{n}a_i$ 的多重集。用这个多重集的所有元素构造一个大小为 $size$ 的数组，输出 $\sum{i=1}^{size}f(i)$ 的最大值，对 $10^9+7$ 取模。 思路$Buff$ 叠满的数学题。 我们先来考虑因子个数：根据算数基本定理，对于一个分解式 $x=P_1^{\alpha_1}P_2^{\alpha_2}…P_n^{\alpha_n}$，因数数量为 $(\alpha_1 + 1)(\alpha_2 + 1)…(\alpha_n+1)$。 那么既然我们要让这个乘积更大，我们就可以每次都不重复地将数字放上去，如 $|2,3,7||2,3||3|$。那么对于第一块，结果为 $2 \times 1 \times 1$、$2 \times 2 \times 1$、$2 \times 2 \times 2$。对于第二块，结果为 $3 \times 2 \times 2$、$3 \times 3 \times 2$。对于第三块，结果为 $4 \times 3 \times 2$。 显然，上述式子是分块的等比数列求和，其中 $q=2,\frac{3}{2},\frac{4}{2},…$ 因而，我们只需一块一块地处理即可。 当然，为了快速求出每一块的元素个数，我们只需在读入的时候使用差分的方法，具体地来说： 横向从左到右绘制一张柱状图，那么纵切面的数量即为每块的元素数量。 时间复杂度：不好评价 对应AC代码 注意，此代码不一定能运行通过，有概率会超时 import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] t = new int[200010]; for(int i=0;i&lt;n;i++)&#123; t[scanner.nextInt() + 1] --; t[1] ++; &#125; int max = 0; for(int i=1;i&lt;200010;i++) &#123; t[i] += t[i - 1]; if(t[i] == 0) &#123; max = i - 1; break; &#125; &#125; long ans = 0, a1 = 1, an; BigInteger res = BigInteger.ONE, ip1, mod = BigInteger.valueOf(1000000007L); for(int i=1;i&lt;=max;i++)&#123; //规避一下逆元 int now = t[i], nxt = t[i + 1]; ip1 = BigInteger.valueOf(i + 1); res = res.multiply(ip1.modPow(BigInteger.valueOf(now - nxt), mod)).mod(mod); a1 = (a1 * (i + 1)) % 1000000007L; an = res.multiply(ip1.modPow(BigInteger.valueOf(nxt), mod)).mod(mod).longValue(); ans = (ans + (an * (i + 1)) % 1000000007L + 1000000007L - a1) % 1000000007L; a1 = an; &#125; System.out.println(ans); &#125; &#125; 不用考虑第几个质数是啥呢]]></content>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 2</title>
    <url>/blog/posts/4009320463/</url>
    <content><![CDATA[Rank 906/3920. AC 5/12. A. Tokitsukaze and a+b=n (easy)题意在两个闭区间 $[L1, R1]$ 和 $[L2, R2]$ 之间取两个数 $a$，$b$，满足 $a+b=n$。$a \neq b$ 时交换两者可算作两种选法。输出选法总数。 思路暴力枚举 $a$，$b$。快速签到。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T = scanner.nextInt(); while(T -- > 0)&#123; int n = scanner.nextInt(); int l1 = scanner.nextInt(), r1 = scanner.nextInt(); int l2 = scanner.nextInt(), r2 = scanner.nextInt(); int cnt = 0; for(int i=l1;i&lt;=r1;i++)&#123; int j = n - i; if(j >= l2 &amp;&amp; j &lt;= r2) cnt ++; &#125; System.out.println(cnt); &#125; &#125; &#125; 先签了再说 B. Tokitsukaze and a+b=n (medium)题意同$A$题，只有样例数量增加了。 思路一个取交集的思路： 当两个集合有交集时，那么将存在一段值相等的区间，因而我们化 $a+b=n$ 为 $a=n-b$ ，求等式两边集合的交集的元素数量即可。 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T = scanner.nextInt(); while (T-- > 0) &#123; int n = scanner.nextInt(); long l1 = scanner.nextInt(), r1 = scanner.nextInt(), l2 = scanner.nextInt(), r2 = scanner.nextInt(); System.out.println(Math.max(0, Math.min(n - l1, r2) - Math.max(n - r1, l2) + 1)); &#125; &#125; &#125; 这么好的思路，赛时怎么就没想到呢，淦 C. Tokitsukaze and a+b=n (hard)题意给定 $m$ 个区间，在不同的区间内分别取 $a$，$b$，同 $AB$，输出方案数。 思路在 $B$ 题的思路基础上，我们只需先用差分快速求出一个点 $t_i$ 被多少个区间覆盖，求和后便可很快算出一段区间内有多少元素在交集之内了，这里我们可以使用两次前缀和。注意，这里需要排除在相同区间内取交集。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main&#123; static final int N = 400010, mod = 998244353; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); int[] l = new int[m], r = new int[m]; long[] sum = new long[N + 1]; for(int i=0;i&lt;m;i++)&#123; l[i] = scanner.nextInt(); r[i] = scanner.nextInt(); sum[r[i] + 1] --; sum[l[i]] ++; &#125; for(int i=1;i&lt;=N;i++) &#123; sum[i] += sum[i - 1]; sum[i] %= mod; &#125; for(int i=1;i&lt;=N;i++) &#123; //差分转前缀和 sum[i] += sum[i - 1]; sum[i] %= mod; &#125; long ans = 0; for(int i=0;i&lt;m;i++)&#123; int l1 = l[i], r1 = r[i], l2 = n - r[i], r2 = n - l[i]; if(r2 &lt; 1) continue; l2 = Math.max(1, l2); ans += sum[r2] - sum[l2 - 1]; ans -= Math.max(0, Math.min(r1, r2) - Math.max(l1, l2) + 1); while(ans &lt; 0) ans += mod; ans %= mod; &#125; System.out.println(ans); &#125; &#125; 想不出来B题那个简单的做法这题就寄咯 D. Tokitsukaze and Energy Tree题意给定一个根为 $1$ 、有 $n$ 个节点的树，将 $n$ 个为 $v_i$ 的能量球放到 $n$ 个节点上，在每次放置时可获得自己加上子树的所有能量，输出能获得的最大能量。 思路1显然，我们可以贪心地认为从小到大从顶部往下按层放置即可，这样就可以保证最大的能量在层数最大的叶节点。 因而，我们可以直接用 $BFS$ 暴力模拟解决问题。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define ll long long const int N = 200020; int n; vector&lt;int> e[N]; int w[N], idx = 1; ll ans = 0; int v[N]; bool vis[N]; void bfs()&#123; queue&lt;pair&lt;int, int>> q; q.emplace(1, 1); ans += v[idx ++]; vis[1] = true; while(q.size())&#123; auto t = q.front(); q.pop(); for(int c : e[t.first])&#123; if(vis[c]) continue; vis[c] = true; ans += (t.second + 1) * v[idx ++]; q.emplace(c, t.second + 1); &#125; &#125; &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> n; for(int i=1;i&lt;n;i++)&#123; int f; cin >> f; e[f].emplace_back(i + 1); &#125; for(int i=1;i&lt;=n;i++) cin >> v[i]; sort(v + 1, v + n + 1); bfs(); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; 思路2题目输入有限制，在给出节点 $i$ 的父亲的时候，满足父亲的下标小于 $i$ ，所以是没必要 $BFS$ 的，直接用数组即可。 时间复杂度：$O(n)$ #include&lt;bits/stdc++.h> using namespace std; const int N = 200010; #define ll long long ll v[200005], d[200005]; int main() &#123; int n, f, ans = 0; d[1] = 1; cin >> n; for(int i=2;i&lt;=n;i++) &#123; cin >> f; d[i] = d[f] + 1; &#125; for(int i=1;i&lt;=n;i++) cin >> v[i]; sort(v + 1, v + n + 1); sort(d + 1, d + n + 1); for(int i=1;i&lt;=n;i++) ans += v[i] * d[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 看清题目的输入啊，完全没必要BFS E. Tokitsukaze and Function题意给定函数 $f(x)= \lfloor \frac{n}{x} \rfloor + x - 1$ 以及区间 $[L,R]$，输出 使 $f(t)$ 最小 的 最小整数 $t$ 。 思路首先，去掉向下取整符号后，这是一个对勾函数，那么最小值将在 $\sqrt x$ 处取到。 保留符号后，最小值会在 $\lfloor \sqrt x \rfloor$ 和 $\lceil \sqrt x \rceil$ 处取到，我们记为 $p$。 显然，在尝试几个数后，我们可以发现存在至少一段值都为最小值的区间，且 $p$ 在区间内部。 不过，因为我们需要取 $t_{min}$，所以我们只需从 $p$ 点向左找转折点，即左边的值大于自身的那个点。 我们先来特判几个情况： $p \leq L$ 时，输出 $l$ 即可。 $p &gt; R$ 时，我们可以将寻找转折点的区间缩小为 题给区间 $[L,R]$ 。 我们可以发现，题目给的数据量特别大，而且我们要找的区间是有单调性的，二分查找即可。 时间复杂度：$O(log x)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T = scanner.nextInt(); while(T -- > 0) &#123; long n = scanner.nextLong(), l = scanner.nextLong(), r = scanner.nextLong(); long p = Math.round(Math.sqrt(n)) + 1; if(p &lt;= l)&#123; System.out.println(l); continue; &#125; if (f(n, p - 1) &lt;= f(n, p)) p --; if(p > r) p = r; long left = l, right = p, mid; while(left &lt; right)&#123; mid = (left + right) >> 1; if(f(n, mid) &lt;= f(n, right)) right = mid; else left = mid + 1; &#125; System.out.println(left); &#125; &#125; private static long f(long n, long x)&#123; return n / x + x - 1; &#125; &#125; 不要死磕在一道题 F. Tokitsukaze and Gold Coins (easy)题意给定 $n \times 3$ 有障碍迷宫，输出从 $(1，1)$ 到 $(n, 3)$ 的所有路径中经过的点的个数，不重复计算。 思路正反两遍 $BFS$，统计被访问两遍的点的个数即可，无需找规律。 时间复杂度：$O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define ll long long const int N = 500010; int n; bool have[N][4], vis[N][4][2]; void bfs(pair&lt;int, int> s, int w) &#123; queue&lt;pair&lt;int, int>> q; q.emplace(s); while (!q.empty()) &#123; auto t = q.front(); q.pop(); if(vis[t.first][t.second][w]) continue; vis[t.first][t.second][w] = true; if (w) &#123; if (t.first - 1 > 0 &amp;&amp; !have[t.first - 1][t.second]) q.emplace(t.first - 1, t.second); if (t.second - 1 > 0 &amp;&amp; !have[t.first][t.second - 1]) q.emplace(t.first, t.second - 1); &#125; else &#123; if (t.first + 1 &lt;= n &amp;&amp; !have[t.first + 1][t.second]) q.emplace(t.first + 1, t.second); if (t.second + 1 &lt;= 3 &amp;&amp; !have[t.first][t.second + 1]) q.emplace(t.first, t.second + 1); &#125; &#125; &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, k, x, y; cin >> t; while (t--) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= 3; j++) &#123; vis[i][j][0] = vis[i][j][1] = have[i][j] = false; &#125; cin >> n >> k; while (k--) &#123; cin >> x >> y; have[x][y] = !have[x][y]; &#125; bfs(&#123;1, 1&#125;, 0); bfs(&#123;n, 3&#125;, 1); vis[1][1][0] = vis[1][1][1] = false; long long cnt = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= 3; j++) if (vis[i][j][0] &amp;&amp; vis[i][j][1]) cnt++; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; &#125; 先试试暴力啊，怎么会t呢？ G. Tokitsukaze and Gold Coins (hard) 待补充 H. Tokitsukaze and K-Sequence题意给定数组 $a$，将其划分为 $k$ 个非空可不连续的子序列，输出 $k \in [1, n]$ 时子序列的总和的最大值。定义子序列的值为只出现一次的数字个数。 思路定义 $cnt_i$ 为出现 $i$ 次的数的个数。 $k=1$ 时，显然答案为 $cnt_1$。 $k&gt;1$ 时，我们可以将 $cntp,p \in [k,n]$ 对应数都留下一个，其余全都取出作为新子序列，此时答案为上一个答案的基础上加上 $cnt_k+(cnt_k+cnt{k+1}+…+cnt_{n})$。 可以证明此时的个数最大。 因此，我们可以用类似于后缀和的方法写。 当然也有更简单的写法。 时间复杂度：$O(n)$ 对应AC代码import java.io.*; import java.math.BigInteger; import java.util.*; public class Main&#123; //快读，此处略过 //public static class Console implements Closeable &#123;&#125; public static void main(String[] args) throws Throwable&#123; Console scanner = new Console(); int T = scanner.nextInt(); while(T -- > 0)&#123; int n = scanner.nextInt(); Map&lt;Integer, Integer> cnt = new HashMap&lt;>(); int max = 0; for(int i=0;i&lt;n;i++) &#123; int b = scanner.nextInt(); int p = cnt.getOrDefault(b, 0) + 1; cnt.put(b, p); max = Math.max(max, p); &#125; int[] p = new int[max + 1], suf = new int[max + 1]; for(int e : cnt.keySet()) p[cnt.get(e)] ++; suf[max] = p[max]; for(int i=max-1;i>=1;i--) suf[i] = suf[i + 1] + p[i]; long ans = p[1]; scanner.println(ans); for(int i=2;i&lt;=max;i++)&#123; ans += suf[i] + p[i]; scanner.println(ans); &#125; for(int i=max+1;i&lt;=n;i++) scanner.println(ans); &#125; scanner.close(); &#125; &#125; 很签的题呢 I. Tokitsukaze and Musynx题意对于 $n$ 个 $Note$，有 $5$ 个判定区间，每个区间有对应分数，输出调整谱面延时后分数的最大值。 给定 $n$ 个音符，每个音符有对应判定分 $x$，定义五个判定区间 $(- \infty,a)$, $[a,b)$, $[b,c)$, $[c,d]$, $(d,+\infty)$，$x$ 落在区间内可获得对应分数 $v_1$，$v2$，$v3$，$v4$，$v5$。输出将所有的 $x$ 加上或减去任意值后判定分总和的最大值。 思路考虑到枚举 $h$ 的时间复杂度过大，我们尝试另一种暴力枚举的方法： 将所有 $x$ 减去一个较大的值，使所有的音符全都落在第一个判定区间内； 用数组存储每一个音符达到下一个判定区间的 $\triangle x$，以及对应的分数改变量； 按 $\triangle x$ 升序排序，枚举所有改变量并算出分数的最大值即可。 时间复杂度：$O(4n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define ll long long const ll N = 200010, inf = 1e18; ll x[N]; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) &#123; int n, a, b, c, d, v1, v2, v3, v4, v5; cin >> n; for (int i = 0; i &lt; n; i++) &#123; cin >> x[i]; x[i] -= 2ll * 1e9; &#125; cin >> a >> b >> c >> d >> v1 >> v2 >> v3 >> v4 >> v5; vector&lt;pair&lt;ll, int>> p; for (int i = 0; i &lt; n; i++) &#123; p.emplace_back(a - x[i], v2 - v1); p.emplace_back(b - x[i], v3 - v2); p.emplace_back(c - x[i], v4 - v3); p.emplace_back(d + 1 - x[i], v5 - v4); &#125; sort(p.begin(), p.end()); ll cur = v1 * n, ans = cur; for (auto &amp;e: p) &#123; cur += e.second; ans = max(ans, cur); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 一个音游人居然没开这题 J. Tokitsukaze and Sum of MxAb题意给定数组 $a$，定义 $MxAb(i,j)=max(|ai-a_j|,|a_i+a_j|)$，求 $\sum{i=1}^n\sum_{j=1}^nMxAb(i,j)$。 思路很显然，同号取和的绝对值，异号取差的绝对值，总和显然是和所有 $|a_i|$ 的总和有关的。 可以贪心的认为，$ans=sum{|a_i|} \times 2n$。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T = scanner.nextInt(); while(T -- > 0)&#123; int n = scanner.nextInt(); int[] a = new int[n]; long ans = 0; for(int i=0;i&lt;n;i++) &#123; a[i] = scanner.nextInt(); ans += Math.abs(a[i]); &#125; System.out.println(ans * 2 * n); &#125; &#125; &#125; 签到题呢 K. Tokitsukaze and Synthesis and Traits 待补充 L. Tokitsukaze and Three Integers题意给定序列 $a$ 和正整数 $p$，对于所有 $x=0…p-1$，输出满足条件的三元组 $[i,j,k]$ 的数量。 满足条件： $i \neq j $，$i \neq k$，$j \neq k$； $(a_i·a_j+a_k) \equiv x(mod\ p)$ 思路因为 $n$ 为 $1e3$ 级别，所以可以考虑时间复杂度为 $n^2$ 的做法。 我们可以把式子分解成 $(a_i·a_j)\ mod\ p =(x-a_k)\ mod\ p$，因此我们只需计算等式左右两边的配对情况即可。 需要注意的是，$k$ 不能和 $i$，$j$ 相等，所以最后需要排除。 时间复杂度：$O(n^2)$ 对应AC代码import java.io.*; import java.math.BigInteger; import java.util.*; public class Main&#123; //快读，此处略过 //public static class Console implements Closeable &#123;&#125; public static void main(String[] args) throws Throwable&#123; Console console = new Console(); int n = console.nextInt(), p = console.nextInt(); long[] a = new long[n + 1]; for(int i=1;i&lt;=n;i++) a[i] = console.nextInt(); long[] cnt = new long[p]; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) cnt[(int)((a[i] * a[j]) % p)] += 2; long[] ans = new long[p]; for(int x=0;x&lt;p;x++) for(int k=1;k&lt;=n;k++)&#123; long i = x - a[k]; if (i &lt; 0) i += (-i / p + 1) * p; ans[x] += cnt[(int)(i % p)]; &#125; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++)&#123; ans[(int)((a[i] * a[j] + a[i]) % p)] -= 2; ans[(int)((a[i] * a[j] + a[j]) % p)] -= 2; &#125; for(int i=0;i&lt;p;i++) console.print(ans[i] + " "); console.close(); &#125; &#125; 别看了仔细想想就切题啊喂]]></content>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 1</title>
    <url>/blog/posts/2012230069/</url>
    <content><![CDATA[Rank 449/4376. AC 7/13. A. World Final? World Cup! (I)题意$A$队与$B$队轮流点球，$A$先手，判断$10$场内是否有某队必胜，输出该场次，或者输出$-1$ 思路对于第 $i$ 场 $(i \in [0,9])$ ，剩余 $left=10-i-1$ 场未打。 分开判断$A$队和$B$队， 对于$A$队，还有 $left/2+(1-i\%2)$ 场； 对于$B$队，还有 $left/2$ 场。 计算差值即可。 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int a = 0, b = 0; char[] in = scanner.next().toCharArray(); int i = 0; for(;i&lt;10;i++) &#123; if (i % 2 == 0) a += in[i] - '0'; else b += in[i] - '0'; int left = 10 - i - 1; if (a > b + left / 2 + (1 - i % 2)) break; if (b > a + left / 2) break; &#125; System.out.println(i != 10 ? i + 1 : -1); &#125; &#125; &#125; 很签的题要做快一点 B. World Final? World Cup! (II) 待补充 C. 现在是，学术时间 (I)题意每个教授有一篇引用量为 $a_i$ 的论文，一个教授可发表多篇论文，找出一种分配方式使所有教授的 $H$ 指数最大。$H$ 指数定义为使得”该教授发表的所有论文中，有至少 $H$ 篇论文的引用量大于等于 $H$ “这一命题成立的最大的 $H$。 思路很容易发现，我们只需升序将文章分配，如果遇到有一篇论文分配不能让 $h_i$ 增大，那就让另一个教授发表。因为每个教授只有一篇论文，所以论文无处可放的可能只有一个：引用量为 $0$。 $ans=n-cnt_0$ 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int cnt = n; for(int i=0;i&lt;n;i++) &#123; int a = scanner.nextInt(); if(a == 0) cnt --; &#125; System.out.println(cnt); &#125; &#125; &#125; 能贪心就别想着去模拟 D. 现在是，学术时间 (II)题意在平面直角坐标系中，给定两个与坐标轴平行的矩形，第一个矩形由对角线上的两点 $(0,0)$ 和 $(x,y)$ 确定，第二个矩形的一个顶点为点 $P(xp,y_p)$。记两矩形的交集面积为 $S_1$， 并集面积为 $S_2$， 输出 ${\frac{S_1}{S_2}}{max}$。 思路根据糖水原理，分子小于分母时，分子和分母各加上$k$，分式结果变大。 那么，我们只需在每个方向上取交集的最大值，然后计算即可。 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; //写太乱了，不建议做参考 int x = scanner.nextInt(), y = scanner.nextInt(), xp = scanner.nextInt(), yp = scanner.nextInt(); if(xp &lt;= x &amp;&amp; yp &lt;= y)&#123; System.out.println((double) Math.max(Math.max((x - xp) * (y - yp), xp * (y - yp)), Math.max(xp * yp, (x - xp) * yp)) / (x * y)); &#125;else if(xp > x &amp;&amp; yp > y)&#123; System.out.println((double) (x * y) / (xp * yp)); &#125;else if(xp > x &amp;&amp; yp &lt;= y)&#123; System.out.println(Math.max((double) (x * yp) / (x * y + yp * (xp - x)), (double) (x * (y - yp)) / (x * y + (y - yp) * (xp - x)))); &#125;else&#123; System.out.println(Math.max((double) (y * xp) / (x * y + xp * (yp - y)), (double) (y * (x - xp)) / (x * y + (x - xp) * (yp - y)))); &#125; &#125; &#125; &#125; 猜就完事了 E. 鸡算几何题意一根夹角不为 $180°$ 和 $360°$ 的 $L$ 型铁丝，先后给出在平面中的三个点的坐标，判断是否出现了以边为轴的翻转。 思路1计算四条边和 $x$ 轴正半轴的夹角，判断较长边是否出现在较短边的顺时针方向。 时间复杂度：$O(1)?$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int xa = scanner.nextInt(), ya = scanner.nextInt(), xb = scanner.nextInt(), yb = scanner.nextInt(), xc = scanner.nextInt(), yc = scanner.nextInt(); double xd = scanner.nextDouble(), yd = scanner.nextDouble(), xe = scanner.nextDouble(), ye = scanner.nextDouble(), xf = scanner.nextDouble(), yf = scanner.nextDouble(); if(calLen(xa, ya, xb, yb) == calLen(xc, yc, xb, yb))&#123; System.out.println("NO"); continue; &#125; System.out.println(judge(xa, ya, xb, yb, xc, yc) == judge(xd, yd, xe, ye, xf, yf) ? "NO" : "YES"); &#125; &#125; //返回较长边是否在较短边的顺时针方向 private static boolean judge(double xd, double yd, double xe, double ye, double xf, double yf)&#123; double de = calLen(xe, ye, xd, yd), ef = calLen(xe, ye, xf, yf); double dde = calDegree(xe, ye, xd, yd), def = calDegree(xe, ye, xf, yf); if(de > ef)&#123; if(dde > def)&#123; if(dde - def > 180) return true; else return false; &#125;else&#123; if(def - dde > 180) return false; else return true; &#125; &#125;else &#123; if(dde > def)&#123; if(dde - def > 180) return false; else return true; &#125;else&#123; if(def - dde > 180) return true; else return false; &#125; &#125; &#125; private static double calDegree(double startX, double startY, double endX, double endY)&#123; double tan = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI; if(tan &lt; 0) tan += 360; return tan; &#125; private static double calLen(double x1, double y1, double x2, double y2)&#123; return Math.sqrt(Math.pow(Math.abs(x1 - x2), 2) + Math.pow(Math.abs(y1 - y2), 2)); &#125; &#125; 思路2通过叉乘的方式，判断较长边和较短边的位置关系。 时间复杂度：$O(1)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; double calLen(double x1, double y1, double x2, double y2)&#123; return sqrt(pow(abs(x2 - x1), 2) + pow(abs(y2 - y1), 2)); &#125; double calCross(double x1, double y1, double x2, double y2)&#123; return x1 * y2 - x2 * y1; &#125; int main() &#123; int t, xa, ya, xb, yb, xc, yc; double xd, yd, xe, ye, xf, yf; cin >> t; while(t --)&#123; cin >> xa >> ya >> xb >> yb >> xc >> yc >> xd >> yd >> xe >> ye >> xf >> yf; double ab = calLen(xa, ya, xb, yb), bc = calLen(xb, yb, xc, yc), de = calLen(xd, yd, xe, ye), ef = calLen(xe, ye, xf, yf); if(ab == bc)&#123; cout &lt;&lt; "NO\n"; continue; &#125; //叉乘判断的是一个边在另一个边的哪个方向，那我们就需要用长边叉乘短边（或者换过来 if(ab &lt; bc) swap(xa, xc), swap(ya, yc); if(de &lt; ef) swap(xd, xf), swap(yd, yf); cout &lt;&lt; (calCross(xa - xb, ya - yb, xc - xb, yc - yb) * calCross(xd - xe, yd - ye, xf - xe, yf - ye) &lt; 0 ? "YES\n" : "NO\n"); &#125; return 0; &#125; L型到底是不是直角呢？ F. 鸡玩炸蛋人题意给出一个不一定联通的无向图以及每个点的标记情况。一个符合要求的方案定义为在一个连通块内取两个可以重复的点作为起点和终点，在路上按题给要求做上标记，并不能经过已经做过标记的点。若起点和终点有一个不同即视为方案不同。输出方案数，若无合法方案，输出 $0$ 。 思路因为标记后才不能回溯，所以我们完全可以以 $DFS$ 深度遍历，并在回溯时做上标记。 也就是说，只要起点终点确定，一定能使方案符合要求。 因而，一个连通图的方案数即为 $pow(cnt，2)$ ，$cnt$ 为连通图的大小（点的数量）。 根据有标记的连通块个数分三种情况输出答案即可。 时间复杂度：$O(tnm)$，$t$为连通块数量 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define ll long long const int N = 200020; vector&lt;int> e[N]; int egg[N], n, m; bool vis[N]; pair&lt;ll, bool> dfs(int root)&#123; if(vis[root]) return &#123;0, false&#125;; vis[root] = true; ll cnt = 1; //我自己 bool have = egg[root] > 0; for(int t : e[root])&#123; auto c = dfs(t); if(c.second) have = true; cnt += c.first; &#125; return &#123;cnt, have&#125;; &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> n >> m; for(int i=0;i&lt;m;i++)&#123; int u, v; cin >> u >> v; e[u].emplace_back(v); e[v].emplace_back(u); &#125; for(int i=1;i&lt;=n;i++) cin >> egg[i]; ll tot = 0, cnt, eggCnt = 0; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]) continue; auto one = dfs(i); tot += one.first * one.first; if(one.second)&#123; eggCnt ++; cnt = one.first * one.first; &#125; &#125; if(eggCnt == 0) cout &lt;&lt; tot &lt;&lt; '\n'; else if(eggCnt == 1) cout &lt;&lt; cnt &lt;&lt; '\n'; else cout &lt;&lt; 0 &lt;&lt; endl; &#125; 多看看题，这题真的比上一题好做多了 G. 鸡格线题意给定数组 $a$ ，对于 $m$ 次询问，分成两种操作处理： 输入 $l$，$r$，$k$，对区间 $[l,r]$ 中的所有数字执行 $k$ 次赋值操作：$a_i=round(10\sqrt x)$。 输出所有数字的和 重点当操作次数 $k \geq 20$ 时，$f(x)=x$，可以根据收敛证明。 思路1维护一个 $Set$，存放剩下需要操作的数，然后暴力即可。 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); long[] a = new long[n + 1]; long sum = 0; TreeSet&lt;Integer> left = new TreeSet&lt;>(); for(int i=1;i&lt;=n;i++) &#123; sum += a[i] = scanner.nextInt(); if(f(a[i]) != a[i]) left.add(i); &#125; while(m -- > 0)&#123; int op = scanner.nextInt(); if(op == 1)&#123; int l = scanner.nextInt(), r = scanner.nextInt(), k = scanner.nextInt(); while(true)&#123; Object next = left.higher(l - 1); if(next == null) break; int nxt = Integer.parseInt(String.valueOf(next)); if(nxt > r) break; for(int i=1;i&lt;=Math.min(k, 20);i++)&#123; //最多20次操作即可让x0=f(x0) sum -= a[nxt]; a[nxt] = f(a[nxt]); sum += a[nxt]; &#125; if(a[nxt] == f(a[nxt])) left.remove(nxt); l = nxt + 1; &#125; &#125;else System.out.println(sum); &#125; &#125; private static long f(long x)&#123; return Math.round(Math.sqrt(x) * 10); &#125; &#125; 思路2如果 $l$ 已完成，那么可以用并查集的方式找到一个连通块后面的未完成点，开数组记录完成情况以及完成后连通块指向的点即可。 对应AC代码#include &lt;bits/stdc++.h> using namespace std; #define ll long long const int N = 100010; ll a[N]; int p[N], ne[N]; bool ok[N]; int find(int x) &#123; return p[x] == x ? x : p[x] = find(p[x]); &#125; void merge(int x, int y) &#123; x = find(x), y = find(y); p[y] = x; ne[x] = max(ne[x], ne[y]); &#125; ll f(ll x)&#123; return round(sqrt(x) * 10); &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; ll sum = 0; for (int i = 1; i &lt;= n; i++) &#123; cin >> a[i]; sum += a[i]; ne[i] = i + 1; p[i] = i; &#125; while (m-- > 0) &#123; int op; cin >> op; if (op == 1) &#123; int l, r, k; cin >> l >> r >> k; while (true) &#123; int nxt = ok[l] ? ne[find(l)] : l; if (nxt > r) break; for (int i = 1; i &lt;= min(k, 20); i++) &#123; //最多20次操作即可让x0=f(x0) sum -= a[nxt]; a[nxt] = f(a[nxt]); sum += a[nxt]; &#125; if (a[nxt] == f(a[nxt])) &#123; ok[nxt] = true; if (nxt &lt; n &amp;&amp; ok[nxt + 1]) merge(nxt, nxt + 1); if (nxt > 1 &amp;&amp; ok[nxt - 1]) merge(nxt, nxt - 1); &#125; l = nxt + 1; &#125; &#125; else cout &lt;&lt; sum &lt;&lt; '\n'; &#125; &#125; 思路3一眼线段树，但我不会写。 对应AC代码 待补充 这题其实难在k H. 本题主要考察了DFS题意一个拼图有 $n^2$ 块，部分块之间用凸出和缺口固定，缺口面积和凸出面积相等。一块拼图可用 上右下左 边的情况来表现状态，$0$ 平整，$1$ 缺口，$2$ 凸起。给出 $n^2-1$ 块，输出剩下的那块拼图的成本（$10-cnt_1+cnt_2$）。 思路标题骗人，配对$1$和$2$即可 时间复杂度：$O(n)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int one = 0, two = 0; for(int i=0;i&lt;n * n -1;i++)&#123; String s = scanner.next(); for(char each : s.toCharArray())&#123; if(each == '1') one ++; else if(each == '2') two ++; &#125; &#125; int need = 10; if(one &lt; two)&#123; need -= two - one; &#125;else if(one > two)&#123; need += one - two; &#125; System.out.println(need); &#125; &#125; &#125; 这题还能做得再快点！ I. 本题也主要考察了DFS 待补充 J. 本题竟也主要考察了DFS 待补充 K. 本题主要考察了dp题意构建长为 $n$，只有 $m$ 个 $1$ 的 $01$ 字符串，使连续的长度为$3$的子区间中满足 $cnt_1&gt;cnt_0$ 的子区间的数量最小，并输出数量。 思路1可以证明在 $100,100,100,…$ 序列的最后插 $1$ 的情况下数量最小。 那么，我们可以分三种情况： $n \geq 3m-2$ 时，$100$ 排不到结束，数量为 $0$。 $n==m$，一定只有 $n - 2$ 个，不能再多了。 我们寻找成对出现的 $00$ 和 $0?0$，可以得到对数为 $\frac{3}{2}(n-m) + (n-m)\%2 + 1$，用总对数 $n-2$ 扣除即可。 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); if(n >= 3 * m - 2)&#123; System.out.println(0); &#125;else if(n == m)&#123; System.out.println(n - 2); &#125;else&#123; System.out.println(n - 1 - (n - m) / 2 * 3 - (n - m) % 2); &#125; &#125; &#125; 思路2根据思路$1$的第一句话，模拟建立字符串并遍历统计个数。 时间复杂度：$O(n)$ 对应AC代码 待补充 思路3状压$dp$可解。 对应AC代码 待补充 来波逆向思维~ L. 本题主要考察了运气题意$5$ 个团体，每个团体 $4$ 人，对于猜测次数，输出$($猜对的数学期望$-3.45)/0.05$。 思路五个团体，$x=0.2 \times 1 + 0.2 \times 2 + 0.2 \times 3 + 0.4 \times 4=2.8$； 四个人，$y=0.25 \times 1+0.25 \times 2 + 0.5 \times 3=2.25$； $ans=32(5.05)$。 时间复杂度：$O(1)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; System.out.println(32); &#125; &#125; 6遍就猜对了哈哈哈 M. 本题主要考察了找规律题意将 $m$ 份仙贝分给 $n$ 位朋友。若分给某个好朋友时，还剩 $x$ 个仙贝，并给了他 $y$ 个仙贝，那么定义每个朋友的好感度为 $\frac{y}{x}$。求出总好感度的最大值。 思路动态规划，不是找规律！！！ $dp[i][j]$ 为 目前给了 $i$ 个人仙贝，总共给了 $j$ 个仙贝的最大总好感度。 枚举第 $i$ 个人分到的仙贝数 $k$，得到状态转移方程： $dp[i][j]=max(dp[i-1][j-k]+\frac{k}{m-(j-k)}),k \leq j$ 时间复杂度：小于$O(nm^2)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); double[][] dp = new double[n + 1][m + 1]; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; double max = 0; for(int k=1;k&lt;=j;k++)&#123; max = Math.max(max, dp[i - 1][j - k] + (double) k / (m - j + k)); &#125; dp[i][j] = max; &#125; &#125; System.out.println(dp[n][m]); &#125; &#125; 防诈骗]]></content>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 837 Div 2</title>
    <url>/blog/posts/2672195264/</url>
    <content><![CDATA[Practice. Solved 3 of 6. A. Hossam and Combinatorics题意定义数对 $(a_i,a_j)$ 满足 $i \neq j$。给定数组 $a$，输出满足 $|a_i-a_j|$ 最大的数对数量。 思路 既然要找出 $max(|a_i-a_j|)$，那么我们就需要先把它求出来。更具体地说，我们在读入数组 $a$ 的时候可以顺便记录下来最大值 $maxx$ 和最小值 $minn$，方便后续操作。 考虑到我们不可能再对数组进行多次遍历，我们可以在读入数组 $a$ 的时候也记录一下每个数字出现的次数 $cnt$，为节省空间我们可以用 $map$ 存储。 令 $maxx-minn=dist$，那么对于一个数对 $(a_i,a_j)$，我们只需满足 $|a_i-a_j|=dist$，去掉绝对值，我们便可以得到两个式子：$a_j=a_i-dist$，$a_j=a_i+dist$。不妨记此时的 $a_j$ 为左值和右值，那我们就只需遍历所有 $a_i$，判断一下 $cnt[a_j]$ 是否大于 $0$ 即可。对于左值和右值，我们可以分开标记以防重复计算（看到题解并没有这么做，待考证.jpg) 对于每次遍历的统计，我们只需 $ans+=cnt[a_i] \times cnt[a_j] \times 2$ 即可。 时间复杂度：最坏 $O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 100010, inf = 0x3f3f3f3f; int a[N]; bool stl[N], str[N]; int main() &#123; int T, n; scanf("%d", &amp;T); while (T--) &#123; memset(a, 0, sizeof a); memset(stl, 0, sizeof stl); memset(str, 0, sizeof str); scanf("%d", &amp;n); map&lt;int, long long> cnt; int minn = inf, maxx = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;a[i]); cnt[a[i]] ++; minn = min(minn, a[i]); maxx = max(maxx, a[i]); &#125; int dist = maxx - minn; long long ans = 0; if(dist == 0) ans = (long long) n * (n - 1); else for(int i=0;i&lt;n;i++)&#123; if(!stl[a[i]]) &#123; stl[a[i]] = true; if (a[i] > dist &amp;&amp; cnt[a[i] - dist] > 0) &#123; str[a[i] - dist] = true; ans += cnt[a[i]] * cnt[a[i] - dist] * 2; &#125; &#125; if(!str[a[i]]) &#123; str[a[i]] = true; if (cnt[a[i] + dist] > 0) &#123; stl[a[i] + dist] = true; ans += cnt[a[i]] * cnt[a[i] + dist] * 2; &#125; &#125; &#125; printf("%lld\n", ans); &#125; &#125; 思维还是很重要滴 B. Hossam and Friends题意给定 $m$ 组关系，约定除了这些关系外其他人都是好朋友，输出所有连续子序列中满足所有人都是好朋友的数量。 思路 我们先用一种双指针的思维来模拟一下：一开始，$l=0,r=0$，然后我们将 $r$ 向后移，会发现我们能向右移的范围在缩小。因为每扩大一次区间，我们就会遇到更多对陌生人。为了处理这种情况，我们可以在读入关系 $(x,y)$ 的时候顺便记录下来 $min(x,y)$ 对应的 $max(x,y) -1$，这样我们在每次遍历的时候就可以以 $O(1)$ 的时间复杂度更新右端点最大值了，当无法继续时，我们再更改 $l$，直到结束。 上述思路是完全正确的，但存在一个问题：暴力模拟 $1e10$ 的复杂度绝对是超时的。 顺着不行，我们来换个方向。依然是固定 $l$，但这次我们从 $n-1$ 往回推，就不难发现一个递推式子了： 定义 $nxt[i]$ 为以 $i$ 为左边界的满足条件的最小右边界，那么 $nxt[i]=min(e[i],nxt[i+1])$ 。这里的 $e$ 数组即为1中记录的关系 $(x,y)$。 很好理解，在向左移动头节点的时候，尾节点已经遍历过后面的所有值，因而我们可以直接用动态规划的思路来推出 $nxt$ 数组。 接下来就好办了，既然对于每个左边界 $i$，都能找到确定的右边界 $nxt[i]$，那么连续子区间数量就为 $nxt[i]-i+1$ 了。 当然，$e$ 数组和 $nxt$ 数组完全可以合并。 时间复杂度： $O(n)$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 100010, inf = 0x3f3f3f3f; int nxt[N]; int main() &#123; int T, n, m, x, y; scanf("%d", &amp;T); while (T--) &#123; //hey, this is easy. scanf("%d %d", &amp;n, &amp;m); for(int i=1;i&lt;=n;i++) nxt[i] = n; for(int i=0;i&lt;m;i++)&#123; scanf("%d %d", &amp;x, &amp;y); nxt[min(x, y)] = min(nxt[min(x, y)], max(x, y) - 1); &#125; for(int i=n-1;i>=1;i--) nxt[i] = min(nxt[i], nxt[i + 1]); long long ans = 0; for(int i=1;i&lt;=n;i++) ans += nxt[i] - i + 1; printf("%lld\n", ans); &#125; &#125; 都想到双指针了，何不换个方向想想看呢 C. Hossam and Trainees题意给定数组 $a$，输出是否有满足 $gcd(a_i,a_j)&gt;1,i \neq j$ 的 $i,j$。 思路优雅的暴力 我们只需打表，筛出所有我们需要的质数，然后分解质因数并记录每个因数出现的次数即可，只要有一个 $cnt \geq 2$，那么直接判YES即可。 当然，这么暴力是绝对超时的，我们可以考虑下面的优化思路： 线性筛法，复杂度降到 $O(n)$。 既然是分解质因数，那么我们只需分解小的那一半即可，大的无需考虑，因而我们可以把边界缩小到 $\sqrt{10^9}=31623$。 时间复杂度： $O(\frac{n \sqrt{A}}{logn})$ 对应AC代码#include &lt;bits/stdc++.h> using namespace std; const int N = 1e5 + 5; vector&lt;int> primes; bool vis[N + 1]; map&lt;int, int> cnt; void init() &#123; for (int i = 2; i &lt;= N; ++i) &#123; if (!vis[i]) &#123; primes.emplace_back(i); &#125; for (int &amp;j : primes) &#123; if (1ll * i * j > N) break; vis[i * j] = true; if (i % j == 0) break; &#125; &#125; &#125; bool fact(int x) &#123; int max = (int) sqrt(x); for (int &amp;i : primes) &#123; if(i > max) break; if (x % i == 0) &#123; while (x % i == 0) x /= i; cnt[i] ++; if(cnt[i] == 2) return true; &#125; &#125; if (x != 1) &#123; cnt[x] ++; if(cnt[x] >= 2) return true; &#125; return false; &#125; int main() &#123; init(); int T, n; scanf("%d", &amp;T); while (T--) &#123; cnt.clear(); scanf("%d", &amp;n); bool ok = false; for(int i=0;i&lt;n;i++)&#123; int x; scanf("%d", &amp;x); if(ok) continue; if(fact(x)) ok = true; &#125; printf(ok ? "YES\n" : "NO\n"); &#125; &#125; 有时候可以想想暴力+优化的思路呢]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Good Bye 2022</title>
    <url>/blog/posts/3334935914/</url>
    <content><![CDATA[Contestant. Rank 9289. Rating -54 (+446 -500). A. Koxia and Whiteboards题意给定序列 $a$ , $b$ , 执行 $m$ 次操作，对于第 $j$ 次操作，将序列 $a$ 中任意数值修改为 $b_j$ ，输出操作之后序列 $a$ 的总和的最大值。 思路1注意到题目所给 $n$ 和 $m$ 很小，因而我们可以遍历 $b_j$，在每次替换前 $sort$ 一遍 $a$ 数组，然后替换 $a_0$ 即可。 一句话，暴力+模拟。 时间复杂度：$O(mnlogn)$ 当然也可以用优先队列优化时间复杂度，不过优化后差不多，所以不放代码了。 对应AC代码import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t-- > 0)&#123; int n = scanner.nextInt(), m = scanner.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); for(int i=0;i&lt;m;i++) &#123; Arrays.sort(a, 0, n); a[0] = scanner.nextInt(); &#125; long ans = 0; for(int i=0;i&lt;n;i++) ans += a[i]; System.out.println(ans); &#125; &#125; &#125; 思路2先大胆假设：既然对于 $a$ 中的修改是任意的，那么我们只要把 $a$ 升序排序，依次用降序排序的 $b$ 中的值替换即可。 假设如此，但需要注意到一点：操作的顺序是不能更改的。 因此，在排序前，我们需要一并存下来 $bi$ 的下标。在替换时，我们需要记录访问到的 $b_i$ 所存原下标的最大值 $imax$，如果 $imax \neq m-1$，那么肯定还有一些较小的值等待替换，这些值显然是小于剩下的 $a_i$ 的。所以，我们可以贪心的认为，我们只需找到替换后的一个合适的 $a_p$，用 $b{m-1}$ 替换即可。 那么，我们来考虑如何选取这个 $a_p$： 因为替换后的 $a$ 序列是先递减后递增的，那么最小值将出现在最后一次替换的 $bj$ 和未替换的第一个 $a{i+1}$ （ $bj$ 替换 $a_i$ ）之间，即 $a_p=min(a{i+1}, b_j)$。当然，肯定要判一下 $i$ 的大小，不能越界。 时间复杂度：$O(nlogn)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(), m = scanner.nextInt(); int[] a = new int[n]; int[][] b = new int[m][2]; for (int i = 0; i &lt; n; i++) a[i] = scanner.nextInt(); for (int i = 0; i &lt; m; i++) b[i] = new int[]&#123;i, scanner.nextInt()&#125;; int lastB = b[m - 1][1]; Arrays.sort(a); Arrays.sort(b, (o1, o2) -> o2[1] - o1[1]); long ans = 0; int i = 0, j = 0, lastChange = 0, lastChangedI = 0, approached = 0; for (; i &lt; n &amp;&amp; j &lt; m; i++) &#123; if (a[i] &lt; b[j][1]) &#123; approached = Math.max(approached, b[j][0]); lastChange = b[j][1]; lastChangedI = i; ans += b[j++][1]; &#125; else ans += a[i]; &#125; for (; i &lt; n; i++) ans += a[i]; if(j == 0) ans = ans - a[0] + lastB; else if(j &lt; m &amp;&amp; approached != m - 1) &#123; ans = ans - (lastChangedI + 1 > n - 1 ? lastChange : Math.min(lastChange, a[lastChangedI + 1])) + lastB; &#125; System.out.println(ans); &#125; &#125; &#125; 有时候很简单的签到题不要想太多 B. Koxia and Permutation题意给定 $n$，$k$，求出一种 $n$ 的排列 $p$，使得对于每个长度为 $k$ 的连续子序列中，最大值和最小值的和最小。 思路既然要让最大值和最小值的和最小，那么我们就需要让最大值出现的次数尽量少，最小值出现的次数尽量多。 因而，结合区间的移动，我们可以先降序地输出 $k-1$ 个数，然后再输出 $1$，此时1出现的次数被最大化。 同理，那么我们就可以在降序输出后升序输出 $k$ 个数，然后重复上述2个步骤，循环输出至无数可输出为止。 当然，可以证明交替输出和上述思路得到的序列性质是一样的。 时间复杂度：$O(n)$ 对应AC代码#include&lt;bits/stdc++.h> using namespace std; int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; int n, k; scanf("%d %d", &amp;n, &amp;k); int l = 1, r = n, now = k - 1; for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", now > 0 ? r-- : l++); now--; if (now == 1 - k) now = k - 1; &#125; printf("\n"); &#125; &#125; 思维题还是要多做做，写太慢了。 而且如果用java写的话，需要使用快读，否则会超时。 C. Koxia and Number Theory题意给定序列 $a$ ，判断是否存在 $x$ ，满足对于任意不同的两个下标 $i$ , $j$ ，都有 $gcd(a_i+x,a_j+x)=1$。 做法 显然不能出现重复数值 考虑每个质数 $t$ , 遍历序列 $a$ , 统计所有 $a_i \% t$ 出现的次数，若全都大于2，判定NO 对于第二步的数学证明 假设 $a_u$ 和 $a_v$ 同余于质数 $p$，那么 $a_u+x$ 和 $a_v+x$ 同余于 $p$。 在1的条件下，要使 $gcd(a_u+x,a_v+x)$ 不被 $p$ 整除，则必须满足 $(x + a_u) \not\equiv 0 \pmod p$ 。 因而，我们需要存在至少一个 $a_i \% p$ 的值 $j$ ，满足 $x \equiv (p-j) \pmod p$，这样，我们就可以使用 中国剩余定理 (CRT) 解出 $x$。 任取一个 $j$ ，若它的出现次数 $cnt_j\geq2$，那么存在 $x$ 符合条件1的条件。此时，根据上面的证明，可以得出$x \not\equiv (p-j) \pmod p$ 。 由上述证明，若所有 $cnt_i\geq2$，那么无法解出 $x$ ，判定为NO。 对于上述证明的具体例子判定YES的一个例子：对于下面的输入 1 3 5 7 10 取 $p = 2$，则可得取余后的序列 $1, 1, 0$，此时 $cnt_0&lt;2$，$cnt_1\geq2$，有 $x \equiv 2-0 \pmod 2$ 取 $p = 3$，则可得取余后的序列 $2, 1, 1$，此时 $cnt_1\geq2$，$cnt_2&lt;2$，有 $x \equiv 3-2 \pmod 3$ … 对于每一个 $p$ ，都有一个同余方程组，可根据 $CRT$ 求出 $x$ 的一个通解。从而，我们可以联立后解出 $x$。 判定NO的一个例子：对于下面的输入 1 11 6 9 12 14 16 17 18 20 25 28 30 取 $p = 5$，则可得取余后的序列 $1,4,2,4,1,2,3,0,0,3,0$，此时对于任意 $j$，都有 $cnt_j\geq2$，因而我们无法找到一个式子满足$x \equiv (p-j) \pmod p$，从而无法解得 $x$ 。 中国剩余定理 (CRT)对于 $m_1, m_2, …,m_n$，满足 $gcd(m_1,m_2,..,m_n)=1$，则对于如下形式的一元线性同余方程组 $\begin{cases} x \equiv a_1 \pmod{m_1}\ x \equiv a_2 \pmod{m_2}\ \cdots\ x \equiv a_n \pmod{m_n} \end{cases}$ (1) 计算 $M=\prod\limits_{i=1}^n m_i,M_i=\dfrac{M}{m_i}$，即 $M_i$ 是除 $m_i$ 之外其他整数的乘积； (2) 设 $t_i$ 为 $M_i$ 模 $m_i$ 的逆元，即求 $t_i = (M_i)^{-1}\pmod{m_i}$； (3) 上述方程组的通解为：$x=a_1t_1M_1+a_2t_2M_2+…+a_nt_nM_n+kM，k\in Z$ 。模 $M$ 后，只有一个解 $x=a_1t_1M_1+a_2t_2M_2+…+a_nt_nM_n$。 更加直观的做法 枚举所有元素，若有重复则判NO； 枚举所有 $2 \sim n/2$ 的数 $p$，若模 $p$ 后的序列所有数字出现的次数都大于 $2$，那么判NO。 第二步的可行性肉眼可见，当 $n$ 足够大时，判断素数的步骤是超时的，但因为我们是从小到大枚举的，因而我们可以保证所有合数在被枚举到之前都已经被判断过，且加上对于合数的可行性判断后，时间复杂度在合理范围内。 对于右边界 $n/2$，我们考虑抽屉原理：将 $n+1$ 个物品放入 $n$ 个抽屉，肯定有至少一个抽屉有两个物品。 那么，对于 $n$ 个物品，放入大于 $n/2$ 个抽屉中，我们肯定无法让所有抽屉都放上 $2$ 个物品。 因而，我们只需遍历到 $n/2$ 即可。 时间复杂度：$O\left(\frac{n^2}{\log n} \right)$ 对应AC代码import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t -- > 0)&#123; int n = scanner.nextInt(); long[] a = new long[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextLong(); for(int i=1;i&lt;n;i++) for(int j=i-1;j>=0;j--) if(a[i] == a[j])&#123; System.out.println("NO"); continue nxt; &#125; for(int i=2;i&lt;=n / 2;i++)&#123; int[] m = new int[i]; boolean f = false; for(int j=0;j&lt;n;j++) m[(int)(a[j] % i)] ++; for(int j=0;j&lt;i;j++) &#123; if(m[j] &lt; 2) &#123; f = true; break; &#125; &#125; if(!f)&#123; System.out.println("NO"); continue nxt; &#125; &#125; System.out.println("YES"); &#125; &#125; &#125; 数论得多看看力，有时候可以多尝试一些数据来找寻规律。]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
</search>
