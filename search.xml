<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome to My Blog</title>
    <url>/blog/posts/2656694144/</url>
    <content><![CDATA[欢迎来到 Floating Ocean's Blog! 这是一个部署在 Github / Gitee 上的个人博客，博客目前涵盖部分算法竞赛平台的个人题解和思路，随本人刷题进度更新，欢迎大家偷窥我是否在卷。 博客基于略微修改后的 Hexo + Butterfly 框架，支持评论、一言等拓展功能。 考虑到性能问题，将博客的 repo 镜像到了 Gitee 上，并部署到了 Gitee Pages。 因为静态网页的问题，可能存在部分 Gitee 跳转至 Github 的链接。 站点更新日志 有关文章更新日志，请移步 归档 页 23.07.29 支持内嵌 iframe 弹窗，可弹出视频控件（如b站视频外链） 更新部分友链 23.07.10 ui色调微调 本文章将在主页显示 "更新于"，而非 "发表于" 23.07.09 新增 "每日一图"，目前共5张背景，每天刷新一次 ui强调色随背景图改变，遵循Material Design 3设计 更新版权信息 23.07.04 更新部分文章，并校对比赛信息 略调ui 23.06.30 部署了一下 sitemap，现在可在Bing/Google上搜索到博客的内容 23.06.29 在 /a/ 短链接的基础上，支持 /cf/{cfid} 新短链接，如 id 为 1843 的 Round 881，短链接为 /blog/a/cf_881 和 /blog/cf/1843 优化部分ui 23.06.18 加入提示条，在触发某些提示时会在右上角显示 优化部分ui 23.06.16 优化部分细节体验 23.06.14 "友链" 更新为 "传送"，并添加一些有用的相关链接 23.05.23 将 repo 镜像到了 Gitee 上 23.05.20 更新 关于 页 (p.s. 塞了个私货) 根据 codeforces 的 比赛 id 加入了 "最近 CF 场" 置顶功能，并按照 id 更改了 Codeforces 标签下文章的顺序。 (p.s. 比赛 id 不完全按照时间排序) 进行一个字数统计的功能回归（ 在不知道哪个时间改了一下网站字体~ 23.05.17 在改ui和想改ui之间挣扎着 根据 codeforces 的 规则 重新比对了加减分 23.05.06 来试试新的卡片设计! 23.05.04 调整ui 更新一大堆文章 23.04.13,17 调整部分ui的hover动画 23.04.12 优化底层，对部分文章的公式略作修改 更新并添加了一些小功能 继续修复某些文章的公式显示问题 23.04.09 支持 PWA 应用，可以进行安装 修复某些文章的公式显示问题 23.04.07 完成站点主题的迁移，新增许多 Butterfly 主题的集成功能 将旧站点迁移至 /blog_old 网址下 23.04.05 迁移站点主题至 Butterfly，同步了部分功能 23.03.08 调整部分ui 23.03.07 优化站点资源加载速度 23.03.06 将所有扣分局的文章信息框标红 修复几处链接错误 23.03.04 更新主页 更新置顶功能 添加短链功能，显示在文章标题的右下角 添加 warn 标签，在文章中以红色引用框显示 这是一个带有warn标签的提示 23.03.02 添加 todo 标签，在文章中以黄色引用框显示 这是一个带有todo标签的提示 23.02.19 添加 info 标签，在文章中以绿色引用框显示 添加文章底部版权框 点击一言进入官网 这是一个带有info标签的提示 23.02.12 添加顶部加载条，和文章阅读进度条样式一致 23.02.11 全局更改了动画差值器 23.02.10 加入每日一言 优化评论区样式 23.02.09 改用 prism 渲染代码 加入 spoiler，用于 detail 标签的支持 23.02.06 优化评论区样式 23.02.02 评论区功能完善 23.02.01 新增评论区功能 23.01.30 更新图标库 加入站内搜索 23.01.24 站点独立为新的 repo 23.01.15,18,19,21 优化样式 23.01.14 搭建初始框架 到底了捏，更新还在路上~]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Welcome</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 908 Div. 2</title>
    <url>/blog/posts/4042921353/</url>
    <content><![CDATA[Contestant. Rank 309. Rating +66. A. Secret Sport 题意 对于两个人之间的博弈，定义一局中先赢了 \(X\) 次的玩家在该局中获胜，赢了 \(Y\) 局的玩家获得最后的胜利。 其中，若能确定最后的赢家，那么将立即停止博弈。 现在，在 \(X, Y\) 未知 的条件下，给定一次游戏中，每局获胜的玩家，输出最后的赢家。 思路 既然能确定最后的赢家，那么后面就不会有新的一局了。 换句话说，最后一局决定了当前的赢家。 显然，决定的条件只有一个：最后一个玩家赢了 \(X\) 次。那么，显然最后一局的赢家就是最后的赢家了。 因而，读入字符串后，输出最后一个字符即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pdd pair&lt;double, double> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; string s; cin >> s; cout &lt;&lt; s[n - 1] &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 逆天题面，逆天网络 B. Two Out of Three 题意 给定一个长为 \(n\) 的数组 \(a\)，构造一个由 \(1, 2, 3\) 组成的长为 \(n\) 的数组 \(b\)，使得下面的 \(3\) 个条件恰好有 \(2\) 个满足： 存在 \(a_i = a_j, b_i = 1, b_j = 2\)； 存在 \(a_i = a_j, b_i = 1, b_j = 3\)； 存在 \(a_i = a_j, b_i = 2, b_j = 3\) 思路 显然，我们可以先按值分组，然后将个数为 \(1\) 的所有组都填上任意的数字。 接着，随便挑一组，\(1, 2\) 交替填入。 最后，剩下的组，\(2, 3\) 交替填入。 上面的构造一定是最优的，而显然，当个数 \(\geq 2\) 的组的数量 \(&lt;2\) 时，我们就无法满足任意两个条件了。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pdd pair&lt;double, double> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); map&lt;int, int> cnt; int t = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; cnt[a[i]] ++; if(cnt[a[i]] == 2) t ++; &#125; if(t &lt; 2) &#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; int p = 0; for(int i=1;i&lt;=n;i++)&#123; if(cnt[a[i]] == 1) cout &lt;&lt; "1 "; else if(p == 0 || a[i] == p)&#123; p = a[i]; if(cnt[a[i]] % 2 == 1) cout &lt;&lt; "1 "; else cout &lt;&lt; "2 "; &#125;else&#123; if(cnt[a[i]] % 2 == 1) cout &lt;&lt; "2 "; else cout &lt;&lt; "3 "; &#125; cnt[a[i]] ++; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 简单构造 C. Anonymous Informant 题意 对于一个未知的数组 \(a\)，定义一次操作为： 选定 \(x\)，满足 \(a_x = x\)； 将数组 \(a\) 循环左移 \(x\) 格 现在，给定一个数组 \(b\)，判断其是否由数组 \(a\) 经过 \(k\) 次操作后得到。 思路 循环左移 \(x\) 格后，\(a_x\) 会来到数组的最后一位。 那么显然，我们只要按照这个性质，反向推回去即可，如果出现循环，或者\(a_x &gt; n\)，那么即可判定答案，否则只需判断是否可以循环 \(k\) 次。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pdd pair&lt;double, double> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, m; cin >> n >> m; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; vector&lt;bool> st(n + 1); int now = n; while(m --)&#123; if(a[now] > n)&#123; cout &lt;&lt; "NO\n"; return; &#125; if(st[now])&#123; cout &lt;&lt; "YES\n"; return; &#125; st[now] = true; now = (now - a[now] + n - 1) % n + 1; &#125; cout &lt;&lt; "YES\n"; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 逆向思维（ D. Neutral Tonality 题意 给定两个数组 \(a, b\)，将 \(b\) 按任意顺序排列后，逐一任意插入 \(a\) 中。 输出一种构造，使最后的数组的 最长递增子序列 (LIS) 长度最小。 思路 显然，我们不可以升序插入，那么我们考虑 降序 插入。 可以发现，按这样插入的话，一定不会让 LIS 变大 \(2\) 或者更多。 那么我们考虑如何让 LIS 不变： 对于当前的一个 LIS，它的每一个元素都可以有多个选择，从而我们可以得到很多长度相等的 LIS。 那么，我们只需降序插入时，让这些插入的元素成为某一个元素 \(a_i\) 的多个合法选择，或者大于等于 LIS 的下一个元素 \(a_j\) 即可。 这就简单了。我们在枚举 \(a_i\) 时，如果上次降序插到了第 \(x\) 大的数，那么我们只需从第 \(x+1\) 大的数开始，降序插入所有 \(\geq a_i\) 的数即可。 显然，如果出现了多余的数字，我们降序放到末尾即可，一定不会影响 LIS 的大小。 时间复杂度：\(O(n + m + m \log m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pdd pair&lt;double, double> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, m; cin >> n >> m; vector&lt;int> a(n + 1), b(m + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=1;i&lt;=m;i++) cin >> b[i]; sort(all(b)); int ind = m; for(int i=1;i&lt;=n;i++)&#123; while(ind >= 1 &amp;&amp; b[ind] >= a[i]) cout &lt;&lt; b[ind --] &lt;&lt; ' '; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; while(ind >= 1) cout &lt;&lt; b[ind --] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 感觉思维力也没有 \(B\) 大]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 155</title>
    <url>/blog/posts/877705496/</url>
    <content><![CDATA[Contestant. Rank 761. Rating +41. A. Rigged! 题意 给定 \(n\) 个人的臂力 \(s_i\) 和耐力 \(e_i\)。若比赛的杠铃重量为 \(w\)，那么所有满足 \(s_i \geq w\) 的人都可以举起杠铃，且可以举起 \(e_i\) 次。 输出最小的 \(w\)，使第一个玩家能举起的次数严格最多。 思路 显然，我们要做的就是，让耐力大于等于第一个玩家的人都举不起杠铃。 那么，我们统计耐力大于等于第一个玩家的所有玩家的力量最大值，然后判断最大值是否小于第一个玩家的力量即可。 如果满足，那么 \(w = s_1\)，否则无解。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;pii> a(n + 1); for(int i=1;i&lt;=n;i++)&#123; cin >> a[i].fs >> a[i].sc; &#125; int mx = 0; for(int i=2;i&lt;=n;i++)&#123; if(a[i].sc >= a[1].sc)&#123; mx = max(mx, a[i].fs); &#125; &#125; if(mx >= a[1].fs) &#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; cout &lt;&lt; a[1].fs &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 有点抽象的题面（ B. Chips on the Board 题意 给定一个 \(n \times n\) 的方阵，以及两个长为 \(n\) 的序列 \(a, b\)。 现在，需要在方阵中标记若干点，使对于方阵的任意一个点 \((i, j)\)，它的同一行或同一列至少有一个点被标记。 若标记点 \((i, j)\) 的代价为 \(a_i + b_j\)，输出满足条件的最小代价和。 思路 考虑下面的问题： 选定若干行和若干列进行涂色，使最后整个方阵都涂上色的最小代价和。 那么显然，要么我们把行全都填满，要么我们把列全都填满。 在本题也是一样的，只是我们全都填满行后，还得考虑列的选择；对列也是一样的。 但是，因为我们可以任意选，从而我们一定会选最小的。 那么，最后问题的答案就是 \(\min(n \cdot a_{\min} + \sum b_i,~n \cdot b_{\min} + \sum a_i)\)。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n), b(n); int sum1 = 0, sum2 = 0; for(int i=0;i&lt;n;i++) &#123; cin >> a[i]; sum1 += a[i]; &#125; for(int i=0;i&lt;n;i++) &#123; cin >> b[i]; sum2 += b[i]; &#125; sum1 += *min_element(all(b)) * n, sum2 += *min_element(all(a)) * n; cout &lt;&lt; min(sum1, sum2) &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 有意思的思维，但题面还是有点（ C. Make it Alternating 题意 给定一个二进制字符串，定义一次操作为选定一个位置，并将其删除。 输出使字符串变为 \(0, 1\) 交替需要的最小操作数，以及对应的方案数。 思路 首先，前者很好算，我们只需进行 "去重" 即可：\(00110001 \rightarrow 0101\)。 至于后者，我们先一块一块进行考虑。对于每一块，若长度为 \(cnt\)，那么我们就需要在 \(cnt\) 中选 \(cnt - 1\) 个数进行删除，也就是 \(C_{cnt}^{cnt - 1} = C_{cnt}^1 = cnt\) 种组合方式。 其次，我们得到了方案的所有组合方式，但方案的执行是有先后顺序的，从而我们还得乘上一个全排列。 后者可以通过预处理阶乘实现。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); int fact[N]; void init()&#123; fact[0] = fact[1] = 1; for(int i=2;i&lt;=2e5;i++) fact[i] = fact[i - 1] * i % mod; &#125; void solve() &#123; string s; cin >> s; s = s + " "; int ans = 0, cnt = 1; int tmp = 1; for(int i=1;i&lt;s.size();i++)&#123; if(s[i] == s[i - 1])&#123; tmp ++; &#125;else&#123; ans = (ans + tmp - 1) % mod; cnt = cnt * tmp % mod; tmp = 1; &#125; &#125; cnt = cnt * fact[ans] % mod; cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while (t--) solve(); &#125; 注意，不是对每一块求全排列然后乘起来 D. Sum of XOR Functions 题意 给定一个长为 \(n\) 的数组 \(a\)，输出 \(\sum_{l=1}^{n} \sum _ {r=l}^{n} f(l, r) \cdot (r - l + 1)\)，其中 \(f(l, r) = a_l \oplus a_{l+1} \oplus \ldots \oplus a_{r-1} \oplus a_r\)。 思路 我们可以一位一位考虑本题，这样对异或具有交换律。 那么，问题就转化为了：给定一个二进制序列，输出所有 连续子序列的异或和与序列长度的乘积 的总和。 这是一个比较经典的问题，我们直接暴力枚举右端点，然后在枚举的过程中记录左端点的个数，满足最后整个序列的异或和为 \(1\)，从而将区间的和变为每个点的值之和。 异或和的值取决于区间中 \(1\) 个数的奇偶性，那么我们不妨记录前 \(i\) 个数中 \(0\) 的个数，以及 \(1\) 的个数，然后在出现 \(1\) 的时候，交换 \(0, 1\) 的个数即可（可以理解为进行了一次翻转，原来不合法的变为了合法）。 最后，我们累加每一位的结果即可。 时间复杂度：\(O(64n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; int ans = 0; for(int i=60;i>=0;i--)&#123; int cnt0 = 0, cnt1 = 0; int pre0 = 0, pre1 = 0; for(int j=1;j&lt;=n;j++)&#123; pre0 = (pre0 + cnt0) % mod, pre1 = (pre1 + cnt1) % mod; if(a[j] &amp; (1ll &lt;&lt; i))&#123; ans = (ans + (pre0 + 1) * (1ll &lt;&lt; i) % mod) % mod; swap(pre0, pre1), swap(cnt0, cnt1); cnt1 ++, pre1 ++; &#125;else&#123; ans = (ans + pre1 * (1ll &lt;&lt; i) % mod) % mod; cnt0 ++, pre0 ++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 有意思的数学题（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 899 Div. 2</title>
    <url>/blog/posts/1589186901/</url>
    <content><![CDATA[Contestant. Rank 728. Rating +14. A. Increasing Sequence 题意 给定一个长度为 \(n\) 的序列 \(a\)，构造一个满足下面条件的序列 \(b\)： 长度为 \(n\)； 严格递增； \(a_i \neq b_i\) 输出最小的满足条件的 \(b_n\)。 思路 显然，我们模拟一下构造即可。 我们从 \(1\) 开始向后枚举，如果当前位和 \(a_i\) 相等，那么我们就多加一个 \(1\)。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; int cur = 1; for(int i=1;i&lt;=n;i++)&#123; int a; cin >> a; if(cur == a) cur ++; cur ++; &#125; cout &lt;&lt; cur - 1 &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 签到 B. Sets and Union 题意 给定 \(n\) 个集合 \(S_i\)，定义一个方案为选定若干个集合，并取并集。 输出筛去全选的方案后，元素最多的方案对应的个数。 思路 我们可以反过来考虑，即让被 "删除" 的数尽可能多。 那么，我们肯定是尽可能只删一个数。 但是，删除一个数后，有可能会剔除好几个区间，从而连带着删除好几个数。 那么，我们就需要对每个数，处理出这个数在哪些区间中出现，然后枚举每个数作为需要删除的数字，然后把对应的区间删除后，计算还剩下多少数即可。 时间复杂度：\(O(50 n \log n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;set&lt;int>> a(51); for(int i=1;i&lt;=50;i++)&#123; for(int j=1;j&lt;=n;j++) a[i].ep(j); &#125; vector&lt;vector&lt;int>> p(n + 1); for(int i=1;i&lt;=n;i++)&#123; int m; cin >> m; p[i].resize(m + 1); for(int j=1;j&lt;=m;j++)&#123; cin >> p[i][j]; a[p[i][j]].erase(i); &#125; &#125; int ans = 0; for(int x=1;x&lt;=50;x++)&#123; if(a[x].size() == n) continue; set&lt;int> st; for(auto e : a[x])&#123; for(int j=1;j&lt;p[e].size();j++) st.ep(p[e][j]); &#125; ans = max(ans, (int) st.size()); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 有点抽象的思维题（ C. Card Game 题意 给定 \(n\) 张牌，以及从顶部往下开始编号的牌的值序列 \(a\)。 定义游戏如下： 选择一个不大于剩余牌数的奇数正整数 \(i\)，取走第 \(i\) 张卡，并将其添加到分数中； 选择一个不大于剩余牌数的偶数正整数 \(i\)，取走第 \(i\) 张卡 取走卡牌后，下标会重新索引。 输出最后分数的最大值。 思路 首先，我们设第一个拿掉的牌为 \(i\)，那么有下面的策略： 拿走奇数索引下的正数卡牌； 拿走偶数索引下的正数卡牌 可以发现，只要我们从底往上拿，就不会影响到索引。 上面的操作显然有一个条件，即当我们选择的第一张牌是奇数，我们就一定得拿，而其他的只需拿正数即可。 我们可以用一个前缀和来完成。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; vector&lt;int> suf(n + 4); for(int i=n;i>=1;i--) suf[i] = suf[i + 2] + max(0ll, a[i]); int ans = 0; for(int i=1;i&lt;=n;i++)&#123; if(i % 2 == 1)&#123; ans = max(ans, a[i] + suf[i + 1] + suf[i + 2]); &#125;else&#123; ans = max(ans, suf[1] + suf[i + 2]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 比较抽象 D. Tree XOR 题意 给定包含 \(n\) 个节点的一棵树，每个点具有权值 \(a_i\)。 假设根为 \(r\)，定义一次操作为选定一个点 \(v\) 以及一个整数 \(c\)，并将点 \(v\) 以及其所有子节点 \(i\) 都执行 \(a_i := a_i \oplus c\)，代价为 \(s \cdot c\)，\(s\) 为被操作的点的个数。 现在，对于所有点，若将其作为树根，输出使所有元素都相等的代价和。 思路 首先，两个元素相等，则其异或值为 \(0\)。 那么，如果根为 \(r\)，某个子节点为 \(p\)，那么 \(p := r \oplus p\)。 因此，我们可以通过一次 \(\mathtt{dfs}\) 得到单根的解。 接下来我们考虑换根： 如果我们将根从 \(r\) 换到某个相邻的节点 \(q\)，那么除了这两个点外，其余的点的父节点和子树都没变。 为什么没变呢？因为就算父节点的值变了，其子树之后的计算得到的代价就是不变的，毕竟 \((a \oplus c) \oplus(b \oplus c) = a \oplus b = (a \oplus c&#39;) \oplus(b \oplus c&#39;)\)。 因而，我们只需考虑 \(r\) 和 \(q\)。 可以发现，原来 \(q\) 是 \(r\) 的子节点，那么如果 \(q\) 所在子树大小为 \(X\)，当初的代价就是 \(X \cdot (a_r \oplus a_q)\)。 而现在，\(r\) 是 \(q\) 的子节点，那么如果 \(r\) 所在子树大小为 \(Y\)，现在的代价就是 \(Y \cdot (a_r \oplus a_q)\)。 从而，我们 \(\mathtt{dfs}\) 计算一下每个根的值即可。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;vector&lt;int>> e(n + 1); vector&lt;int> a(n + 1), siz(n + 1, 1), dp(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=1;i&lt;n;i++)&#123; int u, v; cin >> u >> v; e[u].pb(v), e[v].pb(u); &#125; auto dfs = [&amp;](auto dfs, int x, int p) -> void&#123; for(auto y : e[x])&#123; if(y == p) continue; dfs(dfs, y, x); siz[x] += siz[y]; dp[1] += siz[y] * (a[x] ^ a[y]); &#125; &#125;; auto change = [&amp;](auto dfs, int x, int p) -> void &#123; for (auto y : e[x]) &#123; if (y == p) continue; dp[y] = dp[x] + (a[y] ^ a[x]) * (n - 2 * siz[y]); int pre_x = siz[x], pre_y = siz[y]; siz[x] = n - siz[y], siz[y] = n; dfs(dfs, y, x); siz[x] = pre_x, siz[y] = pre_y; &#125; &#125;; dfs(dfs, 1, -1); change(change, 1, 1); for(int i=1;i&lt;=n;i++) cout &lt;&lt; dp[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 神奇的换根 \(dp\)]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 900 Div. 3</title>
    <url>/blog/posts/3021106040/</url>
    <content><![CDATA[Contestant^. Rank 154. Rating +119 (+469 -350). 不知道有没有可能在有生之年打到 cf 第1000场（ A. How Much Does Daytona Cost? 题意 给定一个序列 \(a\)，以及一个整数 \(k\)，判断 \(k\) 是否是 \(a\) 的任意子串中出现次数最多的字符。 思路 只要子串长度是 \(1\)，那么该字符就是出现次数最多的字符。 那么，问题就转化为判断 \(k\) 是否在 \(a\) 中出现了。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, k; cin >> n >> k; bool ok = false; for(int i=1;i&lt;=n;i++)&#123; int x; cin >> x; if(x == k) ok = true; &#125; cout &lt;&lt; (ok ? "YES\n" : "NO\n"); &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 签到 B. Aleksa and Stack 题意 给定一个正整数 \(n\)，构造一个长为 \(n\) 的严格递增序列，满足 \(3 \cdot a_{i + 2}\) 不被 \(a_i + a_{i + 1}\) 整除。 思路1 我们可以构造递增的 \(3\) 的倍数，并加上一定值，来让条件不成立。 具体来说，我们可以构造下面的序列： \(4, 7, 8, 13, 16, 17, \ldots\) 给出如下证明： \(a_{3k + 1} + a_{3k + 2} = (9k + 4) + (9k + 7) = 18k + 11\)，\(a_{3k + 3} = 9k + 8\)；\(3 \cdot a_{3k + 3} = 27k + 24\)； \(lcm(18, 27) = 54\)，\((18k + 11) \cdot \frac{lcm(18, 27)}{18} = 54k + 33, (27k + 24) \cdot \frac{lcm(18, 27)}{27} = 54k + 48\)； \(33 \neq 48\)，从而无法整除。 \(a_{3k + 2} + a_{3k + 3} = (9k + 7) + (9k + 8) = 18k + 15, a_{3k + 4} = 9k + 13\)；\(3 \cdot a_{3k + 4} = 27k + 36\)； \(lcm(18, 27) = 54\)，\((18k + 15) \cdot \frac{lcm(18, 27)}{18} = 54k + 45, (27k + 36) \cdot \frac{lcm(18, 27)}{27} = 54k + 72\)； \(45 \neq 72\)，从而无法整除。 \(a_{3k + 3} + a_{3k + 4} = (9k + 8) + (9k + 13) = 18k + 21, a_{3k + 5} = 9k + 16\)；\(3 \cdot a_{3k + 4} = 27k + 48\)； \(lcm(18, 27) = 54\)，\((18k + 21) \cdot \frac{lcm(18, 27)}{18} = 54k + 63, (27k + 48) \cdot \frac{lcm(18, 27)}{27} = 54k + 96\)； \(63 \neq 96\)，从而无法整除。 从而，可得构造合法。 思路2 我们可以按顺序输出所有奇数，即： \(1, 3, 5, 7, 9, \ldots\) 可以发现，\(3a_{i + 2}\) 为奇数，\(a_i + a_{i + 1}\) 是偶数，从而一定不满足整除条件。 时间复杂度：\(O(n)\) 对应AC代码1 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; for(int i=1;i&lt;=n;i++) &#123; cout &lt;&lt; i * 3 + 1 - (i % 3 == 0) &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 对应AC代码2 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; for(int i=1;i&lt;=n;i++) &#123; cout &lt;&lt; i * 2 - 1 &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 难绷，也是写出了很神奇的构造（ C. Vasilije in Cacak 题意 给定三个正整数 \(n, k, x\)，判断是否可以在 \([1, n]\) 中选择不同的 \(k\) 个数，使总和为 \(x\)。 思路 通过观察，我们可以发现，总和在 \([\) 前 \(k\) 小的数之和 \(,\) 前 \(k\) 大的数之和 \(]\) 之间，且可以取任意值。 那么，我们只要计算一下区间的左右端点，然后判断 \(x\) 是否在区间内即可。 注意特殊情况的边界判断。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, k, x; cin >> n >> k >> x; if((k + 1) * k / 2 > x || (n + n - k + 1) * k / 2 &lt; x) cout &lt;&lt; "NO\n"; else cout &lt;&lt; "YES\n"; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 差点没想到这个结论（x D. Reverse Madness 题意 给定一个字符串，并将字符串分割为 \(k\) 段，给定这 \(k\) 段的左右端点。 现在，给定 \(q\) 次修改，每次修改给定一个正整数 \(x\)，将 \([\min(x, r + l - x), \max(x, r + l - x)]\) 内的字符串翻转。 输出最后一次修改后的字符串。 思路 首先，既然我们只要知道最后一次修改后的字符串，那么我们只需知道每一个位置被修改了几次即可。 考虑到区间修改，我们可以使用差分数组，最后判断每个位置的值的奇偶性即可。 至于判断当前位于哪个区间，我们可以二分。 时间复杂度：\(O(n + q)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, k; cin >> n >> k; string s; cin >> s; s = " " + s; vector&lt;int> l(k + 1), r(k + 1); for(int i=1;i&lt;=k;i++) cin >> l[i]; for(int i=1;i&lt;=k;i++) cin >> r[i]; int q; cin >> q; vector&lt;int> d(n + 2); while(q --)&#123; int x; cin >> x; int ind = lower_bound(all(r), x) - r.begin(); int a = min(x, r[ind] + l[ind] - x), b = max(x, r[ind] + l[ind] - x); d[b + 1] ^= 1; d[a] ^= 1; &#125; for(int i=1;i&lt;=n;i++) d[i] ^= d[i - 1]; for(int i=1;i&lt;=k;i++)&#123; for(int j = l[i];j &lt;= (l[i] + r[i]) / 2;j++)&#123; if(d[j]) swap(s[j],s[r[i] - (j - l[i])]); &#125; &#125; for(int i=1;i&lt;=n;i++) cout &lt;&lt; s[i]; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 不然就用树状数组（x E. Iva &amp; Pav 题意 给定一个序列 \(a\)，定义 \(f(l, r) = a_l~\&amp;~a_{l + 1}~\&amp; \ldots \&amp;~a_r\)。 给定 \(q\) 次询问，每次询问给定两个整数 \(k, l\)，输出最大的 \(r\)，使 \(f(l, r) \geq k\)。 思路 显然，在左端点确定的情况下，右端点越大，\(f(l, r)\) 越小。 所以我们只需二分即可。 具体来说，我们预处理前缀与，然后二分处理每个询问。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;vector&lt;int>> a(n + 1, vector&lt;int>(32)); vector&lt;int> x(n + 1); for(int i=1;i&lt;=n;i++)&#123; cin >> x[i]; bitset&lt;32> bs(x[i]); for(int j=0;j&lt;=30;j++)&#123; a[i][j] = a[i - 1][j]; if(bs[j]) a[i][j] ++; &#125; &#125; auto check = [&amp;](int l, int k, int x)&#123; int cur = 0; for(int i=0;i&lt;=30;i++)&#123; if(a[x][i] - a[l - 1][i] == x - l + 1) cur |= (1ll &lt;&lt; i); &#125; return cur >= k; &#125;; int q; cin >> q; while(q --)&#123; int l, k; cin >> l >> k; if(x[l] &lt; k) &#123; cout &lt;&lt; -1 &lt;&lt; ' '; continue; &#125; int L = l, R = n, mid; while(L &lt; R)&#123; mid = (L + R + 1) >> 1; if(check(l, k, mid)) L = mid; else R = mid - 1; &#125; cout &lt;&lt; L &lt;&lt; ' '; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 位运算的常见结论（x F. Vasilije Loves Number Theory 题意 给定一个整数 \(n\)，定义询问如下： \(1~x\)，将 \(n\) 乘上 \(x\)，即 \(n := n \cdot x\)，并判断是否存在整数 \(a\)，使 \(\gcd(a, n) = 1, d(n \cdot a) = n\)，其中 \(d(x)\) 为 \(x\) 的因子个数； \(2\)，将 \(n\) 赋值为一开始的给定值 现在，给定 \(q\) 次询问，执行对应的操作。 思路 首先，因为 \(\gcd(n, a) = 1\)，所以 \(d(n \cdot a) = d(n) \times k\)。 从而，条件转化为：\(n\) 是 \(d(n)\) 的倍数。 由算术基本定理，若 \(n = p_1^{\alpha_1} \cdot p_2^{\alpha_2}\cdot \ldots \cdot p_k^{\alpha_k}\)，那么 \(d(n) = (\alpha_1 + 1)(\alpha_2 + 1)\ldots(\alpha_k + 1)\)。 直接算乘积是不可行的，那么我们考虑对质因数考虑：只要对于每个质因子，在 \(d(n)\) 的乘积中的出现次数 \(cnt_1\) 大于等于在 \(n\) 的乘积中出现的次数 \(cnt_2\)，那么就满足条件。 因而，我们维护一下质因子个数的序列即可。 时间复杂度：\(O(太复杂了)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); struct MATH &#123; private: struct PRIME &#123; int Check_Num = 0, Max_Factor = 0; vector&lt;pii> Dec; private: void Get_Fac(int Num) &#123; //寻找 Num 的最大因子 if (Num &lt;= Max_Factor || Num &lt; 2) return; if (Miller_Rabin(Num)) return void(Max_Factor = max(Max_Factor, Num)); int Fac = Num; while (Fac >= Num) Fac = Pollard_Rho(Num);//寻 找 因 子 while (!(Num % Fac)) Num /= Fac; return Get_Fac(Num), Get_Fac(Fac); &#125; void Decomposition(int Num) &#123; // 分解 Num 的质因子 if (Num &lt; 2) return; if (Miller_Rabin(Num)) &#123; pair&lt;int, int> Now = &#123;Num, 0&#125;; while (Check_Num % Num == 0) Now.second++, Check_Num /= Num; if (Now.second) Dec.pb(Now); return; &#125; int Fac = Num; while (Fac >= Num) Fac = Pollard_Rho(Num);//寻 找 因 子 while (!(Num % Fac)) Num /= Fac; return Decomposition(Num), Decomposition(Fac); &#125; public: __int128 test[16] = &#123;0, 2, 3, 5, 7, 11, 13, 17, 19, 61, 325, 9375, 28178, 450775, 9780504, 1795265022&#125;; bool Miller_Rabin(__int128 P) &#123; //检测 P 是不是质数, 严格保证答案正确 if (P &lt; 3 || P % 2 == 0) return P == 2; static int i, j; static __int128 Tem, k, Next; Tem = P - 1, k = 0; while (Tem % 2 == 0) Tem >>= 1, ++k; for (j = 1; j &lt;= 15; j++) &#123; Next = qp(test[j], Tem, P); if (Next &lt;= 1 || Next == P - 1) continue; for (i = 0; i &lt; k; ++i) &#123; Next = Next * Next % P; if (Next == P - 1 &amp;&amp; i != k - 1) &#123; Next = 1; break; &#125; if (Next == 1) return false; &#125; if (Next != 1) return false; &#125; return true; &#125; static bool RMiller_Rabin(__int128 P, int test_time = 8) &#123; //检测 P 是不是质数, 基于随机检验 if (P &lt; 3 || P % 2 == 0) return P == 2; static int i, j; static __int128 Tem, k, Rand_Num, Now; Tem = P - 1, k = 0; while (Tem % 2 == 0) Tem >>= 1, ++k; for (i = 1; i &lt;= test_time; ++i) &#123; Rand_Num = rand() % (P - 2) + 2, Now = qp(Rand_Num, Tem, P); if (Now == 1) continue; for (j = 0; j &lt; k; ++j) &#123; if (Now == P - 1) break; Now = Now * Now % P; &#125; if (j >= k) return false; &#125; return true; &#125; static int Pollard_Rho(int x) &#123; static int s, t, c, Div, Val; Val = 1, s = t = 0; static int Step, Goal; Step = 0, Goal = 1; c = (int) rand() % (x - 1) + 1; for (Goal = 1;; Goal &lt;&lt;= 1, s = t, Val = 1) &#123; // 倍增优化 for (Step = 1; Step &lt;= Goal; ++Step) &#123; t = ((__int128) t * t + c) % x, Val = (__int128) Val * abs(t - s) % x; if (!(Step % 127)) &#123; Div = __gcd(Val, x); if (Div > 1) return Div; &#125; &#125; Div = __gcd(Val, x); if (Div > 1) return Div; &#125; &#125; void Get_Max_Fac(int Num) &#123; return Max_Factor = 0, Get_Fac(Num); &#125; //获得 Num 的最大因子 测 试: Luogu P4718 void Dec_Factor(int Num) &#123; return Dec.clear(), Check_Num = Num, Decomposition(Num); &#125; //分解 Num 的本质不同质因子 测 试: Prime Land int Get_Phi(int Num) &#123; //计算 φ(Num) if (Num == 1) return 0; Dec_Factor(Num); for (auto &amp;Now: Dec) Num = Num / Now.first * (Now.first - 1); return Num; &#125; &#125;pm; public: static __int128 qp(__int128 x, __int128 y, __int128 m = mod) &#123; static __int128 ans; ans = 1, x %= m; for (; y; y >>= 1, x = x * x % m) if (y &amp; 1) ans = ans * x % m; return ans; &#125; //ax+by=gcd(a,b),返回gcd int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - (a / b) * y; return d; &#125; //x (mod Mi) = Ai int exCRT(int n, int M[], int A[]) &#123; int a = A[1], m = M[1], ta, tm, x, y, d, l, t; for (int i = 2; i &lt;= n; i++) &#123; tm = M[i], ta = A[i]; d = exgcd(m, tm, x, y); l = m * tm / d; if ((ta - a) % d != 0) return -1; t = tm / d; x *= ((ta - a) / d); x = (x % t + t) % t; a += m * x; m = l; &#125; return a; &#125; //欧拉函数，小于等于n和n互质的数的个数 int phi(int n) &#123; return pm.Get_Phi(n); &#125; bool vis[N]; int pri[N], cnt; //线性筛 void linear_prime(int n) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) pri[cnt++] = i; for (int j = 0; j &lt; cnt; ++j) &#123; if (1ll * i * pri[j] > n) break; vis[i * pri[j]] = true; if (i % pri[j] == 0)break; &#125; &#125; &#125; int inv_ex(int n, int m = mod) &#123; int x, y, ans = exgcd(n, m, x, y); if (ans == 1) return (x % m + m) % m; else return -1; &#125; int inv(int n, int m = mod) &#123; return qp(n, m - 2, m); &#125; //p为1e5以内质数，求c(n, m) % p int lucas(int n, int m, int p) &#123; if (m == 0) return 1; return (C(n % p, m % p, p) * lucas(n / p, m / p, p)) % p; &#125; int C(int m, int n, int p) &#123; int a = 1, b = 1; if (m &lt; n) return 0; while (n) &#123; a = (a * m) % p, b = (b * n) % p; m--, n--; &#125; return a * inv_ex(b, p) % p; &#125; void get_phi(int n, int phi[]) &#123; for (int i = 0; i &lt;= n; i++) phi[i] = i; for (int i = 2; i &lt;= n; i++) if (phi[i] == i) for (int j = 2; j &lt;= n; j++) phi[j] = phi[j] / i * (i - 1); &#125; //线性求逆元 void get_inv(int n, int inv[], int p = mod) &#123; inv[1] = 1; for (int i = 2; i &lt;= n; i++) inv[i] = inv[i] = (p - p / i * inv[p % i] % p) % p; &#125; //线性求阶乘，逆元，阶乘逆元 void get_fact_inv(int n, int fac[], int Inv[], int fac_inv[], int p = mod) &#123; fac[0] = fac_inv[0] = Inv[0] = fac[1] = fac_inv[1] = Inv[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; fac[i] = fac[i - 1] * i % p; Inv[i] = (p - p / i * Inv[p % i] % p) % p; fac_inv[i] = fac_inv[i - 1] * Inv[i] % p; &#125; &#125; vector&lt;pii> factorize(int x) &#123; return pm.Dec_Factor(x), pm.Dec; &#125; int max_factor(int x)&#123; return pm.Get_Max_Fac(x), pm.Max_Factor; &#125; void miller_rabin(__int128 P)&#123; pm.Miller_Rabin(P); &#125; void random_miller_rabin(__int128 P, int test_time = 8)&#123; pm.RMiller_Rabin(P, test_time); &#125; int pollard_pho(int x) &#123; pm.Pollard_Rho(x); &#125; template&lt;class T> T ex_sqrt(T x) &#123; //返回精度更高的sqrt T sqrtX = sqrt(x) - 1; while (sqrtX + 1 &lt;= x / (sqrtX + 1)) sqrtX++; return sqrtX; &#125; &#125;math; void solve() &#123; int n, q; cin >> n >> q; map&lt;int, int> cnt, cnt_n, cnt_d, last; vector&lt;pii > fac = math.factorize(n); for (auto it: fac) cnt_n[it.fs] += it.sc; last = cnt_n; while (q--) &#123; int op, x; cin >> op; if (op == 2) &#123; cnt_n = last; continue; &#125; cin >> x; fac = math.factorize(x); for (auto e: fac) cnt_n[e.fs] += e.sc; for (auto it: cnt_n) &#123; fac = math.factorize(it.sc + 1); for (auto e: fac) cnt_d[e.fs] += e.sc; &#125; bool st = true; for (auto e: cnt_d) &#123; if (cnt_n[e.fs] &lt; e.sc) st = false; &#125; cnt_d.clear(); cout &lt;&lt; (st ? "YES" : "NO") &lt;&lt; '\n'; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 有意思的数论（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 903 Div. 3</title>
    <url>/blog/posts/2247782885/</url>
    <content><![CDATA[Contestant^. Rank 132. Rating +86 (+336 -250). A. Don't Try to Count 题意 给定两个字符串 \(s, t\)，定义操作为将 \(s\) 本身拼接到 \(s\) 后面，操作非独立。 输出最小的操作次数，使 \(s\) 中包含子串 \(t\)。 思路 显然，数据范围小的离谱，那么我们直接暴力。 我们暴力拼接，然后用合适的复杂度下的字符串匹配即可。 可以发现，需要拼接的次数是很少的，此处用了最多 \(10\) 次，但应该不用这么多。 至于匹配，可以用 \(\mathtt{strstr}\) 函数，底层是用 \(\mathtt{KMP}\) 算法实现的，可以跑的飞快。 时间复杂度：\(O(不大)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, m; cin >> n >> m; string s, t; cin >> s >> t; if(strstr(s.c_str(), t.c_str()))&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; for(int i=0;i&lt;10;i++) &#123; s = s + s; if(strstr(s.c_str(), t.c_str()))&#123; cout &lt;&lt; i + 1 &lt;&lt; '\n'; return; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 当然拼个 \(25\) 次就炸了 B. Three Threadlets 题意 给定 \(3\) 根铁丝，定义一次操作为选定任意一根铁丝，并将其裁成任意整数长度的两段。 判断是否可以在最多 \(3\) 次操作内，将铁丝裁成长度相等的若干段。 思路 显然，我们可以贪心地将铁丝裁成等于当前最短的铁丝，如果最后所有铁丝的长度相等，那么操作就是可行的。 时间复杂度：\(O(1)?\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; vector&lt;int> a(3); for(int i=0;i&lt;3;i++)&#123; int x; cin >> x; a[i] = x; &#125; bool f = true; for(int i=1;i&lt;a.size();i++)&#123; if(a[i] != a[0]) f = false; &#125; if(f)&#123; cout &lt;&lt; "YES\n"; return; &#125; for(int i=1;i&lt;=3;i++)&#123; sort(all(a)); int now = a[a.size() - 1]; a.pop_back(); a.pb(a[0]), a.pb(now - a[0]); f = true; for(int j=1;j&lt;a.size();j++)&#123; if(a[j] != a[0]) f = false; &#125; if(f)&#123; cout &lt;&lt; "YES\n"; return; &#125; &#125; cout &lt;&lt; "NO\n"; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 乱猜的，但好像也挺显然的（ C. Perfect Square 题意 给定一个字符方阵，定义一次操作为选定一个字符，并将其按字母表顺序 非循环 右移一格（\(z \rightarrow z\)）。 输出最小的操作数，使给定方阵顺时针旋转 \(90°\) 后，和原方阵相等。 思路 首先，对于 \((i, j)\)，可以简单计算得到，顺时针旋转 \(90°\) 后，坐标为 \((j, n - i + 1)\)。 我们来考虑位于方阵左上半部分的点 \(A(i, j)\)：对于点 \(A\)，它关于中心竖线的对称点就是它旋转 \(90°\) 后的点 \(A&#39;\)。 显然，因为给定的是方阵，那么 \(A&#39;\) 旋转 \(90°\) 后的点就是其关于中心横线的对称点。 如上操作 \(4\) 次，我们可以发现，题目条件变成了： 对于每个点，其旋转 \(90k°\) 后的点都要和该点相等。 那么，我们只需枚举左上半矩阵，然后对于每个点，计算这对应 \(4\) 个点对应的字符需要修改多少次才能相等。 至于如何计算，因为不是循环右移，那么我们肯定是修改为最大值更好，那么我们简单计算一下即可。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;string> a(n + 1); for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; a[i] = " " + a[i]; &#125; int ans = 0; for(int i=1;i&lt;=n/2;i++)&#123; for(int j=1;j&lt;=n/2;j++)&#123; int x = i, y = j; int mx = a[x][y] - 'a', sum = mx; for(int k=1;k&lt;=3;k++)&#123; int t = x; x = y; y = n - t + 1; mx = max(mx, (int)(a[x][y] - 'a')); sum += (a[x][y] - 'a'); &#125; ans += mx * 4 - sum; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 好难解释，太抽象了（x D. Divide and Equalize 题意 给定一个长为 \(n\) 的序列 \(a\)，定义一次操作为选定两个数 \(a, b\)，若 \(d\) 为 \(a\) 的因数，那么 \(a := \frac{a}{d}, b := b \cdot d\)。 判断任意次操作后，序列所有数是否相等。 思路 首先，根据简单的观察，我们可以发现，操作不影响所有数的乘积。 那么我们只要把总乘积分为 \(n\) 个相等的数的乘积即可。 暴力分是不可行的，但是根据算术基本定理，每个数都可以分解为若干个质因数幂的乘积。 那么，上面的观察等价于：对于每一个质因子，将其均分到 \(n\) 个数中。 因此，我们只需对每个数分解质因数，然后统计所有数中，每个质因子的个数，然后判断其是否是 \(n\) 的倍数即可。 至于分解因数，这里我使用了更快的 \(\mathtt{Miller~Rabin}\)；线性筛之后分解也是可以的。 时间复杂度：\(O(n + p)\) 或更小 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); struct MATH &#123; private: struct PRIME &#123; int Check_Num = 0, Max_Factor = 0; vector&lt;pii> Dec; private: void Get_Fac(int Num) &#123; //寻找 Num 的最大因子 if (Num &lt;= Max_Factor || Num &lt; 2) return; if (Miller_Rabin(Num)) return void(Max_Factor = max(Max_Factor, Num)); int Fac = Num; while (Fac >= Num) Fac = Pollard_Rho(Num);//寻 找 因 子 while (!(Num % Fac)) Num /= Fac; return Get_Fac(Num), Get_Fac(Fac); &#125; void Decomposition(int Num) &#123; // 分解 Num 的质因子 if (Num &lt; 2) return; if (Miller_Rabin(Num)) &#123; pair&lt;int, int> Now = &#123;Num, 0&#125;; while (Check_Num % Num == 0) Now.second++, Check_Num /= Num; if (Now.second) Dec.pb(Now); return; &#125; int Fac = Num; while (Fac >= Num) Fac = Pollard_Rho(Num);//寻 找 因 子 while (!(Num % Fac)) Num /= Fac; return Decomposition(Num), Decomposition(Fac); &#125; public: __int128 test[16] = &#123;0, 2, 3, 5, 7, 11, 13, 17, 19, 61, 325, 9375, 28178, 450775, 9780504, 1795265022&#125;; bool Miller_Rabin(__int128 P) &#123; //检测 P 是不是质数, 严格保证答案正确 if (P &lt; 3 || P % 2 == 0) return P == 2; static int i, j; static __int128 Tem, k, Next; Tem = P - 1, k = 0; while (Tem % 2 == 0) Tem >>= 1, ++k; for (j = 1; j &lt;= 15; j++) &#123; Next = qp(test[j], Tem, P); if (Next &lt;= 1 || Next == P - 1) continue; for (i = 0; i &lt; k; ++i) &#123; Next = Next * Next % P; if (Next == P - 1 &amp;&amp; i != k - 1) &#123; Next = 1; break; &#125; if (Next == 1) return false; &#125; if (Next != 1) return false; &#125; return true; &#125; static bool RMiller_Rabin(__int128 P, int test_time = 8) &#123; //检测 P 是不是质数, 基于随机检验 if (P &lt; 3 || P % 2 == 0) return P == 2; static int i, j; static __int128 Tem, k, Rand_Num, Now; Tem = P - 1, k = 0; while (Tem % 2 == 0) Tem >>= 1, ++k; for (i = 1; i &lt;= test_time; ++i) &#123; Rand_Num = rand() % (P - 2) + 2, Now = qp(Rand_Num, Tem, P); if (Now == 1) continue; for (j = 0; j &lt; k; ++j) &#123; if (Now == P - 1) break; Now = Now * Now % P; &#125; if (j >= k) return false; &#125; return true; &#125; static int Pollard_Rho(int x) &#123; static int s, t, c, Div, Val; Val = 1, s = t = 0; static int Step, Goal; Step = 0, Goal = 1; c = (int) rand() % (x - 1) + 1; for (Goal = 1;; Goal &lt;&lt;= 1, s = t, Val = 1) &#123; // 倍增优化 for (Step = 1; Step &lt;= Goal; ++Step) &#123; t = ((__int128) t * t + c) % x, Val = (__int128) Val * abs(t - s) % x; if (!(Step % 127)) &#123; Div = __gcd(Val, x); if (Div > 1) return Div; &#125; &#125; Div = __gcd(Val, x); if (Div > 1) return Div; &#125; &#125; void Get_Max_Fac(int Num) &#123; return Max_Factor = 0, Get_Fac(Num); &#125; //获得 Num 的最大因子 测 试: Luogu P4718 void Dec_Factor(int Num) &#123; return Dec.clear(), Check_Num = Num, Decomposition(Num); &#125; //分解 Num 的本质不同质因子 测 试: Prime Land int Get_Phi(int Num) &#123; //计算 φ(Num) if (Num == 1) return 0; Dec_Factor(Num); for (auto &amp;Now: Dec) Num = Num / Now.first * (Now.first - 1); return Num; &#125; &#125;pm; public: static __int128 qp(__int128 x, __int128 y, __int128 m = mod) &#123; static __int128 ans; ans = 1, x %= m; for (; y; y >>= 1, x = x * x % m) if (y &amp; 1) ans = ans * x % m; return ans; &#125; //ax+by=gcd(a,b),返回gcd int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - (a / b) * y; return d; &#125; //x (mod Mi) = Ai int exCRT(int n, int M[], int A[]) &#123; int a = A[1], m = M[1], ta, tm, x, y, d, l, t; for (int i = 2; i &lt;= n; i++) &#123; tm = M[i], ta = A[i]; d = exgcd(m, tm, x, y); l = m * tm / d; if ((ta - a) % d != 0) return -1; t = tm / d; x *= ((ta - a) / d); x = (x % t + t) % t; a += m * x; m = l; &#125; return a; &#125; //欧拉函数，小于等于n和n互质的数的个数 int phi(int n) &#123; return pm.Get_Phi(n); &#125; bool vis[N]; int pri[N], cnt; //线性筛 void linear_prime(int n) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) pri[cnt++] = i; for (int j = 0; j &lt; cnt; ++j) &#123; if (1ll * i * pri[j] > n) break; vis[i * pri[j]] = true; if (i % pri[j] == 0)break; &#125; &#125; &#125; int inv_ex(int n, int m = mod) &#123; int x, y, ans = exgcd(n, m, x, y); if (ans == 1) return (x % m + m) % m; else return -1; &#125; int inv(int n, int m = mod) &#123; return qp(n, m - 2, m); &#125; //p为1e5以内质数，求c(n, m) % p int lucas(int n, int m, int p) &#123; if (m == 0) return 1; return (C(n % p, m % p, p) * lucas(n / p, m / p, p)) % p; &#125; int C(int m, int n, int p) &#123; int a = 1, b = 1; if (m &lt; n) return 0; while (n) &#123; a = (a * m) % p, b = (b * n) % p; m--, n--; &#125; return a * inv_ex(b, p) % p; &#125; void get_phi(int n, int phi[]) &#123; for (int i = 0; i &lt;= n; i++) phi[i] = i; for (int i = 2; i &lt;= n; i++) if (phi[i] == i) for (int j = 2; j &lt;= n; j++) phi[j] = phi[j] / i * (i - 1); &#125; //线性求逆元 void get_inv(int n, int inv[], int p = mod) &#123; inv[1] = 1; for (int i = 2; i &lt;= n; i++) inv[i] = inv[i] = (p - p / i * inv[p % i] % p) % p; &#125; //线性求阶乘，逆元，阶乘逆元 void get_fact_inv(int n, int fac[], int Inv[], int fac_inv[], int p = mod) &#123; fac[0] = fac_inv[0] = Inv[0] = fac[1] = fac_inv[1] = Inv[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; fac[i] = fac[i - 1] * i % p; Inv[i] = (p - p / i * Inv[p % i] % p) % p; fac_inv[i] = fac_inv[i - 1] * Inv[i] % p; &#125; &#125; vector&lt;pii> factorize(int x) &#123; return pm.Dec_Factor(x), pm.Dec; &#125; int max_factor(int x)&#123; return pm.Get_Max_Fac(x), pm.Max_Factor; &#125; bool miller_rabin(__int128 P)&#123; return pm.Miller_Rabin(P); &#125; void random_miller_rabin(__int128 P, int test_time = 8)&#123; pm.RMiller_Rabin(P, test_time); &#125; int pollard_pho(int x) &#123; return pm.Pollard_Rho(x); &#125; template&lt;class T> T ex_sqrt(T x) &#123; //返回精度更高的sqrt T sqrtX = sqrt(x) - 1; while (sqrtX + 1 &lt;= x / (sqrtX + 1)) sqrtX++; return sqrtX; &#125; &#125;math; void solve() &#123; int n; cin >> n; map&lt;int, int> cnt; for(int i=1;i&lt;=n;i++)&#123; int a; cin >> a; vector&lt;pii> fact = math.factorize(a); for(auto [x, y] : fact) cnt[x] += y; &#125; bool f = true; for(auto [x, y] : cnt)&#123; if(y % n != 0) f = false; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 板子也是长的离谱 E. Block Sequence 题意 给定一个序列 \(a\)，定义一次操作为从序列中选择任意一个数，并将其删除。 输出最小的操作数，使序列可以拆分为若干段 "cnt cnt个数"。 思路 首先，对于每个数，它有删除和不删除的两个状态，这类似于子序列，从而我们考虑用动态规划解决此题。 因为从前往后不好推导状态，我们不知道前面删除了多少数，从而我们考虑从后往前递推。 我们不妨令 \(dp[i][j]\) 为 \(a_{i, n}\) 中第 \(i\) 位选或者不选对应的最小删除个数。 对于第 \(i\) 位，如果该位不选，那么类似于非连续子序列，我们从上一位递推，\(dp[i][0] = \min(dp[i + 1][0], dp[i + 1][1]) + 1\)； 如果该位要选，那么我们就需要从 \(i + a[i] + 1\) 递推，从而有 \(dp[i][1] = \min(dp[i + a[i] + 1][1], dp[i + a[i] + 1][1]\)。 至于上述递推为何成立，因为我们在递推 \(dp[i][0]\) 的时候，我们类似于把这个数从序列中剔除了，此时不影响后面 "\(+a[i] + 1\)" 的操作是否准确。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; vector&lt;vector&lt;int>> dp(n + 2, vector&lt;int>(2, inf)); dp[n][0] = 1; dp[n + 1][0] = 0; for(int i=n-1;i>=1;i--)&#123; dp[i][0] = min(dp[i + 1][0], dp[i + 1][1]) + 1; if(i + a[i] > n) continue; dp[i][1] = min(dp[i + a[i] + 1][0], dp[i + a[i] + 1][1]); &#125; cout &lt;&lt; min(dp[1][0], dp[1][1]) &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 也是赛时对着非连续子序列的递推方式一顿爆改过去了（ F. Minimum Maximum Distance 题意 给定一棵树，以及一个序列 \(a\)，\(a_i\) 代表第 \(i\) 个被标记的点。 现在，遍历树上的所有点，对于每一个点 \(i\)，记 \(f_i\) 为该点到所有被标记的点的最短路的长度的最大值。 输出 \(f_i\) 的最小值。 思路 首先，可以证明的是，我们只需考虑距离最远的两个被标记的点，类似于 "树的直径"。 类比树的直径，我们可以跑 \(3\) 次 \(\mathtt{bfs}\) 求出这两个点，以及每个点到所有点的距离。 我们记距离为 \(dist_1, dist_2\)，那么对于每个点，它到所有被标记的点的最大距离就是 \(\max(dist_1[i], dist_2[i])\)，最后我们取最小值即可。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, k; cin >> n >> k; vector&lt;bool> st(n + 1); for(int i=1;i&lt;=k;i++)&#123; int cur; cin >> cur; st[cur] = true; &#125; vector&lt;vector&lt;int>> e(n + 1); for(int i=1;i&lt;n;i++)&#123; int u, v; cin >> u >> v; e[u].pb(v), e[v].pb(u); &#125; vector&lt;int> dist(n + 1); auto bfs = [&amp;](int s) &#123; dist.assign(n + 1, -1); queue&lt;int> q; q.ep(s); dist[s] = 0; while(!q.empty())&#123; int x = q.front(); q.pop(); for(auto y : e[x])&#123; if(dist[y] == -1)&#123; dist[y] = dist[x] + 1; q.ep(y); &#125; &#125; &#125; int p = -1; for(int i=1;i&lt;=n;i++)&#123; if(st[i] &amp;&amp; (p == -1 || dist[i] > dist[p])) p = i; &#125; return p; &#125;; int a = bfs(1), s = bfs(a); auto re = dist; bfs(s); int ans = inf; for(int i=1;i&lt;=n;i++) ans = min(ans, max(dist[i], re[i])); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 也是在赛时没想到这个结论的（x G. Anya and the Mysterious String 题意 给定一个字符串 \(s\)，定义询问如下： \(1~l~r~x\)，将 \(s_{l ,r}\) 内的所有字符按字母表顺序循环右移 \(x\) 位； \(2~l~r\)，判断 \(s_{l,r}\) 中是否包含回文串 现在，给定 \(q\) 个询问，执行对应的操作。 思路 首先，我们考虑下面的贪心： 既然我们只需判断是否包含回文串，那么我们只需考虑区间内是否包含长度为 \(2, 3\) 的回文串即可。 为何呢？因为如果有比它更长的，它也会包含长度为 \(2\) 或 \(3\) 的回文串。 那么，问题简化为判断长度为 \(2\) 或 \(3\) 的回文串是否在区间内即可。 对于区间修改，因为我们是整体右移的，可以发现，操作对区间内是否包含回文串不造成任何影响，而只会对端点处的造成影响。 那么，我们考虑下面的分类讨论： 对于长度为 \(2\) 的回文串，我们只需考虑修改后，\(s[l - 1]\) 和 \(s[l]\) 是否相等，以及 \(s[r]\) 和 \(s[r + 1]\) 是否相等即可； 对于长度为 \(3\) 的回文串，我们只需考虑以某个点为回文中心，它的相邻两侧字符是否相等即可。 此处需要考虑 \(4\) 个情况，即回文中心分别为 \(l-1, l, r, r + 1\) 的时候的判断。 当然，因为我们还对区间进行了修改，并且区间内修改的值是相等的，从而我们可以考虑差分数组，然后进行前缀和即可。 如上，我们可以使用 \(3\) 个树状数组完成本题，分别维护差分数组，区间内长度为 \(2, 3\) 的回文串的个数。 注意边界的判断。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); template&lt;class Info = int> struct BinaryIndexTree &#123; int n; vector&lt;Info> info; BinaryIndexTree() : n(0) &#123;&#125; explicit BinaryIndexTree(int _n, Info _v = Info()) : info(_n + 1, _v), n(_n) &#123;&#125; inline static int lowbit(int x) &#123; return x &amp; (-x); &#125; void pointUpdate(int pos, Info _info) &#123; for (int i = pos; i &lt;= n; i += lowbit(i)) info[i] = info[i] + _info; &#125; Info rangeQuery(int r) &#123; Info ans&#123;&#125;; for (int i = r; i > 0; i -= lowbit(i)) ans = ans + info[i]; return ans; &#125; Info rangeQuery(int l, int r) &#123; return rangeQuery(r) - rangeQuery(l - 1); &#125; &#125;; struct Info&#123; int val = 0; &#125;; Info operator+(const Info &amp;a, const Info &amp;b) &#123; Info c; c.val = ((a.val + b.val) % 26 + 26) % 26; return c; &#125; Info operator-(const Info &amp;a, const Info &amp;b) &#123; return a + Info&#123;-b.val&#125;; &#125; void solve() &#123; int n, m; cin >> n >> m; string s; cin >> s; s = " " + s; BinaryIndexTree&lt;> two(n), three(n); BinaryIndexTree&lt;Info> d(n + 1); //d 差分 for(int i=1;i&lt;=n;i++)&#123; d.pointUpdate(i, &#123;s[i] - 'a'&#125;); d.pointUpdate(i + 1, &#123;-(s[i] - 'a')&#125;); if(i &lt; n &amp;&amp; s[i] == s[i + 1]) two.pointUpdate(i, 1); if(i &lt; n - 1 &amp;&amp; s[i] == s[i + 2]) three.pointUpdate(i, 1); &#125; while(m --)&#123; int op; cin >> op; if(op == 1) &#123; int l, r, x; cin >> l >> r >> x; if(r - l + 1 >= 1) &#123; if(l > 1 &amp;&amp; d.rangeQuery(l - 1).val == d.rangeQuery(l).val) two.pointUpdate(l - 1, -1); if(r &lt; n &amp;&amp; d.rangeQuery(r).val == d.rangeQuery(r + 1).val) two.pointUpdate(r, -1); if(l > 2 &amp;&amp; d.rangeQuery(l - 2).val == d.rangeQuery(l).val) three.pointUpdate(l - 2, -1); if(r &lt; n - 1 &amp;&amp; d.rangeQuery(r).val == d.rangeQuery(r + 2).val) three.pointUpdate(r, -1); &#125; if(r - l + 1 >= 2) &#123; if(l > 1 &amp;&amp; d.rangeQuery(l - 1).val == d.rangeQuery(l + 1).val) three.pointUpdate(l - 1, -1); if(r &lt; n &amp;&amp; d.rangeQuery(r - 1).val == d.rangeQuery(r + 1).val) three.pointUpdate(r - 1, -1); &#125; d.pointUpdate(l, &#123;x&#125;); d.pointUpdate(r + 1, &#123;-x&#125;); //维护端点 if(r - l + 1 >= 1) &#123; if(l > 1 &amp;&amp; d.rangeQuery(l - 1).val == d.rangeQuery(l).val) two.pointUpdate(l - 1, 1); if(r &lt; n &amp;&amp; d.rangeQuery(r).val == d.rangeQuery(r + 1).val) two.pointUpdate(r, 1); if(l > 2 &amp;&amp; d.rangeQuery(l - 2).val == d.rangeQuery(l).val) three.pointUpdate(l - 2, 1); if(r &lt; n - 1 &amp;&amp; d.rangeQuery(r).val == d.rangeQuery(r + 2).val) three.pointUpdate(r, 1); &#125; if(r - l + 1 >= 2) &#123; if(l > 1 &amp;&amp; d.rangeQuery(l - 1).val == d.rangeQuery(l + 1).val) three.pointUpdate(l - 1, 1); if(r &lt; n &amp;&amp; d.rangeQuery(r - 1).val == d.rangeQuery(r + 1).val) three.pointUpdate(r - 1, 1); &#125; &#125;else&#123; int l, r; cin >> l >> r; if(two.rangeQuery(l, r - 1) > 0 || three.rangeQuery(l, r - 2) > 0)&#123; cout &lt;&lt; "NO\n"; &#125;else&#123; cout &lt;&lt; "YES\n"; &#125; &#125; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 其实应该有点裸的数据结构题（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 901 Div. 2</title>
    <url>/blog/posts/1700941914/</url>
    <content><![CDATA[Contestant. Rank 728. Rating +14. 罚时爆炸 A. Jellyfish and Undertale 题意 对于一个即将引爆的炸弹，给定 \(i\) 个工具，每个工具最多使用一次，使用时将会使炸弹的计时器 \(+x_i\) 个单位时间，但如果计时器的时间大于 \(a\)，它将会复位为 \(a\)。 找出一个方案，使计时器在归 \(0\) 前，时间尽可能长，并输出这个时间。 思路 显然，为了让时间尽可能长，我们一定会在计时器为 \(1\) 时使用工具，那么工具的使用顺序是无所谓的。 那么，我们只需将每个工具的 \(x_i\) 和 \(a - 1\) 取最小值，然后累加即可。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int a, b, n; cin >> a >> b >> n; vector&lt;int> p(n + 1); int ans = b; for(int i=1;i&lt;=n;i++) &#123; cin >> p[i]; ans += min(a - 1, p[i]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 不可以乱贪心 B. Jellyfish and Game 题意 给定两个人之间的博弈： 总共进行 \(k\) 轮； 如果当前是奇数轮，那么 \(A\) 可以选择将自己的一个元素和 \(B\) 的任意一个元素交换，或者不操作； 如果当前是偶数轮，那么 \(B\) 可以选择将自己的一个元素和 \(A\) 的任意一个元素交换，或者不操作； 每个玩家都尽可能最大化自己的元素总和 输出最后，\(A\) 的所有元素总和。 思路 首先，可以想象为两个人在 "拉扯"： \(A\) 把自己最小的元素和 \(B\) 最大的元素交换； \(B\) 把自己最小的元素和 \(A\) 最大的元素交换； \(\ldots\) 可以发现，\(A\) 的元素总和是以 \(2\) 为周期的，那么我们分讨一下即可。 当然，如果 \(A\) 最小的元素大于等于 \(B\) 的最大元素，那么 \(A\) 考虑不操作。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, m, t; cin >> n >> m >> t; vector&lt;int> a(n + 1), b(m + 1); int sum1 = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; sum1 += a[i]; &#125; for(int j=1;j&lt;=m;j++) cin >> b[j]; sort(all(a)), sort(all(b)); if(a[1] &lt; b[m])&#123; sum1 = sum1 - a[1] + b[m]; &#125; if(t % 2 == 0)&#123; sum1 = sum1 - max(a[n], b[m]) + min(a[1], b[1]); &#125; cout &lt;&lt; sum1 &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 打个表（x C. Jellyfish and Green Apple 题意 给定 \(n\) 个水果块，每块重量 \(1~\text{kg}\)，需要将这些水果平均分给 \(m\) 个人。 定义一次操作为选定一个水果块，并将其分成等重量的两块。 输出最小的操作数，使最后每个人收到水果块总重量相同。 思路 首先，我们可以给每个人分 \(\lfloor \frac{n}{m} \rfloor\) 个，从而剩下 \(n \bmod m\) 块。 我们记其为 \(p\)，那么我们现在就需要将 \(p\) 拆成 \(m\) 份。 显然，因为我们是对半切的，那么保留某些不切是不合理的，这样只会让能分的份数更小（我们需要凑起来）。 那么，我们只需枚举切成了多小即可。 具体来说，我们枚举对每一小块切了几次，如果现在的块数是 \(m\) 的倍数，那么这个方案就是合法的，我们模拟算一下切了几次即可。 时间复杂度：\(O(32 ^ 2)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, m; cin >> n >> m; n %= m; if(n == 0) &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; for(int k=1;k&lt;=32;k++)&#123; if(n * (1ll &lt;&lt; k) % m == 0)&#123; int ans = 0; for(int i=1;i&lt;=k;i++)&#123; ans += n; n = n * 2 % m; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 有种暴力的美 D. Jellyfish and Mex 题意 给定一个序列 \(a\)，定义操作如下： 从序列中选定一个数并删除； \(m := m + MEX(a)\) 初始状态下，\(m\) 为 \(0\)。 在 \(n\) 次操作后，输出 \(m\) 的最大值。 思路 首先，如果我们确定要删哪个有效的数的时候，我们完全可以直接将其删完，因为删完之后，\(MEX\) 肯定会减小。 其次，删除的顺序并不是有规律的，我们只能从当前的 \(MEX\) 开始往前删除，无法确定具体删哪个。 因而，我们考虑动态规划。 具体来说，我们可以倒推，记 \(i\) 为这次要删掉的数，那么我们枚举 \(j \in [i + 1, MEX]\)，将 \(j\) 视为上一次删掉的数。 那么显然有递推式：\(dp[i] = \min(dp[i], dp[j] + (cnt[i] - 1) \times j + i)\)。 其中，\(cnt[i]\) 为数字 \(i\) 的个数。 为何呢？因为我们删掉 \(cnt[i] - 1\) 个数之前，\(MEX\) 都是上一个被删掉的数，而将最后一个删完后，\(MEX\) 变成了当前的数。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; sort(all(a)); map&lt;int, int> cnt; int mex = -1; for(int i=1;i&lt;=n;i++) &#123; cnt[a[i]] ++; if(a[i] == mex + 1) mex ++; &#125; mex ++; if(mex == 0)&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; vector&lt;int> dp(mex + 1, inf); dp[mex] = 0; for(int i=mex;i>=0;i--)&#123; for(int j=i+1;j&lt;=mex;j++)&#123; dp[i] = min(dp[i], (cnt[i] - 1) * j + i + dp[j]); &#125; &#125; cout &lt;&lt; dp[0] &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 也是推了好久没推清楚（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 902 Div. 2</title>
    <url>/blog/posts/1418349255/</url>
    <content><![CDATA[Practice. A. Goals of Victory 题意 对于 \(n\) 只队伍，存在 \(\frac{n(n - 1)}{2}\) 个任意两只队伍间的比赛。每支队伍具有一个效率值，为队伍的所有比赛中自己的进球数减去其他队伍进球数的总和。 现在，给定 \(n - 1\) 个队伍的效率，求第 \(n\) 个队伍的效率。 思路 对于一场比赛，如果 \(A\) 赢，那么 \(A\) 的效率 \(+ 1\)，\(B\) 的效率 \(-1\)。 因而，所有队伍的效率和为定值 \(0\)。 那么，第 \(n\) 个队伍的效率为前 \(n - 1\) 个队伍的效率和的相反数。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; int ans = 0; for(int i=1;i&lt;n;i++)&#123; int x; cin >> x; ans += -x; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 乱猜都猜得出来（x B. Helmets in Night Light 题意 \(A\) 在分享一则公告，他每直接分享给一个居民，就会消耗 \(p\) 代价。 但是，对于所有居民 \(i\)，每个居民都具有一个可以分享给其他居民的数量上限 \(a_i\)，以及分享给一个居民的代价 \(b_i\)。 现在，需要将公告传给所有人，输出最小代价和。 思路 首先，如果 \(A\) 只会分享给一个人，那么我们只需从代价最小的开始分享，遍历一遍即可。 但是，\(A\) 会分享给不同的人，此时我们可以用 \(p\) 来进行替换，将所有要进行分享的人中，所有超过 \(b_i\) 的代价全都替换为 \(p\) 即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, p; cin >> n >> p; vector&lt;pii> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i].sc; for(int i=1;i&lt;=n;i++) cin >> a[i].fs; sort(all(a)); int cnt = 1, ans = p; for(int i=1;i&lt;=n;i++)&#123; ans += min(p, a[i].fs) * min(n - cnt, a[i].sc); cnt += min(n - cnt, a[i].sc); if(cnt == n) break; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 签到 C. Joyboard 题意 给定三个整数 \(n, m, k\)，对于长为 \(n + 1\) 的序列 \(a\)，定义一种方案为从 \([0, m]\) 中选一个数，填入 \(a_{n + 1}\)，然后对于 \(i \in [1, n]\)，从后往前递推，有 \(a_i = a_{i + 1} \bmod i\)。 输出满足序列 \(a\) 中恰好有 \(k\) 个不同的数的方案总数。 思路 我们直接打表，可以发现，如果选 \(0\)，那么恰好只有 \(1\) 种不同的数字。 如果选 \([1, n - 1], kn\)，那么恰好有 \(2\) 种不同的数字。 否则，恰好有 \(3\) 种不同的数字。 那么，列一下式子即可。 时间复杂度：\(O(1)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, m, k; cin >> n >> m >> k; if(k > 3)&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; if(k == 1)&#123; cout &lt;&lt; 1 &lt;&lt; '\n'; &#125;else if(k == 2)&#123; cout &lt;&lt; (m > n ? n + m / n - 1 : m) &lt;&lt; '\n'; &#125;else&#123; cout &lt;&lt; max(0ll, m - (m > n ? n + m / n - 1 : m)) &lt;&lt; '\n'; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 《Div.2 C》 D. Effects of Anti Pimples 题意 给定一个序列 \(a\)，一开始所有元素都是白色。 定义一种方案为挑选一部分元素，将其染为黑色，然后对于每个黑色元素，将其下标的倍数对应的白色元素染成绿色。 定义方案的值为所有染成黑色或绿色的元素的值的最大值。 现在，对于所有方案，输出值的总和。 思路 首先，如果选第 \(i\) 位，那么最大值至少是 \(ki\) 中最大的数。 那么，我们对于每一位，先去把选上该位后可能的最大值预处理出来。 我们记 \(b_i\) 为选上第 \(i\) 位后，对应的最大值，本题就转化为了从 \(b\) 中选取一些数，所有方案的最大值总和。 那么，我们将 \(b\) 从小到大排序，答案就是 \(b_1 + 2 ^ 1 \times b_2 + \ldots + 2 ^ n \times b_n\)。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=1;i&lt;=n;i++)&#123; int mx = 0; for(int j=i;j&lt;=n;j+=i) mx = max(mx, a[j]); a[i] = mx; &#125; sort(all(a)); int ans = 0; for(int i=n;i>=1;i--)&#123; ans = (ans * 2 % mod + a[i]) % mod; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 难得 \(D\) 只有以往的 \(C\) 难度（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 156</title>
    <url>/blog/posts/2908350626/</url>
    <content><![CDATA[Contestant. Rank 263. Rating +90. A. Sum of Three 题意 给定一个整数 \(n\)，构造一种方案，使得 \(n = x + y + z\)，且 \(x \neq y \neq z; x, y, z \not \equiv 0 \pmod 3\)。 思路 分类讨论。 首先，最小的构造是 \(x = 1, y = 2, z = n - 3\)，那么显然，\(n - 3 &gt; 2\)，即 \(n \geq 6\)。 并且，因为 \(z\) 不可以是 \(3\) 的倍数，所以 \(n\) 也不可以是 \(3\) 的倍数。 那么，如果 \(n\) 是 \(3\) 的倍数，我们考虑次小的构造：\(x = 1, y = 4, z = n - 5\)，此时 \(n - 5 &gt; 4\)，即 \(n \geq 10\)。 此时，可以发现 \(n - 5\) 不是 \(3\) 的倍数，从而符合要求。 时间复杂度：\(O(1)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; if(n % 3 == 0)&#123; if(n &lt;= 9) &#123; cout &lt;&lt; "NO\n"; return; &#125; cout &lt;&lt; "YES\n"; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; 4 &lt;&lt; ' ' &lt;&lt; n - 5 &lt;&lt; '\n'; &#125;else&#123; if(n &lt;= 5) &#123; cout &lt;&lt; "NO\n"; return; &#125; cout &lt;&lt; "YES\n"; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; n - 3 &lt;&lt; '\n'; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 好久没有 \(A\) 写这么久了（ B. Fear of the Dark 题意 给定一个目标点，以及两个光源。输出最小的光源半径，使两个光源将从原点 \((0, 0)\) 到目标点的任意一条路径全都照亮。 思路 显然，半径更大，能照亮的概率更大，具有单调性，从而我们考虑二分。 我们按照下面的方式检查半径是否合法： 任意一个光源到目标点的距离小于半径； 任意一个光源到原点的距离小于半径； 任意一个光源覆盖原点和目标点，或者两个光源的距离小于半径之和 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int px, py, ax, ay, bx, by; cin >> px >> py >> ax >> ay >> bx >> by; auto comp = [&amp;](double a, double b)&#123; if(a &lt; b) return true; if(fabs(a - b) &lt;= eps) return true; return false; &#125;; auto dist = [&amp;](double x1, double y1, double x2, double y2)&#123; return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2); &#125;; auto check = [&amp;](double r) -> bool &#123; bool f1 = false, f2 = false, f3 = false; if (comp(dist(px, py, ax, ay), r * r) &amp;&amp; comp(dist(0, 0, ax, ay), r * r)) f1 = true; if (comp(dist(px, py, bx, by), r * r) &amp;&amp; comp(dist(0, 0, bx, by), r * r)) f1 = true; if (comp(dist(ax, ay, bx, by), 4 * r * r)) f1 = true; if (comp(dist(px, py, ax, ay), r * r) || comp(dist(px, py, bx, by), r * r)) f2 = true; if (comp(dist(0, 0, ax, ay), r * r) || comp(dist(0, 0, bx, by), r * r)) f3 = true; return f1 &amp;&amp; f2 &amp;&amp; f3; &#125;; double l = 0, r = 1e5, mid; while(r - l > eps)&#123; mid = (l + r) / 2; if(check(mid)) r = mid; else l = mid; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(9) &lt;&lt; l &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 其实可以直接解，但精度要求不高，浮点数二分过得去 C. Decreasing String 题意 给定一个长为 \(n\) 的由小写字母组成的字符串 \(s\)，以及初始状态下等于 \(s\) 的字符串 \(p\)。 接下来会有 \(n - 1\) 次操作，每次操作会从字符串里删除一个字符，并满足删除的所有方案中，该方案删除后得到的字符串字典序最小。 对于每次操作完后得到的 \(s\)，将其拼接到 \(p\) 的后面，从而最后 \(p\) 是一个长度为 \(\frac{n(n - 1)}{2}\) 的字符串。 给定一个整数 \(x\)，输出 \(p_x\) 对应的字符。 思路 首先，删除的方案是：如果存在一个点 \(i\)，满足 \(s_i &gt; s_{i + 1}\)，那么删除 \(s_i\)；否则，我们从最后一个字符开始往前删。 暴力模拟是不可行的，但是考虑到单点查询，我们完全可以不用推出前面操作后得到的答案。 那么我们只要处理查询的字符对应的字符串是什么即可。 我们可以简单计算得到，\(x\) 位于第几个字符串，我们记其为 \(l\)。 那么，问题转化为：维护一个长为 \(l\) 的单调序列，如果在长度大于 \(l\) 时已经递增，那么考虑从后往前删。 那么，我们直接用单调栈即可解决此题。合理使用 \(\mathtt{stl}\) 即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; string s; int pos; cin >> s >> pos; int n = s.size(); s = " " + s; int at = 0, sum = 0; for(int i=1;i&lt;=n;i++)&#123; sum += n - i + 1; if(sum >= pos)&#123; at = i; break; &#125; &#125; pos -= ((n - (at - 1) + 1) + n) * (at - 1) / 2; set&lt;int> st; int ind = 0; st.ep(++ ind); for(int i=2;i&lt;=at;i++)&#123; while(ind + 1 &lt;= n &amp;&amp; (st.empty() || s[ind + 1] >= s[*st.rbegin()])) st.ep(++ ind); st.extract(-- (st.end())); &#125; for(int i=ind+1;i&lt;=n;i++) st.ep(i); auto ans = st.begin(); for(int i=1;i&lt;pos;i++) ans ++; cout &lt;&lt; s[*ans]; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 写完才发现写了个单调栈（x D. Monocarp and the Set 题意 对于一个序列 \(a\)，以及一个空字符串 \(s\)，定义构造方式如下： 对于 \(i \in [2, n]\)，如果 \(a_i\) 比前面的所有数都小，那么在 \(s\) 里放入一个 \(&lt;\)；如果 \(a_i\) 比前面的所有数都大，那么放入 \(&gt;\)；否则放入 \(?\)。 现在，给定构造好的字符串 \(s\)，并给定 \(q\) 个非独立询问： 每个询问给定一个整数 \(i\) 和一个字符 \(c\)，并将 \(s_i\) 修改为 \(c\)。 输出询问前，以及每一次询问修改后，字符串 \(s\) 对应的原序列 \(a\) 有多少种。 思路 我们考虑逆向思维。 首先，如果当前位置是 \(&gt;\) 或 \(&lt;\)，那么这个位置的数值是唯一确定的，否则，如果这个位置位于 \(i\)，我们就有 \(i - 1\) 种选择。 为何是 \(i - 1\) ？因为我们只能把最小值或最大值放在第一个位置，而因为这个位置是 \(?\)，所以它不可以是可以放置的最大值或最小值，从而会少一种取法。 最后累乘即可。 至于询问，我们直接模拟替换，然后更新答案即可，当然，如果第一位是 \(?\)，我们在最后输出的时候输出 \(0\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); static __int128 qp(__int128 x, __int128 y, __int128 m = mod) &#123; static __int128 ans; ans = 1, x %= m; for (; y; y >>= 1, x = x * x % m) if (y &amp; 1) ans = ans * x % m; return ans; &#125; int inv(int n, int m = mod) &#123; return qp(n, m - 2, m); &#125; void solve() &#123; int n, q; cin >> n >> q; string s; cin >> s; int ans = 1; for(int i=1;i&lt;n;i++)&#123; if(s[i] == '?') ans = ans * i % mod; &#125; cout &lt;&lt; (s[0] == '?' ? 0 : ans) &lt;&lt; '\n'; while(q --)&#123; int x; char c; cin >> x >> c; if(x != 1) &#123; if (s[x - 1] != '?' &amp;&amp; c == '?') &#123; ans = ans * (x - 1) % mod; &#125; else if (s[x - 1] == '?' &amp;&amp; c != '?') &#123; ans = ans * inv(x - 1) % mod; &#125; &#125; s[x - 1] = c; cout &lt;&lt; (s[0] == '?' ? 0 : ans) &lt;&lt; '\n'; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 最神秘的是打表可以看出规律（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 2023 第三场世纪大战</title>
    <url>/blog/posts/4265615967/</url>
    <content><![CDATA[Personal solution. 入门算法套思维场 A. 打牌 题意 对于一张牌，有对应的权值和点数。 对于牌上的字符，按照 A,K,Q,J,10,9,8,7,6,5,4,3,2 的顺序，权值依次减小。 对于牌上的字符，若字符为 2 ~ 9，则点数为字符对应的数字；否则，有下面的对应关系： A: 1, T: 10, J: 11, Q: 12, K: 13 现在给定 A, B 之间的博弈： 每个人有两张牌，牌上会有两个字符，我们无视第二个字符； 双方都可以看到对方的牌，从而采取最优策略； 第一局 A 先手。当 先手 所出的牌的权值 \(\geq\) 后手 所出的牌的权值，先手 获得权值最大的牌对应的点数，否则 后手 获得权值最大的牌对应的点数。 上一局获得点数的玩家在第二局为先手，规则和上一局一致。 现在，若两个人都使用最优策略，输出 A 获得的点数 \(-\) B 获得的点数 的最大值。 思路 为方便计算，我们记 B 获得的都是负点数。 首先，因为只有两轮，我们可以发现，第一局的选择总共有四种。 即，如果我们将其标一个号，A 的牌为 1, 2，B 的牌为 3, 4，那么第一局可以是 1:3, 1:4, 2:3, 2:4。 我们可以枚举 A 出的牌，然后找出 B 可以出的牌中，最后答案最小的（即对于 B 来说获得点数最大的），最后对 A 出的所有牌对应的答案取最大的即可。 至于打牌得到的点数，直接模拟即可，注意对 A 的处理。 时间复杂度：\(O(1)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; string s = "0A23456789TJQK"; map&lt;char, int> ind; for(int i=1;i&lt;=13;i++) ind[s[i]] = i; auto duel = [&amp;](int a, int b) -> int&#123; if(a == b) return a; if(a == 1) return 1; if(b == 1) return -1; if(a >= b) return a; return -b; &#125;; auto check = [&amp;](int a, int b, int c, int d) -> int&#123; int ans = duel(a, b); if(ans >= 0) ans += duel(c, d); else ans -= duel(d, c); return ans; &#125;; int q; cin >> q; while(q --) &#123; string s1, s2, s3, s4; cin >> s1 >> s2 >> s3 >> s4; int a1 = check(ind[s1[0]], ind[s3[0]], ind[s2[0]], ind[s4[0]]), a2 = check(ind[s1[0]], ind[s4[0]], ind[s2[0]], ind[s3[0]]), a3 = check(ind[s2[0]], ind[s3[0]], ind[s1[0]], ind[s4[0]]), a4 = check(ind[s2[0]], ind[s4[0]], ind[s1[0]], ind[s3[0]]); cout &lt;&lt; max(min(a1, a2), min(a3, a4)) &lt;&lt; '\n'; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 《博弈》 B. 括号大师 题意 给定 \(n\) 个由小括号组成的字符串，定义方案为选出若干个字符串，并将其按照任意顺序拼接，满足最后得到的字符串合法。 输出 长度最长的方案 的长度。 思路 首先，可以证明的是，最优策略是先让左括号尽可能递增，然后再递减到 \(0\)。 其次，在左括号递增的时候，我们需要判断它是否合法。因而我们尽可能把不合法的放后面。 同样的，在左括号递减的时候，也是一样的。 从而，我们可以按照上面的方式，对字符串进行排序，然后我们可以用背包计算出我们需要的答案。 时间复杂度：\(O(n \log n + nv ^ 2)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;array&lt;int, 3>> a(n); for(int i=0;i&lt;n;i++) &#123; string s; cin >> s; auto &amp;[min_v, sum_v, siz] = a[i]; siz = s.size(); for(int j=0;j&lt;siz;j++)&#123; if(s[j] == '(') sum_v ++; else sum_v --; min_v = min(min_v, sum_v); &#125; &#125; sort(all(a), [&amp;](auto o1, auto o2) -> bool&#123; auto [min1, sum1, l1] = o1; auto [min2, sum2, l2] = o2; if(sum1 >= 0 &amp;&amp; sum2 &lt; 0) return true; if(sum1 &lt; 0 &amp;&amp; sum2 >= 0) return false; if(sum1 >= 0 &amp;&amp; sum2 >= 0) return min1 > min2; return sum1 - min1 > sum2 - min2; &#125;); vector&lt;int> pre(90010, -1); pre[0] = 0; for(int i=0;i&lt;n;i++)&#123; auto [min, sum, len] = a[i]; vector&lt;int> dp(90010, -1); for(int j=0;j&lt;=90000;j++)&#123; dp[j] = max(dp[j], pre[j]); if(j + min >= 0 &amp;&amp; j + sum >= 0 &amp;&amp; j + sum &lt;= 90000 &amp;&amp; pre[j] != -1)&#123; dp[j + sum] = max(dp[j + sum], pre[j] + len); &#125; &#125; pre = dp; &#125; cout &lt;&lt; pre[0] &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 背包一下（ C. Vigenère 密码 题意 给定加密方式，反推解密方式，并解密。 思路 首先，我们可以发现，加密的方式如下： 将密钥重复若干次，直到和需要加密的文本一样长； 从 0 开始对字母表编号，并用其替换密钥字符串为一个数字序列 \(p\)； 对于第 \(i\) 个需要加密的字符，对应的加密后的字符为将原字符按照字母表的顺序循环右移 \(p_i\) 位 那么，解密就是循环左移咯。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; string k, enc; cin >> k >> enc; transform(all(k), k.begin(), ::tolower); int ind = 0; for(auto &amp;e : enc)&#123; int d = k[ind] - 'a'; if(e >= 'A' &amp;&amp; e &lt;= 'Z')&#123; e = ((e - 'A' - d + 26) % 26) + 'A'; &#125;else&#123; e = ((e - 'a' - d + 26) % 26) + 'a'; &#125; ind = (ind + 1) % k.size(); &#125; cout &lt;&lt; enc &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 看着吓人罢了 D. 菜数 题意 对于 \(n = a \cdot 10 ^ 0 + a \cdot 10 ^ 1 + a \cdot 10 ^ 2 + \ldots + a \cdot 10 ^ k\)，给定 \(n\)，任取 \(k\)，找出最小的 \(a\)，使式子成立。 思路 式子可以改为：\(n = a \cdot \underbrace{11 \ldots 1}_{k - 1个1}\)。 那么，我们直接枚举 \(k\) 的长度，然后计算答案即可。 时间复杂度：\(O(1)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; int base = 111111111111; while(n % base != 0) base /= 10; cout &lt;&lt; n / base &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 验题的时候蠢了一下，写了个模拟版的，改一下可以过更大的数据。 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; for (int len = 1; len &lt;= 12; len++) &#123; for (int cnt = 1; cnt &lt;= 13 - len; cnt++) &#123; int now = n, suf = 0, beg = 0; vector&lt;int> sum = &#123;0&#125;; bool f = false; for (int j = 1, p10 = 1; j &lt;= len; j++, p10 *= 10) &#123; now -= sum[j - 1] - sum[beg]; if (now &lt; 0) f = true; suf += p10 * (now % 10); if(j >= cnt) beg ++; sum.pb(sum[j - 1] + now % 10); now /= 10; &#125; if (f) continue; int cur = 0; for (int j = 1; j &lt;= cnt; j++) &#123; cur = cur * 10 + suf; if (cur == n) &#123; cout &lt;&lt; suf &lt;&lt; '\n'; return; &#125; &#125; &#125; &#125; cout &lt;&lt; n &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 有点愚蠢在的 E. 拯救Ocean 题意 给定两个 \(4\) 位质数 \(x, y\)，不包含前导 \(0\)。 定义一次操作为选定一个位置，并将该位置上的数字修改为任意数字，满足修改完后的整个数字为不包含前导 \(0\) 的 \(4\) 位质数。 输出将 \(x\) 修改为 \(y\) 的最小操作数。 思路 我们直接 \(\mathtt{bfs}\)。 对于判素数，我们可以用线性筛先筛出来，也可以直接在 \(O(\sqrt n)\) 复杂度下暴力判。 时间复杂度：\(O(懒得分析，反正不大)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); bool vis[N], is_pri[N]; int pri[N], cnt; //线性筛 void linear_prime(int n) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) pri[cnt++] = i, is_pri[i] = true; for (int j = 0; j &lt; cnt; ++j) &#123; if (1ll * i * pri[j] > n) break; vis[i * pri[j]] = true; if (i % pri[j] == 0)break; &#125; &#125; &#125; void solve() &#123; linear_prime(2e5); int x, y; cin >> x >> y; queue&lt;pii> q; q.ep(x, 0); map&lt;int, int> st; while(!q.empty())&#123; auto [now, tot] = q.front(); q.pop(); if(st[now]) continue; st[now] = true; if(now == y)&#123; cout &lt;&lt; tot &lt;&lt; '\n'; return; &#125; int tmp = now; for(int i=1,msk=1;i&lt;=4;i++,msk*=10)&#123; for(int j=0;j&lt;=9;j++)&#123; if(i == 4 &amp;&amp; j == 0) continue; int cur = now - (tmp % 10) * msk + j * msk; if(cur == now || !is_pri[cur]) continue; q.ep(cur, tot + 1); &#125; tmp /= 10; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 当然也可以跑最短路 F. 小菜玩积木 题意 定义在 \(n\) 块积木上的博弈： 先手和后手每次可以拿走 \(2 ^ k, k \geq 0\) 个积木； 将最后一个积木拿走的玩家获胜 输出获胜的玩家。 如果先手胜，输出先手第一次至少要拿多少积木。 思路 首先，如果后手拿了 \(x\) 个，先手可以拿 \(\frac{x}{2}\) 个，这样可以保证拿的合法。 那么如果要让先手最后拿完，在后手第一次拿的时候，积木数量就必须是 \(3\) 的倍数。 那么，只要先手第一次拿掉 \(n \bmod 3\) 就可以了，而且可以发现 \(1, 2\) 都是合法的。 如果 \(n \bmod 3 = 0\)，那么后手就赢了。 时间复杂度：\(O(1)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int _t = 3; while(_t --) &#123; string s; cin >> s; int sum = 0; for (auto e : s) sum += e - '0'; if(sum % 3 == 0) cout &lt;&lt; "You win!" &lt;&lt; '\n'; else cout &lt;&lt; "Caicai wins!" &lt;&lt; '\n' &lt;&lt; sum % 3 &lt;&lt; '\n'; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 从结论开始证是很好证的（x G. 新俄罗斯方块 题意 给定 \(m\) 个柱子，第 \(i\) 个柱子的高度为 \(h[i]\)，输出柱子围成一圈排列的方案数，使相邻两个柱子的高度差不超过 \(k\)。 思路 因为 \(m\) 太小了，所以我们直接暴力 \(\mathtt{dfs}\)，进行一个回溯搜索。 注意围成一圈，最后判断答案的时候不要漏判第一个和最后一个。 当然，最后的答案要除 \(m\)，因为可能有一些方案是通过某个方案 "旋转后" 得到的。 时间复杂度：\(O(10!)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int m, k; cin >> m >> k; vector&lt;int> h(m + 1); for(int i=1;i&lt;=m;i++) cin >> h[i]; vector&lt;bool> st(m + 1); int ans = 0; auto dfs = [&amp;](auto dfs, int start, int pre, int cnt) -> void&#123; if(cnt == m)&#123; if(abs(start - pre) &lt;= k) ans ++; return; &#125; for(int i=1;i&lt;=m;i++)&#123; if(st[i] || abs(h[i] - pre) > k) continue; st[i] = true; dfs(dfs, start, h[i], cnt + 1); st[i] = false; //回溯 &#125; &#125;; for(int i=1;i&lt;=m;i++) &#123; st[i] = true; dfs(dfs, h[i], h[i], 1); st[i] = false; &#125; cout &lt;&lt; ans / m &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 签 H. 小菜学数学 题意 给定一个长为 \(n\) 的数组 \(a\)，输出任意去掉一个元素后，所有元素的最大公约数的最大值。 思路 首先，你可以发现最大公约数具有前缀和的性质。 那么，我们记 \(pre[i]\) 为前 \(i\) 个数的 \(\gcd\)，\(suf[i]\) 为后 \(i\) 个数的 \(\gcd\)。 若第 \(i\) 个数是需要去掉的，那么剩下所有数的 \(\gcd\) 就是 \(\gcd(pre[i - 1], suf[i + 1])\)。 枚举即可。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1), pre(n + 1), suf(n + 2); for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; if(i == 1) pre[i] = a[i]; else pre[i] = __gcd(pre[i - 1], a[i]); &#125; for(int i=n;i>=1;i--)&#123; if(i == n) suf[i] = a[i]; else suf[i] = __gcd(suf[i + 1], a[i]); &#125; int ans = max(pre[n - 1], suf[2]); for(int i=2;i&lt;n;i++)&#123; ans = max(ans, __gcd(pre[i - 1], suf[i + 1])); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 前缀和套了个壳 I. Ocean做噩梦 题意 给定 \(n\) 组人，每组人会有一个排列方式，这里用三个数 \(s_i, e_i, d_i\) 表示： 从 \(s_i\) 开始，每隔 \(d_i\) 放一个人，直到 \(e_i\)。 找出唯一的一个位置，该位置的人数为奇数，或输出找不到。 思路 我们记 \(sum[i]\) 为前 \(i\) 个位置的人数前缀和。 如果某一个位置的人数是奇数，那么可以发现，从这一位开始，后面的所有 \(sum[i]\) 都是奇数，而前面的都是偶数。 那么，这里出现了一个分隔点，分割点左边的值为偶数，右边为奇数。 那么，我们考虑二分答案，找出这个分隔点。 至于后面的计算，只要留意边界即可。 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;array&lt;int, 3>> a(n); //s, e, d for(int i=0;i&lt;n;i++) cin >> a[i][0] >> a[i][1] >> a[i][2]; auto check = [&amp;](int x)&#123; int cnt = 0; for(auto [s, e, d] : a)&#123; if(x &lt; s) continue; cnt += (min(e, x) - s) / d + 1; &#125; return cnt % 2 == 1; &#125;; int l = 0, r = 4000000000, mid; bool ok = false; while(l &lt; r)&#123; mid = (l + r) >> 1; if(check(mid)) &#123; r = mid; ok = true; &#125; else l = mid + 1; &#125; if(!ok) &#123; cout &lt;&lt; "Poor QIN Teng:(" &lt;&lt; '\n'; return; &#125; int ans = 0; for(auto [s, e, d] : a) &#123; if (e >= l &amp;&amp; l >= s &amp;&amp; (l - s) % d == 0) ans++; &#125; cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 还有位运算的做法]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 2023 国庆消消乐B</title>
    <url>/blog/posts/3770146735/</url>
    <content><![CDATA[Solution from problem setter. 简单算法场 A. Amiable Parameter 背景 福师大第20届校赛 E 题 改编。 题意 给定 \(f(x) = |x - a_1| + |x - a_2| + \ldots + |x - a_n| + b_1 + b_2 + \ldots + b_n\)，找出最小的 \(x\)，使 \(f(x)\) 最小。 思路 计算中位数。 我们可以用点到数轴上的距离来形象化式子的左半部分。 如果数轴上有 \(n\) 个点，要找到一个点 \(p\)，使 \(p\) 和这些点的距离之和最小，显然我们取这些数的中位数。 你可以发现，如果中位数有两个，一定是取最小的那个中位数，因为两个中位数的答案是一样的。 那么，我们将 \(a_i\) 读入到数组中 并 升序排序，并统计 \(b_i\) 的总和 \(sum_b\)，然后我们对中位数算一下答案即可。 最后，别忘了加上右半部分式子的结果 \(sum_b\)。 注意，本题无法使用复杂度为 \(O(n ^ 2)\) 的排序算法通过。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n); int sum_b = 0; for(int i=0;i&lt;n;i++)&#123; int A, B; cin >> A >> B; a[i] = A, sum_b += B; &#125; sort(a.begin(), a.end()); vector&lt;int> mid = &#123;a[n / 2]&#125;; if(n % 2 == 0) mid.push_back(a[n / 2 - 1]); int at = -1, ans = inf; for(auto x : mid)&#123; int cur = 0; for(int i=0;i&lt;n;i++) cur += abs(a[i] - x); if(cur &lt; ans) ans = cur, at = x; else if(cur == ans) at = min(at, x); &#125; cout &lt;&lt; at &lt;&lt; ' ' &lt;&lt; ans + sum_b &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; bonus: 原题的修改是在线的，需要使用对顶堆维护 B. Breaking Dawn 题意 给定 \(n\) 张牌，输出是否存在一种方案，满足： 从中取出若干张牌，伤害总和 \(\geq X\)； 剩余的牌伤害总和 \(\geq Y\)。 思路 背包问题。 首先，乱贪心是完全错误的，无论怎么排序，你都不能保证最后一定是最优解。 我们不妨这么考虑：设 \(sum\) 为所有牌的伤害总和，那么如果存在一种方案，满足伤害总和恰好为 \(p\)，且满足 \(p \geq X, sum - p \geq Y\)，那么这个方案就是我们想要的。 这里，我们需要使用 \(01\) 背包 来解决这个问题 （动态规划）。 这是一个经典的 \(01\) 背包，我们将伤害总和想象为一个背包的容量，将一张牌的伤害想象为这张牌所占用的体积。 那么，我们定义 \(dp[i]\) 为容积为 \(i\) 的背包是否能装满。 你可以用二维空间的 \(01\) 背包解决问题（需要滚动数组），但显然一维空间会更优。 我们可以从前往后枚举所有牌，并从大到小枚举背包的容量。 如果某个牌的体积是 \(a_i\)，那么如果 \(dp[c - a_i]\) 为真，也就是容量为 \(c - a_i\) 的背包可以装满，放入这个牌之后，容量为 \(c\) 的背包也就可以装满了。 从而有状态转移方程：$dp[c] = dp[c] | dp[c - a_i] $。（取或） 最后，我们检查是否存在一个满足上面条件的 \(p\)，有 \(dp[p] = true\) 即可。 当然，\(dp[0] = true\)。 时间复杂度：\(O(nx)\) 对应AC代码1 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int n, x, y; cin >> n >> x >> y; vector&lt;int> a(n + 1); int sum = 0; for (int i = 1; i &lt;= n; i++) &#123; cin >> a[i]; sum += a[i]; &#125; vector&lt;int> dp(100010); //干脆开大一点，省事（ dp[0] = true; for (int i = 1; i &lt;= n; i++) &#123; for (int v = x; v >= a[i]; v--) &#123; dp[v] |= dp[v - a[i]]; &#125; &#125; for (int i = x; i &lt;= sum &amp;&amp; sum - i >= y; i++) &#123; if (dp[i]) &#123; cout &lt;&lt; "Breaking Dawn!" &lt;&lt; '\n'; return; &#125; &#125; cout &lt;&lt; "Adventure!" &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; 本题也可以用 \(\mathtt{bitset}\) 优化复杂度，这也是很经典的。但好心的出题人并没有想要卡掉上面的做法。 时间复杂度：\(O(nx / 64)\) 对应AC代码2 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int N, X, Y, s = 0, a; cin >> N >> X >> Y; bitset&lt;100007> bit; bit[0] = 1; for (int i = 1; i &lt;= N; i++) &#123; cin >> a; s += a; bit |= bit &lt;&lt; a; &#125; for (int i = X; i &lt;= s &amp;&amp; s - i >= Y; i++) &#123; if (bit[i]) &#123; cout &lt;&lt; "Breaking Dawn!\n"; return; &#125; &#125; cout &lt;&lt; "Adventure!\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; 背包专题在 oj 里有 C. Calculate my Ptt, please! 题意 给定 \(n\) 个两位小数，令 \(ptt = (\) 最大的 \(10\) 个数之和 \(+\) 最大的 \(30\) 个数之和 \() / 40\)，将 \(ptt\) 保留两位小数，并去掉多余的小数位，而不是四舍五入。 输出 \(ptt\)。 思路 坑人签到题。 本题有三个坑点： 不要使用 \(O(n ^ 2)\) 的排序算法；你可以使用自带的 \(sort\) 函数（\(c\) 语言下是 \(qsort\)）； 避免对 \(double\) 进行累加求和；本题中，你可以把数字全都乘 \(100\) 并转为 \(long\ long\)，来规避这个问题； 注意审题，不要四舍五入；本题中，你可以在上面的操作基础上，向下取整，接着除 \(100\)，最后保留两位小数输出即可。 避开这三个坑点，这题就是签到题，模拟一下过程即可。 基本上挂的人都是挂在累加 \(double\)，然后乘 \(100\)，向下取整，然后除 \(100\)。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int n; cin >> n; vector&lt;int> a(n); for(int i = 0; i &lt; n; i ++) &#123; double cur; cin >> cur; a[i] = (int) (cur * 100); //全都乘个100，方便算 &#125; sort(a.rbegin(), a.rend()); //自带函数复杂度 O(n log n) double ptt = 0; for(int i = 0; i &lt; 30; i ++)&#123; ptt += (i &lt; 10 ? 2.0 : 1.0) * a[i]; &#125; ptt /= 40; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ((int) ptt) / 100.0 &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; 其实样例就是我的 ptt（（ D. Dozens of Move 题意 给定一个包含 . 和 # 的字符串，指定一开始的位置。 有一个机器人在上面移动，一开始机器人向右移动，若遇到 #，机器人会将其改为 .，并更改移动方向；如果遇到左右边界，也会更改移动方向。 输出机器人在移动了几次后，字符串里的所有 # 才能变为 .。 思路 双指针。 首先，最朴素的做法就是模拟移动，但这样的复杂度最坏可以达到 \(O(n ^ 2)\) 级别，显然是无法通过的。 我们可以发现，每次移动后，我们都在扩展我们的可移动区间，并且扩展之后，这些地方都会被重新走好几次。 我们记当前扩展得到的区间为 \([l, r]\)。 那么比如我们这一次需要向左扩展，我们就完全没必要从 \(r\) 再模拟走到 \(l\)，因为我们知道 \([l, r]\) 上面一定没有 #，而且需要走的步数是已知的 \(r - l\)，那么我们不妨将答案加上 \(r - l\)，然后直接跳到 \(l\)，并继续向左扩展。向右扩展的方法是类似的。 那么，我们可以发现，现在每个格子就只会被访问到一次了，从而将时间复杂度降为了最坏 \(O(n)\)。 时间复杂度：\(O(n)\) 对应AC代码 (Ocean) #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int n, a; cin >> n >> a; string s; cin >> s; s = " " + s; //让下标从1开始 int cnt = 0; for(auto &amp;e : s)&#123; if(e == '#') cnt ++; &#125; int l = a, r = a; int ans = 0; int d = 1; //1 right, -1 left while(cnt > 0)&#123; ans += r - l; if(d == 1) &#123; while(r &lt;= n &amp;&amp; s[r] == '.') r ++, ans ++; if(r &lt;= n) s[r] = '.', cnt --; &#125;else&#123; while(l >= 1 &amp;&amp; s[l] == '.') l --, ans ++; if(l >= 1) s[l] = '.', cnt --; &#125; d = -d; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; 对应AC代码 (Std) #include &lt;bits/stdc++.h> using namespace std; int main()&#123; int N, A; string S; cin >> N >> A >> S; int l = A-1, r = A-1, n = A-1, d = 1, cnt = 0; for(int i=0; i&lt;S.size(); i++)&#123; if(S[i] == '#') cnt++; &#125; long long ans = 0; while(cnt > 0)&#123; if(d == 1)&#123; ans++, n++; if(n &lt; N) r = n; if(n == N || S[n] == '#')&#123; if(n &lt; N) cnt--; d = -1; if(cnt > 0) ans += n - l, n = l; // skip &#125; &#125; else&#123; ans++, n--; if(n >= 0) l = n; if(n == -1 || S[n] == '#')&#123; if(n >= 0) cnt--; d = 1; if(cnt > 0) ans += r - n, n = r; // skip &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 严格来说也不是双指针算法，只是有两个指针罢了（ E. End with NO 0 背景 灵感来自暑假牛客集训营的某一题（有点忘了）。 题意 对于 \(1, 2, \ldots, n\)，删除尽可能少的数字，来让剩余数字的乘积不包含后缀 \(0\)。输出剩余数字的最大个数。 思路 简单思维题。 首先，既然要让乘积末尾出现 \(0\)，乘积中肯定要同时存在 \(2\) 的倍数和 \(5\) 的倍数。 那么很明显，我们只要让剩余数字中不包含 \(2\) 的倍数，或者不包含 \(5\) 的倍数就好了。 显然，从 \(1\) 开始的话，肯定是 \(5\) 的倍数更少，从而我们考虑删除 \(5\) 的倍数，剩下的数字个数就是我们要的答案。 好心的出题人没有把范围开到 \(10 ^ {18}\)，他怕你一顿操作爆 \(long\ long\) 了（x 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int n; cin >> n; cout &lt;&lt; (n - n / 5) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; 下一场要么来卡一下 \(long\ long\)？ F. Force Ripening 背景 题目来自 Codeforces CodeTON Round 4 (Div. 1 + Div. 2) B题，难度 \(800\)。 题意 对于 \(x\)，一开始 \(x = 1\)，定义操作为下面选项任选一： \(x := 2x - 1\)； \(x := 2x + 1\)。 现在，给定操作后的数，判断是否可以还原操作方案，不可以输出 \(-1\)，可以的话输出方案。 思路 思维题。 首先，很显然，操作后得到的数不可能是偶数，那么我们就可以进行特判。 在上面的基础上，我们可以发现，若操作后的数是 \(p\)，那么原来的数可以是 \(\frac{p - 1}{2}, \frac{p + 1}{2}\)。 显然，这两个数是一奇一偶的，而原来的数也不可能是偶数，从而原来的数是唯一确定的。 那么，我们可以倒推，只要能推到 \(1\)，就可以还原操作方案（当然，既然我们是倒推，记得反着输出）。 事实上，上面的操作可以将 \(1\) 变为任意正奇数。 时间复杂度：\(O(\log x)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int n; cin >> n; if(n % 2 == 0)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; vector&lt;int> ans; while(n > 1)&#123; if((n - 1) / 2 % 2 == 0) n = (n + 1) / 2, ans.emplace_back(1); //≈push_back else n = (n - 1) / 2, ans.emplace_back(2); &#125; reverse(ans.begin(), ans.end()); //反转一下 cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto each : ans) cout &lt;&lt; each &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 逆向思维（ G. Genshin Impact, Start! 题意 给定一个灰度值矩阵，找出与 \(255\) 的差值不小于 \(k\) 的点的个数 \(cnt\)，如果 \(cnt\) 不超过 \(p\)，那么判定启动。 思路 简单签到题。 显然，我们将所有数全都读进来，然后根据题面模拟计算即可。 注意题面中的 "不小于"，"不超过"。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int k, p, n, m; cin >> k >> p >> n >> m; int cnt = 0; for (int i = 0; i &lt; n * m; i ++) &#123; int cur; cin >> cur; if (255 - cur >= k) cnt ++; &#125; if (cnt &lt;= p) cout &lt;&lt; "zenmenile" &lt;&lt; '\n'; else cout &lt;&lt; "wande" &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; 本来想出的更麻烦一点，但这种 ___ 题还是去 \(AtCoder\) 做吧 H. Homework of Math 题意 给定整数 \(n\)，输出 \((a + b) ^ n\) 的表达式，如果系数是 \(1\) 需要忽略，次方是 \(0\) 也需要忽略。 例如 \((a + b) ^ 2 = a ^ 2 + 2ab + b ^ 2\)。 思路 组合数问题。 显然，总共有 \(n + 1\) 项，第 \(i\) 项的系数是 \(C_n^{i - 1}\)。 对于系数，你可以暴力计算（只要不是太暴力），也可以使用杨辉三角递推。 出题人想要卡掉暴力计算和 \(long\ long\)，但是被好心的组题人和验题人拦下了（x 但，于是这题变成了可以打表的题（？ 时间复杂度：\(O(n)\) 对应AC代码 (Ocean) #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int n; cin >> n; vector&lt;int> p(n + 2); p[0] = 1; for (int i = 1; i &lt;= n; i++) &#123; //杨辉三角 for (int j = i; j >= 1; j --) p[j] += p[j - 1]; &#125; cout &lt;&lt; "(a+b)^" &lt;&lt; n &lt;&lt; "="; for(int i=0;i&lt;=n;i++)&#123; if(p[i] != 1) cout &lt;&lt; p[i]; if(i != n) &#123; cout &lt;&lt; "a"; if(i != n - 1) cout &lt;&lt; '^' &lt;&lt; (n - i); &#125; if(i != 0) &#123; cout &lt;&lt; "b"; if(i != 1) cout &lt;&lt; '^' &lt;&lt; i; &#125; if(i != n) cout &lt;&lt; "+"; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; 对应AC代码 (Std) #include &lt;cstdio> #define FOR(i, l, r) for(int i = l; i &lt;= r; i++) using namespace std; unsigned long long f[71]; int n; int main() &#123; scanf("%d", &amp;n); f[0] = 1; FOR(i, 1, n) for(int j = i; j; j--) f[j] += f[j - 1]; printf("(a+b)^%d=", n); FOR(i, 0, n) &#123; if (i) putchar('+'); if (i &amp;&amp; n - i) printf("%llu", f[i]); if (n - i) &#123; putchar('a'); if (n - i != 1) printf("^%d", n - i); &#125; if (i) &#123; putchar('b'); if (i != 1) printf("^%d", i); &#125; &#125; puts(""); return 0; &#125; bonus: 如果 \(n \leq 67\) 呢？ I. I Super, Explosion 背景 2023 牛客寒假训练营 2 的 I 题 改编。 题意 给定 \(n\) 个音符，每个音符有对应偏移值 \(c\)，定义 \(m\) 个判定区间 \((- \infty,a_1), [a_1, a_2), \ldots, [a_{m - 1},+\infty)\)，\(c\) 落在第 \(i\) 个区间内可获得对应判定分 \(v_i\)。输出将所有的 \(c\) 加上或减去任意值后判定分总和的最大值。 思路 思维+排序。 首先，我们可以将所有音符的偏移值全都减去一个相同的且很大的值，来让所有音符都位于第一个判定区间。 然后，我们可以按照 每个音符 距离进入下一个判定区间 所需的偏移值更改量，从小到大进行偏移值的更改。 因为偏移值是整体移动的，所以如果按照上面的排序方式，当我们枚举到第三小的偏移值更改时，前面两个偏移值也一定进行了更改。 从而，我们只需在枚举的时候，累加每次更改偏移值后的分数变化，最后找出分数和最大的一种更改即可。 形象地来说，你可以将音符理解为数轴上的点，一开始所有点都在第一个判定区间，然后所有点向右整体移动，累加每次移动带来的分数变化，最后最大的分数和就是调整后判定分总和的最大值了。 时间复杂度：\(O(nm \log (nm))\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int n, m; cin >> n >> m; vector&lt;int> c(n + 1), a(m), v(m + 1); for (int i = 1; i &lt;= n; i++) &#123; cin >> c[i]; c[i] -= 2e9; //全部挪到第一判定区间 &#125; for (int i = 1; i &lt; m; i++) cin >> a[i]; for (int i = 1; i &lt;= m; i++) cin >> v[i]; vector&lt;pair&lt;int, int>> p; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; m; j++) &#123; p.emplace_back(a[j] - c[i], v[j + 1] - v[j]); //设备偏移值，修改后分数的变化 &#125; &#125; sort(p.begin(), p.end()); int cur = v[1] * n, ans = cur; for (auto &amp;e: p) &#123; cur += e.second; ans = max(ans, cur); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; 听说有人想做牛客寒假的题（x 牛客的原题是可以二分的，这题不好说（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 2023 国庆消消乐A</title>
    <url>/blog/posts/2042531349/</url>
    <content><![CDATA[Solution from problem setter. 语法场 A. Ocean睡大觉 题意 给定一个时间段，去掉这个时间段后，给定一个结束时刻 \(E\)，确定最大的开始时刻 \(S\)，使 \(S\) 到 \(E\) 这段时间的时长至少为 \(8\) 小时。 开始时刻 \(S\) 不能超过给定时间段的开始时间。 思路 直接模拟。 因为题面给的是小时和分钟，那么如果我们将其转化为分钟，显然这就转化为数轴上的问题了（比如说，\(3:40 \rightarrow 220\)）。 那么，你可以画个图，把边界情况都列出来，然后问题自然就迎刃而解了。 当然，题面是有坑的。如果你仔细看题了，不难发现，最后答案是要和比赛开始时间取一个最小值的，不然有可能出现只需睡一个阶段的情况，从而刚好挂掉 \(1\) 个点。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int hs, ms, he, me, ht, mt; cin >> hs >> ms >> he >> me >> ht >> mt; int len = (he * 60 + me) - (hs * 60 + ms), ed = (ht * 60) + mt; int time = min(hs * 60 + ms, ed - len - 8 * 60); if(time &lt; 0) cout &lt;&lt; "ipmama" &lt;&lt; '\n'; else cout &lt;&lt; "sleep" &lt;&lt; '\n' &lt;&lt; (time / 60) &lt;&lt; ' ' &lt;&lt; (time % 60) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; 睡了吗，如睡 B. Ocean不是OP 题意 对于 \(n\) 个怪，在 \(a\) 秒内连续两次使用技能后，技能会锁定 \(b\) 秒。判断能否对所有怪使用技能。 思路 显然，因为使用技能的时间是固定的，那么我们直接模拟就好了。 我们可以把使用技能的时间都存到数组里，那么每次我们只需比较 当前时间和上一次使用技能的时间 的差值就好了。 我们记这个差值为 \(d\)。 显然，题面中有一个类似于"锁定"的状态，如果状态是锁定的，并且 \(d \leq b\)，那么这个时候技能就使用不了了，我们直接判定答案就好。 对于状态的设定，我们只要判断 \(d \leq a\) 是否满足就好了，如果满足，那么我们就可以标记锁定了，否则，我们就取消标记锁定。 如上，解毕。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int n, a, b; cin >> n >> a >> b; vector&lt;int> x(n + 1); for(int i=1;i&lt;=n;i++) cin >> x[i]; bool f = true, lock = false; for(int i=2;i&lt;=n;i++) &#123; if(lock &amp;&amp; x[i] &lt;= x[i - 1] + b) f = false; lock = x[i] &lt;= x[i - 1] + a; &#125; cout &lt;&lt; (f ? "tilennnb\n" : "wasted\n"); &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; OP C. Ocean不是铁P 题意 怪物最初有 \(h\) 血量，定义技能为： \(n\) 段伤害，每段伤害扣除怪物的血量一定值； 具有初始值 \(x\)，该值为默认伤害； 若怪物血量低于原血量的 \(50\%\)，那么伤害变为初始值的 \(1.5\) 倍并向上取整 输出可以让怪物在释放一次技能后被击杀的最小初始伤害 \(x\)。 思路 Part1. 二分 显然，数据范围大到无法暴力扫答案。 我们进行下面的观察： 当初始伤害越大，最后需要使用的段数就会减小，否则就会增大，且增大到一定值后就不能一击必杀了。 可以发现，上面的关系满足单调性，即 需要使用的段数随 \(x\) 递增而递减。 因而，我们考虑对 \(x\) 二分，即二分答案。 如果没有学过二分答案，你可以先完成 oj 的对应题单再来看这题。 你可以通过画图来加深对其的理解。 Part2. check 首先，我们需要注意到题目中的 "低于 \(50\%\)"。 我们可以将答案分成两部分计算，也就是先算普通攻击，再算暴击。我们将两种攻击需要的段数加起来，和 \(n\) 比较即可。 下面给出一个计算流程，供参考（\(\lceil x \rceil\) 表示向上取整）： 计算普通攻击需要的段数 \(\displaystyle cnt1 = \lceil \frac{\frac{h}{2} + 1}{x} \rceil\)； 计算还剩下多少血量 \(left = cnt1 \cdot x\)； 计算暴击需要的段数 \(\displaystyle cnt2 = \lceil \frac{left}{\lceil{1.5x}\rceil} \rceil\)。 至于第一个式子为什么要 \(+1\)，因为我们需要低于 \(50\%\) 后才能使用暴击，所以我们的普通攻击一定要至少把怪物血量减少到 \(50\% \cdot h - 1\)。 注意检查答案的时候的边界问题，以及取整的问题。 当然，请注意，本题卡 \(int\)。 时间复杂度：\(O(\log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int h, n; cin >> h >> n; auto check = [&amp;](int x)&#123; int cnt1 = (h / 2 + 1 + (x - 1)) / x, left = h - cnt1 * x, kick = (x * 3 + 1) / 2, cnt2 = (left + (kick - 1)) / kick; return cnt1 + cnt2 &lt;= n; &#125;; int l = 1, r = h, mid; while(l &lt; r)&#123; mid = (l + r) >> 1; if(check(mid)) r = mid; else l = mid + 1; &#125; cout &lt;&lt; l &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; 铁P D. Ocean的Minecraft之旅 题意 给定 \(n + 1\) 个不同的三维坐标点，从 \(0\) 开始编号。第 \(0\) 个点为家 \((0, 80, 0)\)，剩下 \(n\) 个点会给出。 在半径 \(r\) 给定的条件下，遍历每个点为球心，从第 \(1 - n\) 个点中找出位于球内和球上的点的个数（不包含球心），并输出最大值对应的编号最小的点的编号，以及这个最大值。 思路 看懂题就简单了，我们直接暴力检查答案，然后更新结果即可。 具体来说，我们枚举每一个点作为球心，然后暴力检查，统计点数。 当然，在检查 \(\sqrt{d} \leq r\) 的时候，我们不妨两边平方，变成 \(d \leq r ^ 2\)，这样可以避免根号运算的精度问题（看到好几个被卡掉了）。 其余就是对边界情况的处理了。 当然，这题也卡 \(int\)，但好心的出题人并没有想卡掉 \(long\ long\)。 但好心的出题人不小心把 \(java\) 做法的 \(O(n^2 log n)\) 卡掉了，属实意料之外。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int n, r; cin >> n >> r; vector&lt;array&lt;int, 3>> p(n + 1); for(int i=1;i&lt;=n;i++) cin >> p[i][0] >> p[i][1] >> p[i][2]; array&lt;int, 3> home = &#123;0, 80, 0&#125;; auto check = [&amp;](array&lt;int, 3> o, array&lt;int, 3> a)&#123; return (a[0] - o[0]) * (a[0] - o[0]) + (a[1] - o[1]) * (a[1] - o[1]) + (a[2] - o[2]) * (a[2] - o[2]) &lt;= r * r; &#125;; int at = 0, ans = 0; for(int i=1;i&lt;=n;i++)&#123; if(check(home, p[i])) ans ++; &#125; for(int i=1;i&lt;=n;i++)&#123; int cnt = 0; for(int j=1;j&lt;=n;j++)&#123; if(i == j) continue; if(check(p[i], p[j])) cnt ++; &#125; if(cnt > ans) at = i, ans = cnt; &#125; cout &lt;&lt; at &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; McP E. Ocean与Hello World 题意 给定分别包含了 \(n, m\) 个单词的两组单词，求出所有可能的组合（保证左边的单词一定从左边那组单词里取，右边同理）中，在不区分大小写的条件下，不为 \(Hello\ World\) 的方案数。 思路 答案就是 方案总数 \(-\) 组合为 \(Hello\ World\) 的方案数。 那么，我们统计左边为 \(Hello\) 的取法个数 \(a\)，右边为 \(World\) 的取法个数 \(b\)，答案就是 \(n \cdot m - a \cdot b\)。 至于不区分大小写，你可以直接写一个函数判断，又或者调用自带的函数（具体怎么使用自行百度）。 时间复杂度：\(O(单词总长度)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int n, m; cin >> n >> m; int cnt1 = 0, cnt2 = 0; string first = "hello", second = "world"; for(int i=1;i&lt;=n;i++)&#123; string s; cin >> s; //转换为小写 func：转换（开始地址，结束地址，放结果的开始地址，操作） transform(s.begin(), s.end(), s.begin(), ::tolower); if(s == first) cnt1 ++; &#125; for(int i=1;i&lt;=m;i++)&#123; string s; cin >> s; transform(s.begin(), s.end(), s.begin(), ::tolower); if(s == second) cnt2 ++; &#125; cout &lt;&lt; (n * m - cnt1 * cnt2) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; 至少不是输出 \(hello\ world\) （（ F. Ocean的自白书 题意 输出 \(ocean\)。 思路 不会写这题的请自裁（x 怎么真的有人挂了啊，我哭死。 时间复杂度：\(O(1)?\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; cout &lt;&lt; "ocean" &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; 别大写别大写（（ G. Ocean说这是一道博弈，我也不知道是不是 背景 题目来自 Codeforces Round 884 (Div. 1 + Div. 2) A题，难度 \(800\)。 题意 给定两个人之间的博弈：每个人可以选择拿走 \(a\) 或 \(b\) 个原石。 输出后手有必胜策略的原石的总数。 思路1 如果先手拿走 \(x\) 个石头后，后手都能拿走 \(n - x\) 个石头，那么后手必胜。 那么，\(n = a + b\) 是一定正确的，因为对方拿掉 \(a\) 或者 \(b\) 后，我都可以拿掉对应的 \(b\) 或者 \(a\)，使原石被用完，从而先手无法操作。 当然，输出 \(a + b\) 的任意整数倍都是可以的，因为每一轮都是后手有必胜策略。 思路2 我们可以直接让先手一开始就无法操作，那么如果最小值是大于 \(1\) 的，我们直接输出 \(n = 1\)，即可达到目的。 否则，我们可以输出 \(b + 1\)，这和思路 \(1\) 是一样的。 思路3 同思路2，区别是，当 \(a = 1\) 的时候，我们再做一个分类讨论： \(b \geq 3\)，那么输出 \(n = 2\)，这样可以让先手只能拿 \(1\)，从而后手再拿 \(1\) 之后，刚好拿完石头； \(b = 2\)，那么输出 \(n = 1 + 2 = 3\)，这和思路 \(1\) 是一样的。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int a, b; cin >> a >> b; cout &lt;&lt; a + b &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; A + B Problem H. Ocean与奇怪的数列 题意 定义数组 \(a\) 前三项为 \(6, 1, 6\)，从第四项开始，每一项都是前三项分别乘上系数后相加，然后对 \(998244353\) 取模。 关于系数，\(a_i = 61 \times a_{i - 1} + 11 \times a_{i - 2} + 16 \times a_{i - 3}\)。 回答 \(q\) 个询问，每次询问给定一个下标，输出下标对应的数。 思路 注意数据范围，我们不可以对每一个询问都计算答案，因而我们考虑预处理。 我们先预处理好整个数组，然后回答询问即可。 注意，因为取模的值是 \(998244353\)，乘上一个十位数是一定超过 \(int\) 范围的，所以记得开 \(long\ long\)。 至于推导，如果会取模的话，把式子直接套进去就好了。 但我都把取模式子放在最后了，你不是可以直接改一下字母套进来么（x 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, mod = 998244353; int a[N]; void init() &#123; a[1] = 6, a[2] = 1, a[3] = 6; for(int i=4;i&lt;=2e5;i++)&#123; a[i] = (61 * a[i - 1] % mod + 11 * a[i - 2] % mod + 16 * a[i - 3] % mod) % mod; &#125; &#125; void solve() &#123; int q; cin >> q; while(q --)&#123; int i; cin >> i; cout &lt;&lt; a[i] &lt;&lt; '\n'; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); solve(); &#125; 斐波那契plus I. Ocean与"大模拟" 背景 来自 HNOI 2005。 题意 设计一个程序完成题面所指的算法。 太模拟了，建议看原题自己阅读理解（ 思路 本题不详细解释，建议你可以留着，等到之后学了 \(stl\) 之后来补题。 一道逻辑很清楚但是不好写的 模拟题。 我们很明显能发现，不可以暴力，会寄，想想有序性，不难发现可以用 堆 来维护。 我们需要存一下当前某一页的状态，方便找空页，我们可以用 \(\mathtt{Map}\)。 模拟即可 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve() &#123; int n, m; cin >> n >> m; map&lt;int, pair&lt;int, int>> data; set&lt;array&lt;int, 3>> least; //cnt, time, query int ans = 0; for (int i = 0; i &lt; m; i++) &#123; int query; cin >> query; if(data.count(query))&#123; auto [cnt, time] = data[query]; least.erase(&#123;cnt, time, query&#125;); least.insert(&#123;cnt + 1, time, query&#125;); data[query] = &#123;cnt + 1, time&#125;; ans ++; &#125;else if(data.size() &lt; n)&#123; data[query] = &#123;1, i&#125;; least.insert(&#123;1, i, query&#125;); &#125;else&#123; data.erase((*least.begin())[2]); least.erase(least.begin()); data[query] = &#123;1, i&#125;; least.insert(&#123;1, i, query&#125;); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); solve(); &#125; 如果用 C 写估计会很头大，但你正式打比赛的时候难道写纯 C 吗]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - CodeTON Round 6 Div. 1 + 2</title>
    <url>/blog/posts/1514777285/</url>
    <content><![CDATA[Contestant. Rank 1335. Rating +80. A. MEXanized Array 题意 给定三个整数 \(n, k, x\)，构造一个长为 \(n\) 的数组，满足 \(MEX = k\)，最大值不超过 \(x\)。 输出数组总和的最大值。无法构造输出 \(-1\)。 思路 首先，如果 \(MEX\) 大于数组的长度，或者大于数组的最大值 \(+ 1\)，那么就无法构造。 否则，我们就只需对 \(MEX\) 和最大值的大小关系进行特判即可。 我们先依次填入 \(0, 1, 2, \ldots, k - 1\)，然后剩余的都填上最大值。如果最大值是 \(MEX\)，那么我们应该填上 最大值 $ - 1$。 时间复杂度：\(O(1)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, k, x; cin >> n >> k >> x; if(k > n || k > x + 1)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; int sum = 0; for(int i=0;i&lt;k;i++) sum += i; sum += (n - k) * (x - (x == k ? 1 : 0)); cout &lt;&lt; sum &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 签到签到 B. Friendly Arrays 题意 给定一个长为 \(n\) 的序列 \(a\)，以及一个长为 \(m\) 的序列 \(b\)，定义一次操作为选定任意一个 \(b_j\)，然后对所有 \(i \in [1, n]\)，执行 \(a_i = a_i | b_j\)。 输出任意次操作后，序列 \(a\) 所有数的异或和的最小值和最大值。 思路 首先，如果序列 \(a\) 长为偶数，那么执行一次操作后，\(b_j\) 上所有为 \(1\) 的位置都会因为异或而变成 \(0\)，从而可以发现操作次数越多，异或和越小。 那么这个时候最大值就是操作前的异或和，最小值就是将所有 \(b_j\) 都操作一遍后的异或和。 如果序列 \(a\) 长为奇数，那么执行一次操作后，\(b_j\) 上所有为 \(1\) 的位置都会因为异或而变成 \(1\)，从而可以发现操作次数越多，异或和越大。 那么相反的，此时最小值就是操作前的异或和，最大值就是将所有 \(b_j\) 都操作一遍后的异或和。 那么不妨直接把这两个答案算出来，然后输出最小值和最大值即可。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, m; cin >> n >> m; vector&lt;int> a(n + 1); int ans1 = 0, ans2 = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; ans1 ^= a[i]; &#125; int w = 0; for(int i=1;i&lt;=m;i++) &#123; int x; cin >> x; w |= x; &#125; for(int i=1;i&lt;=n;i++)&#123; ans2 ^= (a[i] | w); &#125; if(ans1 > ans2) swap(ans1, ans2); cout &lt;&lt; ans1 &lt;&lt; ' ' &lt;&lt; ans2 &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 有意思的思维题 C. Colorful Table 题意 给定一个长为 \(n\) 的序列 \(a, a[i] \leq k\)，对于一个 \(n \times n\) 的矩阵 \(b\)，有 \(b[i][j] = \min(a[i], a[j])\)。 对于 \(x \in [1, k]\)，输出将 \(b[i][j] = x\) 的所有方格包含在里面的最小矩形的长宽之和。 思路 首先，得到的矩阵是对称的，所以最后的答案肯定是一个正方形的边长 \(\times 2\)。 其次，因为有取最小值操作，所以我们不妨从小到大枚举所有颜色，用 \(\mathtt{set}\) 维护值大于等于当前颜色的下标集合。 那么，对于这个颜色，我们需要的答案就是最大的下标和最小的下标的距离 \(\times 2\)。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n), ans(k); vector&lt;vector&lt;int>> pos(k); set&lt;int> s; for(int i = 0;i &lt; n;i++)&#123; cin >> a[i]; a[i] --; pos[a[i]].push_back(i); s.insert(i); &#125; for(int i = 0;i &lt; k;i++) &#123; if (pos[i].empty()) continue; int x = *s.rbegin(), y = *s.begin(); ans[i] = x - y + 1; for (auto it : pos[i]) s.extract(it); &#125; for(auto e : ans) cout &lt;&lt; e * 2 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 其实很显然，但我也不知道为啥做了好一会儿（x D. Prefix Purchase 题意 给定长度为 \(n\) 的序列 \(a, c\)，其中序列 \(a\) 的初始值都是 \(0\)。 对于第 \(i\) 种支付，可以通过支付 \(c_i\) 个硬币，来使 \([1, i]\) 内所有 \(a_i\) 都加上 \(1\)。 现在，在硬币最多有 \(k\) 个的条件下，输出字典序最大的 \(a\)。 思路 首先，为了让第一个数尽可能大，我们一定会尽可能多使用价格低的。 那么，我们先全用价格最低的硬币，然后考虑用价格高但范围更大的硬币替换。 显然，我们肯定先用小的替换，这样代价更小，那么我们只需贪心地从小到大枚举所有支付方式，然后只使用能让范围进一步扩大地方式即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1), d(n + 2); map&lt;int, int> mp; for (int i = 1; i &lt;= n; i++) &#123; cin >> a[i]; mp[a[i]] = i; &#125; int k; cin >> k; int v = 0, pos = 0, pcnt = inf; for (auto [x, y]: mp) &#123; if (y &lt;= pos) continue; int cnt = min(pcnt, k / (x - v)); d[pos + 1] += cnt; d[y + 1] -= cnt; k -= cnt * (x - v); pcnt = cnt; v = x, pos = y; &#125; for (int i = 1; i &lt;= n; i++) &#123; d[i] += d[i - 1]; cout &lt;&lt; d[i] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 哎，贪心]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 897 Div. 2</title>
    <url>/blog/posts/243689992/</url>
    <content><![CDATA[Contestant~. Rank 313. Rating +53. 这场的 \(E\) 难度感觉很有争议，感觉放 \(C\) 都不过分（个人看法 A. green_gold_dog, array and permutation 题意 给定一个序列 \(a\)，构造一个排列 \(b\)，使所有 \(a_i - b_i\) 中不同值的个数最大，并输出方案。 思路 显然地，因为我们可以减到负数，那么我们用大数减小数的方式，一定可以构造出尽可能多的 \(a_i - b_i\)。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;pii> a(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i].fs; a[i].sc = i; &#125; sort(all(a)); vector&lt;int> ans(n); for(int i=0;i&lt;n;i++) ans[a[i].sc] = n - i; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 题目差点没看懂（x B. XOR Palindromes 题意 给定一个长为 \(n\) 的二进制字符串，对于 \(k \in [0, n]\)，输出是否可以构造出长为 \(n\) 且包含 \(k\) 个 \(1\) 的二进制字符串，满足和原串进行按位异或后，得到的结果是一个回文串。 以二进制的方式输出。 思路 首先，我们先判断有多少个位置是不满足回文的，对于每一对 \(&lt;0, 1&gt;\)，对应的我们构造的字符串上也应满足不是回文。 那么，\(k\) 至少得大于等于非回文对的个数，否则直接输出 \(0\)。 那么，在上述条件下，其他位置都放 \(0\)，就是对应的 \(1\) 最少的方案。 至于剩下的位置，我们直接一对一对放 \(1\) 即可。 因为会出现 \(n\) 为奇数的情况，所以中间的数是任意的，需要特判一下。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; string s; cin >> s; s = " " + s; int dif = 0; for(int i=1;i&lt;=n/2;i++)&#123; if(s[i] != s[n - i + 1]) dif ++; &#125; for(int i=0;i&lt;=n;i++)&#123; if(i &lt; dif)&#123; cout &lt;&lt; 0; continue; &#125; int lf = i - dif; if(n % 2 == 1)&#123; if(lf % 2 == 0 &amp;&amp; lf &lt;= (n / 2 - dif) * 2)&#123; cout &lt;&lt; 1; &#125;else if(lf % 2 == 1 &amp;&amp; lf - 1 &lt;= (n / 2 - dif) * 2)&#123; cout &lt;&lt; 1; &#125;else cout &lt;&lt; 0; &#125;else&#123; if(lf % 2 == 0 &amp;&amp; lf &lt;= (n / 2 - dif) * 2)&#123; cout &lt;&lt; 1; &#125;else cout &lt;&lt; 0; &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 还是很形象的（ C. Salyg1n and the MEX Game 题意 这是一道交互题。 这是一道和测评机的博弈题。（？ 在本题中，给定一个序列 \(s\)，你 \(A\) 和测评机 \(B\) 需要进行下面的博弈： 每轮，\(A\) 先手； \(A\) 选择一个数 \(x\)，并将其放入 \(s\)，需要满足 \(s\) 中本来不包含 \(x\)； \(B\) 从 \(s\) 中选择一个数 \(y\) 删除，需要满足 \(y\) 严格小于 上一次 \(A\) 放入的数 当 \(B\) 无法操作，或者两者的总操作数等于 \(2n + 1\) 时，游戏结束； 最后，\(MEX(s)\) 就是游戏的结果； \(A\) 希望最大化结果，\(B\) 希望最小化结果 在你足够聪明的条件下，和测评机博弈，使最后的结果一定是一个定值。 思路 如果我要最大化结果，我自然会填上空缺。 此时，如果测评机选了比较小的数，我一定可以重新填上去，并缩小 \(B\) 的范围，因而最后 \(B\) 一定会无法操作，而且他的所有操作都是无效的。 可以发现总操作数最大是奇数，也就是说最后一个操作的人一定是我，那么不存在 \(B\) 删掉了数的情况。 以上，本题题面中的结果为我填入 \(MEX(s)\) 后的 \(MEX(s&#39;)\)，为一个定值。 交互方式就是先填入 \(MEX(s)\)，然后测评机删一个我塞回去一个。 时间复杂度：\(O(测评机的无聊程度)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; sort(all(a)); int mn = 0; for(int i=1;i&lt;=n;i++)&#123; if(a[i] == mn) mn ++; &#125; cout &lt;&lt; mn &lt;&lt; '\n'; cout.flush(); int now; cin >> now; while(now != -1)&#123; cout &lt;&lt; now &lt;&lt; '\n'; cout.flush(); cin >> now; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 测评机直接删 \(0\) 不好吗（x D. Cyclic Operations 题意 给定一个序列 \(a\)，最初序列全都是 \(0\)，定义一次操作为选择一个左端点 \(l\)，对于 \(i \in [1, k]\)，执行 \(a_{l_i} := l_{(i \bmod k) + 1}\)。 现在，给定可能的若干次操作后的序列 \(b\)，输出其是否合法。 思路 显然，一次操作对应着一个环，如果我们以 \(i \rightarrow b_i\) 的方式建图，最后的图是一种形为太阳的图的集合。 可以发现，因为存在覆盖，那么对于图上的所有链，我们都可以按顺序取 \(k\) 个节点，然后把最后一个节点指向第一个节点，即可构成一个环。 所以我们无需考虑链，去掉即可。 我们利用拓扑排序，标记非环点，然后枚举所有环，判断这些环长度是否都是 \(k\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n + 1), in(n + 1); for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; in[a[i]] ++; &#125; if(k == 1)&#123; for(int i=1;i&lt;=n;i++)&#123; if(a[i] != i)&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; return; &#125; vector&lt;bool> st(n + 1); queue&lt;int> q; for(int i = 1;i &lt;= n;i++)&#123; if(!in[i])&#123; st[i] = true; q.push(i); &#125; &#125; while(!q.empty())&#123; int u = q.front(); q.pop(); if(--in[a[u]] == 0)&#123; st[a[u]] = true; q.push(a[u]); &#125; &#125; auto dfs = [&amp;](auto dfs, int x, int step) -> bool&#123; if(st[x])&#123; return step == k; &#125; st[x] = true; return dfs(dfs, a[x], step + 1); &#125;; for(int i=1;i&lt;=n;i++)&#123; if(st[i]) continue; if(!dfs(dfs, i, 0))&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 抽象的，具象的，好做的 E1. Salyg1n and Array (simple version) 详见 \(E2\)，区别是本题交互的次数是 \(100\)。 E2. Salyg1n and Array (hard version) 题意 这又是一道交互题。 对于一个未知的序列，定义一次询问为选定一个长为给定 \(k\) 的区间，测评机会给出这个区间内所有元素的异或和，并将这个区间翻转。 在不超过 \(57\) 次询问下，输出整个序列的异或和。 保证 \(1 \leq k \leq n \leq k^2 \leq 2500\)。n和k都是偶数！ 思路 首先，我们先询问前面相邻的长度为 \(k\) 的区间，即询问满足条件的 \(1 + mk\)。 接着，如果 \(n \bmod k = 0\)，那么我们无需操作，最后答案就是上面询问的异或和。 否则，我们还需询问两次。 我们看下面的序列： 1 2 3 4 5 6 7 8 9 10 如果 \(k = 4\)，那么最后 \(9, 10\) 我们是没有算上的。 我们考虑将剩下的数分成两半，然后先询问以前面一半的数为结尾的区间，然后再询问以序列右端点为结尾的区间。 如上我们即可得到答案。 我们可以模拟一下： 第一种操作完成后： 4 3 2 1 | 8 7 6 5 | 9 10 询问以前面一半的数为结尾的区间，得到 "7 6 5 9": 4 3 2 1 8 | 9 5 6 7 | 10 询问以序列右端点为结尾的区间，得到 "5 6 7 10" 可以发现，我们抵消后得到了 "9 10"。 上面的翻转操作会将我们真正需要的翻转到前面，留下后面不需要的，而分成两半后，我们需要的前一半在操作后会翻转到前面，然后我们恰好又将询问区间向后移动了一半，刚好让前面一半的数在区间外，从而恰好可以抵消。 至于 \(100\) 次的方案，我们可以从以第一个剩余的数为结尾的区间开始询问，下一次询问是上一次询问的区间向右移动一格，可以发现也是类似的抵消方式。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, k; cin >> n >> k; auto fetch = [&amp;]()&#123; int x; cin >> x; return x; &#125;; int ans = 0; for(int i=1;i+k-1&lt;=n;i+=k) &#123; cout &lt;&lt; "? " &lt;&lt; i &lt;&lt; '\n'; cout.flush(); ans ^= fetch(); &#125; if(n % k != 0)&#123; cout &lt;&lt; "? " &lt;&lt; n - (n % k) / 2 - k + 1 &lt;&lt; '\n'; cout.flush(); ans ^= fetch(); cout &lt;&lt; "? " &lt;&lt; n - k + 1 &lt;&lt; '\n'; cout.flush(); ans ^= fetch(); &#125; cout &lt;&lt; "! " &lt;&lt; ans &lt;&lt; '\n'; cout.flush(); &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 也是差点没看到那个偶数的条件，看到了就是个签到了（怎么不放在题面而是放在输入约束里啊啊啊啊啊]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 896 Div. 2</title>
    <url>/blog/posts/2834391484/</url>
    <content><![CDATA[Contestant~. Rank 257. Rating +51. A. Make It Zero 题意 给定一个序列，定义一次操作为选定一个区间，并将区间内的所有数全都替换为他们的异或总和。 输出不超过 \(8\) 次操作后，让整个序列变为 \(0\) 的一种方案。 思路 我们分奇偶性来考虑： 如果序列长度为偶数，显然偶数个相同的元素异或和为 \(0\)，那么我们只要对整个序列进行异或，然后再重复一次操作即可； 如果序列长度为奇数，那么我们同上，对前 \(n - 1\) 个元素执行两次操作。因为任何数和 \(0\) 异或都是它本身，因而我们对最后两个元素操作两次即可。 时间复杂度：\(O(1)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; &#125; if(n % 2 == 0)&#123; cout &lt;&lt; 2 &lt;&lt; '\n'; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; n &lt;&lt; '\n'; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; n &lt;&lt; '\n'; &#125; else &#123; cout &lt;&lt; 4 &lt;&lt; '\n'; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; n - 1 &lt;&lt; '\n'; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; n - 1 &lt;&lt; '\n'; cout &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n &lt;&lt; '\n'; cout &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n &lt;&lt; '\n'; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 脑子不好使卡了一会儿qaq B. 2D Traveling 题意 给定 \(n\) 个点，其中前 \(k\) 个点位于主城内，主城内的点相互传送代价为 \(0\)，否则代价为两点横纵坐标差值的绝对值之和，即 \(|x_i-x_j|+|y_i-y_j|\)。 现在，给定起点和终点所在的点的标号，输出从起点走到终点的最小代价和。 思路 首先，因为主城内相互传送无代价，所以当我们传送到主城后，我们就直接另找一个更近的点传送到外面即可。 并且，因为三角不等式，我们可以发现 从一个点走到另一个点 总是优于 从一个点走到一个点再走到另一个点。 因而，我们只需先走到主城，再从主城走到终点，最多需要使用三个点。对于点的选择，暴力判断即可。 当然，也会有直接从起点走到终点的方案，我们特判一下即可。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, k, a, b; cin >> n >> k >> a >> b; vector&lt;pii> p(n + 1); for(int i=1;i&lt;=n;i++)&#123; cin >> p[i].fs >> p[i].sc; &#125; int mn1 = inf, mn2 = inf; for(int i=1;i&lt;=k;i++)&#123; int now = abs(p[i].fs - p[a].fs) + abs(p[i].sc - p[a].sc); mn1 = min(mn1, now); &#125; for(int i=1;i&lt;=k;i++)&#123; int now = abs(p[i].fs - p[b].fs) + abs(p[i].sc - p[b].sc); mn2 = min(mn2, now); &#125; int ans = min(mn1 + mn2, abs(p[a].fs - p[b].fs) + abs(p[a].sc - p[b].sc)); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 妥妥一个诈骗 C. Fill in the Matrix 题意 给定矩阵的规模 \(n \times m\)，构造矩阵，满足每一行都是 \([0, m - 1]\) 内数的排列。 对于构造好的矩阵，我们计算每一列每个元素的 \(MEX\) 值，然后再对每一列的 \(MEX\) 值再求一次 \(MEX\)。 构造矩阵，让最后的 \(MEX\) 最大，并输出值和方案。 思路 我们可以发现，下面的矩阵总是更优的： \(M= \begin{pmatrix} 0&amp;1&amp;\cdots&amp;m-2&amp;m-1\\ 1&amp;2&amp;\cdots&amp;m-1&amp;0\\ 2&amp;3&amp;\cdots&amp;0&amp;1\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\ m-2&amp;m-1&amp;\cdots &amp;m-4 &amp; m-3\\ 0&amp;1&amp;\cdots&amp;m-2&amp;m-1\\ 0&amp;1&amp;\cdots&amp;m-2&amp;m-1\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\ 0&amp;1&amp;\cdots&amp;m-2&amp;m-1\\ \end{pmatrix}\) 对于 \(MEX\) 值，我们可以暴力计算（需要适当剪枝），也可以寻找规律： 当 \(m = 1\) 的时候，可以发现只有一列，且都为 \(0\)，那么该列的 \(MEX = 1\)，对所有列的结果求 \(MEX = 0\)； 当 \(n &gt; m - 1\) 的时候，因为后面都是相同的行，通过计算得到 \(MEX = [0, m - 1]\)，最后的答案是 \(MEX = m\)； 否则，由我们的构造，可以发现 \(MEX = [0, n]\)，最后的答案是 \(MEX = n + 1\) 时间复杂度：\(O(nm)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, m; cin >> n >> m; if(m == 1) cout &lt;&lt; 0 &lt;&lt; '\n'; else if(n > m - 1) cout &lt;&lt; m &lt;&lt; '\n'; else cout &lt;&lt; n + 1 &lt;&lt; '\n'; for(int i=0;i&lt;min(n,m-1);i++)&#123; for(int j=0;j&lt;m;j++)&#123; cout &lt;&lt; (i + j) % m &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; for(int i=min(n,m-1);i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++) cout &lt;&lt; j &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 能暴力求是没想到的 D1. Candy Party (Easy Version) 题意 给定一个序列，定义一个元素可以选择一个不超过自己本身的 \(2^k\)，并将其给其他元素。 在本题中，一个元素需要恰好给另一个元素 \(2^p\)，同时也需要恰好从另一个元素得到 \(2^q\)。 在满足上述操作的条件下，判断最后能否让整个序列所有元素相等。 思路 首先，既然是序列内的互相给予，那么最后的总和是不变的，且最后所有元素都会变为平均值 \(avg\)。那么我们可以先特判总和是否是 \(n\) 的倍数。 其次，按照题给条件，对于每个元素 \(a_i\)，一定存在 \(p, q\)，满足 \(a_i - 2^p + 2^q = avg\)。 我们可以发现，就算出现了不够的情况，也一定有一种方案可以避免，因为这种依赖是环形的。 那么，最后我们只需按照上式，令 \(cnt[j]\) 为当前整个序列 \(2^j\) 多余或缺少的数量，那么我们对每一个元素枚举，找出 \(p, q\)，然后 \(cnt[p] --, cnt[q] ++\) 即可。 最后，我们判断是否 \(cnt\) 里所有元素都是 \(0\)，不是的话就出现了多余或不够的情况。 时间复杂度：\(O(32n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); int sum = 0; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; sum += a[i]; &#125; if(sum % n != 0) &#123; cout &lt;&lt; "NO\n"; return; &#125; sum /= n; vector&lt;int> cnt(32); for(int i=1;i&lt;=n;i++)&#123; bool f = false; for(int j=0;j&lt;32;j++)&#123; for(int k=0;k&lt;32;k++)&#123; if(a[i] - (1ll &lt;&lt; j) + (1ll &lt;&lt; k) == sum)&#123; f = true; cnt[j] ++; cnt[k] --; &#125; &#125; &#125; if(!f)&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; for(int i=31;i>=0;i--)&#123; if(cnt[i] > 0)&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 二进制多少有点抽象（ D2. Candy Party (Hard Version) 题意 同 \(D1\)，区别是加粗的条件替换为： 在本题中，一个元素需要最多给另外一个元素 \(2^p\)，同时也需要最多从另外一个元素得到 \(2^q\)。 思路 我们需要分类讨论： 刚好比平均值少 \(2^k\)，那么我们可以从别的元素拿来 \(2^k\)，或者将自己的 \(2^{k + 1}\) 给别的元素，并从别的元素拿来 \(2^k\)； 否则，执行和 \(D1\) 一样的操作 我们可以将情况 \(1\) 的数单独拿出来考虑，并将剩余的数按照 \(D1\) 的方式，更新得到 \(cnt\) 数组。 对于情况 \(1\) 的数，因为最高位的更高一位的 \(cnt\) 一定是 \(0\)，从而不可以进位上来，所以可以发现最高位是不可以进位的。 那么，我们先统计情况 \(1\) 的数，第 \(i\) 位缺少 \(pn[i]\) 或 多余 \(pl[i]\)，然后我们从最高位开始递推更新 \(cnt\)： 首先，更新 \(cnt[i] := cnt[i] + (pl[i] - pn[i])\)； 然后，若要满足 \(cnt[i] = 0\)，我们需要从下一位进位或在本位退位； 前者，我们从 \(pl[i - 1]\) 借 \(cnt[i]\) 个来进位，此时 \(i - 1\) 位自然就少了 \(cnt[i]\) 个多余的数；后者同理 最后，我们判断 \(cnt[0]\) 是否为 \(0\) 即可，因为我们上述的操作已经满足 \(i &gt; 0, cnt[i] = 0\)。 自然，我们需要判断每一位 \(pl[i], pn[i]\) 是否小于 \(0\)，是的话说明无解。 时间复杂度：\(O(32n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); int sum = 0; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; sum += a[i]; &#125; if(sum % n != 0) &#123; cout &lt;&lt; "NO\n"; return; &#125; sum /= n; vector&lt;int> cnt(32), pl(32), pn(32); for(int i=1;i&lt;=n;i++)&#123; bool f = false; for(int j=0;j&lt;32;j++)&#123; if(a[i] - (1ll &lt;&lt; j) == sum)&#123; f = true; pl[j] ++; &#125;else if(a[i] + (1ll &lt;&lt; j) == sum)&#123; f = true; pn[j] ++; &#125; &#125; if(f) continue; for(int j=0;j&lt;32;j++)&#123; for(int k=0;k&lt;32;k++)&#123; if(a[i] - (1ll &lt;&lt; j) + (1ll &lt;&lt; k) == sum)&#123; f = true; cnt[j] ++; cnt[k] --; &#125; &#125; &#125; if(!f)&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; for(int i=31;i>=0;i--)&#123; if(pl[i] &lt; 0 || pn[i] &lt; 0)&#123; cout &lt;&lt; "NO\n"; return; &#125; cnt[i] += (pl[i] - pn[i]); if(i == 0) break; if(cnt[i] &lt; 0)&#123; pl[i - 1] -= -cnt[i]; cnt[i - 1] -= -cnt[i]; &#125;else&#123; pn[i - 1] -= cnt[i]; cnt[i - 1] += cnt[i]; &#125; &#125; cout &lt;&lt; (cnt[0] == 0 ? "YES\n" : "NO\n"); &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 好一个分类讨论]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 895 Div. 3</title>
    <url>/blog/posts/3994962871/</url>
    <content><![CDATA[Contestant_. Rank 344. Rating +183. A. Two Vessels 题意 给定两个水槽，初始状态下有 \(a, b\) 单位的水。现在给定一个容量为 \(c\) 的水杯，输出最少需要舀几次水，让两个水槽的水体积相等 思路 显然我们缺少 \(\frac{abs(a- b)}{2}\)，设其为 \(p\)，那么我们需要舀 \(\lceil \frac{p}{c} \rceil\) 次。 时间复杂度：\(O(1)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int a, b, c; cin >> a >> b >> c; cout &lt;&lt; (abs(a - b) / 2 / c + (abs(a - b) % (2 * c) != 0)) &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 很形象的签到 B. The Corridor or There and Back Again 题意 给定一个数轴，数轴上有一些障碍物，位于 \(d_i\) 的障碍物会在 \(s_i\) 时刻出现。 输出最远能到达的距离，满足以一个单位时间移动一格的速度下从原点走到该点再走回原点，路上不会碰到障碍物。 思路 我们直接暴力枚举最远能到的距离，然后检查每一个障碍物是否会在路上出现即可。 对于判断，如果我们最远到达 \(k\)，那么需要满足 \(s[j] \leq 2(k - d[j])\)。 时间复杂度：\(O(10000n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> s(n + 1), d(n + 1); for(int i=0;i&lt;n;i++) cin >> s[i] >> d[i]; int ans = 0; for(int i=1;i&lt;=10000;i++)&#123; bool st = true; for(int j=0;j&lt;n;j++)&#123; if(d[j] &lt;= (i - s[j]) * 2) &#123; st = false; break; &#125; &#125; if(st) ans = max(ans, i); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 也是没想到去直接枚举 C. Non-coprime Split 题意 给定两个整数 \(l, r\)，满足 \(l \leq r\)，输出两个整数 \(a, b\)，满足： \(l \leq a + b \leq r\)； \(\gcd(a, b) \neq 1\) 如果不存在，输出 \(-1\)。 思路 首先，如果 \(a + b\) 可以取到偶数，那么显然，两个偶数的 \(\gcd\) 一定是不等于 \(1\) 的。 那么我们对 \(l, r\) 进行特判： 如果 \(l &lt; r\)，我们将 \(l := l + l \bmod 2, r := r - r \bmod 2\)，并令 \(p = \max(l, r)\)，那么如果 \(p = 2\) 就是无解，否则答案就是 \(2, l - 2\)。 如果 \(l = r\)，那么如果 \(l\) 为偶数，就等价于上面的判断，否则我们枚举 \(a \in [3, \sqrt l]\)，并暴力判断即可。 至于为什么只要枚举到 \(\sqrt l\)，因为我们需要满足的是 \(l - a\) 具有因数 \(l\)。 时间复杂度：\(O(\sqrt n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int l, r; cin >> l >> r; if(l &lt; r)&#123; if(l % 2 == 1) l ++; if(r % 2 == 1) r --; l = max(l, r); if(l == 2)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; cout &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; l - 2 &lt;&lt; '\n'; return; &#125; if(l % 2 == 0)&#123; if(l == 2)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; cout &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; l - 2 &lt;&lt; '\n'; &#125;else&#123; for(int i=3;i*i&lt;=l;i++)&#123; if((l - i) % i == 0)&#123; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; l - i &lt;&lt; '\n'; return; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 其实也可以暴力枚举 \(l\)，可以证明不需要枚举很多就可以得到结果 D. Plus Minus Permutation 题意 给定三个整数 \(n, x, y\)，构造一个长为 \(n\) 的排列 \(p\)，\(a - b\) 最大。 其中，\(a\) 定义为 \(p\) 中所有下标是 \(x\) 的倍数的数之和，\(b\) 为 \(p\) 中所有下标是 \(y\) 的倍数的数之和。 输出 \(a- b\)。 思路 这是一个类似于容斥的想法，因为我们减的时候，会将下标是 \(lcm(x, y)\) 倍数的数抵消掉，所以我们无需考虑这些数。 那么可以发现，筛除这些数后，\(a\) 中数的取法和 \(b\) 中数的取法是互不相交的，因而我们直接用最大的几个减去最小的几个即可。 时间复杂度：\(O(1)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, x, y; cin >> n >> x >> y; int cnt1 = n / x, cnt2 = n / y, cnt3 = n / (x * y / __gcd(x, y)); cnt1 -= cnt3, cnt2 -= cnt3; cout &lt;&lt; ((n + (n - cnt1 + 1)) * cnt1 / 2 - (1 + cnt2) * cnt2 / 2) &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 也是差点用 \(x \times y\) 去做了（ E. Data Structures Fan 题意 给定一个长为 \(n\) 的序列 \(a\) 以及二进制字符串，定义询问如下： \(1\ l\ r\)，将 \([l, r]\) 内所有 \(s_i\) 翻转； \(2\ g, g \in [0, 1]\)，将字符串中为 \(g\) 的所有位置对应的 \(a\) 的值取异或总和并输出 回答询问。 思路1 题目有说数据结构，无脑线段树可过。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); struct Node&#123; int l, r; int val, x0, x1, lazy; &#125;; struct SegTree&#123; vector&lt;Node> tr; explicit SegTree(int _n)&#123; tr = vector&lt;Node>(_n &lt;&lt; 2); &#125; static int ls(int x)&#123; return x &lt;&lt; 1; &#125; static int rs(int x)&#123; return x &lt;&lt; 1 | 1; &#125; void push_up(int rt)&#123; tr[rt].val = tr[ls(rt)].val ^ tr[rs(rt)].val; tr[rt].x0 = tr[ls(rt)].x0 ^ tr[rs(rt)].x0; tr[rt].x1 = tr[ls(rt)].x1 ^ tr[rs(rt)].x1; &#125; void build(int rt, int l, int r, vector&lt;int> &amp;a, string &amp;s)&#123; if(l == r)&#123; tr[rt] = &#123;l, r, a[l], s[l] == '0' ? a[l] : 0, s[l] == '1' ? a[l] : 0, 0&#125;; return; &#125; int mid = (l + r) >> 1; build(ls(rt), l, mid, a, s); build(rs(rt), mid + 1, r, a, s); tr[rt] = &#123;l, r&#125;; push_up(rt); &#125; void push_down(int rt)&#123; if(tr[rt].lazy)&#123; swap(tr[ls(rt)].x0, tr[ls(rt)].x1); swap(tr[rs(rt)].x0, tr[rs(rt)].x1); tr[ls(rt)].lazy ^= 1; tr[rs(rt)].lazy ^= 1; tr[rt].lazy = 0; &#125; &#125; void modify(int rt, int l, int r)&#123; if(l &lt;= tr[rt].l &amp;&amp; tr[rt].r &lt;= r)&#123; tr[rt].lazy ^= 1; swap(tr[rt].x0, tr[rt].x1); return; &#125; push_down(rt); int mid = (tr[rt].l + tr[rt].r) >> 1; if(l &lt;= mid) modify(ls(rt), l, r); if(r > mid) modify(rs(rt), l, r); push_up(rt); &#125; int query(int rt, int l, int r, int zero) &#123; if (l &lt;= tr[rt].l &amp;&amp; tr[rt].r &lt;= r) &#123; return zero == 0 ? tr[rt].x0 : tr[rt].x1; &#125; push_down(rt); int mid = (tr[rt].l + tr[rt].r) >> 1; int sum = 0; if (l &lt;= mid) sum ^= query(ls(rt), l, r, zero); if (r > mid) sum ^= query(rs(rt), l, r, zero); return sum; &#125; &#125;; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; string s; cin >> s; s = " " + s; SegTree tr(n); tr.build(1, 1, n, a, s); int q; cin >> q; while(q --)&#123; int op; cin >> op; if(op == 1)&#123; int l, r; cin >> l >> r; tr.modify(1, l, r); &#125;else&#123; int x; cin >> x; cout &lt;&lt; tr.query(1, 1, n, x) &lt;&lt; ' '; &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 思路2 首先，异或两次等于没有异或。 那么我们考虑前缀异或 \(p\)，对于 \(0\) 所对应的异或总和，如果我们异或 \(p[r] \oplus p[l - 1]\)，那么等价于我们将 \([l, r]\) 内的字符翻转，因为原本为 \(0\) 的异或抵消，原本为 \(1\) 的现在异或上去了。 那么很显然，我们维护一个 \(msk\)，然后将所有 \([l, r]\) 修改映射到这个 \(msk\) 上，即 \(msk = msk \oplus (p[r] \oplus p[l - 1])\)。 在处理询问之前，我们预处理 \(0\) 对应的所有数的异或和 \(ans0\)，以及 \(1\) 对应的所有数的异或和 \(ans1\)，那么最后答案就是 \(ans0 \oplus msk, ans1 \oplus msk\)。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; string s; cin >> s; s = " " + s; vector&lt;int> pre(n + 1); int ans0 = 0, ans1 = 0; for(int i=1;i&lt;=n;i++)&#123; pre[i] = a[i] ^ pre[i - 1]; if(s[i] == '0') ans0 ^= a[i]; else ans1 ^= a[i]; &#125; int q; cin >> q; int msk = 0; while(q --)&#123; int tp; cin >> tp; if(tp == 1)&#123; int l, r; cin >> l >> r; msk ^= pre[r] ^ pre[l - 1]; &#125;else&#123; int g; cin >> g; if(g == 0) cout &lt;&lt; (ans0 ^ msk) &lt;&lt; ' '; else cout &lt;&lt; (ans1 ^ msk) &lt;&lt; ' '; &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 用线段树多少有点费时间了（x F. Selling a Menagerie 题意 给定 \(n\) 个动物，每个动物都有害怕的对象，动物 \(i\) 害怕 \(a_i, a_i \neq i\)，每个动物也有对应的价格 \(c_i\)。 现在，需要按照一定的顺序将所有动物卖掉，如果一个动物害怕的动物没有被卖掉，那么卖掉这个动物的价格会翻倍。 输出一种方案。 思路 首先，如果没有环，那么我们直接跑拓扑即可。 那么我们可以用类似的思路实现这道题。 首先，我们以 \(i \rightarrow a_i\) 的方式建立有向边，然后跑一边拓扑，那么剩下的点肯定都在环上。 那么显然，我们需要删掉一个点来让这个环变成链。因为一条链的最后一个删掉的点不可以价格翻倍，所以我们需要将环中的最小值放在最后一个删除。 从而，我们跑完拓扑后，枚举所有环，对于每个环，找出最小值 \(c_i\) 所在的位置 \(i\)，然后从 \(a_i\) 开始删除即可。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;vector&lt;int>> e(n + 1); vector&lt;int> a(n + 1), in(n + 1); for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; in[a[i]] ++; e[i].pb(a[i]); &#125; vector&lt;int> v(n + 1); for(int i=1;i&lt;=n;i++) cin >> v[i]; vector&lt;int> ans; queue&lt;int> q; for(int i=1;i&lt;=n;i++) &#123; if(in[i] == 0) q.ep(i); &#125; vector&lt;bool> st(n + 1); while(!q.empty())&#123; int x = q.front(); q.pop(); ans.pb(x); st[x] = true; for(auto y : e[x])&#123; if(-- in[y] == 0) q.ep(y); &#125; &#125; auto dfs = [&amp;](auto dfs, int x, int p, vector&lt;int> &amp;v) -> void&#123; v.pb(x); for(auto y : e[x])&#123; if(y == p || st[y]) continue; st[y] = true; dfs(dfs, y, x, v); &#125; &#125;; for(int i=1;i&lt;=n;i++)&#123; if(st[i]) continue; st[i] = true; vector&lt;int> p; dfs(dfs, i, -1, p); int mn = *min_element(all(p), [&amp;](int a, int b) -> bool&#123; return v[a] &lt; v[b]; &#125;); int start = a[mn]; int cur = start; ans.pb(cur); cur = a[cur]; while(cur != start)&#123; ans.pb(cur); cur = a[cur]; &#125; &#125; for(auto x : ans) cout &lt;&lt; x &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 环不参与拓扑，因为入度不会减到 \(0\) G. Replace With Product 题意 给定一个序列，定义一次操作为选定 \(l, r, l \leq r\)，并将 \(a_{[l, r]}\) 替换为区间所有数的乘积。 输出 一次操作后 序列总和的最大值 对应的方案。 思路 首先，直观上可以发现，我们只需考虑 \(1\) 的选择，因为只有 \(1\) 是改为乘后使总和减小的。 那么，如果出现乘积大于 \(2n\) 的情况，显然是全部乘起来更好（当然，两端的 \(1\) 不考虑），因为此时 \(1\) 不够让答案减小。 注意到 \(2n \leq 2 ^ {19}\)，实际上我们最多只需对 \(19\) 个非 \(1\) 的数进行相乘。 那么，我们重新整理一下思路： 找出所有非 \(1\) 的数； 预处理 前缀和 和 前缀乘； 在前缀乘的时候，判断乘积是否已经大于 \(2n\)，是的话直接令左端点为第一个非 \(1\) 的数，右端点为最后一个非 \(1\) 的数，并输出； 暴力枚举所有非 \(1\) 的数，作为左端点和右端点，并找出最后答案的最大值对应的方案。 时间复杂度：\(O(m ^ 2), m &lt;&lt; n\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1), sum(n + 1); vector&lt;pii> g; int cur = 1; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; sum[i] = sum[i - 1] + a[i]; if(a[i] != 1) g.pb(i, a[i]); &#125; if(g.size() &lt;= 1)&#123; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; '\n'; return; &#125; for(int i=1;i&lt;=n;i++)&#123; cur *= a[i]; if(cur >= n * 2)&#123; cout &lt;&lt; g[0].fs &lt;&lt; ' ' &lt;&lt; g[g.size() - 1].fs &lt;&lt; '\n'; return; &#125; &#125; vector&lt;int> prod(g.size() + 1); prod[0] = 1; for(int i=0;i&lt;g.size();i++) prod[i + 1] = prod[i] * g[i].sc; int mx = 0, tl = 0, tr = 0; for(int i=0;i&lt;g.size();i++)&#123; for(int j=i+1;j&lt;g.size();j++)&#123; int k = prod[j + 1] / prod[i] - sum[g[j].fs] + sum[g[i].fs - 1]; if(k > mx)&#123; tl = g[i].fs, tr = g[j].fs; mx = k; &#125; &#125; &#125; if(tl == 0) &#123; cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; '\n'; return; &#125; cout &lt;&lt; tl &lt;&lt; ' ' &lt;&lt; tr &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 妥妥一个诈骗题，最后几秒没交上去qaq]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 154</title>
    <url>/blog/posts/1129810318/</url>
    <content><![CDATA[Contestant~. Rank 881. Rating +7. A. Prime Deletion 题意 给定 \(\{0, 1, \ldots, 9\}\) 的一种排列，定义一次操作为在排列剩余元素个数 大于2 的条件下，任意删去一个数字。 任意次操作后，输出排列拼接而成的数字，并满足该数字是质数。 思路 因为 \(13, 31\) 都是质数，并且 \(1\) 一定在 \(3\) 的左边或者右边，因而判一下 \(1\) 的位置即可。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; string s; cin >> s; int i1 = -1, i3 = -1; for(int i=0;i&lt;9;i++)&#123; if(s[i] == '1') i1 = i; if(s[i] == '3') i3 = i; &#125; if(i1 &lt; i3) cout &lt;&lt; "13\n"; else cout &lt;&lt; "31\n"; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 太奇妙了 B. Two Binary Strings 题意 给定两个长度均为 \(n\) 的二进制字符串 \(a, b\)，满足两个字符串都以 \(0\) 开头，\(1\) 结尾。 定义一次操作为选定任意一个字符串 \(s\)，并选定 \(1 \leq l &lt; r \leq n\)，满足 \(s_l = s_r\)，并将 \(s_{[l, r]}\) 内所有字符赋值为 \(s_l\)。 任意次操作后，输出两个字符串是否可能相同。 思路 既然都以 \(0\) 开头，\(1\) 结尾，那么如果存在某个位置 \(i\)，满足 \(a_i = b_i = 0\)，那么我们就可以将 \(a_{[1, i]}, b_{[1, i]}\) 内所有字符改为 \(0\)。 同理，如果存在某个位置 \(j\)，满足 \(a_j = b_j = 1\)，那么我们就可以将 \(a_{[j, n]}, b_{[j, n]}\) 内所有字符改为 \(1\)。 显然，若 \(j = i + 1\)，那么最后的字符串一定相等。 那么问题等价于：判断是否存在 \(i \in [1, n - 1]\)，使 \(a_i = b_i = 0, a_{i + 1} = b_{i + 1} = 1\)。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; string s1, s2; cin >> s1 >> s2; int n = s1.size(); s1 = " " + s1, s2 = " " + s2; for(int i=1;i&lt;=n-1;i++)&#123; if(s1[i] == s2[i] &amp;&amp; s1[i + 1] == s2[i + 1])&#123; if(s1[i] == '0' &amp;&amp; s1[i + 1] == '1')&#123; cout &lt;&lt; "YES\n"; return; &#125; &#125; &#125; cout &lt;&lt; "NO\n"; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 如果没那个条件就成大模拟了（ C. Queries for the Array 题意 定义 已排序 为该序列不降序，若序列元素个数 \(&lt; 2\)，也判定为已排序。 对于一个未知的序列，一开始序列为空，给定操作序列对应的字符串，判断是否合法，其中操作如下： "0"：当前序列未排序； "1"：当前序列已排序； "+"：加入任意一个数字； "-"：删去 最后 一个数字 思路 首先，既然元素个数 \(&lt;2\) 一定已排序，那么我们只需记录当前序列的长度 \(cnt\)，如果出现 \(cnt &lt; 2\)，且当前字符为 \(0\)，那么直接判 \(NO\)。 其次，我们记最小的 未排序 序列的长度为 \(mn\)，最长的 已排序 序列的长度 \(mx\)， 那么，另一个不合法的条件是：\(mn \leq mx, mn &gt; 0\)。 我们可以考虑下面的构造： 遇到 \(+\)，将 \(1\) 加入序列； 遇到 \(0\)，将最后一个数改为 \(0\)。 可以证明上面的构造是最优的，且恰好满足上述的合法判定条件。 那么我们考虑下面的维护： 遇到 \(+\)，增加序列长度； 遇到 \(-\)，减小序列长度。此时，如果 \(mx\) 和减小前的长度相等，那么我们就得去掉一个数，也就是减掉 \(1\)。同样的，如果 \(mn\) 和减小前的长度相等，那么可能会出现删除该数后整个序列有序，因而将 \(mn\) 修改为 \(0\)； 遇到 \(1\)，\(mx = cnt\)； 遇到 \(0\)，如果 \(cnt &lt; 2\)，那么直接判 \(NO\)。此时一并更新 \(mn\)； 在处理完每个字符之后，判断 \(mn \leq mx, mn &gt; 0\) 是否满足，满足直接判 \(NO\)。 当然，也可以直接用线段树维护，不过去掉板子之后码量差不多。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; string s; cin >> s; int mx = 0, mn = 0; //最大已排序前缀，最小未排序后缀 int cnt = 0; for(auto &amp;e : s)&#123; if(e == '+') cnt ++; else if(e == '-')&#123; cnt --; if(mx == cnt + 1) mx = cnt; if(cnt &lt; mn) mn = 0; &#125;else if(e == '1')&#123; mx = cnt; &#125;else&#123; if(cnt &lt;= 1)&#123; cout &lt;&lt; "NO\n"; return; &#125; if(mn == 0 || mn > cnt) mn = cnt; &#125; if(mn &lt;= mx &amp;&amp; mn > 0)&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 线段树用在 \(C\) 还是太抽象了 D. Sorting By Multiplication 题意 给定一个序列 \(a\)，定义一次操作为选定 一个区间 以及 任意一个数字 \(x\)，并将区间内的所有数都乘上 \(x\)。 在 \(x\) 可以为负的条件下，输出最小操作总数，使整个序列升序。 思路 显然，上一个数的状态可以转移到下一个数，且对应的变化是是否多一次操作，因而我们考虑动态规划。 具体来说，我们令 \(dp[i][j]\) 为前 \(i\) 个数让其升序的最小操作数，\(j\) 代表当前位置是否为负数。 那么，我们按照 \(a_{i - 1}, a_i\) 的大小进行分类讨论： \(a_{i - 1} &lt; a_i\)，此时如果该位为正数，我们就无需操作；否则我们得单独对该数进行一次操作，来让这个数比前一个 负数 大，显然这个时候，前面的数不可以是正数。 \(a_{i - 1} &gt; a_i\)，此时如果该位是正数，我们就得单独对该数进行一次操作，来让这个数比前一个数大；否则，我们就无需操作，但需要满足上一个数是负数。 \(a_{i - 1} = a_i\)，此时无论如何，当前位置都得单独进行一次操作，来让这个数比前一个数大。 当然，初始化的时候 \(dp[1][1] = 1\)。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for (int i = 1; i &lt;= n; i++) cin >> a[i]; vector&lt;vector&lt;int>> dp(n + 1, vector&lt;int>(2)); //当前位置是不是负数 dp[1][1] = 1; for (int i = 2; i &lt;= n; i++) &#123; dp[i][0] = dp[i - 1][1]; dp[i][1] = dp[i - 1][1]; if (a[i - 1] &lt; a[i]) &#123; dp[i][1] ++; dp[i][0] = min(dp[i][0], dp[i - 1][0]); &#125; else if (a[i - 1] > a[i]) &#123; dp[i][0] = min(dp[i][0], dp[i - 1][0] + 1); &#125; else &#123; dp[i][1] ++; dp[i][0] = min(dp[i][0], dp[i - 1][0] + 1); &#125; &#125; cout &lt;&lt; min(dp[n][0], dp[n][1]) &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 主要难在设计状态（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Pinely Round 2 Div. 1 + 2</title>
    <url>/blog/posts/1362040354/</url>
    <content><![CDATA[Contestant~. Rank 1909. Rating -24. A. Channel 题意 定义每个人上线都会阅读所有帖子。 现在，\(A\) 发布了一篇文章，发布的时候。 给定由 "+", "-" 组成的字符串，分别代表该时刻有一个人上线/下线，按照下面的方式输出答案： 所有人都阅读过该文章，输出 \(YES\)； 有可能所有人都阅读过该文章，输出 \(MAYBE\)； 所有人都不可能阅读过该文章，输出 \(NO\) 思路 所有人都阅读过的条件是假设下线后上线的是同一个人，有可能所有人都阅读过的条件是假设下线后上线的是不同的人。 否则就是不可能。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, m, q; cin >> n >> m >> q; string s; cin >> s; int cur1 = 0, cur2 = 0; for(int i=0;i&lt;q;i++)&#123; if(m + cur1 == n) &#123; cout &lt;&lt; "YES\n"; return; &#125; if(s[i] == '-') cur1 --; else&#123; cur1 ++, cur2 ++; &#125; &#125; if(m + cur1 == n) &#123; cout &lt;&lt; "YES\n"; return; &#125; cout &lt;&lt; (m + cur2 >= n ? "MAYBE\n" : "NO\n"); &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 但是很抽象（ B. Split Sort 题意 给定一个排列 \(p\)，定义一次操作为： 选定一个数 \(x \in [2, n]\)； 在不改变顺序的条件下，将小于 \(x\) 的元素放在左边，将剩余的元素放在右边 输出最小操作数，使对于所有 \(i \in [1, n]\)，有 \(p_i = i\)。 思路 显然，对于 \(a_i = k, a_j = k + 1\)，如果 \(i &gt; j\)，那么我们就得选择 \(x = k + 1\) 并执行一次操作。 观察可得，上面的操作方案即可让方案数最小。 具体来说，我们令 \(a_{p_i} = i\)，然后统计 \(a_i &gt; a_{i + 1}\) 的个数即可。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1), pos(n + 1); for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; pos[a[i]] = i; &#125; int ans = 0; for(int i=1;i&lt;=n;i++)&#123; if(pos[i] > pos[i - 1]) continue; ans ++; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 思维题（ C. MEX Repetition 题意 给定一个序列，定义一次操作如下： 遍历 \(i \in [1, n]\)； 对于 \(a_i\)，将其替换为 \(MEX(a_1, a_2, \ldots , a_{i - 1}, a_{i + 1}, \ldots, a_n)\)。 输出 \(k\) 次操作后的序列。 思路 观察可得，执行一次操作后等价于将其变为 \(\{MEX(a_2, a_3, \ldots , a_n), a_1, a_2, \ldots, a_{n - 1}\}\)。 如果我们将 \(MEX(a_2, a_3, \ldots , a_n)\) 放到序列的最后，整道题就等价于：将这个序列循环右移 \(k\) 位后，输出前 \(n\) 个数。 显然，循环右移是的周期是 \(n + 1\)，那么我们只需将 \(k \ \% = (n + 1)\)。 我们可以将 \([1, n + 1]\) 复制一份到 \([n + 2, 2n + 2]\)，最后输出 \([n - k + 2, 2n - k + 1]\) 内的数即可。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(2 * n + 4); vector&lt;bool> st(n + 1); for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; st[a[i]] = true; &#125; int p = 0; for(int i=1;i&lt;=n;i++)&#123; if(st[i]) continue; p = i; break; &#125; a[n + 1] = p; for(int i=1;i&lt;=n + 1;i++) a[n + i + 1] = a[i]; k %= (n + 1); for(int i=1;i&lt;=n;i++)&#123; cout &lt;&lt; a[n - k + i + 1] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 找规律题（ D. Two-Colored Dominoes 题意 给定由若干个两格长的多米诺骨牌拼成的图形，该图形位于一个点阵中。 骨牌可以横向放置，也可以竖向放置，分别如下所示： .... ... .LR. .U. .... .D. .... ... 现在，给定点阵，按下面的要求涂色： 每个骨牌有白色方块和黑色； 每行黑白方块个数相等； 每列黑白方块个数相等 若无法涂色，输出 \(-1\)。 思路 如果我们单独考虑 "LR" 和 "UD"，不难发现两者是互相不影响的。 换句话说，"LR" 的多少不影响当前行的黑白配对，"UD" 的多少不影响当前列的黑白配对。 因而，我们只需单独对两者进行操作，且操作是随意的，对于 \(j\) 列，我们将所有的 "L" 交叉插入黑白，对于 \(i\) 行，我们将所有 "U" 交叉插入黑白。 自然，如果某一列可以涂色的方块个数为奇数，或者某一行可以涂色的方块个数为奇数，那么就是无解。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, m; cin >> n >> m; vector&lt;string> s(n); for(int i=0;i&lt;n;i++) &#123; cin >> s[i]; &#125; for(int i=0;i&lt;n;i++)&#123; int cnt = 0; for(int j=0;j&lt;m;j++)&#123; if(s[i][j] != '.') cnt ++; &#125; if(cnt % 2 == 1)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; &#125; for(int j=0;j&lt;m;j++)&#123; int cnt = 0; for(int i=0;i&lt;n;i++)&#123; if(s[i][j] != '.') cnt ++; &#125; if(cnt % 2 == 1)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; &#125; auto res = s; for(int j = 0;j &lt; m;j++) &#123; bool f = true; for (int k = 0; k &lt; n; k++) &#123; if (res[k][j] == 'L') &#123; if (f) &#123; res[k][j] = 'W', res[k][j + 1] = 'B'; &#125; else &#123; res[k][j] = 'B', res[k][j + 1] = 'W'; &#125; f = !f; &#125; &#125; &#125; for(int i = 0;i &lt; n;i++) &#123; bool f = true; for (int k = 0; k &lt; m; k++) &#123; if (res[i][k] == 'U') &#123; if (f) &#123; res[i][k] = 'W', res[i + 1][k] = 'B'; &#125; else &#123; res[i][k] = 'B', res[i + 1][k] = 'W'; &#125; f = !f; &#125; &#125; &#125; for(auto e : res) cout &lt;&lt; e &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 一起涂就寄咯 E. Speedrun 题意 给定 \(n\) 个任务，每个任务 \(i\) 必须在每一个 游戏日 的 \(h_i\) 小时时刻完成，且每个人物只需完成一次。 上述 游戏日 为给定的 \(k\) 小时。 现在，给定 \(n\) 个限制 \((a_i, b_i)\)，每个限制代表任务 \(b_i\) 必须在任务 \(a_i\) 完成后才能完成。保证没有环。 输出 最后一个任务完成的时刻 与 第一个任务完成的时刻 的 差值 的最小值。 思路 首先，任务之间的依赖性，不难让我们想到拓扑序，我们可以以 \(a_i \rightarrow b_i\) 的建图方式，先跑一遍拓扑排序，得到拓扑序 \(q\)。 那么显然，后面的任务依赖于前面的任务。 那么如果我们定义 \(dp[i]\) 为 \(i\) 任务及其所有子任务完成的总时间，就有 \(dp[x] = \max(dp[x], dp[y] + (h[y] - h[x] + k) \bmod k):x \to y\)。 如果我们只要求最后一个任务完成的时刻，那么此时问题已经解决了，也就是 \(\max(dp[x])\)。 但我们需要求的是差值，也就是说，可能存在某两个依赖的任务的相差时间大于 \(k\) 的情况，导致第一个任务完成时间偏小，造成答案偏大。 不难发现，我们只需从小到大枚举 \(h_i\)，并将其加上 \(k\) 即可，因为相差时间不会超过 \(2k\)。 那么，我们只需维护当前 \(dp_{max}\) 以及第一个任务完成的时刻即可。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, m, k; cin >> n >> m >> k; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; vector&lt;vector&lt;int>> e(n); vector&lt;int> in(n); while(m --)&#123; int u, v; cin >> u >> v; u --, v --; e[u].pb(v); in[v] ++; &#125; vector&lt;int> q; for(int i=0;i&lt;n;i++)&#123; if(in[i] == 0) q.pb(i); &#125; for(int i=0;i&lt;n;i++)&#123; int x = q[i]; for(auto y : e[x])&#123; if(-- in[y] == 0) q.pb(y); &#125; &#125; vector&lt;int> dp(n); for(int i=n-1;i>=0;i--)&#123; int x = q[i]; for(auto y : e[x])&#123; dp[x] = max(dp[x], dp[y] + (a[y] - a[x] + k) % k); &#125; &#125; for(int i=0;i&lt;n;i++) dp[i] += a[i]; int res = *max_element(all(dp)); vector&lt;int> p(n); iota(all(p), 0); sort(all(p), [&amp;](int o1, int o2) -> bool&#123; return a[o1] &lt; a[o2]; &#125;); int ans = inf; for(auto i : p)&#123; ans = min(ans, res - a[i]); res = max(res, dp[i] + k); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 为什么我会去反向拓扑呢，为什么嘞(x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Harbour.Space Scholarship Contest 2023-2024 Div. 1 + 2</title>
    <url>/blog/posts/2737470781/</url>
    <content><![CDATA[Contestant~. Rank 1201. Rating +25. A. Increasing and Decreasing 题意 给定三个整数 \(x, y, n\)，构造一个长为 \(n\) 的序列 \(a\)，满足： \(a_1 = x, a_n = y\)； \(a_1 &lt; a_2 &lt; \ldots &lt; a_n\)； 记 \(b_i = a_{i + 1} - a_i\)，\(b_1 &gt; b_2 &gt; \ldots &gt; b_{n - 1}\) 如果无法构造，输出 \(-1\)。 思路 既然要尽可能构造出来，那么我们就尽可能缩小相邻 \(b_i\) 的差值，也就是说，\(b_{n - 1} = 1, b_{n - 2} = 2, \ldots\)。 我们令 \(a_n = y\)，然后递推到 \(a_1\)，最后比较一下 \(a_1\) 和 \(x\) 的大小。 显然，如果 \(a_1 &gt; x\)，那么无解，否则就可以满足 \(a_2 - x \geq a_2 - a_1 = b_1 &gt; b2 &gt; \ldots\)。 最后记得设 \(a_1 = x\)。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int x, y, n; cin >> x >> y >> n; vector&lt;int> ans(n + 1); ans[n] = y; for(int i=n-1;i>=1;i--)&#123; ans[i] = ans[i + 1] - (n - i); &#125; if(ans[1] &lt; x) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; cout &lt;&lt; x &lt;&lt; ' '; for(int i=2;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 在多数签到题里有点偏模拟 B. Swap and Reverse 题意 给定一个字符串 \(s\) 以及一个整数 \(k\)，定义一次操作为下面两者任选一： 选择一个点 \(i, i \in [1, n - 2]\)，交换 \(s_i, s_{i + 2}\)； 选择一个点 \(i, i \in [1, n - k + 1]\)，将 \([i, i + k - 1]\) 内的字符串翻转 在任意次操作后，输出字符串的最小字典序。 思路 首先，如果没有操作 \(2\)，那么最后的答案就是分别将奇数位和偶数位上的字符排序。 如果有操作 \(2\)，我们先来考虑 \(k\) 是奇数的情况。 因为我们只能翻转奇数长度的字符，可以发现翻转操作可以等效于若干个操作 \(1\)。 而相反地，如果 \(k\) 是偶数，我们可以将奇数位和偶数位上的数交换，因此在若干次操作后，我们可以将其等效于交换任意两个相邻数。 因而，我们就只需对整个字符串排序。 从而，最后的结论是： \(k\) 为奇数，分别对奇数位和偶数位上的字符排序； \(k\) 为偶数，将整个字符串排序 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; string s; cin >> n >> k >> s; if (k % 2 == 0) &#123; sort(all(s)); cout &lt;&lt; s &lt;&lt; '\n'; return; &#125; string a, b; for (int i = 0; i &lt; n; i++) &#123; if (i % 2 == 0) a += s[i]; else b += s[i]; &#125; sort(all(a)); sort(all(b)); for (int i = 0; i &lt; n; i++) &#123; if (i % 2 == 0) cout &lt;&lt; a[i / 2]; else cout &lt;&lt; b[i / 2]; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 有意思的思维题 C. Divisor Chain 题意 给定整数 \(x\)，定义一次操作为选定 \(x\) 的一个因数 \(y\)，并将 \(x\) 减去 \(y\)。 在不超过 \(1000\) 次操作，且 不 连续 选择 两次以上 相同的因数的条件下，将 \(x\) 减为 \(1\)，并输出一种可行的方案。 思路 我们将其放到二进制下考虑： 从第 \(2\) 位开始向高位枚举； 如果第 \(i\) 位为 \(1\)，那么删去该位，也就是 \(1 &lt;&lt; i\) 上述操作存在缺陷，因为如果出现最低位为 \(0\) 的情况，最后答案会变成 \(0\)。 因此，我们考虑直接从最低位开始枚举删除，直到最高位的前一位。 当我们达到最高位时，可以发现后面低位全都是 \(0\)，也就是说，现在 \(x\) 是 \(2\) 的次方。那么我们只需循环减去 \(\frac{x}{2}\) 即可，最后一定会变为 \(1\)。 时间复杂度：\(O(\log A)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> ans; ans.pb(n); bitset&lt;64> a(n); for(int i=0;i&lt;64;i++)&#123; if(a[i])&#123; if(n == (1ll &lt;&lt; i))&#123; while(n > 1) ans.pb(n /= 2); &#125;else ans.pb(n -= (1ll &lt;&lt; i)); &#125; &#125; cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; \(1000\) 纯属骗人 D. Matrix Cascade 题意 给定一个 \(n \times n\) 的二进制矩阵，定义一次操作为选定一个点 \((x, y)\)，并将满足 \(x - i \ge \left|y - j\right|\) 的所有点 \((i, j)\) 上面的值全都反转。 输出最小操作数，使整个矩阵全变为 \(0\)。 思路 我们不妨观察这样一个三角形： a bcd 我们可以发现，点 \(c\) 只会被点 \(a, b, d\) 影响到，而整个三角形都是 \(a\) 的影响范围。 因而，我们考虑 \(dp[i][j][k]\)，表示 \((i, j)\) 左边的点的状态，右边的点的状态 以及自身的状态。 因为相邻两行的 \(dp\) 具有递推性，所以我们考虑从上一行推到当前行。 那么很显然，左边的点只需考虑向右影响的递推，\(dp[i][j][0] = dp[i - 1][j - 1][0]\)，同理，\(dp[i][j][1] = dp[i - 1][j + 1][1]\)。 因而，\(dp[i][j][2] = dp[i][j][0] + dp[i][j][1] + dp[i - 1][j][2]\)。 如果我们发现 \((i, j)\) 点需要修改，那么我们将 \(dp[i][j][0], dp[i][j][1], dp[i][j][2]\) 都加上 \(1\)，来表征当前点可以影响下一行。 结合图形理解，可以证明上面的递推的合理性。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;string> s(n); for(int i=0;i&lt;n;i++) cin >> s[i]; vector&lt;vector&lt;vector&lt;int>>> dp(n + 2, vector&lt;vector&lt;int>>(n + 2, vector&lt;int>(3))); int ans = 0; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; int now = s[i - 1][j - 1] - '0'; dp[i][j][0] = dp[i - 1][j - 1][0]; dp[i][j][1] = dp[i - 1][j + 1][1]; dp[i][j][2] = dp[i][j][0] + dp[i][j][1] + dp[i - 1][j][2]; if((dp[i][j][2] + now) % 2 == 1)&#123; ans ++; dp[i][j][0] ++, dp[i][j][1] ++, dp[i][j][2] ++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 赛时还想出来个二分的写法，感觉有点抽象，而且常数不小 E. Guess Game 题意 给定序列 \(s\)，定义 \(A, B\) 之间的游戏如下： 均匀随机选择两个数，可以重复，记为 \(a, b\)； 将 \(a, a|b\) 告诉 \(A\)，若 \(A\) 能根据 之前自己和 对手 的猜测 来确定 \(a &lt; b, a &gt; b\) 或 \(a = b\)，那么说出结果并结束游戏，否则说出自己不知道； 将 \(b, a|b\) 告诉 \(B\)，若 \(B\) 能根据 之前自己和 对手 的猜测 来确定 \(a &lt; b, a &gt; b\) 或 \(a = b\)，那么说出结果并结束游戏，否则说出自己不知道； 不断猜测，直到有人说出结果为止 两个人足够聪明。 定义一个人为一轮，输出游戏进行的轮数的期望。 思路 既然两个人足够聪明，那么他们肯定会从高位向低位考虑。 我们来模拟一下过程， 其中，下面的过程会默认将 \(a|b\) "离散化" 为 低位全是 \(1\)，或者说，将所有 \(1\) 挪到最前面： \(A\) 拿到了 \(a, a|b\)，如果 \(a\) 的最高位为 \(0\)，那么直接说出 \(a &lt; b\)，否咋说出自己不知道； \(B\) 拿到了 \(b, a|b\)，如果 \(b\) 的最高位或者次高位 至少有一个 为 \(0\)，那么因为 \(A\) 说自己不知道，就可以断定最高位一定是 \(1\)，那么直接说出 \(a &gt; b\)，否则说出自己不知道； 如果 \(a\) 的次高位或者 次 次高位 至少有一个 为 \(0\)，那么因为 \(B\) 说自己不知道，就可以断定 最高位 和 次高位 一定是 \(1\)，那么直接说出 \(a &lt; b\)，否则说出自己不知道； \(\ldots\) 因而，最后我们可以推导出结论： 从高位向低位枚举所有 \(a|b\) 为 \(1\) 的二进制位； 如果 \(a &lt; b\)，并且 \(a\) 的第 \(i\) 位是 \(0\)，那么进行了 \(i + (i \bmod 2 == 0)\) 轮； 如果 \(a = b\)，那么进行了 \(k + 1\) 轮，其中 \(k\) 为 \(a | b\) 中有多少个 \(1\)。 如果 \(a &gt; b\)，并且 \(b\) 的第 \(i\) 位是 \(0\)，那么进行了 \(i + (i \bmod 2 == 1)\) 轮 如上，我们得到了复杂度为 \(O(n ^ 2 \log A)\) 的暴力算法。 我们考虑使用 \(\mathtt{01}\) 字典树来优化复杂度。 具体来说，在 \(\mathtt{dfs}\) 的时候，我们可以记录当前路径上有多少个 \(1\)，并可以轻松获取当前点是否同时具有 \(0, 1\) 节点，或同时不具有 \(0, 1\) 节点。 前者可以构造出大小关系，后者可以构造出相等关系。 将公式略微修改即可得到答案。 当然，不要忘记除 \(n^2\)，也就是总方案数。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; struct Node &#123; int nxt[2], cnt; Node() &#123; nxt[0] = nxt[1] = -1; cnt = 0; &#125; &#125;; vector&lt;Node> tr; void insert(int x)&#123; int now = 0; for(int i= 31; i >= 0;i--) &#123; int p = (x >> i) &amp; 1; if(tr[now].nxt[p] == -1) &#123; tr[now].nxt[p] = tr.size(); tr.pb(); &#125; tr[now].cnt ++, now = tr[now].nxt[p]; &#125; tr[now].cnt ++; &#125; void query(int v, int k, int &amp;ans)&#123; if(v == -1) return; //存在某一位上一个为0一个为1的情况 if(tr[v].nxt[0] != -1 &amp;&amp; tr[v].nxt[1] != -1)&#123; int cnt = tr[tr[v].nxt[0]].cnt * tr[tr[v].nxt[1]].cnt % mod; ans = (ans + cnt * (2 * ((k + 1) / 2) + 1) % mod) % mod; //a &lt; b ans = (ans + cnt * 2 % mod * ((k + 2) / 2) % mod) % mod; //a > b &#125; //一模一样的情况 if(tr[v].nxt[0] == -1 &amp;&amp; tr[v].nxt[1] == -1)&#123; ans = (ans + (k + 1) * tr[v].cnt % mod * tr[v].cnt % mod) % mod; &#125; query(tr[v].nxt[0], k, ans); query(tr[v].nxt[1], k + 1, ans); &#125; static __int128 qp(__int128 x, __int128 y, __int128 m = mod) &#123; static __int128 ans; ans = 1, x %= m; for (; y; y >>= 1, x = x * x % m) if (y &amp; 1) ans = ans * x % m; return ans; &#125; int inv(int n, int m = mod) &#123; return qp(n, m - 2, m); &#125; void solve() &#123; int n; cin >> n; tr = &#123;&#125;; tr.pb(); for(int i=0;i&lt;n;i++)&#123; int x; cin >> x; insert(x); &#125; int ans = 0; query(0, 0, ans); ans = ans * inv(n * n) % mod; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 不要尝试用 \(memset\) 初始化字典树 qaq]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 894 Div. 3</title>
    <url>/blog/posts/1214857219/</url>
    <content><![CDATA[Contestant_. Rank 245. Rating +76 (+326 -250). A. Gift Carpet 题意 给定一个 \(n \times m\) 的字符矩阵，判断是否能找出四列，满足这四列按顺序分别包含 "v,i,k,a"。 思路 既然要按顺序，那么我们直接从左向右遍历，从 上一次找到的列 之后 开始 找下一个字符第一次出现的列 即可。 时间复杂度：\(O(nm)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m; cin >> n >> m; vector&lt;string> s(n); for(int i=0;i&lt;n;i++)&#123; cin >> s[i]; &#125; int ind = 0; bool ok = false; string fd = "vika"; for(int i=0;i&lt;m;i++)&#123; bool f = false; for(int j=0;j&lt;n;j++)&#123; if(s[j][i] == fd[ind])&#123; f = true; break; &#125; &#125; if(f)&#123; ind ++; &#125; if(ind == 4) &#123; ok = true; break; &#125; &#125; cout &lt;&lt; (ok ? "YES\n" : "NO\n"); &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 一定要有序 B. Sequence Game 题意 对于长为 \(p\) 的序列 \(a\)，定义序列 \(b\) 的构造方式如下： 将 \(a_1\) 放入序列 \(b\)； 枚举 \(i \in [2, p]\)，如果 \(a_{i - 1} \leq a_i\)，那么将 \(a_i\) 放入序列 \(b\)。 现在，给定序列 \(b\)，构造出任意符合条件的序列 \(a\)，且满足 \(a\) 的长度不超过 \(b\) 长度的两倍。 思路 既然要满足 \(a_{i - 1} \leq a_i\)，那么如果我们遍历的时候发现 \(b_{i - 1} &gt; b_i\)，我们直接在 \(b_i\) 前面多放一个 \(b_i\) 即可。 否则，我们就只需按顺序放入 \(b_i\)。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; vector&lt;int> ans; ans.pb(a[1]); for(int i=2;i&lt;=n;i++) &#123; if (a[i] >= a[i - 1])ans.pb(a[i]); else &#123; ans.pb(a[i]); ans.pb(a[i]); &#125; &#125; cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 放 \(1\) 应该也是可以的 C. Flower City Fence 题意 给定不递增序列 \(a\)，\(a_i\) 代表从左往右第 \(i\) 列方块的高度。 判断整个图形是否与过左下角的对角线对称，如下图： 思路 显然，如果某一列的高度为 \(a_i\)，那么将其横着放后，\([1, a_i]\) 区域内的高度都会 \(+1\)。 因而，我们考虑差分，最后比较高度即可。 注意特判，防止数组越界。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1), d(n + 2); for(int i=1;i&lt;=n;i++) cin >> a[i]; if(a[1] > n)&#123; cout &lt;&lt; "NO\n"; return; &#125; for(int i=1;i&lt;=n;i++)&#123; d[1] ++; d[a[i] + 1] --; &#125; for(int i=1;i&lt;=n;i++)&#123; d[i] += d[i - 1]; if(a[i] != d[i])&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 有趣的题 D. Ice Cream Balls 题意 定义 \(&lt;x, y&gt;\) 为无序对，即 \(&lt;2,3&gt;\ =\ &lt;3,2&gt;, &lt;1,1&gt;\ =\ &lt;1,1&gt;\)。 对于一个序列 \(a\)，其不同无序对的个数是确定的。 现在，给定不同的无序对的个数，输出序列 \(a\) 的最短长度。 思路 令序列 \(a\) 中共有 \(x\) 种数字，其中 \(y\) 种数字的数量 \(\geq 2\)，那么 \(cnt = C_x^2 + y\)。 我们可以二分，或者求出接近正解的 \(x\) 的值。 化简式子，我们可以得到 \(x(x-1) = 2 \times (cnt - y)\)。 可得 \(x \geq \sqrt {2 \times cnt}\)。 然后我们暴力求出正解即可。 时间复杂度：\(O(玄学)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; template&lt;class T> T ex_sqrt(T x) &#123; //返回精度更高的sqrt T sqrtX = sqrt(x) - 1; while (sqrtX + 1 &lt;= x / (sqrtX + 1)) sqrtX++; return sqrtX; &#125; void solve() &#123; int n; cin >> n; int k = max(0ll, ex_sqrt(2 * n)); while (k * (k - 1) &lt;= 2 * n) k++; k --; k += (n - k * (k - 1) / 2); cout &lt;&lt; k &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 糟糕的题面 E. Kolya and Movie Theatre 题意 给定序列 \(a\)，定义可从中最多选 \(m\) 个元素，价值为 \(a_i - d \times t\)，其中 \(d\) 给定，\(t\) 为距上一个选择的元素的下标差。 序列下标从 \(1\) 开始，特别地，在选择之前，"第 \(0\) 个元素默认被选择"。 输出最大价值之和。 思路 题目等价于：选择最多 \(m\) 个元素，总和为 \(sum\)，其中最后一个元素的下标为 \(p\)，最后答案即为 \(sum - d \times p\)。 最后一个元素的下标是可以枚举的，那么我们只需快速算出前 \(p\) 个元素中最大的前 \(m\) 个最大数的和即可。 我们考虑使用 \(\mathtt{multiset}\) 维护即可。 注意长度超过 \(m\) 后的增删操作。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m, d; cin >> n >> m >> d; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; int ans = 0; multiset&lt;int> st; int sum = 0; for(int i=1;i&lt;=n;i++)&#123; if(a[i] &lt; 0) continue; if(st.size() == m)&#123; if(*st.begin() > a[i]) continue; sum -= *st.begin(); st.extract(st.begin()); &#125; st.emplace(a[i]); sum += a[i]; ans = max(ans, sum - d * i); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 题面还是看了好久才看懂 F. Magic Will Save the World 题意 给定两种法术，每一个时刻，两种法术分别会提高 \(w, f\) 点。 给定 \(n\) 个怪物，消灭第 \(i\) 个怪物需要 \(a_i\) 点法术，且不可以同时使用两种法术。 输出最早在哪个时刻能把所有怪消灭。 思路 题目等价于：输出最小的\(t\)，满足对于容量为 \(w \times t\) 的背包 \(1\) 和容量为 \(f \times t\) 的背包 \(2\)，恰好能分别将所有物品装下。 那么如果 \(t\) 更大，能装下的物品自然就更多，满足单调性。 因而我们考虑二分答案。 在检查答案的时候，我们可以直接用 \(\mathtt{bitset}\) 优化 \(\mathtt{01}\) 背包。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int w, f, n; cin >> w >> f >> n; vector&lt;int> a(n + 1); int sum = 0; bitset&lt;1000010> dp; dp.set(0); for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; sum += a[i]; dp |= (dp &lt;&lt; a[i]); &#125; auto check = [&amp;](int mid) -> bool&#123; for(int i=0;i&lt;=sum;i++)&#123; if(dp[i]) &#123; if((i &lt;= w * mid &amp;&amp; sum - i &lt;= f * mid) || (sum - i &lt;= w * mid &amp;&amp; i &lt;= f * mid))&#123; return true; &#125; &#125; &#125; return false; &#125;; int l = 1, r = 1e9, mid; while(l &lt; r)&#123; mid = (l + r) >> 1; if(check(mid)) r = mid; else l = mid + 1; &#125; cout &lt;&lt; l &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 其实不用这两个优化好像也行 G. The Great Equalizer 题意 对于一个数组，定义其 值 的计算方式如下： 升序排序并去重； 如果数组长度等于 \(1\)，那么跳出循环，剩下的元素就是 数组的值； 将 \(\{n, n - 1, \ldots , 1\}\) 依次加到数组各个元素上，其中 \(n\) 为数组当前的长度 现在，对于 \(q\) 次 非独立 询问，每次询问给定 \(i, x\)，并将数组的第 \(i\) 个元素修改为 \(x\)，输出修改后 数组的值。 思路 我们不妨打表，可以发现，每一次循环后，数组的最大相邻元素差值 恰好减少了 \(1\)。 那么，循环的次数只和 数组的最大相邻元素差值 有关。 至于最大的元素，从值的角度看，可以发现它始终是最大的，因而最后他被加上了 数组的最大相邻元素差值。 因而，我们可以发现规律：最后的答案为 数组的最大相邻元素差值 \(+\) 数组的最大元素。 至于维护答案，我们可以用两个 \(\mathtt{multiset}\)，其中第一个维护值，第二个维护差值。 我们可以发现，修改一个元素，等价于删掉原来的元素，并加入一个新元素。 那么，以加入元素为例，我们在 \(a, b\) 中间插入一个 \(c\)，那么差值集合就需要删掉 \(b - a\)，并添加 \(b - c, c - a\)。当然我们需要判断插入的位置，因为可能会插在序列的头部或者尾部。 对于元素位置的获取，其实是很方便的，因为 \(\mathtt{insert, emplace}\) 方法都会返回插入后元素的位置。 同样的，对于删除，我们只需执行相反操作即可。 时间复杂度：\(O((n + 2q) \log n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); multiset&lt;int> dis&#123;0&#125;, val; for(int i=1;i&lt;=n;i++) cin >> a[i]; //multiset模拟链表 auto add = [&amp;](int x) -> void&#123; auto cur = val.ep(x), nxt = next(cur); if(cur != val.begin())&#123; dis.ep(x - *prev(cur)); &#125; if(nxt != val.end())&#123; dis.ep(*nxt - x); &#125; if(cur != val.begin() &amp;&amp; nxt != val.end())&#123; dis.extract(*nxt - *prev(cur)); &#125; &#125;; auto del = [&amp;](int x) -> void&#123; auto cur = val.find(x), nxt = next(cur); if(cur != val.begin())&#123; dis.extract(x - *prev(cur)); &#125; if(nxt != val.end())&#123; dis.extract(*nxt - x); &#125; if(cur != val.begin() &amp;&amp; nxt != val.end())&#123; dis.ep(*nxt - *prev(cur)); &#125; val.erase(cur); &#125;; for(int i=1;i&lt;=n;i++) add(a[i]); int q; cin >> q; while(q --)&#123; int x, y; cin >> x >> y; del(a[x]); a[x] = y; add(a[x]); cout &lt;&lt; *val.rbegin() + *dis.rbegin() &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 其实就像链表一样吧（?]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 153</title>
    <url>/blog/posts/3711114285/</url>
    <content><![CDATA[Contestant~ Rank 1115. Rating +1. 又是一个疯狂叉人场 A. Not a Substring 题意 给定一个长为 \(n\) 的 不一定合法的 括号字符串 \(S\)，构造一个长为 \(2n\) 的 合法 括号字符串 \(T\)，满足 \(S\) 不是 \(T\) 的子串。 思路 可以发现，只要 \(S\) 中存在连续的 \(((\) 或者 \())\)，我们就只需构造 \(()()()\ldots\)。 如果 \(S\) 不满足上述的条件，那么我们就构造存在连续 \(((\) 或者 \())\) 的 \(T\)，即 \((((\ldots)))\ldots\)。 显然，只有 \(()\) 无法构造。 上述操作也可以更改为： 特判 \(()\)； 构造 \((((\ldots)))\ldots\)； 判断是否为子串； 是则输出，否则改为 \(()()()\ldots\)。 至于判断子串，直接判断 \(S\) 是否是由连续的 \((((\ldots\) 和连续的 \()))\ldots\) 拼接而成即可。 当然，也可以直接无脑 \(\mathtt{KMP}\)，复杂度可行。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; string s; cin >> s; int n; n = s.size(); if(s == "()")&#123; cout &lt;&lt; "NO\n"; &#125;else&#123; cout &lt;&lt; "YES\n"; bool f = false; int ind = 0; for(;ind&lt;n;ind++)&#123; if(s[ind] == ')')&#123; break; &#125; &#125; for(;ind&lt;n;ind++)&#123; if(s[ind] == '(')&#123; f = true; break; &#125; &#125; if(f)&#123; for(int i=0;i&lt;n;i++) cout &lt;&lt; "("; for(int i=0;i&lt;n;i++) cout &lt;&lt; ")"; cout &lt;&lt; '\n'; &#125;else&#123; for(int i=0;i&lt;n;i++) cout &lt;&lt; "()"; cout &lt;&lt; '\n'; &#125; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 能让人想到 \(\mathtt{KMP}\) 还是很逆天的 B. Fancy Coins 题意 给定总额 \(m\) 元，购买下面所属的硬币，使 花哨硬币 花费数量尽可能少，并满足最后没有钱剩余： 花费 \(1\) 元的硬币：\(a_1\) 个常规硬币，无限多个花哨硬币； 花费 \(k\) 元的硬币：\(a_k\) 个常规硬币，无限多个花哨硬币 输出最少的数量。 思路 首先，既然要尽量不使用花哨硬币，我们自然会尽可能多使用 \(k\) 元的硬币。 因此，我们可以先算出全都使用 \(k\) 后的代价，然后将部分硬币换为用使用 \(1\)，从而得到答案。 显然我们不可以暴力搜索，但上述可以进行分类讨论推出式子。 \(a_0 + k \times a_k \geq m\)，此时我们可以发现，花费 \(k\) 元的常规硬币一定是够用的，而因为需要最后没有钱剩余，我们就需要比较我们还需多少个 \(1\) 元花哨硬币，而不是输出 \(0\)； \(a_0 + k \times a_k &lt; m\)，此时我们可以发现，我们还需使用 \(d = m - (a_0 + k \times a_k)\) 个硬币，那么我们尽可能多使用 \(k\)，剩余的用 \(1\)，然后和情况 \(1\) 一样，判断一下即可 这题也可以用三分搜索 时间复杂度：\(O(1)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int m, k, a0, ak; cin >> m >> k >> a0 >> ak; int sum = a0 + k * ak; if (m &lt;= sum) &#123; cout &lt;&lt; max(0ll, max(m - k * ak, m % k) - a0) &lt;&lt; '\n'; return; &#125; int d = m - sum, w = d / k + d % k; int t = d % k == 0 ? 0 : k - d % k; if (a0 >= t) w = min(w, d / k + 1); cout &lt;&lt; w &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 分讨分讨 C. Game on Permutation 题意 给定一个排列 \(p\) 以及一个标签，定义 \(A, B\) 之间的游戏为： 当前标签位于 \(i\)； 选定一个下标 \(j\)，满足 \(j &lt; i, p_j &lt; p_i\)； 将标签移动到 \(j\)； 不能移动 的一方 赢 现在，由 \(A\) 决定标签的初始位置，然后由 \(B\) 先手开始游戏。 如果 \(A\) 决定 \(i\) 为标签的初始位置，并满足它有必胜策略，那么该点 \(i\) 为 幸运点。 输出 幸运点 的个数。 思路 首先，形象地说，对于一个点 \(i\)，必胜的条件就是以 \(i\) 结尾的 最长 不一定连续 递增 子序列 的长度为 \(2\)。 上述条件可以转化为：当前位置 \(i\)，对应的值 \(p_i\) 满足： 大于 \(p_{[1, i - 1]}, n + 1\) 中的最小值； 小于 \(p_{[2, i - 1]}, n\) 中的最小值 \(+ 1\) \(p_i \neq 1\) 可以使用数据结构维护，也可以直接用两个变量记录。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; set&lt;int> st; st.emplace(n + 1); int ans = 0; int mn = n + 1; for(int i=1;i&lt;=n;i++)&#123; if(*st.begin() &lt; a[i])&#123; if(mn > a[i] &amp;&amp; a[i] != 1) ans ++; mn = min(mn, a[i] + 1); &#125; st.emplace(a[i]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 丢两个线段树上去是最抽象的 D. Balanced String 题意 给定一个二进制字符串 \(s\)，定义一次操作为选定 \(i, j, i &lt; j\) 并交换 \(s_i, s_j\)。 输出让字符串中所有长为 \(2\) 的 不一定连续 子序列中 \(01, 10\) 个数相等所需的最小操作数。 思路 首先，如果你想到了类似贪心的思路，请使用下面的强样例验证你的代码： in: 0011110101001010000000000111100101011110100111001011000101111111010011001000110010110110001101110111 Out: 2 上述样例几乎叉掉了所有的贪心写法。 既然不可以用贪心，我们自然考虑 \(dp\)。 定义 \(dp[i][j][k]\) 为 前 \(i\) 个数中包含 \(j\) 个 \(0\) 和 \(k\) 个 \(01\) 串所需 修改 的最小数量，那么状态很好推： 在 \(i\) 位置放上 \(1\)，那么会多出 \(j\) 个 \(01\) 串，此时 \(dp[i + 1][j][k + j] = dp[i][j][k] + p\)； 在 \(i\) 位置放上 \(0\)，那么会多出 \(1\) 个 \(0\)，此时 \(dp[i + 1][j + 1][k] = dp[i][j][k] + p\) 上述的 \(p\) 取决于放上的数和原来位置的数是否相等，相等为 \(0\)，不等为 \(1\)。 那么，最后 \(dp[n][cnt0][cnt0 \times (n - cnt0)]\) 就是最少修改次数。 至于最后的答案，我们注意一下边界情况的赋值，那么就可以满足修改是成对的，最后答案就只需 \(÷2\)。 时间复杂度：\(O(n ^ 4)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; string s; cin >> s; int n = s.size(); s = " " + s; vector&lt;vector&lt;vector&lt;int>>> dp(2, vector&lt;vector&lt;int>>(n + 1, vector&lt;int>(n * n * 2 + 1))); int cnt0 = 0; for(int i=1;i&lt;=n;i++)&#123; if(s[i] == '0') cnt0 ++; for(int j=0;j&lt;i+1;j++)&#123; for(int p=0;p&lt;=j * (i + 1 - j);p++)&#123; dp[1][j][p] = n; &#125; &#125; for(int j=0;j&lt;i;j++)&#123; for(int p=0;p&lt;=j * (i - j);p++)&#123; dp[1][j + 1][p] = min(dp[1][j + 1][p], dp[0][j][p] + (s[i] == '1')); dp[1][j][p + j] = min(dp[1][j][p + j], dp[0][j][p] + (s[i] == '0')); &#125; &#125; swap(dp[0], dp[1]); &#125; cout &lt;&lt; dp[0][cnt0][cnt0 * (n - cnt0) / 2] / 2 &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 叉掉这么多人，直接从 \(-10\) 变成 \(+1\)。]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 893 Div. 2</title>
    <url>/blog/posts/4207496731/</url>
    <content><![CDATA[Contestant~. Rank 955. Rating +11. 有种瓶颈期的美 A. Buttons 题意 给定三种只能按一次的按钮，按钮 \(a\) 只能被 \(First\) 按，按钮 \(b\) 只能被 \(Second\) 按下，按钮 \(c\) 能被两个人按下。 无法按按钮的玩家输。输出赢者。 思路 \(First\) 能按 \(a + \lceil \frac{c}{2} \rceil\) 个按钮，\(Second\) 能按 \(b + \lfloor \frac{c}{2} \rfloor\) 个按钮，比较大小即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int a, b, c; cin >> a >> b >> c; c %= 2; a += c; cout &lt;&lt; (a &lt;= b ? "Second\n" : "First\n"); &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 当然不是 \(a+b+c\) 的奇偶性了 B. The Walkway 题意 给定一个数轴，数轴上有 \(m\) 个点上有卖家。 \(A\) 从 \(1\) 走到 \(n\)，定义满足下面的任意一个条件，\(A\) 会在当前位置 \(i\) 吃一个饼干： 还没吃过饼干； 当前位置有卖家； 在 \([\max(1, i - d + 1), i - 1]\) 区间内没吃饼干 现在，输出移走一个卖家后，吃饼干的数量最小值，以及对应的移除方案数。 思路 这是一个思路很清楚但特判比较多的模拟题，但题面表述我只能说 \(\mathtt{no}\) \(\mathtt{comment}\)。 首先，条件 \(1\) 就等价于，\(A\) 在点 \(1\) 一定会吃饼干。 其次，剩下的两个条件可以合并为，在有卖家的位置都会吃饼干，并且对于所有相邻的卖家的距离 \(D\)，会 多出 \(\frac{D - 1}{d}\) 个吃饼干的点。 如果要让吃饼干的数量减少，我们就得枚举三个卖家，将中间的卖家去掉后，得到的叠加距离不会使 多出的吃饼干的点 增加。 我们还得对点 \(n\) 进行单独处理，因为可能在走到 \(n\) 前，又出现了长度大于 \(d\) 的情况。 如上，我们先预处理出不移走卖家的饼干数，然后三个三个枚举即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m, d; cin >> n >> m >> d; vector&lt;int> s(m + 1); for(int i=1;i&lt;=m;i++) cin >> s[i]; int sum = 0; vector&lt;int> cnt(m + 2); for(int i=1;i&lt;=m;i++)&#123; if(i == 1)&#123; if(s[1] == 1)&#123; sum ++; cnt[1] = 1; &#125;else&#123; sum += (s[1] - 1 - 1) / d + 2; cnt[1] += (s[1] - 1 - 1) / d + 2; &#125; &#125;else&#123; sum += (s[i] - s[i - 1] - 1) / d + 1; cnt[i] += (s[i] - s[i - 1] - 1) / d + 1; &#125; if(i == m)&#123; sum += (n - s[i]) / d; cnt[m + 1] += (n - s[i]) / d; &#125; &#125; int ans = inf, tot = 0; for(int i=1;i&lt;=m;i++)&#123; int now; if(i == 1)&#123; now = sum - (cnt[i] + cnt[i + 1]) + (s[i + 1] - 1 - 1) / d + 1 + 1; &#125;else if(i == m)&#123; now = sum - (cnt[i] + cnt[i + 1]) + (n - s[i - 1]) / d; &#125;else&#123; now = sum - (cnt[i] + cnt[i + 1]) + (s[i + 1] - s[i - 1] - 1) / d + 1; &#125; if(ans > now)&#123; ans = now; tot = 1; &#125;else if(ans == now)&#123; tot ++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; tot &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 不予置评 C. Yet Another Permutation Problem 题意 给定排列的长度 \(n\)，构造排列，满足将其首尾相连后，相邻数的 \(gcd\) 的不同数量最大。 思路 很显然，我们先在开头置 \(1\)，然后枚举 \(x \in [2, \inf]\)。 对于 \(x\)，我们循环乘 \(2\)，并将其放入排列中，如果遇到之前放进去的数，我们直接跳出循环。 上述贪心的正确性是很显然的，因为更小的数拥有更多的在范围内的倍数，并且 \(2\) 是我们最小可以乘上的数。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> ans; vector&lt;bool> vis(n + 10); int cur = 2; ans.pb(1); while (ans.size() &lt; n) &#123; int t = cur; vis[cur] = true; while (t &lt;= n) &#123; ans.pb(t); vis[t] = true; t *= 2; &#125; while (vis[cur]) &#123; cur++; &#125; &#125; for (auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 《Div. 2 C》 D. Trees and Segments 题意 给定一个长为 \(n\) 的二进制字符串，定义操作为选定一个字符，并将其反转。 在不超过 \(k\) 次操作的条件下，得到最大连续 \(0\) 的长度 \(l_0\)，最大连续 \(1\) 的长度 \(l_1\)。 在所有可能的操作中，对 \(a \in [1, n]\)，输出 \(a \times l_0 + l_1\) 的最大值。 思路 我们定义 \(len[i]\) 为 操作后 最大的连续 \(1\) 的长度为 \(i\)，且该条件下最大的连续 \(0\) 的长度为 \(len[i]\)。 其中，我们可以用 \(O(n ^ 2)\) 的复杂度，遍历所有的连续区间，并得到将每个区间所有数都改为 \(1\) 需要的操作数 \(x\)，通过操作数 \(x\) 来计算答案。 我们以一个区间为例，如果该区间内，我们操作了 \(x\) 次来让所有数都变成 \(1\)，那么我们就剩下 \(k - x\) 次操作提供给拓展连续 \(0\) 的操作。并且 我们一定会将这 \(k-x\) 次操作都用完，因为这样可以最大化答案。 显然，因为最长的连续 \(0\) 一定在该区间的左边或者右边，那么我们考虑维护一个前缀 \(pre[i][j]\) 和后缀 \(suf[i][j]\)，分别代表 前 \(i\) 个数 操作了 \(j\) 次后 最长的 连续 \(0\) 区间 的长度，以及 后 \(i\) 个数中 操作了 \(j\) 次后 最长的 连续 \(0\) 区间 的长度。 那么，对于区间 \([i + 1, j - 1]\)，操作了 \(x\) 次，\(len[j - i] = \max(len[j - i], \max(pre[i][k - x], suf[j][k - x]))\)。 接下来，我们考虑如何递推。 我们遍历 \(i \in [1, n], j \in [i + 1, n + 1]\)，满足区间 \([i + 1, j - 1]\) 内所有元素都是 \(0\)，那么 我们可以在遍历的时候 处理出 当前区间需要操作几次 以达到 全变成 \(1\) 的目标。 我们记操作数为 \(x\)，那么前 \(j\) 个数中，操作 \(x\) 次后 最大连续 \(0\) 的长度至少为 \(j - i\)，后 \(i\) 个数同理。 也就是说，\(pre[j][x] = \max(pre[j][x], j - i), suf[i][x] = \max(suf[i][x], j - i)\)。 处理完成后，我们得到的 \(pre[i][j]\) 为以 \(i\) 结尾的，操作 \(j\) 次得到的 最大连续 \(0\) 的长度，后缀同理。 我们以前缀为例，继续递推，以得到我们需要的前缀： 如果我们不操作，那么我们从 前 \(i-1\) 个字符 且 操作 \(j\) 次 递推状态； 如果我们操作，那么我们从 前 \(i\) 个字符 且 操作 \(j - 1\) 次 递推状态 根据我们最开始的处理，我们只需在递推的时候取最大值即可。 时间复杂度：\(O(nk + n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; string s; cin >> s; s = " " + s; vector&lt;vector&lt;int>> pre(n + 2, vector&lt;int>(k + 1)), suf(n + 2, vector&lt;int>(k + 1)); for(int i=1;i&lt;=n;i++)&#123; int x = 0; for(int j=i+1;j&lt;=n+1;j++)&#123; if(s[j - 1] == '1') x ++; if(x > k) break; pre[j][x] = max(pre[j][x], j - i); suf[i][x] = max(suf[i][x], j - i); &#125; &#125; for(int i=1;i&lt;=n+1;i++)&#123; for(int j=0;j&lt;=k;j++)&#123; if(i > 1) pre[i][j] = max(pre[i][j], pre[i - 1][j]); if(j > 0) pre[i][j] = max(pre[i][j], pre[i][j - 1]); &#125; &#125; for(int i=n+1;i>=1;i--)&#123; for(int j=0;j&lt;=k;j++)&#123; if(i &lt;= n) suf[i][j] = max(suf[i][j], suf[i + 1][j]); if(j > 0) suf[i][j] = max(suf[i][j], suf[i][j - 1]); &#125; &#125; vector&lt;int> len(n + 1, -inf); for(int i=1;i&lt;=n;i++)&#123; int x = 0; for(int j=i;j&lt;=n+1;j++)&#123; if(j > i &amp;&amp; s[j - 1] == '0') x ++; if(x > k) break; len[j - i] = max(len[j - i], pre[i][k - x]); len[j - i] = max(len[j - i], suf[j][k - x]); &#125; &#125; for(int a=1;a&lt;=n;a++)&#123; int ans = 0; for(int i=0;i&lt;=n;i++) &#123; if(len[i] == -inf) continue; ans = max(ans, i + len[i] * a); &#125; cout &lt;&lt; ans &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 感觉官方题解的式子有点抽象]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 892 Div. 2</title>
    <url>/blog/posts/1555973551/</url>
    <content><![CDATA[Contestant~. Rank 1938. Rating -45. 掉分日记.md A. United We Stand 题意 给定一个数组 \(a\)，将其分成两个非空数组 \(b, c\)，满足任意一个 \(c\) 中的元素都不是任意一个 \(b\) 中的元素的约数。 思路 很显然，若 \(x &gt; y\)，则 \(x\) 一定不可能是 \(y\) 的约数。 因而，找出数组中最大值，并将等于最大值的所有数都放到 \(c\) 中，剩余的放到 \(b\) 中即可。 显然，若 \(a\) 中所有元素都相同，那么无解，否则必有解。 时间复杂度：\(O(n) - O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(rall(a)); int cnt = 0; for(int i=0;i&lt;n;i++)&#123; if(a[i] == a[0]) cnt ++; else break; &#125; if(cnt == n)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; cout &lt;&lt; n - cnt &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; '\n'; for(int i=cnt;i&lt;n;i++) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; for(int i=0;i&lt;cnt;i++) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 速签 B. Olya and Game with Arrays 题意 给定 \(n\) 个序列，定义操作如下： 遍历所有序列； 对于每一个序列，取出一个数，放入任意一个其他序列中 更具体地说，每一个序列最多取出一个元素，但可以放入任意数量的元素。 输出操作之后，所有序列最小值之和的最大值。 思路 我们既然希望最小值之和尽可能小，那么我们肯定希望把每个序列的最小值都尽可能拿走。 显然，所有序列中的最小值无法不参与计算，且所有的最小值都可以转移到同一个序列中。 我们记所有最小值都转移到了序列 \(p\) 中。 那么，最后我们的答案就是 所有序列的次小值之和 \(-\) \(p\) 的次小值 \(+\) 所有序列的最小值。 那么，很显然，最后答案就是 次小值之和 \(-\) 次小值的最大值 \(+\) 最小值 时间复杂度：\(O(nm) - O(n m \log m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;vector&lt;int>> a(n + 1); int mn = inf, sum = 0, mn2 = inf; for(int i=1;i&lt;=n;i++)&#123; int c; cin >> c; a[i] = vector&lt;int>(c); for(int j=0;j&lt;c;j++) cin >> a[i][j]; sort(all(a[i])); sum += a[i][1]; mn = min(mn, a[i][1]); mn2 = min(mn2, a[i][0]); &#125; cout &lt;&lt; sum - mn + mn2 &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 为什么做了这么久呢？为什么呢？ C. Another Permutation Problem 题意 给定整数 \(n\)，构造一个 \(n\) 的排列 \(p\)，使 \(\displaystyle (\sum_{i = 1}^{n} p_i \cdot i) - (\max_{j = 1}^{n} p_j \cdot j)\) 最大。 思路 这道题很有趣，\(std\) 的复杂度是 \(O(n ^ 3)\)，但存在一种 \(O(n ^ 2)\) 的做法。 做法很好猜，我们直接枚举拐点，从拐点开始，从 \(n\) 开始倒着放，变成诸如 \(1, 2, 3, 6, 5, 4\) 的形式，然后代入即可。 为什么呢？我也不知道。 引用官方题解的一句话： We know about the \(O(N^2)\) solution in C, but we did not find a good suitable proof for it (and, using the method, we could achieve faster solutions). 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int sum = 0; for(int k=1; k &lt;= n; k++) &#123; int t = 0, mx = 0; for (int i = 1; i &lt; k; i++) &#123; t += i * i; mx = max(i * i, mx); &#125; int now = n; for (int i = k; i &lt;= n; i++) &#123; t += now * i; mx = max(mx, now * i); now--; &#125; t -= mx; sum = max(sum, t); &#125; cout &lt;&lt; sum &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 尝试找到一个证明，但失败了 D. Andrey and Escape from Capygrad 题意 给定 \(n\) 个传送装置，对应到数轴上，装置由两条线段表征。 两条线段的端点分别为给定的 \(l, r, a, b\)，满足 \(l \leq a \leq b \leq r\)。若位于 \([l, r]\) 上，那么可以传送到 \([a, b]\)。 现在，给定 \(q\) 个询问，每次询问给定一个点的坐标 \(x_j\)，输出最远能到达的点的下标。 思路 首先，我们可以贪心地认为，如果我们要使用某一个传送装置 \(i\)，一定会传送到 \(b_i\)，而非其他点。 证明是很显然的，因为如果我们希望从 \(p\) 传送到 \(b_i\) 的右边，那么我们也一定可以从 \(b_i\) 传送。 那么，我们也可以得到另一个结论：\(r_i\) 毫无用处。 因此，我们考虑使用扫描线，离线处理答案并输出。 我们记 \(ans_i\) 为 \(i\) 点可以到达的最大坐标，\(p_j\) 为第 \(j\) 个查询的答案，那么显然 \(p_j = \max(x_j, \max_{i = 1}^n {ans_i \vert l_i \le x_j \le r_i})\)。 具体地说，我们考虑从后往前枚举 \(b_i, x_j, l_i\)，并维护一个数据结构来更新 \(ans_i, p_j\)： 对于 \(b_i\)，我们将 \(ans_i\) 更新为数据结构中的最大值，并将最大值放入数据结构中； 对于 \(x_j\)，我们将 \(p_j\) 更新为数据结构中的最大值； 对于 \(l_i\)，我们将 \(ans_i\) 从数据结构中删去 如上，为了快速得到最大值，我们使用 \(\mathtt{multiset}\)，对于删除重复元素的其中一个元素，我们考虑使用 \(\mathtt{extract}\) 方法。 时间复杂度：\(O((n + q) \log (n + q))\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e5 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;tpi> ask; vector&lt;int> a(n); for(int i=0;i&lt;n;i++)&#123; int l, r, A, b; cin >> l >> r >> A >> b; a[i] = b; ask.pb(b, 3, i); ask.pb(l, 1, i); &#125; int q; cin >> q; //离线 vector&lt;int> ans(q); for(int i=0;i&lt;q;i++)&#123; cin >> ans[i]; ask.pb(ans[i], 2, i); &#125; sort(rall(ask)); multiset&lt;int> st; for(auto [x, op, ind] : ask)&#123; if(op == 3)&#123; if(!st.empty()) a[ind] = max(a[ind], *st.rbegin()); st.emplace(a[ind]); &#125;else if(op == 2)&#123; if(!st.empty()) ans[ind] = max(ans[ind], *st.rbegin()); &#125;else st.extract(a[ind]); //extract保证只删除最早的一个 &#125; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 没想到这个贪心，直接想合并区间去了（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 891 Div. 3</title>
    <url>/blog/posts/441544612/</url>
    <content><![CDATA[Contestant_. Rank 230. Rating +111 (+461 -350). 不小心给sqrt传了double，爆精度被叉了一题qaq A. Array Coloring 题意 给定一个序列，将其分成非空两堆，并给两堆数染上不同颜色。 输出是否存在一种分配方式，使两堆数总和的奇偶性相等。 题意 显然，奇偶性相同的两个数相加，得到偶数。 所以总和为偶数就存在，否则不存在。 时间复杂度：\(O(n)\) 对应AC代码 //Code template from Floating Ocean. #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb push_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e3 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int sum = 0; for(int i=0;i&lt;n;i++)&#123; int x; cin >> x; sum += x; &#125; if(sum % 2 == 0)&#123; cout &lt;&lt; "YES\n"; &#125;else cout &lt;&lt; "NO\n"; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 签到 B. Maximum Rounding 题意 给定一个数字，定义操作为选定数字的某一位，满足该位数字 \(\geq 5\)，将该位及其后面的所有数变为 \(0\)，并将前一位数字 \(+ 1\)，向上进位。 输出一次操作后，数字的最大值。 思路 因为数字长度很大，我们考虑对字符串模拟。 因为如果前面位存在操作，那么后面位的数都会变为 \(0\)。 因而，我们倒着读数字，对所有 \(a_i \geq 5\)，执行 \(a_i := 0, a_{i - 1} ++\)，并记录最前面执行操作的位置。 最后，我们从最前面执行操作的位置开始，将后面全都替换位 \(0\) 即可。 当然，注意不要输出前导零。 时间复杂度：\(O(n)\) 对应AC代码 //Code template from Floating Ocean. #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb push_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e3 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; string s; cin >> s; int n = s.size(), pos = inf; s = "0" + s; for(int i=s.size();i>0;i--)&#123; if(s[i] >= '5')&#123; s[i] = '0'; s[i - 1] ++; pos = i; &#125; &#125; for(int i=pos;i&lt;s.size();i++) s[i] = '0'; for(int i=0;i&lt;=n;i++)&#123; if(i == 0)&#123; if(s[i] != '0') cout &lt;&lt; s[i]; &#125;else cout &lt;&lt; s[i]; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 题目有点长了捏 C. Assembly via Minimums 题意 对于一个序列 \(a\)，操作为遍历所有 \(&lt;i, j&gt;, 1 \leq i &lt; j \leq n\)，并将 \(\min(a_i, a_j)\) 放入新序列 \(b\) 中。 现在，给定打乱顺序后的序列 \(b\)，输出任意一个满足条件的 \(a\)。 思路 对于升序排序的 \(a\)，不难发现，每一个元素在 \(b\) 中出现的次数是 \(n, n - 1,\ldots,1\)。 那么，我们直接对 \(b\) 倒序排个序，然后输出第 \(1, 2, 4, 7, \ldots\) 个元素即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 //Code template from Floating Ocean. #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e3 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int m = n * (n - 1) / 2; vector&lt;int> b(m); for(int i=0;i&lt;m;i++) &#123; cin >> b[i]; &#125; sort(all(b)); int cnt = 0; for(int i=n-1;i>=0;i--)&#123; cnt += i; cout &lt;&lt; b[cnt - 1] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 差点以为 \(a\) 中元素不会重复（不重复可以用 \(map\) 完成此题） D. Strong Vertices 题意 给定两个长度相等的数组 \(a, b\)，对于两个下标 \(u, v\ (u \neq v)\)，若满足 \(a_u - a_v \geq b_u - b_v\)，那么在图中建立一条 \(u =&gt; v\) 的有向边。 定义 "强连通点" 为 满足 存在该点 到 所有其他点的有向边。 升序输出所有 "强连通点"。 思路 首先，根据建图的方式，强连通点满足的条件就是出度为 \(n - 1\)。 我们将不等式化简，得到 \(a_u - b_u \geq a_v - b_v\)。 那么，若我们设 \(c_i = a_i - b_i\)，就有 \(c_u \geq c_v\)。 也就是说，只要 \(c_u \geq c_i\) 对所有 \(i \in [1, n], i \neq u\) 成立， \(u\) 就是一个强连通点。 判断是很显然的，我们只需找出有多少个 \(c_i\) 和 \(max(c_i)\) 相等即可。 最后，不要忘记对答案序列升序排个序。 时间复杂度：\(O(n \log n)\) 对应AC代码 //Code template from Floating Ocean. #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e3 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;pii> p(n); for(int i=0;i&lt;n;i++) &#123; p[i].sc = i + 1; cin >> p[i].fs; &#125; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; p[i].fs -= cur; &#125; sort(all(p)); vector&lt;int> ans; for(int i=n-1;i>=0;i--)&#123; if(p[i].fs == p[n-1].fs) ans.pb(p[i].sc); else break; &#125; cout &lt;&lt; ans.size() &lt;&lt; '\n'; sort(all(ans)); for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 不会真的有人觉得这是正经的图论吧（ E. Power of Points 题意 给定数轴上的 \(n\) 个点 \(x_i\)。 对于某个整数 \(s\)，对 \(i \in [1, n]\)，构造线段 \([x_i, s]\)。 定义 \(f_p\) 为与坐标 \(p\) 相交的线段数量，计算对于 \(s \in \{x1, x2, \ldots, x_n\}\) 的 \(\displaystyle \sum^{10^9}_{p=1}f_p\)。 思路 我们可以将问题转化为：对于 \(s \in \{x1, x2, \ldots, x_n\}\)，计算 \(n + \sum abs(s - x_i)\)。 那么，我们不妨直接对 \(x_i\) 排序，然后对其求前缀和 \(pre\) 和后缀和 \(suf\) (其实后缀和可以直接由前缀和得到)。 那么，对于 \(s = x_p\)，\(\sum abs(s - x_i) = (s \times (p - 1) - pre_{p - 1}) + 0 + (suf_{p + 1} - s \times (n - p))\)。 时间复杂度：\(O(n)\) 对应AC代码 //Code template from Floating Ocean. #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e3 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;pii> a(n); vector&lt;int> sum(n + 1); for(int i=0;i&lt;n;i++)&#123; cin >> a[i].fs; a[i].sc = i; &#125; sort(all(a)); for(int i=1;i&lt;=n;i++) sum[i] = sum[i - 1] + a[i - 1].fs; vector&lt;int> ans(n); for(int i=1;i&lt;=n;i++)&#123; ans[a[i - 1].sc] = a[i - 1].fs * (i - 1) - sum[i - 1] + sum[n] - sum[i] - a[i - 1].fs * (n - i) + n; &#125; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 如果去掉题面的包裹，这题比前面几题简单 F. Sum and Product 题意 给定一个序列 \(a\)，对于 \(q\) 个询问，每次给定两个数 \(x, y\)，输出二元组 \(&lt;i, j&gt;, 1 \leq i &lt; j \leq n\) 的个数，满足 \(a_i + a_j = x, a_i \times a_j = y\)。 题意 我们设 \(a_i = p, a_j = q\)，将 \(x, y\) 视为常数，那么我们可以联立并化简，得到一个一元二次方程 \(p(x - p) = y\)。 也就是 \(p ^ 2 - xp + y = 0\)。 我们对考虑 \(\Delta = x ^ 2 - 4y\) 分类讨论： \(\Delta &lt; 0\)，答案为 \(0\)； \(\Delta = 0\)，那么 \(p = q\)。因为下标需要满足不同，那么我们只能在所有 \(a_x = p\) 中挑选两个，也就是组合数； \(\Delta &gt; 0\)，那么答案就是两个值出现次数之积。 当然，因为我们需要得到正整数解，因而根据求根公式，\(\sqrt\Delta\) 为整数，\(x + \sqrt \Delta\) 为偶数。 判断的时候注意不要爆精度。 至于出现次数，使用 \(map\) 即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 //Code template from Floating Ocean. #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e3 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; template&lt;class T> T ex_sqrt(T x) &#123; //返回精度更高的sqrt if(x == 0) return 0; T sqrtX = sqrt(x) - 1; while (sqrtX + 1 &lt;= x / (sqrtX + 1)) sqrtX++; return sqrtX; &#125; void solve() &#123; int n; cin >> n; map&lt;int, int> cnt; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; cnt[cur] ++; &#125; int q; cin >> q; while(q --)&#123; int x, y; cin >> x >> y; int delta = x * x - 4 * y; if(delta &lt; 0)&#123; cout &lt;&lt; 0 &lt;&lt; ' '; continue; &#125; if(fabs(ex_sqrt(delta) * ex_sqrt(delta) - delta) > 1e-9)&#123; cout &lt;&lt; 0 &lt;&lt; ' '; continue; &#125; if(abs(ex_sqrt(delta) - x) % 2 != 0)&#123; cout &lt;&lt; 0 &lt;&lt; ' '; continue; &#125; int p1 = -(ex_sqrt(delta) - x) / 2, p2 = (ex_sqrt(delta) + x) / 2; int ans = cnt[p1] * cnt[x - p1]; if(delta == 0) ans = max(0ll, cnt[p1] * (cnt[p1] - 1) / 2); cout &lt;&lt; ans &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; sqrt + double = 寄 G. Counting Graphs 题意 给定一颗生成树。 现在，找出满足下面条件的不同图的个数，其中边权不同即为不同： 该图的 唯一 最小生成树为给定的生成树； 不包含重边和自环 图中任意边的边权的最大值 \(S\) 思路 等价于给生成树加边，且所加边的边权应大于两点之间最短路的长度。 我们记两个点间的最短路为 \(P(u, v)\)。 显然，我们只能选择两个点进行加边，因而，如果我们假设不加边的两点加了一条虚拟的边，边权为 \(P(u, v)\)。 那么，对于每两个点，都会有一个边权的选择，选择总共有 \(S - P(u, v) + 1\) 种。 根据乘法原理，最后的答案就是 \(\prod\limits_{1\le u &lt; v \le n}{} (S-P(u,v)+1)\)。 接下来我们考虑如何计算。 在 \(\mathtt{Kruskal}\) 算法中，我们使用了并查集来合并两个连通块。 不难发现，在合并的时候，我们可以顺便记录两个连通块分量的个数，并进行赋值，从而在每次合并前都可以快速得到左右两个连通块分量个数。 那么，在合并入一个新的连通块的时候，我们会用一条边连结。我们设两个连通块分量个数为 \(siz_u, siz_v\)，经过这条边的路径数就是 \(siz_u \times siz_v\)，减掉 \(u - v\) 这条边，剩余的路径数就是满足 \(P(a, b) = w_{u, v}\) 的所有 \(&lt;a, b&gt;\)。 因而，在合并的时候，我们将答案乘上 \((S - w + 1) ^ {siz_u \times siz_v - 1}\)。 如上，跑一遍 \(\mathtt{Kruskal}\) 即可。 时间复杂度：\(O(m \log m)\) 对应AC代码 //Code template from Floating Ocean. #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e3 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; struct MATH &#123; private: struct PRIME &#123; int Check_Num = 0, Max_Factor = 0; vector&lt;pii> Dec; private: void Get_Fac(int Num) &#123; //寻找 Num 的最大因子 if (Num &lt;= Max_Factor || Num &lt; 2) return; if (Miller_Rabin(Num)) return void(Max_Factor = max(Max_Factor, Num)); int Fac = Num; while (Fac >= Num) Fac = Pollard_Rho(Num);//寻 找 因 子 while (!(Num % Fac)) Num /= Fac; return Get_Fac(Num), Get_Fac(Fac); &#125; void Decomposition(int Num) &#123; // 分解 Num 的质因子 if (Num &lt; 2) return; if (Miller_Rabin(Num)) &#123; pair&lt;int, int> Now = &#123;Num, 0&#125;; while (Check_Num % Num == 0) Now.second++, Check_Num /= Num; if (Now.second) Dec.pb(Now); return; &#125; int Fac = Num; while (Fac >= Num) Fac = Pollard_Rho(Num);//寻 找 因 子 while (!(Num % Fac)) Num /= Fac; return Decomposition(Num), Decomposition(Fac); &#125; public: __int128 test[16] = &#123;0, 2, 3, 5, 7, 11, 13, 17, 19, 61, 325, 9375, 28178, 450775, 9780504, 1795265022&#125;; bool Miller_Rabin(__int128 P) &#123; //检测 P 是不是质数, 严格保证答案正确 if (P &lt; 3 || P % 2 == 0) return P == 2; static int i, j; static __int128 Tem, k, Next; Tem = P - 1, k = 0; while (Tem % 2 == 0) Tem >>= 1, ++k; for (j = 1; j &lt;= 15; j++) &#123; Next = qp(test[j], Tem, P); if (Next &lt;= 1 || Next == P - 1) continue; for (i = 0; i &lt; k; ++i) &#123; Next = Next * Next % P; if (Next == P - 1 &amp;&amp; i != k - 1) &#123; Next = 1; break; &#125; if (Next == 1) return false; &#125; if (Next != 1) return false; &#125; return true; &#125; static bool RMiller_Rabin(__int128 P, int test_time = 8) &#123; //检测 P 是不是质数, 基于随机检验 if (P &lt; 3 || P % 2 == 0) return P == 2; static int i, j; static __int128 Tem, k, Rand_Num, Now; Tem = P - 1, k = 0; while (Tem % 2 == 0) Tem >>= 1, ++k; for (i = 1; i &lt;= test_time; ++i) &#123; Rand_Num = rand() % (P - 2) + 2, Now = qp(Rand_Num, Tem, P); if (Now == 1) continue; for (j = 0; j &lt; k; ++j) &#123; if (Now == P - 1) break; Now = Now * Now % P; &#125; if (j >= k) return false; &#125; return true; &#125; static int Pollard_Rho(int x) &#123; static int s, t, c, Div, Val; Val = 1, s = t = 0; static int Step, Goal; Step = 0, Goal = 1; c = (int) rand() % (x - 1) + 1; for (Goal = 1;; Goal &lt;&lt;= 1, s = t, Val = 1) &#123; // 倍增优化 for (Step = 1; Step &lt;= Goal; ++Step) &#123; t = ((__int128) t * t + c) % x, Val = (__int128) Val * abs(t - s) % x; if (!(Step % 127)) &#123; Div = __gcd(Val, x); if (Div > 1) return Div; &#125; &#125; Div = __gcd(Val, x); if (Div > 1) return Div; &#125; &#125; void Get_Max_Fac(int Num) &#123; return Max_Factor = 0, Get_Fac(Num); &#125; //获得 Num 的最大因子 测 试: Luogu P4718 void Dec_Factor(int Num) &#123; return Dec.clear(), Check_Num = Num, Decomposition(Num); &#125; //分解 Num 的本质不同质因子 测 试: Prime Land int Get_Phi(int Num) &#123; //计算 φ(Num) if (Num == 1) return 0; Dec_Factor(Num); for (auto &amp;Now: Dec) Num = Num / Now.first * (Now.first - 1); return Num; &#125; &#125;pm; public: static __int128 qp(__int128 x, __int128 y, __int128 m = mod) &#123; static __int128 ans; ans = 1, x %= m; for (; y; y >>= 1, x = x * x % m) if (y &amp; 1) ans = ans * x % m; return ans; &#125; //ax+by=gcd(a,b),返回gcd int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - (a / b) * y; return d; &#125; //x (mod Mi) = Ai int exCRT(int n, int M[], int A[]) &#123; int a = A[1], m = M[1], ta, tm, x, y, d, l, t; for (int i = 2; i &lt;= n; i++) &#123; tm = M[i], ta = A[i]; d = exgcd(m, tm, x, y); l = m * tm / d; if ((ta - a) % d != 0) return -1; t = tm / d; x *= ((ta - a) / d); x = (x % t + t) % t; a += m * x; m = l; &#125; return a; &#125; //欧拉函数，小于等于n和n互质的数的个数 int phi(int n) &#123; return pm.Get_Phi(n); &#125; bool vis[N]; int pri[N], cnt; //线性筛 void linear_prime(int n) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) pri[cnt++] = i; for (int j = 0; j &lt; cnt; ++j) &#123; if (1ll * i * pri[j] > n) break; vis[i * pri[j]] = true; if (i % pri[j] == 0)break; &#125; &#125; &#125; int inv_ex(int n, int m = mod) &#123; int x, y, ans = exgcd(n, m, x, y); if (ans == 1) return (x % m + m) % m; else return -1; &#125; int inv(int n, int m = mod) &#123; return qp(n, m - 2, m); &#125; //p为1e5以内质数，求c(n, m) % p int lucas(int n, int m, int p) &#123; if (m == 0) return 1; return (C(n % p, m % p, p) * lucas(n / p, m / p, p)) % p; &#125; int C(int m, int n, int p) &#123; int a = 1, b = 1; if (m &lt; n) return 0; while (n) &#123; a = (a * m) % p, b = (b * n) % p; m--, n--; &#125; return a * inv_ex(b, p) % p; &#125; void get_phi(int n, int phi[]) &#123; for (int i = 0; i &lt;= n; i++) phi[i] = i; for (int i = 2; i &lt;= n; i++) if (phi[i] == i) for (int j = 2; j &lt;= n; j++) phi[j] = phi[j] / i * (i - 1); &#125; //线性求逆元 void get_inv(int n, int inv[], int p = mod) &#123; inv[1] = 1; for (int i = 2; i &lt;= n; i++) inv[i] = inv[i] = (p - p / i * inv[p % i] % p) % p; &#125; //线性求阶乘，逆元，阶乘逆元 void get_fact_inv(int n, int fac[], int Inv[], int fac_inv[], int p = mod) &#123; fac[0] = fac_inv[0] = Inv[0] = fac[1] = fac_inv[1] = Inv[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; fac[i] = fac[i - 1] * i % p; Inv[i] = (p - p / i * Inv[p % i] % p) % p; fac_inv[i] = fac_inv[i - 1] * Inv[i] % p; &#125; &#125; vector&lt;pii> factorize(int x) &#123; return pm.Dec_Factor(x), pm.Dec; &#125; int max_factor(int x)&#123; return pm.Get_Max_Fac(x), pm.Max_Factor; &#125; void miller_rabin(__int128 P)&#123; pm.Miller_Rabin(P); &#125; void random_miller_rabin(__int128 P, int test_time = 8)&#123; pm.RMiller_Rabin(P, test_time); &#125; int pollard_pho(int x) &#123; pm.Pollard_Rho(x); &#125; template&lt;class T> T ex_sqrt(T x) &#123; //返回精度更高的sqrt T sqrtX = sqrt(x) - 1; while (sqrtX + 1 &lt;= x / (sqrtX + 1)) sqrtX++; return sqrtX; &#125; &#125;math; struct DSU &#123; vector&lt;int> pa; void init(int n) &#123; pa = vector&lt;int>(n + 1), iota(all(pa), 0); &#125; int find(int x) &#123; return pa[x] == x ? x : pa[x] = find(pa[x]); &#125; void unite(int u, int v) &#123; int f1 = find(u); int f2 = find(v); if (f1 != f2) pa[f2] = f1; &#125; &#125;dsu; struct KRUSKAL &#123; int n, m, idx; struct Edge&#123; int a, b, w; bool operator&lt; (const Edge &amp;W)const&#123; return w &lt; W.w; &#125; &#125;edges[M]; void init(int tn, int tm)&#123; n = tn, m = tm, dsu.init(n), idx = 0; &#125; void add(int u, int v, int w) &#123; edges[idx ++] = &#123;u, v, w&#125;; &#125; int kruskal(auto func)&#123; sort(edges, edges + m); int res = 0, cnt = 0; for (int i = 0; i &lt; m; i ++)&#123; auto [a, b, w] = edges[i]; a = dsu.find(a), b = dsu.find(b); if (a != b) dsu.unite(a, b), res += w, cnt ++; func(a, b, w); &#125; if (cnt &lt; n - 1) return inf; return res; &#125; &#125;kruskal; void solve() &#123; int n; cin >> n; vector&lt;int> siz(n + 1, 1); kruskal.init(n, n - 1); int s; cin >> s; for(int i=0;i&lt;n-1;i++)&#123; int u, v, w; cin >> u >> v >> w; kruskal.add(u, v, w); &#125; int ans = 1; kruskal.kruskal([&amp;](int tx, int ty, int w) -> void&#123; ans = ans * math.qp(s - w + 1, siz[tx] * siz[ty] - 1, mod) % mod; siz[tx] += siz[ty]; &#125;); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 随手扔了个数论板子，一下子给干到200行了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 890 Div. 2</title>
    <url>/blog/posts/3407959174/</url>
    <content><![CDATA[Contestant~. Rank 707. Rating +20. A. Tales of a Sort 题意 给定一个序列 \(a\)，定义一次操作为将所有数改为 \(\max(0, a_i - 1)\)。 输出让序列 \(a\) 不递减的最小操作数。 思路 既然我们要让序列不递减，那么如果出现了相邻不递减的元素，我们就必须将其减到 \(0\)。 那么，我们就直接枚举所有 \(i \in [1, n - 1]\)，找出所有满足 \(a_i &gt; a_{i + 1}\) 的元素 \(a_i\)，计算 \(\max(a_i)\)。 时间复杂度：\(O(n)\) 对应AC代码 //Code template from Floating Ocean. #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb push_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e3 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; int ans = 0; for(int i=n-1;i>=1;i--)&#123; if(a[i + 1] >= a[i]) continue; ans = max(ans, a[i]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 差点看错题了（ B. Good Arrays 题意 给定一个 正整数 序列 \(a\)，判断是否可以构造一个长度相等的 正整数 序列 \(b\)，满足下面的条件： \(a_i \neq b_i\)； \(a_1 + a_2 + \ldots + a_n = b_1 + b_2 + \ldots + b_n\) 思路 与其考虑如何构造，我们不妨考虑怎么修改原序列来达成条件。 不难发现，我们只需选择两个元素 \(a_i, a_j\)，执行操作 \(a_i + 1, a_j - 1\)，即可让这两个元素都和原来不相同，且最后序列总和不变。 那么很显然，我们考虑将较大的元素的 "分给" 较小的元素，不能分自然就是无解了。 因为序列为正整数序列，因而能进行分配的元素就是大于 \(1\) 的元素。 那么，代价最小的分配方式就是将 所有 非 \(1\) 元素 各分配 值 \(1\) 到未被分配的 为 \(1\) 的元素上。 设 \(cnt\) 为 \(1\) 的个数，\(sum\) 为序列总和，显然多余的能分配的值就是 \(sum - n\)，也就是说，临界条件是 \(sum - n \geq cnt\)。 时间复杂度：\(O(n)\) 对应AC代码 //Code template from Floating Ocean. #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb push_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e3 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); int sum = 0, cnt = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; sum += a[i]; if(a[i] == 1) cnt ++; &#125; if(n == 1)&#123; cout &lt;&lt; "NO\n"; return; &#125; cout &lt;&lt; (sum >= n + cnt ? "YES\n" : "NO\n"); &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 结论还是很显然的捏 C. To Become Max 题意 给定一个序列 \(a\)，定义一次操作如下： 选定一个下标 \(i\)，满足 \(i \in [q, n - 1]\) 且 \(a_i \leq a_{i + 1}\)； \(a_i := a_i + 1\) 给定一个整数 \(k\)，输出在最多 \(k\) 次操作后，序列的最大值。 思路 显然，操作次数越多，序列最大值越大，反之越小。这满足单调性。 因而，我们考虑二分答案。 因为序列最后一定是递减的，因而我们只需二分答案 \(x\)，并暴力检查以每一个数作为最大值 \(x\) 需要操作的次数，最后取最小值即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 //Code template from Floating Ocean. #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb push_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e3 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n + 1); int mx = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; mx = max(mx, a[i]); &#125; auto check = [&amp;](int mid) -> bool&#123; int ans = inf; for(int i=1;i&lt;=n;i++)&#123; int t = 0, sum = 0; int j = i; for(;j&lt;=n;j++)&#123; if(a[j] &lt; mid - t)&#123; sum += mid - t - a[j]; t ++; &#125;else break; &#125; if(j &lt;= n) ans = min(ans, sum); &#125; return ans &lt;= k; &#125;; int l = mx - 1, r = 2e9, mid, ans = -1; while(l + 1 &lt; r)&#123; mid = (l + r) >> 1; if(check(mid))&#123; l = mid, ans = mid; &#125;else r = mid; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 有点长的二分 D. More Wrong 题意 这是一道交互题。 对于一个未知的排列，定义一次交互为输出一个区间的左端点 \(l\) 和右端点 \(r\)，并以 这个区间内逆序对的个数 作为响应，代价为 \((r - l) ^ 2\)。 在总代价 \(\leq 5n ^ 2\) 的条件下，猜出排列中最大值的下标。 猜想思路 首先，如果两个区间 \([l, r - 1], [l, r]\) 的逆序对个数相同，\(r\) 就比 \([l, r - 1]\) 中任意一个数都大，也就是说，\(r\) 是 \([l ,r]\) 中的最大值。 那么，如果我们知道 \([l, r - 1]\) 中的最大值 \(p\)，在逆序对个数不相同的条件下，\(p\) 就是 \([l, r]\) 中的最大值。 为了让询问的区间尽可能小，我们用分治的思想，递归求出 \([l, mid], [mid + 1, r]\) 内的最大值 \(a, b\)，并询问 \([a, b - 1], [a, b]\) 中逆序对的个数。如果个数相同，那么 \([l, r]\) 中的最大值就是 \(b\)，否则为 \(a\)。 对于每次询问的 \([a, b - 1], [a, b]\)，代价为 \((b - 1 - a) ^ 2 + (b - a) ^ 2 \leq (b - a) ^ 2 \leq (r - l) ^ 2\)。 归纳证明 令 \(g_n\) 为在长度为 \(n\) 的排列中找到最大值位置的总代价。 猜想：\(g_n \leq 4n^2\) 下面用数学归纳法证明： ① 令 \(n = 1\)，\(g_1 = 0 \leq 4 \times 1 ^ 2=4\)； ② 记 \(m = \lceil \frac{n}{2} \rceil\)， \(\because\) 当 \(n = m, n - m\) 时，\(g_m \leq 4m^2, g_{n - m} \leq 4(n - m) ^ 2\) \(\therefore g_n\) \(\leq 2(n - 1) ^ 2 + g_m + g_{n - m}\) \(\leq 2(n - 1) ^ 2 + 4[m^2 + (n - m) ^ 2]\) \(=6n^2+8m^2+2-8nm-4n\) \(=4n^2 + 2(n^2 - 4nm + 4m^2) + 2 - 4n\) \(= 4n^2 + 2(n - 2m)^2 + 2 - 4n\) \(\leq 4n^2 + 2 + 2 - 4n\) $4n^2 $ 时间复杂度：\(O(\log n)?\) 对应AC代码 //Code template from Floating Ocean. #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb push_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e3 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; auto fetch = [&amp;](int l, int r) -> int&#123; if(l == r) return 0; cout &lt;&lt; "? " &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; '\n'; cout.flush(); int in; cin >> in; return in; &#125;; auto mx = [&amp;](auto mx, int l, int r) -> int&#123; if(l == r) return l; int mid = (l + r) >> 1; int a = mx(mx, l, mid), b = mx(mx, mid + 1, r); return fetch(a, b - 1) == fetch(a, b) ? b : a; &#125;; int ans = mx(mx, 1, n); cout &lt;&lt; "! " &lt;&lt; ans &lt;&lt; '\n'; cout.flush(); &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 经典结论好猜证明难证，放在 \(D\) 根本不敢猜 E1. PermuTree (easy version) 题意 给定一棵以 \(1\) 为根的有根树。 在任意给所有节点赋值，且最后所有值构成的集合为 \(n\) 的排列的条件下，输出最多的二元组 \(&lt;u, v&gt;\) 的个数，满足节点 \(u, v\) 的最近公共祖先 \((lca)\) 的值在 \(u, v\) 两点值之间。 思路 首先，如果这棵树是二叉树，那么我们只需按照二叉树的中序遍历填写，即可让最后的个数最大。 这个结论放到这题，就是尽可能将一个节点的所有子树分成两堆，任意一个堆的节点数 都尽可能靠近 所有子树的总节点数 \(/ 2\)。 我们设这个节点的所有子树的总节点数为 \(siz\)。 也就是说，我们希望 节点数量较小的那一堆 满足 节点数总和最多不超过 \(\frac{siz}{2}\)，并最大化节点数总和。 这就是一个容量为 \(\frac{siz}{2}\)，价值和体积一样的 \(01\) 背包问题。 我们求出最大价值 \(q\)，那么对于这个节点，左右 ”两半" 子树的所有组合可能就是 \(q(siz-q)\)。 因而，我们枚举所有节点，\(\mathtt{dfs}\) 计算即可。 时间复杂度：\(O(n^2)\) 对应AC代码 //Code template from Floating Ocean. #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb push_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e3 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;vector&lt;int>> e(n + 1); for(int i=2;i&lt;=n;i++)&#123; int p; cin >> p; e[p].pb(i); &#125; vector&lt;int> siz(n + 1); int ans = 0; auto dfs = [&amp;](auto dfs, int x, int p) -> void&#123; vector&lt;int> child; for(auto y : e[x])&#123; if(y == p) continue; dfs(dfs, y, x); child.pb(siz[y]); siz[x] += siz[y]; &#125; int mx = siz[x] / 2; vector&lt;bool> dp(mx + 1); dp[0] = true; for(auto y : child)&#123; for(int i=mx;i>=y;i--) dp[i] = dp[i] | dp[i - y]; &#125; int now = 0; for(int i=mx;i>0;i--)&#123; if(dp[i]) &#123; now = max(now, i * (siz[x] - i)); break; &#125; &#125; ans += now; siz[x] ++; &#125;; dfs(dfs, 1, -1); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; // cin >> t; while (t--) solve(); &#125; 奇妙的在树上算背包 E2. PermuTree (hard version) 需要手写 \(bitset\) 实现范围可修改。题目区别是本题的数据范围更大，时限大了 \(1s\)。]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 889 Div. 2</title>
    <url>/blog/posts/2450723275/</url>
    <content><![CDATA[Contestant~. Rank 316. Rating +66. A. Dalton the Teacher 题意 给定一个序列，定义一次操作为任意交换两个数。 输出让所有 \(a_i \neq i\) 的最小操作数。 思路 显然，我们直接统计 \(a_i = i\) 的个数，这些数就是参与交换的。 我们推一下式子，最后答案就是 \(\frac{cnt + 1}{2}\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int cnt = 0; for(int i=1;i&lt;=n;i++)&#123; int x; cin >> x; if(x == i) cnt ++; &#125; cout &lt;&lt; (cnt + 1) / 2 &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t = 1; cin >> t; while (t--) solve(); &#125; 签到。这个式子已经有种经验感了（ B. Longest Divisors Interval 题意 给定一个整数 \(n\)，输出最长的区间 \([l, r]\) 的长度，满足对于所有 \(l \leq i \leq r\)，都有 \(n \bmod i = 0\)。 思路 显然，如果我们找到了某个合法的 \([l, r]\)，那么在 \([1, r - l + 1]\) 中，可以通过倍数关系知道所有数也都合法。 那么，我们直接令 \(l = 1\)，暴力枚举右端点，当 \(x \bmod i \neq 0\) 时，合法区间就是 \([1, x - 1]\)。 时间复杂度：\(O(\log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int ans = 0; for(int i=1;;i++)&#123; if(n % i == 0) ans ++; else break; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t = 1; cin >> t; while (t--) solve(); &#125; 先乱猜再说 C1. Dual (Easy Version) 题意 给定一个长为 \(n\) 的序列 \(a\)，满足 \(n \leq 20, |a_i| \leq 20\)。 定义一次操作指定两个参数 \(i, j\)，其中 \(i\) 和 \(j\) 可以相等，将 \(a_j\) 加上 \(a_i\)。 输出一种操作数不大于 \(50\) 的方案，使序列不递减。 思路 首先，我们思考一下，我们在构造什么的时候，能得到一个不递减序列。 不难发现，我们在求非负数序列的前缀和的时候，得到的前缀和数组就是不递减的。 同样，我们在求非正数序列的后缀和的时候，得到的后缀和数组也是不递减的。 那么，我们就可以将所有正数变成负数，或将所有负数变成正数，然后 从右向左 或 从左向右 依次加上即可。 为了让变号的操作数尽可能少，我们以将负数变成正数为例，我们自然希望用最大的正数来进行赋值。 但是可能会出现正数太小的情况。这时，因为 \(2^5 = 32 \geq 20\)，所以我们最多只需 \(5\) 次操作即可让这个最大数 \(\geq 20\)。 如上，我们可以在 \(5 + 2(n - 1) \leq 43\) 次操作内完成此题。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 2); bool f = true; int mx = 1, mn = 1; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; if(a[i] &lt; a[i - 1]) f = false; if(a[i] > a[mx]) mx = i; if(a[i] &lt; a[mn]) mn = i; &#125; if(f)&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; vector&lt;pii> ans; if(a[mx] > 0) &#123; while (a[mx] &lt;= 20) &#123; ans.pb(mx, mx); a[mx] *= 2; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (a[i] &lt; 0) &#123; ans.pb(i, mx); a[i] += a[mx]; &#125; &#125; for (int i = 2; i &lt;= n; i++) &#123; if (a[i] &lt; a[i - 1]) &#123; ans.pb(i, i - 1); a[i] += a[i - 1]; &#125; &#125; &#125;else &#123; while (a[mn] >= -20) &#123; ans.pb(mn, mn); a[mn] *= 2; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (a[i] > 0) &#123; ans.pb(i, mn); a[i] += a[mn]; &#125; &#125; for (int i = n - 1; i >= 1; i--) &#123; if (a[i] > a[i + 1]) &#123; ans.pb(i, i + 1); a[i] += a[i + 1]; &#125; &#125; &#125; cout &lt;&lt; ans.size() &lt;&lt; '\n'; for (auto [x, y]: ans) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t = 1; cin >> t; while (t--) solve(); &#125; 主打一个灵感乍现，但是怎么吃了两发罚时啊啊啊啊啊 D2. Dual (Hard Version) 题意 在 \(D1\) 的基础上，限制操作数最多 \(31\) 次。 思路 我们先考虑优化将绝对值最大的数变为 \(\geq 20\) 的操作。 我们以将最大值变为 \(\geq 20\) 为例。因为显然，我们有时候不需要将其变为 \(\geq 20\)，而是只需要将其变为大于最小值的绝对值。 那么，我们设此类操作需要执行 \(x1\) 次；同样的，在改变最小值的时候，此类操作需要执行 \(y1\) 次。 因为我们只需在 改变最大值 和 改变最小值 中选一个进行操作，因而 \(x1, y1\) 中，有一个操作数 因为不需要执行 而为 \(0\)，另一个操作数 因为需要执行 而最多为 \(5\) 。 也就是说，\(x_1 + y_1 \leq 5\)。 接下来，我们需要将这个正数最大值加到所有负数上去，设其需要 \(x2\) 次操作；同样的，设负数最小值加到所有正数上去的操作数为 \(y2\)。 显然，\(x2 + y2 \leq n \leq 20\)。 那么，我们可以得到 \(x1 + x2 + y1 + y2 \leq 25\)，因而，我们取操作数最小的操作，可得 \(\min(x1 + x2, y1 + y2) \leq \lfloor \frac{25}{2} \rfloor = 12\)。 最后，我们需要执行最初我们在 \(C1\) 所说的，类似于求前后缀和的操作，这个操作最多有 \(n - 1 \leq 19\) 次。 从而，按照这个写法，我们取两种操作方案的操作数最小值，可在 \(12 + 19 = 31\) 次内完成操作，从而通过本题。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a1(n + 2), a2(n + 2); bool f = true; int mx = 1, mn = 1; for(int i=1;i&lt;=n;i++)&#123; cin >> a1[i]; a2[i] = a1[i]; if(a1[i] &lt; a1[i - 1]) f = false; if(a1[i] > a1[mx]) mx = i; if(a1[i] &lt; a1[mn]) mn = i; &#125; if(f)&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; vector&lt;pii> ans1, ans2; if(a1[mx] > 0) &#123; while(a1[mx] &lt; -a1[mn])&#123; ans1.pb(mx, mx); a1[mx] *= 2; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (a1[i] &lt; 0) &#123; ans1.pb(i, mx); a1[i] += a1[mx]; &#125; &#125; for (int i = 2; i &lt;= n; i++) &#123; if (a1[i] &lt; a1[i - 1]) &#123; ans1.pb(i, i - 1); a1[i] += a1[i - 1]; &#125; &#125; &#125; if(a2[mn] &lt; 0)&#123; while(a2[mn] > -a2[mx])&#123; ans2.pb(mn, mn); a2[mn] *= 2; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (a2[i] > 0) &#123; ans2.pb(i, mn); a2[i] += a2[mn]; &#125; &#125; for (int i = n - 1; i >= 1; i--) &#123; if (a2[i] > a2[i + 1]) &#123; ans2.pb(i, i + 1); a2[i] += a2[i + 1]; &#125; &#125; &#125; if(ans1.size() > ans2.size()) swap(ans1, ans2); if(ans1.size() == 0) ans1 = ans2; cout &lt;&lt; ans1.size() &lt;&lt; '\n'; for (auto [x, y]: ans1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t = 1; cin >> t; while (t--) solve(); &#125; 结论是好猜的，证明是难写的，代码是乱交的 D. Earn or Unlock 题意 对于一个竖直放置的牌堆，从上到下给定每张牌的点数 \(a_i\)。每张牌有解锁和未解锁两个状态。 规定一次操作为选定任意一张解锁的牌 \(i\)，并执行下面两种操作任选其一： 从上往下依次解锁未解锁的牌 \(a_i\) 张； 获得这个牌的点数 \(a_i\). 当没有已解锁的牌，或者没有牌剩余，游戏结束。 输出游戏结束时最多的点数。 思路 我们用 \(bitset\) 维护使用了前 \(i\) 张牌的某些牌后，能拓展到的右端点。 我们记使用的 \(bitset\) 为 \(bs\)。 那么，如果我们使用 \(a_i\)，\(bs |= (bs &lt;&lt; a_i)\)；不使用，\(bs |= bs\)。 为了方便不使用中间某张牌的推算，我们在使用第 \(i\) 个牌拓展右端点后，将 \(i\) 位置标记为不可达，这样即可将所有状态都判断全。 上述思路可以类比 \(01\) 背包。 最后，如果某个点可达，我们可以推得该点可以获得的最大点数是唯一确定的 \(sum[i] - i + 1\)，其中 \(sum\) 是前缀和。 时间复杂度：\(O(\frac{n^2}{64})\) 对应AC代码 #pragma GCC optimize("O3,unroll-loops") #pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt,fma") #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; bitset&lt;N> bs; int sum = 0, ans = 0; bs[1] = 1; for(int i=1;i&lt;=n;i++)&#123; sum += a[i]; if(bs[i]) ans = max(ans, sum - i + 1); bs |= bs &lt;&lt; a[i]; bs[i] = 0; &#125; for(int i=n+1;i&lt;=2*n;i++)&#123; if(bs[i]) ans = max(ans, sum - i + 1); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t = 1; //cin >> t; while (t--) solve(); &#125; 听懂了吗，如懂。 其实这题 \(n^2\) 的解法挺多也挺好想，但放到 \(bitset\) 里还是太抽象了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 152</title>
    <url>/blog/posts/2855546043/</url>
    <content><![CDATA[Contestant~. Rank 856. Rating +27 (+77 -50). A. Morning Sandwich 题意 规定三明治的顶部和底部分别是两块面包片，中间由若干层火腿肠或芝士组成，每层之间由面包片分隔。 现在，给定面包片，芝士和火腿肠的数量，输出最大的层数。 思路 如题，推一个式子即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int b, c, h; cin >> b >> c >> h; cout &lt;&lt; min((b - 1) * 2 + 1, (c + h) * 2 + 1) &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 签到 B. Monsters 题意 给定 \(n\) 个怪物，每个怪物有 \(a_i\) 的血量。 现在，规定每次只能扣除血量最高的且下标更小的怪物的血量，每次扣除给定整数 \(k\) 的血量，当一个怪物的血量 \(\leq 0\) 时怪物死亡。 输出怪物死亡的时间顺序。 思路 首先，我们不难发现，在若干次操作后，最后序列中的所有数都会剩下 相同的 需操作的次数。 到这个分界点之后，我们一定只能按照一个特定的顺序扣血。 因而，我们直接考虑还剩一次操作的情况。此时，如果 \(a_i \bmod k = 0\)，还剩 \(k\) 点血量，否则还剩 \(a_i \bmod k\) 点血量。 我们按这个排序，即可得到死亡顺序。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; vector&lt;pii> a(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i].fs; a[i].sc = i + 1; a[i].fs %= k; if(a[i].fs == 0) a[i].fs = k; a[i].fs = -a[i].fs; &#125; sort(all(a)); for(int i=0;i&lt;n;i++) cout &lt;&lt; a[i].sc &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 暴力模拟肯定 \(tle\) C. Binary String Copying 题意 给定一个二进制字符串，将其复制 \(q\) 份。 对于被复制的第 \(i\) 份，给定两个整数 \(l_i, r_i\)，将 \([l_i, r_i]\) 内的字符升序排序，得到新字符串。 现在，输出 被复制的所有字符串 被处理后 得到的 \(q\) 个字符串中 有多少个 不同的 字符串。 思路 与其比较排序后的结果，我们不妨考虑一下我们在排序的时候对原字符串的影响。 显然，对于一个形如 \(00101011\) 的字符串，我们的排序区间就可以缩减到 \(1010\)，并且这个排序区间内的数在排序后一定和原字符串不同。 那么，如果两个字符串处理后是相同的，他们的排序区间就一定是相同的。 也就是说，这个排序区间，就是表征两个字符串排序后是否相等的依据。 那么，我们可以预处理出 \([l, r]\) 中最左边的 \(1\) 和最右边的 \(0\) 所在位置 \(i, j\)，用 \([i, j]\) 作为本次排序后的字符串特征。 最后，有多少个不同的 \([i, j]\)，就有多少个不同的字符串了。 至于处理，我们直接正反跑一遍递推即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m; cin >> n >> m; string s; cin >> s; s = "#" + s; vector&lt;int> pre(n + 1), suf(n + 1); int l = 1, r = n; for(int i=1;i&lt;=n;i++)&#123; if(s[i] == '0') l = i; pre[i] = l; &#125; for(int i=n;i>0;i--)&#123; if(s[i] == '1') r = i; suf[i] = r; &#125; int ans = 0; map&lt;pii, bool> cnt; bool f = false; while(m --)&#123; cin >> l >> r; int L = suf[l], R = pre[r]; if(L &lt; R)&#123; if(!cnt.count(&#123;L, R&#125;)) ans ++; cnt[&#123;L, R&#125;] = true; &#125;else f = true; &#125; cout &lt;&lt; ans + (f ? 1 : 0) &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 硬着去哈希就寄了 D. Array Painting 题意 给定一个由 \(0, 1, 2\) 组成的字符串，一开始所有格子都是蓝色的。 现在，根据下面的规则，将所有的格子涂成红色： 花费一个金币，将一个蓝色格子涂成红色； 如果某个红色格子值大于 \(0\)，那么可以以 \(-1\) 的代价，将相邻的某个蓝色格子变成红色 输出让所有格子变成红色的最小代价。 思路 我们可以先进行预处理。 因为操作的传递，连续的 \(1\) 等价于一个 \(1\)，连续的 \(2\) 等价于一个 \(2\)，因此我们对连续的 \(1, 2\) 进行等价替代。 同时，因为不好处理 \(12\) 连在一起的情况，我们直接将一个 "\(12\)" 其等价为一个 \(2\)。 如上预处理后，我们直接贪心即可。 我们从左向右枚举，贪心地将 \(1\) 的左端点做上标记，如果之前已经做标记，那就给右端点做标记。 同时，对于 \(2\)，我们直接将其左右端点都做标记。 那么，最后没有做标记的，就是我们需要花费金币填色的格子。 上述贪心是显然的，因为这样就可以避免出现 \(1\) 不知道取哪边而造成一定的浪费。 注意端点的判定。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(1); for(int i=0;i&lt;n;i++)&#123; //reduce int cur; cin >> cur; if(a[a.size() - 1] == 1 &amp;&amp; cur == 2) a[a.size() - 1] = 2; else if(cur == 0 || !a[a.size() - 1]) a.pb(cur); &#125; n = a.size() - 1; a.pb(0); vector&lt;bool> ok(n + 2); for(int i=1;i&lt;=n;i++)&#123; if(a[i] == 1)&#123; if(i - 1 >= 1 &amp;&amp; !ok[i - 1]) ok[i - 1] = true; else if(i + 1 &lt;= n &amp;&amp; !ok[i + 1]) ok[i + 1] = true; &#125;else if(a[i] == 2) ok[i - 1] = ok[i + 1] = true; &#125; int ans = 0; for(int i=1;i&lt;=n;i++) if(!ok[i]) ans ++; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while (t--) solve(); &#125; 别问我为什么挂了这么多发（ E. Max to the Right of Min 题意 给定一个序列，对于所有其连续子序列 \([l, r]\)，统计 最大值 在 最小值 右边 的区间个数。 思路 我们考虑枚举最大值和最小值的位置。 对于最大值的下标 \(i\)，最小值的下标 \(j\)，\([i\) 左边第一个比它大的元素的下标 \(+1, i\) 右边第一个比它大的元素的下标 \(-1]\) 和 \([j\) 左边第一个比它小的元素的下标 \(+1, j\) 右边第一个比它小的元素的下标 \(-1]\) 这两个区间的交集即为 \([i, j]\) 最大可左右扩展的区间范围。 我们可以用两个单调栈预处理，得到 \(l_{max}, r_{max}, l_{min}, r_{min}\) 四个数组，表征字面意思。 关于枚举，我们也可以开一个单调栈，用于维护从左到右遍历时，以第 \(i\) 位作为最大值，前面比它小的元素的下标。 那么，我们可以得到下面的暴力写法： int ans = 0; vector&lt;int> s(1, -1); for(int i=0;i&lt;n;i++)&#123; //枚举第i位作为最大值所在点 for(int j=1;j&lt;s.size();j++)&#123; //枚举第j位作为最小值所在点 ans += max(0ll, (s[j] - max(lmax[i], s[j - 1]))) * max(0ll, (min(rmax[i], rmin[s[j]]) - i)); &#125; while(s.size() > 1 &amp;&amp; p[i] &lt; p[s.back()])&#123; rmin[s.back()] = i; s.pop_back(); &#125; s.pb(i); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; 上述代码是 \(tle\) 的，因而我们考虑优化。 首先，我们先去掉两个和 \(0\) 取 \(max\) 的操作。因为单调栈 \(s\) 递增，我们直接二分 \(s\)，找出第一个大于 \(l_{max}[i]\) 的点 \(l\)，那么即可去掉两个外围 \(max\)。 其次，因为上述二分，对于 \(l + 1\) 及以后的点，\(max(l_{max}[i], s[j - 1]) = s[j - 1]\)，所以我们将 \(j = l\) 的情况单独提出，剩余的部分就可以改为 \(s[j] - s[j - 1]\) 了。 我们再考虑后者。因为 \(s\) 和 \(r_{min}\) 自身的单调性，我们可以得知，\(r_{min}[s[j]]\) 也是单调的，从而我们可以找到第一个满足 \(r_{min}[s[j]] &gt; r_{max}[i]\) 的点 \(m\)，从而将两者分开，得到 \((s[j] - s[j - 1])\times(r_{max}[i] - i)\) 和 \((s[j] - s[j - 1]) \times (r_{min}[s[j]] - i)\)。 对于左式，因为都有公因子 \(r_{max}[i] - i\)，我们将其提出并合并同类项后，可得 \((s[m - 1] - s[l]) \times (r_{max}[i] - i)\)。 对于右式，我们将其拆开得到 \((s[j] - s[j - 1]) \times r_{min}[s[j]]\) 和 \((s[j] - s[j - 1]) \times i\)。那么，左边的可以用前缀和优化，右边的可以合并到上面的左式中。 如上，即可通过本题。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> p(n); for(int i=0;i&lt;n;i++) cin >> p[i]; vector&lt;int> lmin(n, -1), lmax(n, -1), rmin(n, n), rmax(n, n); //当前位置i 第一个左边比他小，左边比他大，右边比他小，右边比他大 vector&lt;int> smin, smax; //单调栈 for(int i=0;i&lt;n;i++)&#123; while(!smin.empty() &amp;&amp; p[i] &lt; p[smin.back()])&#123; rmin[smin.back()] = i; smin.pop_back(); &#125; if(!smin.empty()) lmin[i] = smin.back(); //满足单调性后自然可得 smin.pb(i); while(!smax.empty() &amp;&amp; p[i] > p[smax.back()])&#123; rmax[smax.back()] = i; smax.pop_back(); &#125; if(!smax.empty()) lmax[i] = smax.back(); smax.pb(i); &#125; int ans = 0; vector&lt;int> s(1, -1), sum(1, 0); //单调栈 前缀和 for(int i=0;i&lt;n;i++)&#123; //枚举第i位作为最大值所在点 // for(int j=1;j&lt;s.size();j++)&#123; //枚举第j位作为最小值所在点 // ans += max(0ll, (s[j] - max(lmax[i], s[j - 1]))) * max(0ll, (min(rmax[i], rmin[s[j]]) - i)); // &#125; while(s.size() > 1 &amp;&amp; p[i] &lt; p[s.back()])&#123; rmin[s.back()] = i; s.pop_back(); sum.pop_back(); &#125; int l = upper_bound(all(s), lmax[i]) - s.begin(); //规避外围两个max if(l &lt; s.size()) &#123; ans += (s[l] - max(lmax[i], s[l - 1])) * (min(rmax[i], rmin[s[l]]) - i); //提出第二个max //因为s单调，自然rmin[s[j]]也单调，最后会出现一个partition point，从而分开min int m = partition_point(s.begin() + l + 1, s.end(), [&amp;](int x) -> bool&#123; return rmin[x] > rmax[i]; &#125;) - s.begin(); ans += (s[m - 1] - s[l]) * rmax[i]; //化简 ans += sum.back() - sum[m - 1]; //前缀和处理 sum((s[j] - s[j - 1]) * rmin[s[j]]) ans -= (s.back() - s[l]) * i; &#125; sum.pb(sum.back() + (i - s.back()) * rmin[i]); s.pb(i); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t = 1; //cin >> t; while (t--) solve(); &#125; 代码参考了 \(\mathtt{jiangly}\) 的 视频，做了一些注释方便理解]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 888 Div. 3</title>
    <url>/blog/posts/1130572521/</url>
    <content><![CDATA[Contestant_. Rank 240. Rating +152 (+652 -500). A. Escalator Conversations 题意 给定 \(m\) 个台阶，以及相邻两个台阶的平面所在的高度差 \(k\)。 另给定 \(n\) 个人，每个人的高度是 \(h_i\)。 若两个人站在两个不同的台阶上，且 两个人的身高差 等于 这两个台阶的高度差，那么他们可以一起聊天。 给定 \(A\) 的身高 \(H\)，输出他可以和多少人聊天。 思路 题意简化为：遍历 \(h_i\)，设 \(x = abs(H - h_i)\)，记录满足 \(x | k\) 且 \(1 \leq \frac{x}{k} \leq m - 1\) 的个数。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m, k, h; cin >> n >> m >> k >> h; int cnt = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(abs(cur - h) / k > 0 &amp;&amp; abs(cur - h) / k &lt;= (m - 1) &amp;&amp; abs(cur - h) % k == 0)&#123; cnt ++; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 有点阅读理解了（ B. Parity Sort 题意 给定一个序列，定义一次操作为选择两个奇偶性相同的元素，并将其交换。 输出任意次交换后是否可以让序列不递减。 思路 我们记原序列为 \(a\)，并直接把序列升序排个序，记为序列 \(b\)。 我们遍历所有位，判断 \(a_i\) 和 \(b_i\) 的奇偶性是否都相等即可。 不相等，那就一定不可以。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n), b(n); for(int i=0;i&lt;n;i++) cin >> a[i], b[i] = a[i]; sort(all(b)); for(int i=0;i&lt;n;i++)&#123; if(a[i] % 2 != b[i] % 2)&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 签到 C. Tiles Comeback 题意 给定排成一行的 \(n\) 个方块，每个方块都有一个颜色 \(c_i\)。 现在，判断是否能找出一条 不后退的 从起点到终点的 路径，满足下面的条件： 路径长度是 \(k\) 的倍数； 路径可切割为若干段长为 \(k\) 的子段，每个子段需满足颜色相同 思路 很显然，我们直接找最短的路径。 也就是说，如果起点和终点颜色都为 \(p\)，我们直接在起点和终点中挑 \(k-2\) 个颜色为 \(p\) 的点即可。 如果起点和终点颜色分别为 \(p, q\)，那么我们取前 \(k\) 个颜色为 \(p\) 的点和后 \(k\) 个颜色为 \(q\) 的点即可。 前者直接判点的个数，后者还需多判一个条件，即 从左往右数第 \(k\) 个颜色为 \(p\) 的点 在 从右往左数第 \(k\) 个颜色为 \(q\) 的点的左边。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; if(a[0] == a[n - 1])&#123; int cnt = 0; for(int i=0;i&lt;n;i++)&#123; if(a[i] == a[0]) cnt ++; &#125; cout &lt;&lt; (cnt >= k ? "YES\n" : "NO\n"); return; &#125; int cnt = 0, l = -1, r = -1; for(int i=0;i&lt;n;i++)&#123; if(a[i] == a[0])&#123; cnt ++; if(cnt == k) &#123; l = i; break; &#125; &#125; &#125; if(cnt != k)&#123; cout &lt;&lt; "NO\n"; return; &#125; cnt = 0; for(int i=n-1;i>=0;i--)&#123; if(a[i] == a[n - 1])&#123; cnt ++; if(cnt == k) &#123; r = i; break; &#125; &#125; &#125; if(cnt != k)&#123; cout &lt;&lt; "NO\n"; return; &#125; cout &lt;&lt; (l &lt; r ? "YES\n" : "NO\n"); &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 简单思维题 D. Prefix Permutation Sums 题意 对于一个未知的原数组 \(t\)，将其进行前缀和运算后得到一个数组 \(a\)。 现在，将数组 \(a\) 中的一个数去掉，得到数组 \(b\)。 给定数组 \(b\)，判断其对应的原数组 \(t\) 是否是 \(n\) 的排列。 思路 我们先通过相邻项作差，得到差分数组 \(c\)。 因为存在删除了元素的情况，并且删除的位置不确定，因而我们会出现下面的几种情况： 删除的元素在序列的最后，此时得到的 \(c\) 相比 \(t\) 只会少一个数，且不会多出其他数； 删除的序列在其他位置，此时会少两个数，并多出一个数，多出的数是缺少的两个数之和 分讨判断即可。 至于判断，可以用 \(map\)。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; n --; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; map&lt;int, int> mp; for(int i=1;i&lt;=n;i++)&#123; mp[a[i] - a[i - 1]] ++; &#125; n ++; for(int i=1;i&lt;=n;i++)&#123; mp[i] --; &#125; int v0 = 0, v1 = 0, cnt1 = 0, cnt2 = 0; for(auto [x, y] : mp)&#123; if(y &lt; 0) v0 += x, cnt1 ++; else if(y > 0) v1 += x, cnt2 ++; &#125; if(cnt1 == 1 &amp;&amp; cnt2 == 0)&#123; cout &lt;&lt; "YES\n"; &#125;else if(cnt1 == 2 &amp;&amp; cnt2 == 1)&#123; cout &lt;&lt; (v0 == v1 ? "YES\n" : "NO\n"); &#125;else cout &lt;&lt; "NO\n"; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 应该是分讨全了 E. Nastya and Potions 题意 给定 \(n\) 种药水，每种药水具有价格 \(c_i\)。 初始状态下，给定 \(k\) 种无限供应的药水，其不需额外合成。 现在，给定每种药水的合成表，即每种药水可以用其他的药水进行合成。 合成时，如果某一个药水无限供应，或者已经被预先合成，那么这个药水无需购买；否则需要花费对应价格的金币。 输出合成每种药水需要的最小金币数。 思路 首先，我们不妨将无限供应的药水的价格设为 \(0\)，那么本题就等价于如何安排药水的合成顺序，来让每种药水合成的原材料尽可能已经被合成。 如果药水 \(p\) 可以由 \(a, b, c\) 合成，我们就建立三条有向边 \(a \rightarrow p, b \rightarrow p, c \rightarrow p\)。然后依照拓扑序来合成即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=1;i&lt;=k;i++) &#123; int cur; cin >> cur; a[cur] = 0; &#125; vector&lt;vector&lt;int>> e(n + 1); vector&lt;int> in(n + 1); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; while(cur --)&#123; int x; cin >> x; if(a[i] == 0) continue; e[x].pb(i); in[i] ++; &#125; &#125; queue&lt;int> q; vector&lt;int> val(n + 1); for(int i=1;i&lt;=n;i++)&#123; if(in[i] == 0) &#123; val[i] = inf; q.emplace(i); &#125; &#125; while(!q.empty())&#123; int x = q.front(); q.pop(); a[x] = min(a[x], val[x]); for(auto p : e[x])&#123; val[p] += a[x]; if(--in[p] == 0) q.emplace(p); &#125; &#125; for(int i=1;i&lt;=n;i++) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 有种奇怪的贪心的味道 F. Lisa and the Martians 题意 给定一个序列 \(a\)，满足 \(0 \leq a_i &lt; 2^k\)，其中 \(k\) 给定。 现在，对于式子 \((a_i \oplus x) \&amp; (a_j \oplus x), 0 \leq x &lt; 2 ^ k\)，输出所有可能的答案中，最大的答案对应的 \(i, j, x\)。 思路 首先，如果我们不异或，那么我们一定希望取最高位尽量都是 \(1\) 的二元组。 那么，在异或的参与下，我们可以将 \(0\) 转变为 \(1\)，也就是说，如果某一位对应的 \(a_i, a_j\) 上的值相等，我们就可以通过异或将其改为全是 \(1\)，从而使其与运算后变为 \(1\)。 那么，不难发现，在异或的参与下，最后的最优答案就是 \(a_i,a_j\) 同或后的值的最大值。 也就是说，最后答案就是 使 \(a_i \oplus a_j\) 最小的 二元组 \(&lt;i, j&gt;\)。 至此，我们有两种做法。 一种做法是 \(\mathtt{01\ Trie}\)，我们利用贪心即可解决。 另一种做法是根据异或的性质。 我们将数组 \(a\) 排序，并计算相邻两个数的异或值的最小值，那么这个最小值对应的二元组在原数组的下标即为答案。 不难证明，数组中两个数的异或值的最小值 就是 排序后所有相邻数的异或值的最小值。 得到答案后，我们按照 \(a_i, a_j\) 每一位的关系构造 \(x\) 即可。 时间复杂度：\(O(n \log n)\) 对应AC代码（xor性质） #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; vector&lt;pii > a(n); for (int i = 0; i &lt; n; i++) cin >> a[i].fs, a[i].sc = i + 1; sort(all(a)); int ind = 0, ans = 0; for (int i = 1; i &lt; n - 1; i++) &#123; if ((a[i].fs ^ a[i + 1].fs) &lt; (a[ind].fs ^ a[ind + 1].fs)) &#123; ind = i; ans = (a[i].fs ^ a[i + 1].fs); &#125; &#125; cout &lt;&lt; a[ind].sc &lt;&lt; ' ' &lt;&lt; a[ind + 1].sc &lt;&lt; ' '; int f1 = a[ind].fs; int res = 0; for (int i = k - 1; i >= 0; i--) &#123; int t1 = (f1 >> i) &amp; 1, t2 = (f1 >> i) &amp; 1; res *= 2; if (t1 == t2) res += (1 ^ t1); else res++; &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 对应AC代码（01 Trie） #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 3e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; struct TRIE01 &#123; int nxt[N][2], idx, cnt[N], len; void init(int k) &#123; len = k, memset(nxt, 0, (sizeof nxt[0]) * (idx + 1)), memset(cnt, 0, (sizeof cnt[0]) * (idx + 1)), idx = 0; &#125; void change(int x, bool del = false)&#123; int now = 0; for(int i= len - 1; i >= 0;i--) &#123; int p = (x >> i) &amp; 1; if(!nxt[now][p]) nxt[now][p] = ++ idx; now = nxt[now][p], cnt[now] += (del ? -1 : 1); &#125; &#125; void insert(int x) &#123; change(x); &#125; void remove(int x) &#123; change(x, true); &#125; int query(int s, bool large = true)&#123; //查找和x异或后的最大值/最小值 int now = 0, ans = large ? 0 : (1 &lt;&lt; len) - 1; bool st = true; //取最小时，需要判断 是否是 第一次出现 cnt&lt;2 的情况，防止自身异或 for (int i = len - 1; i >= 0; i--) &#123; int x = (s >> i) &amp; 1; if(large) x ^= 1; if (!nxt[now][x] || (!large &amp;&amp; st &amp;&amp; cnt[nxt[now][x]] &lt; 2)) &#123; st = false; now = nxt[now][x ^ 1]; &#125; else &#123; ans += (large ? 1 : -1) * (1 &lt;&lt; i); now = nxt[now][x]; &#125; &#125; return ans; &#125; &#125;trie01; void solve() &#123; int n, k; cin >> n >> k; trie01.init(k); vector&lt;int> a(n); map&lt;int, vector&lt;int>> mp; //存vector防止重复下标 for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; trie01.insert(a[i]); mp[a[i]].pb(i); &#125; int ans = inf, ind = 0; for(int i=0;i&lt;n;i++) &#123; int x = trie01.query(a[i], false); if(x &lt;= ans) ind = i, ans = x; &#125; cout &lt;&lt; ind + 1 &lt;&lt; ' ' &lt;&lt; (mp[ans ^ a[ind]][0] == ind ? mp[ans ^ a[ind]][1] : mp[ans ^ a[ind]][0]) + 1 &lt;&lt; ' '; int f1 = a[ind]; int res = 0; for (int i = k - 1; i >= 0; i--) &#123; int t1 = (f1 >> i) &amp; 1, t2 = (f1 >> i) &amp; 1; res *= 2; if (t1 == t2) res += (1 ^ t1); else res ++; &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 这个性质太强了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 887 Div. 2</title>
    <url>/blog/posts/3257690774/</url>
    <content><![CDATA[Contestant~. Rank 1116. Rating -8(+92 -100). A. Desorting 题意 给定一个序列 \(a\)，定义操作如下： 选择一个下标 \(i \in [1, n - 1]\)； 将 \(a_1, a_2, \ldots, a_i\) 中所有元素 \(+1\)； 将 \(a_{i+1}, a_{i+2}, \ldots, a_n\) 中所有元素 \(-1\) 输出使序列 \(a\) 不是不递减序列的最小操作数。 思路 显然，我们只需贪心地认为序列中某两个相邻数满足 \(a_i &gt; a_{i + 1}\)，就可以判定其不是不递减序列。 那么，我们先判断给定序列是否是不递减序列，如果不是，直接输出 \(0\)； 否则，我们找出相邻差值的最小值 \(d\)，答案即为 \(\frac{d}{2} + 1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; bool f = true; for(int i=1;i&lt;n;i++) &#123; if(a[i - 1] > a[i]) f = false; &#125; if(!f)&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; int ans = inf; for(int i=0;i&lt;n-1;i++)&#123; ans = min(ans, (a[i + 1] - a[i] + 2) / 2); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; \(A\) 就整 要绕一圈 的思维题 B. Fibonaccharsis 题意 给定序列的最后一项 \(n\)，以及序列的长度 \(k\)，输出序列的所有数量，满足其为非负整数的斐波那契数列。 思路 首先，因为 \(2e5\) 范围内的斐波那契数列最多只有 \(20\) 多项，所以题面中的 \(k \leq 1e9\) 纯属诈骗。 那么，因为我们知道最后一项，我们直接枚举倒数第二项的值，然后倒推即可。 最后，这个序列需要满足下面的条件： \(a_i \leq a_{i + 1}\)； 第一个数可以是 \(0\)，其余不可以是 \(0\) 暴力枚举即可。 时间复杂度：\(O(nk)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, k; cin >> n >> k; int ans = 0; for(int i=n;i>=0;i--)&#123; int rr = n, rl = i; bool f = true; for(int j=3;j&lt;=k;j++)&#123; int tmp = rr - rl; rr = rl, rl = tmp; if(rl > rr || (rl == 0 &amp;&amp; j != k))&#123; f = false; break; &#125; &#125; if(f) ans ++; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 正推就寄咯 C. Ntarsis' Set 题意 给定一个升序无重复数字的数组 \(a\)，定义一次操作如下： 枚举 \(i \in [1, n]\)； 按顺序删除给定序列的第 \(a_i\) 个数。 现在，对 \(\{1, 2, 3, \ldots, inf\}\) 序列，执行 \(k\) 次操作，输出第一小的数。 思路 首先，在删除第 \(a_n\) 个数的时候，不难发现，前面删除了多少数是已知的。 也就是说，我们会固定删除 \(a_n, a_n + n, a_n + 2n, \ldots\)。 同理，我们可以发现，我们在不考虑后面的数字的时候，如果假设最后答案 \(x\) 已知，那么前 \(x - 1\) 个数的约束下，我们就可以确定我们需要删多少数了。 具体来说，我们在 \(a_1 - 1, a_2 - 2,\ldots, a_n - n\) 位置的后面加上一个 \(0\)，就可以保证需要删除的位置都是 \(0\)。至此，我们完成了将相对位置转换为绝对位置的操作。 因此，我们枚举 \(a_i\)，并考虑能在当前答案 \(ans\) 前找到多少个 \(a_i - i\)，从而更新当前答案的范围。 如果能放 \(p\) 个 \(a_i - i\)，那么范围扩大 \(i \times p\)，即可保证在所有 \(a_i\) 位置都插上了 \(0\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n + 1, inf); for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; a[i] -= i; &#125; if(a[0] != 1)&#123; cout &lt;&lt; 1 &lt;&lt; '\n'; return; &#125; int ans = 1, inc = 1; while(inc &lt; n)&#123; int now = (a[inc] - ans + inc - 1) / inc; //前面有多少a[inc] - inc if(now >= k)&#123; ans += k * inc; k = 0; break; &#125; ans += now * inc; k -= now; while(a[inc] &lt;= ans) inc ++; &#125; cout &lt;&lt; ans + k * n &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 这题做法挺多，但都很难解释，这边给出了官方题解的做法.]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 886 Div. 4</title>
    <url>/blog/posts/2369307671/</url>
    <content><![CDATA[Contestant~. Rank 96. Rating +99. (+249 -150). 终于ak一场div4了 A. To My Critics 题意 给定三个数，输出最大两个数的和是否 \(\geq 10\)。 思路 如题。 方便写的话可以考虑存到数组里。 时间复杂度：\(O(n \log n)?\) 对应AC代码 #pragma GCC optimize(2) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; vector&lt;int> a(3); for(int i=0;i&lt;3;i++) cin >> a[i]; sort(all(a)); if(a[1] + a[2] >= 10) cout &lt;&lt; "YES\n"; else cout &lt;&lt; "NO\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 无脑签 B. Ten Words of Wisdom 题意 给定 \(n\) 句话的长度以及价值，输出长度不超过 \(10\) 的最大价值对应的下标。 思路 如题。 时间复杂度：\(O(n)\) 对应AC代码 #pragma GCC optimize(2) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int idx = -1, vidx = -1; for(int i=1;i&lt;=n;i++)&#123; int x, y; cin >> x >> y; if(x > 10) continue; if(idx == -1)&#123; idx = i; vidx = y; &#125;else&#123; if(y > vidx) idx = i, vidx = y; &#125; &#125; cout &lt;&lt; idx &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 无脑签 C. Word on the Paper 题意 对于一个 \(8 \times 8\) 的矩阵，初始状态下都是 "."。 现在，选定一列，并在该列插入一个连续的单词。 给定插入后的矩阵，输出单词。 思路 既然只会出现在某一列，我们直接一列一列枚举枚举所有位，将所有非 "." 字符拼接到答案上即可。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #pragma GCC optimize(2) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; vector&lt;string> a(8); for(int i=0;i&lt;8;i++) cin >> a[i]; string ans = ""; for(int j=0;j&lt;8;j++)&#123; for(int i=0;i&lt;8;i++)&#123; if(a[i][j] == '.') continue; ans += a[i][j]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 无脑签 D. Balanced Round 题意 给定一个序列，定义操作如下： 删除一些元素； 任意排序序列 在任意次操作后，输出需要删除多少元素，使得最后的序列满足 相邻元素差的绝对值 \(\leq k\)，其中 \(k\) 给定。 思路 既然要让差值的绝对值尽可能小，唯一办法就是升序或降序排序。 我们考虑升序排序，那么如果某两个相邻数的差值的绝对值大于 \(k\)，若我们删掉左边的元素，那么右边的元素和其新的相邻数的差值是一定大于 \(k\) 的。另一边也是同理的。 因而我们不难发现，最佳方案就是 将排序后的序列切割为若干个区间，满足相邻区间的相邻端点之差的绝对值 \(&gt; k\)，区间内所有相邻数之差的绝对值 \(\leq k\)。 那么，显然我们只能保留一个区间，那么答案就是 \(n - len_{max}\)。 时间复杂度：\(O(n \log n)\) 对应AC代码 #pragma GCC optimize(2) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, k; cin >> n >> k; vector&lt;int> a(n + 2, inf); a[0] = 0; for(int i=1;i&lt;=n;i++) cin >> a[i]; sort(all(a)); int len = 1, now = 1; for(int i=2;i&lt;=n+1;i++)&#123; if(a[i] - a[i - 1] > k)&#123; len = max(len, now); now = 1; &#125;else now ++; &#125; cout &lt;&lt; n - len &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 有脑签 E. Cardboard for Pictures 题意 给定 \(n\) 个正方形照片的边长 \(s_i\)。 现在，将每张照片裱上宽度为 \(w\) 的边框，将其变成大正方形。 给定最后所有大正方形的面积和，输出 \(w\)。 保证有解。 思路 最简单的思路莫过于推式子 \(+\) 求根公式，但是存在 \(sqrt\) 卡精度和 \(long\ long\) 爆掉的情况。 当然，前者可以加优化，后者可以用 \(\_\_int128\) 代替，不过我们不妨换个思路。 我们直接考虑二分答案。 我们二分 \(w\)，那么根据 \((s[i] + 2w) ^ 2\) 的大小 \(check\) 即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #pragma GCC optimize(2) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, c; cin >> n >> c; vector&lt;int> s(n + 1); for(int i=1;i&lt;=n;i++) cin >> s[i]; auto check = [&amp;](int x) -> bool&#123; int ans = 0; for(int i=1;i&lt;=n;i++)&#123; ans += (s[i] + 2 * x) * (s[i] + 2 * x); if(ans >= c) return false; &#125; return ans &lt; c; &#125;; int l = 0, r = 1e9, mid; while(l &lt; r)&#123; mid = (l + r) >> 1ll; if(check(mid)) l = mid + 1; else r = mid; &#125; cout &lt;&lt; l &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 更搞笑的是，我一开始式子还推错了 F. We Were Both Children 题意 给定 \(n\) 只青蛙的跳跃距离 \(a_i\)，所有青蛙从 \(0\) 开始向前跳跃。 现在，规定可以在 \([1, n]\) 之内选择一个节点放上陷阱，青蛙到达这个节点会被困住。 输出能困住最多多少青蛙。 思路 我们用类似预处理的方式，先记录能跳 \(p\) 距离的青蛙一共有多少只，然后在 \([1, n]\) 里枚举能跳到的点，记录该点有多少青蛙经过。 那么，最后答案就是 \([1, n]\) 中青蛙数量最多的节点对应的个数。 时间复杂度：\(O(\frac{n}{1} + \frac{n}{2} + \ldots +\frac{n}{n}) = O(n \log n)\) 对应AC代码 #pragma GCC optimize(2) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n + 1), s(n + 1); map&lt;int, int> mp; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; mp[a[i]]++; &#125; for(auto [x, y] : mp)&#123; //分块暴力 for(int i=x;i&lt;=n;i+=x) s[i] += y; &#125; int ans = 0; for(int i=1;i&lt;=n;i++) ans = max(ans, s[i]); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 真就暴力呗 G. The Morning Star 题意 给定 \(n\) 个点的二维坐标，输出有多少不同的两个点组成的二元组，满足两个点所在直线的倾斜角为 \(0°, 45°, 90°, 135°\)。 思路 这四个倾斜角对应的方程为 \(x = t, y = x + t, y = t, y = -x + t\)。 可以发现，每个方程都只有一个特征值 \(t\)，我们将其作为 \(map\) 的参数，分别统计每个方程不同参数下有多少个点。 那么，如果对于 \(y = x + t\)，在某个特定的 \(t\) 下，满足该方程的点有 \(cnt\) 个，那么该情况下的二元组个数为 \(cnt(cnt - 1)\)。 时间复杂度：\(O(n \log n)\) 对应AC代码 #pragma GCC optimize(2) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; map&lt;int, int> a, b, c, d; vector&lt;pii> p(n + 1); for(int i = 1; i &lt;= n; i ++)&#123; cin >> p[i].fs >> p[i].sc; a[p[i].fs] ++; b[p[i].sc] ++; c[p[i].fs - p[i].sc] ++; d[p[i].fs + p[i].sc] ++; &#125; int ans = 0; for(auto [x, y] : a) ans += y * (y - 1); for(auto [x, y] : b) ans += y * (y - 1); for(auto [x, y] : c) ans += y * (y - 1); for(auto [x, y] : d) ans += y * (y - 1); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 还是很暴力捏 H. The Third Letter 题意 给定 \(n\) 个人，以及 \(m\) 个限制条件。 第 \(i\) 个限制条件包含三个整数 \(a_i, b_i, c_i\)，表示在数轴上，第 \(a_i\) 个人在第 \(b_i\) 个人前面 \(c_i\) 个单位长度位置。 输出限制是否存在冲突。 思路 首先，这是一道很经典的带权并查集，并且有一道约等于一模一样的题：Zjnu Stadium. 下面给出具体思路： 我们可以对每个连通块单独考虑。 对于每一个连通块，根据并查集的做法，我们知道每个点最后会连结到一个父节点。 那么，我们不妨在连结的时候，加入一个新的参数：距离 \(d\)。 我们设一条有向边为 \(u \rightarrow v\)，距离为 \(w\)。\(u\) 在并查集中的父节点为 \(f1\)，\(v\) 在并查集中的父节点为 \(f2\)。 我们在连边的时候，也就是 \(unite\) 函数内，添加对距离 \(d\) 的更新。 我们将 \(u\) 的父节点更新为 \(f2\)，那么 \(u\) 与 \(f2\) 之间的距离就是 \(w\)，但是在之前 \(u\) 的权重值是相对于 \(f1\) 计算的，所以我们需要减去 \(d[u]\)，再加上 \(d[v]\)，才能得到相对于 \(f2\) 的权重值。 因而，我们在 \(unite\) 函数内添加 \(d[f2] = d[u] + w - d[v]\). 当然，因为我们进行了路径压缩，所以在 \(find\) 函数里也得对应更新一下 \(d\)。 时间复杂度：\(O(m \log n)\) 对应AC代码 #pragma GCC optimize(2) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; struct DSU &#123; vector&lt;int> pa; void init(int n) &#123; pa = vector&lt;int>(n + 1), iota(all(pa), 0); &#125; int find(vector&lt;int> &amp;d, int x) &#123; if(pa[x] != x)&#123; int root = find(d, pa[x]); d[x] += d[pa[x]]; return pa[x] = root; &#125; return x; &#125; &#125;dsu; void solve()&#123; int n, m; cin >> n >> m; vector&lt;int> d(n + 1); dsu.init(n); bool f = true; while(m --)&#123; int u, v, w; cin >> u >> v >> w; int f1 = dsu.find(d, u), f2 = dsu.find(d, v); if(f1 == f2)&#123; if(d[v] - d[u] != w)&#123; f = false; &#125; &#125;else&#123; dsu.pa[f2] = f1; d[f2] = d[u] + w - d[v]; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 一开始忘了更新 \(find\) 了，能过样例还是很抽象的]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 310</title>
    <url>/blog/posts/3721656837/</url>
    <content><![CDATA[Contestant. Rank 1293. Rating +429. 待更新. A. Order Something Else 题意 给定一个需要购买的物品的原价和促销价。 促销价需要多买一个其他物品，需在 \(n\) 个物品中选一个，并支付额外费用。 输出最少开支。 思路 从额外需购买的物品中找出最小价格，并和促销价求和，最后和原价取最小值。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, p, q; cin >> n >> p >> q; int mn = inf; for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; mn = min(mn, cur); &#125; int x = min(p, q + mn); cout &lt;&lt; x &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while (t--) solve(); &#125; 阅读理解 B. Strictly Superior]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 884 Div. 1 + 2</title>
    <url>/blog/posts/1574447968/</url>
    <content><![CDATA[Contestant~. Rank 1733. Rating +45(+295 -250). 乱猜结论场，猜不出来坐牢场 A. Subtraction Game 题意 给定两个人之间的博弈：每个人可以选择拿走 \(a\) 或 \(b\) 个石头。 输出后手有必胜策略的石头的总数。 思路 很经典的博弈。 如果先手拿走 \(x\) 个石头后，后手都能拿走 \(n - x\) 个石头，那么后手必胜。 那么，\(n = a + b\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 3e5 + 10, mod = 1e9 + 9, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int a, b; cin >> a >> b; cout &lt;&lt; a + b &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 怎么有人放典题啊 B. Permutations &amp; Primes 题意 给定排列的长度 \(n\)，构造一个排列，满足所有连续子序列中 \(MEX\) 为质数的子序列最多。 \(MEX\) 代表不出现在区间中的最小正数。 思路 首先，我们希望 \(MEX\) 尽量不等于 \(1\)，那么我们就需要将 \(1\) 放在中间。 其次，比 \(1\) 大的两个质数刚好是 \(2, 3\)，也就是说，如果某个区间内包含了 \(1\)，但不包含 \(2\) 或 \(3\)，那么它的 \(MEX\) 就一定是质数。 换句话说，我们希望 \(2, 3\) 尽可能不出现在区间中，因此我们将其放在两个端点。 那么，剩下的位置，任意放置即可，因为只要不包含 \(1\)，就一定不是质数。 基于上述操作的考虑，在赛时可能会出现下面的猜测： 中间放 \(1\)，左边升序放奇数，右边降序放偶数； 中间放 \(1\)，依次在两端放上质数，剩下的填合数； ... 时间复杂度：\(O(n)\) 对应AC代码（猜测1） #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 9, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; for(int i=3;i&lt;=n;i+=2) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; 1 &lt;&lt; ' '; for(int i=n-n%2;i>=2;i-=2) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 对应AC代码（正解） #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 9, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> ans(n); ans[0] = 2, ans[n - 1] = 3, ans[n / 2] = 1; int val = 4; for(int i=0;i&lt;n;i++)&#123; if(ans[i]) continue; ans[i] = val ++; &#125; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 如果再胆大一点就不会卡着半小时不交题了（悲 C. Particles 题意 给定一个序列，定义一次操作如下： 选定一个元素； 将其删除； 将其左边和右边的元素合并，值变为两者之和 输出任意操作后，最后剩余的一个数的最大值。 思路 首先，我们不难发现，奇偶性不同的两个元素是不可能加在一起的。 其次，如果奇数位上出现负数，我们将其删除后，左右两者合并之后变为一个元素，那么这个元素变成偶数位上的元素，无法参与奇数位的运算了。 偶数位也是一样。 也就是说，我们只需统计奇数位和偶数位的和，遇到负数的时候，直接忽略即可。 当然，如果全都是负数，我们取负数的最大值。 很巧的是，赛时写了个连续子序列的 \(dp\)，刚好顺手用 \(0\) 和负数取了个最大值，刚好就是正解（小声 时间复杂度：\(O(n)\) 对应AC代码（dp） #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 9, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 2); for(int i=2;i&lt;=n+1;i++) cin >> a[i]; vector&lt;vector&lt;int>> dp(n + 2, vector&lt;int>(2, -inf)); for(int i=2;i&lt;=n+1;i++)&#123; dp[i][0] = max(dp[i - 2][0], dp[i - 2][1]); dp[i][1] = max(0ll, dp[i][0]) + a[i]; &#125; cout &lt;&lt; max(max(dp[n][0], dp[n][1]), max(dp[n + 1][0], dp[n + 1][1])) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 对应AC代码（正解） #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 9, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int ans0 = 0, ans1 = 0, mx = -inf; for(int i=1;i&lt;=n;i++) &#123; int cur; cin >> cur; mx = max(mx, cur); if(cur &lt; 0) continue; if(i % 2 == 0) ans0 += cur; else ans1 += cur; &#125; cout &lt;&lt; (mx &lt; 0 ? mx : max(ans0, ans1)) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 真就乱猜 D. Row Major 题意 给定字符串的长度 \(n\)，对于所有 \(a \times b = n\)，将字符串横向依次放入 \(a \times b\) 的矩阵中，输出一个字符串，满足所有矩阵的所有相邻字符都不相同，且字符的种数最小。 如 "tomato"： \(\mathtt{t\ \ \ \ t\ o\ \ \ \ t\ o\ m\ \ \ \ t\ o\ m\ a\ t\ o}\) \(\mathtt{o\ \ \ \ m\ a\ \ \ \ a\ t\ o}\) \(\mathtt{m\ \ \ \ t\ o}\) \(\mathtt{a}\) \(\mathtt{t}\) \(\mathtt{o}\) 思路 很明显，如果循环节是 \(n\) 的因数，我们就不能出现重复。 因而，我们只需枚举所有数，找出第一个不是 \(n\) 的因数的数即可，这个数就可以作为循环节。 这样，即可让字符的种数最小。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 9, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int len = 1; while(n % len == 0) len ++; for(int i=1;i&lt;=n;i++) cout &lt;&lt; (char) ('a' + ((i - 1) % len)); cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 什么诈骗题啊 E. Great Grids 题意 给定一个 \(n \times m\) 的字符矩阵，矩阵满足下面的条件： 字符为 \(A, B, C\) 中的其中一个； 每个 \(2 \times 2\) 连续子矩阵中，必须同时出现 \(A, B, C\)； 相邻两个字符不能相同 现在，给定 \(k\) 个限制，每个限制给定两个坐标 \((x1, y1), (x2, y2)\)，满足两点为 \(2 \times 2\) 连续子矩阵中的对角。 对于每个限制，要求这两点字符相同。 输出是否可以构造出这个矩阵。 思路 我们设 \(A = 0, B = 1, C = 2\)。 观察/证明 1 对于下面的矩阵： \(\mathtt{x\ \ y}\) \(\mathtt{y\ \ z}\) 若 \((y - x)\mod 3 = p, (z - y)\mod 3 = q\)，我们进行下面的化简： \(=&gt; (y - (3 - y - z))\mod 3 = p\) \(=&gt; (2y + z)\mod 3 = p\) \(=&gt; ((2y + z) - (z - y))\mod 3 = p - q\) \(=&gt; (3y) \bmod 3 = p - q\) \(=&gt; 0 = p - q\) \(=&gt; p = q\) \(\mathtt{x\ \ y}\) \(\mathtt{z\ \ x}\) 同理可证得。 那么，对于所有的 \(2 \times 2\) 连续子矩阵，由于两两相邻，等式具有传递性，也就是说，每两列左右元素差值在模 \(3\) 意义下相等。 行的差值同理可证得，模 \(3\) 意义下也是相等的。 观察/证明 2 对于下面的矩阵： \(\mathtt{x\ \ y}\) \(\mathtt{z\ \ x}\) 若 \((y - x)\mod 3 = p, (z - x)\mod 3 = q\)，很显然 \(p \neq q\)。 也就是说，"\" 对角线上相等，行列差值不同。 而对于下面的矩阵： \(\mathtt{x\ \ y}\) \(\mathtt{y\ \ z}\) 显然行列差值相同。 也就是说，"/" 对角线上相等，行列差值相同。 归纳 通过上述分析，我们可以将所有限制转化为对应的 相邻行差值 和 相邻列差值 是否相等。 更具体地说，我们将 所有相邻行和所有相邻列 的差值 这一"属性" 都视为图中的点，那么所有限制等价为两个点的值是否相同。 也就是等价为 图上两个点的颜色是否相同 的限制。 这就是 二分图 问题。那么，我们只需 \(\mathtt{dfs}\)，判断涂色是否出现冲突即可。 时间复杂度：\(O(n + m + k)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 9, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m, k; cin >> n >> m >> k; vector&lt;vector&lt;pii>> e(n + m + 1); while(k --)&#123; int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2; e[min(x1, x2)].pb(n + min(y1, y2), y2 != y1 - 1); e[n + min(y1, y2)].pb(min(x1, x2), y2 != y1 - 1); &#125; vector&lt;int> color(n + m + 1, -1); bool f = true; auto dfs = [&amp;](auto dfs, int x, int c) -> void&#123; if(color[x] != -1 || !f) return; color[x] = c; for(auto [p, r] : e[x])&#123; if(color[p] != -1)&#123; if((color[p] != color[x]) != r)&#123; f = false; cout &lt;&lt; "NO\n"; return; &#125; continue; &#125; dfs(dfs, p, c ^ r); if(!f) return; &#125; &#125;; for(int i=1;i&lt;=n+m;i++)&#123; if(color[i] != -1) continue; dfs(dfs, i, 0); if(!f) return; &#125; cout &lt;&lt; "YES\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 但凡往模三上去想]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 883 Div. 3</title>
    <url>/blog/posts/1097104915/</url>
    <content><![CDATA[Contestant~. Rank 538. Rating +59 (+409 -350). A. Rudolph and Cut the Rope 题意 给定 \(n\) 个钉子，第 \(i\) 个钉子钉在离地面 \(a_i\) 的位置，并连有 \(b_i\) 长的绳子。所有钉子的另外一端连着同一个糖果。 输出需要剪断多少根绳子，让糖果掉到地上。 思路 画个图即可，我们不难发现最后的结果就是 \(a_i &gt; b_i\) 的钉子个数。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int a, b; cin >> a >> b; if(a > b) ans ++; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 具象的，抽象的，物理的 B. Rudolph and Tic-Tac-Toe 题意 \(3\) 个人玩 \(3 \times 3\) 的井字格游戏。 给定某个时刻的井字格状态，输出当前是否出现了赢家。 如果没有赢家，或者出现多个赢家，输出 \(\mathtt{DRAW}\)。 思路 直接枚举即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; vector&lt;string> s(3); for(int i=0;i&lt;3;i++) cin >> s[i]; bool a = false, b = false, c = false; for(int i=0;i&lt;3;i++)&#123; if(s[i][0] == s[i][1] &amp;&amp; s[i][1] == s[i][2])&#123; if(s[i][0] == 'O') a = true; else if(s[i][0] == 'X') b = true; else if(s[i][0] == '+') c = true; &#125; &#125; for(int i=0;i&lt;3;i++)&#123; if(s[0][i] == s[1][i] &amp;&amp; s[1][i] == s[2][i])&#123; if(s[0][i] == 'O') a = true; else if(s[0][i] == 'X') b = true; else if(s[0][i] == '+') c = true; &#125; &#125; if(s[0][0] == s[1][1] &amp;&amp; s[1][1] == s[2][2])&#123; if(s[0][0] == 'O') a = true; else if(s[0][0] == 'X') b = true; else if(s[0][0] == '+') c = true; &#125; if(s[0][2] == s[1][1] &amp;&amp; s[1][1] == s[2][0])&#123; if(s[0][2] == 'O') a = true; else if(s[0][2] == 'X') b = true; else if(s[0][2] == '+') c = true; &#125; if(a &amp;&amp; !b &amp;&amp; !c)&#123; cout &lt;&lt; 'O' &lt;&lt; '\n'; &#125;else if(!a &amp;&amp; b &amp;&amp; !c)&#123; cout &lt;&lt; 'X' &lt;&lt; '\n'; &#125;else if(!a &amp;&amp; !b &amp;&amp; c) &#123; cout &lt;&lt; '+' &lt;&lt; '\n'; &#125;else cout &lt;&lt; "DRAW" &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 主打一个复制粘贴 C. Rudolf and the Another Competition 题意 对于 \(n\) 个人和 \(m\) 道题，给定每个人每道题需要花的时间。 每个人可以任意排列做题的顺序，给定比赛的总时长，在 \(\mathtt{ICPC}\) 规则下，若每个人都希望自己的排名尽可能高，输出第一个人最后的排名。 若第一个人和其他人的排名一致，第一个人的排名更高。 \(\mathtt{ICPC}\) 规则： 每一道题的罚时 \(=\) 通过这道题离 比赛开始 的时间； 排名的主关键词：过题数（降序），总罚时（升序） 思路 对于某一个人，我们将所有过题的时间升序排序，然后依次做题，如果某一道题做完的时候已经超过比赛总时长，那这题及以后的所有题都不用做了。 以上，我们统计过题数 \(cnt\)，罚时 \(pen\)，每个人的下标 \(i\)。 我们将三元组 \(\{-cnt, pen, i\}\) 升序排序，然后输出 \(i = 1\) 的位置即可。 不排序也是可以的，因为我们只需要知道第一个人的排名。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m, h; cin >> n >> m >> h; vector&lt;ppii> res(n); for(int i=0;i&lt;n;i++)&#123; vector&lt;int> a(m); for(int j=0;j&lt;m;j++) cin >> a[j]; sort(all(a)); int last = 0, cnt = 0, p = 0; for(int j=0;j&lt;m;j++)&#123; if(last + a[j] &lt;= h)&#123; p += last + a[j]; cnt ++; last += a[j]; &#125;else break; &#125; res[i] = &#123;-cnt, &#123;p, i&#125;&#125;; &#125; sort(all(res)); for(int i=0;i&lt;n;i++)&#123; if(res[i].sc.sc == 0)&#123; cout &lt;&lt; i + 1 &lt;&lt; '\n'; return; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; ICPCGPT D. Rudolph and Christmas Tree 题意 给定一个三角形的底和高，在坐标系中，三角形底边和 \(x\) 轴平行，高和 \(y\) 轴平行。 给定 \(n\) 个上述三角形的底边所在的 \(y\) 坐标，输出最后坐标轴上的图形的面积。 思路 显然会有重叠。 对于两个重叠的三角形，我们不难发现，底下的三角形需要去掉一个小三角形。 小三角形和原三角形是相似的，因而计算面积是很容易的（相似比的平方即为面积比）。 也许你会觉得三个三角形重叠的时候不能按照上述操作计算，但本题中三角形大小都是一样的，画个图不难发现，上述操作移除的小三角形面积不受其他的三角形影响。 那么，我们降序排序底边 \(y\) 坐标，然后枚举相邻的三角形是否出现重叠即可。 p.s. 本题按照升序给出了 \(y\) 坐标。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; //《容斥》 int n, d, h; cin >> n >> d >> h; vector&lt;int> y(n); for(int i=0;i&lt;n;i++) cin >> y[i]; int pre = inf; double ans = 0; for(int i=n-1;i>=0;i--)&#123; ans += (double) (d * h) / 2; if(y[i] + h > pre)&#123; ans -= (double) (d * h) / 2 * ((double) (y[i] + h - pre) * (y[i] + h - pre) / h / h); &#125; pre = y[i]; &#125; printf("%.7f\n", ans); &#125; signed main()&#123; //ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 还以为是不可做的几何题(x)。输出的时候记得输出 \(7\) 位小数 E1. Rudolf and Snowflakes (simple version) 题意 对于整数 \(k \in [2, +\inf)\)，定义 "雪花" 构造操作如下： 定义一个点为根节点； 根节点有 \(k\) 个子节点； 上述 \(k\) 个子节点，每个子节点自己有 \(k\) 个子节点； 重复任意次操作 \(3\)，操作 \(3\) 需要执行至少一次。 如 \(k = 4\)，操作 \(3\) 执行一次，雪花图如下： 现在，给定节点总数 \(n\)，判断是否可以用这些节点构造出一个雪花。 本题中，\(n \leq 1e6\)。 思路 本题的 \(n\) 比较小，我们考虑直接枚举所有 \(k\)，以及操作 \(3\) 执行的次数，对 \(n\) 打表即可。 不难发现 \(n\) 是等比数列的前 \(n\) 项和，我们套公式爆搜即可。 时间复杂度：不大 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; map&lt;int, bool> mp; int qp(int a, int b) &#123; int res = 1; while (b > 0) &#123; if (b &amp; 1) res = (res * a); a = (a * a); b >>= 1; &#125; return res; &#125; void init()&#123; int k = 2; while(true)&#123; bool f = false; int p = 3; while(true)&#123; if((qp(k, p) - 1) / (k - 1) > 1e6) break; mp[(qp(k, p) - 1) / (k - 1)] = true; f = true; p ++; &#125; if(!f) break; k ++; &#125; &#125; void solve() &#123; int n; cin >> n; cout &lt;&lt; (mp.count(n) ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 狠狠地打表 E2. Rudolf and Snowflakes (hard version) 题意 在 \(E1\) 的基础上，\(n \leq 1e18\)。 思路 首先，因为我们枚举的是等比数列的前 \(n\) 项和，我们不妨固定项数，观察答案不超过 \(1e18\) 的 \(k\) 的最大值。 我们不难发现，在量级上考虑，\(k &gt;1e9\) 时，只能取两项，\(k \in [1e6, 1e9]\) 时，只能取三项。 我们不可以取两项，那么我们只需对取三项的情况进行单独考虑。 取三项时，方程即为 \(q ^ 2 + q + 1 = n\)，那么如果能解出 \(q \geq 2\)，\(n\) 就是正确的。 否则，\(k\) 一定小于 \(1e6\) 量级。 分析复杂度可知，对 \(k \in [2, 1e6]\)，我们直接打表即可。 时间复杂度：还好 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; map&lt;int, bool> mp; __int128 qp(__int128 a, int b) &#123; __int128 res = 1; while (b > 0) &#123; if (b &amp; 1) res = (res * a); a = (a * a); b >>= 1; &#125; return res; &#125; void init()&#123; int k = 2; while(true)&#123; if(k > 1e6) break; bool f = false; int p = 3; while(true)&#123; if(p > 70) break; if((qp(k, p) - 1) / (k - 1) > 1e18 || (qp(k, p) - 1) / (k - 1) &lt;= 0) break; mp[(qp(k, p) - 1) / (k - 1)] = true; f = true; p ++; &#125; if(!f) break; k ++; &#125; &#125; void solve() &#123; int n; cin >> n; int delta = 1 - 4 * (1 - n); if((int) sqrt(delta) * (int) sqrt(delta) == delta)&#123; if((-1 + (int) sqrt(delta)) % 2 == 0)&#123; int q = (-1 + (int) sqrt(delta)) / 2; if(q >= 2) &#123; cout &lt;&lt; "YES\n"; return; &#125; &#125; &#125; cout &lt;&lt; (mp.count(n) ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 注意 越界 / 浮点数误差 的问题！ F. Rudolph and Mimic 题意 这是一道交互题。 在长度为 \(n\) 的序列 \(a\) 中，满足 \(1 \leq a_i \leq 9\)，存在一只怪物，躲藏在某一个未知元素后。 定义一次交互如下： 输出：给定序列中需要删除的元素； 输出后： 将元素删除； 打乱序列； 怪物可以选择是否将其所在元素的值改变为另一个不同的数，但两次交互后如果都不改变，第三次一定会改变 输入：操作后的序列 在不超过 \(5\) 次交互内，确定怪物在哪个下标。 注意，本题的所有下标都是针对上一次给定的序列，而不是最初给的序列。 思路 因为怪物第三次一定会改变，那么我们只要等他改变即可。 在等他改变的时候，我们为了防止误删怪物所在的元素，我们直接不删除。 那么，当他改变的时候，我们保留所有等于 他所在的元素的值 的元素，然后把其他的元素全都删掉。 接着，我们继续等待，当他再改变时，那个不同的元素就是怪物了。 为了方便判断，我们不妨记录每个值对应出现的下标，然后比较每个值出现了几次即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 3e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; auto fetch = [&amp;]() -> vector&lt;vector&lt;int>>&#123; vector&lt;vector&lt;int>> a(10); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; a[cur].pb(i); &#125; return a; &#125;; vector&lt;vector&lt;int>> a0 = fetch(); int leave; while(true)&#123; cout &lt;&lt; "- 0\n"; cout.flush(); vector&lt;vector&lt;int>> a1 = fetch(); int ind = -1; for(int i=1;i&lt;=9;i++)&#123; if(a1[i].size() > a0[i].size()) ind = i; &#125; if(ind != -1)&#123; leave = ind; a0 = a1; break; &#125; &#125; cout &lt;&lt; "- "; vector&lt;int> del; for(int i=1;i&lt;=9;i++)&#123; if(i == leave) continue; for(auto e : a0[i]) del.pb(e); &#125; cout &lt;&lt; del.size() &lt;&lt; ' '; n -= del.size(); for(auto e : del) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; cout.flush(); while(true)&#123; vector&lt;vector&lt;int>> a1 = fetch(); if(a1[leave].size() == a0[leave].size())&#123; cout &lt;&lt; "- 0\n"; cout.flush(); &#125;else&#123; for(int i=1;i&lt;=9;i++)&#123; if(i == leave) continue; if(a1[i].size() == 1)&#123; cout &lt;&lt; "! " &lt;&lt; a1[i][0] &lt;&lt; '\n'; cout.flush(); return; &#125; &#125; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 但凡题面正常一点 G. Rudolf and CodeVid-23 题意 给定 \(n\) 个病症，以及 \(m\) 种药。 每种药可以治疗若干病症，但也会导致若干个并发症。每个药都有一段服用时间。同一时刻只能服用一种药。治疗的病症不会出现在并发症中。 现在，给定初始患上的病症，输出在使用若干药后所有病症痊愈的条件下需要服用的最短时间。 本题输入使用二进制表示某一个病症是否患上。 思路 首先，因为二进制串长度很短，所以我们直接将其转为十进制处理。 对于任意一个状态，如果我们确定需要用什么药，那么用药结束后的状态是唯一确定的。 那么，我们唯一需要做的，就是对于初始状态，通过状态的转换，从而变为 \(0\)。 那么我们考虑图论，从某一个状态，连一条有向边到 使用某一个药之后的状态，边权就是这个药需要服用的时间。 那么很显然了，这道题就可以转化为 "求初始状态到 \(0\) 的最短路长度"。 有关计算，设 \(x, h, s\) 分别为服药前状态、能治哪些病、并发症，那么我们将 \(h\) 取反为 \(rh\)，不难发现最后结果就是 \((x\ \&amp;\ rh)|s\)。（取反操作可以考虑异或）。 有关建图，我们用类似 "状压枚举" 的方式，枚举所有可能的状态，对于某一个状态，枚举所有的药，然后按上述操作建边即可。 时间复杂度：\(O(2^n(m+n))?\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m; cin >> n >> m; int mx = (1 &lt;&lt; n) - 1; auto calc = [&amp;](string s) -> int&#123; int ans = 0; for(auto e : s) ans = ans * 2 + (e - '0'); return ans; &#125;; auto heal = [&amp;](int pre, int heal, int side) -> int&#123; return (pre &amp; (heal ^ mx)) | side; &#125;; string c; cin >> c; int start = calc(c); vector&lt;int> w(m), h(m), s(m); for(int i=0;i&lt;m;i++) &#123; string a, b; cin >> w[i] >> a >> b; h[i] = calc(a), s[i] = calc(b); &#125; vector&lt;vector&lt;pii>> e(mx + 1); for(int p=0;p&lt;=mx;p++)&#123; //《状压》 for(int i=0;i&lt;m;i++)&#123; e[p].pb(heal(p, h[i], s[i]), w[i]); &#125; &#125; auto dijkstra = [&amp;](int start, int end) -> int&#123; vector&lt;int> dist(mx + 1, inf); vector&lt;bool> st(mx + 1); dist[start] = 0; priority_queue&lt;pii, vector&lt;pii>, greater&lt;>> q; q.emplace(0, start); while (!q.empty())&#123; auto t = q.top(); q.pop(); int cur = t.second, d = t.first; if (st[cur]) continue; st[cur] = true; for (auto [j, wi] : e[cur])&#123; if (dist[j] > dist[cur] + wi)&#123; dist[j] = dist[cur] + wi; q.emplace(dist[j], j); &#125; &#125; &#125; if (dist[end] == inf) return -1; return dist[end]; &#125;; cout &lt;&lt; dijkstra(start, 0) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 怎么比 \(E2\) 简单啊]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 882 Div. 2</title>
    <url>/blog/posts/2417247537/</url>
    <content><![CDATA[Contestant~. Rank 596. Rating +153 (+653 - 500). A. The Man who became a God 题意 给定数组 \(a\)，定义 \(f(l,r) = |a_l - a_{l+1}| + |a_{l + 1} - a_{l + 2}| + \ldots + |a_{r-1} - a_r|\)。 将数组 \(a\) 划分为 \(k\) 段，输出各段 \(f\) 值之和的最小值。 思路 不难发现，划分等价于删除一个 \(|a_i - a_{i + 1}|\)。 那么，我们将所有 \(|a_i - a_{i + 1}|\) 排个序，删去前 \(k - 1\) 个大的，然后求和即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; vector&lt;int> d(n - 1); int ans = 0; for(int i=1;i&lt;n;i++) &#123; d[i - 1] = abs(a[i] - a[i - 1]); ans += d[i - 1]; &#125; sort(all(d)); for(int i=0;i&lt;k-1;i++)&#123; ans -= d[n - i - 2]; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 尼玛，测评机卡这么久，我一开始还交错语言了 B. Hamon Odyssey 题意 给定一个数组 \(a\)，定义 \(f(l,r) = a_l \&amp; a_{l+1} \&amp; a_{l+2} \&amp; \ldots \&amp; a_r\)。 将数组 \(a\) 划分为任意段，输出各段 \(f\) 值之和的最小值，并最大化段数。 思路 我们直接贪心，按照段内所有数与运算后是否为 \(0\) 划分即可。 此处不给出证明（因为我不会 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int ans = 0; bool f = false; int now = 0; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; if(now == 0) now = cur; else now &amp;= cur; if(now == 0)&#123; if(!f) f = true; else ans ++; &#125; &#125; cout &lt;&lt; ans + 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 这不就乱猜（（ C. Vampiric Powers, anyone? 题意 给定一个序列 \(a\)，定义添加元素操作如下： 设当前有 \(m\) 个元素； 选择一个下标 \(i\)； \(a_{m+1} = a_i \oplus a_{i+1} \oplus \ldots \oplus a_m\) 在可以添加任意数量的元素的条件下，输出序列中的元素的最大值。 思路 首先，因为我们处理的的是后缀，因而上一次加入的元素一定会在本次异或的范围内。 那么，我们不难发现，根据奇偶性以及异或的性质，我们无法取非连续子区间的异或值。 因而，我们考虑所有连续字符列中异或的最大值。 这可以通过枚举所有 前缀 和 后缀 的异或值，并和 整个序列的异或值 取异或，最后求出最大值。 时间复杂度：\(O(n + 256 ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int ans = 0; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; ans = max(ans, a[i]); &#125; map&lt;int, bool> pre, suf; pre[0] = suf[0] = true; int now = 0; for(int i=1;i&lt;=n;i++)&#123; now ^= a[i]; pre[now] = true; &#125; now = 0; for(int i=n;i>=1;i--)&#123; now ^= a[i]; suf[now] = true; &#125; for(auto i : pre) for(auto j : suf) ans = max(ans, now ^ i.fs ^ j.fs); //连续 cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 好像不可以 \(dp\) D. Professor Higashikata 题意 给定一个长为 \(n\) 的二进制字符串 \(s\)，以及 \(m\) 个区间。 按照给定顺序 将区间内的所有字符串 \(s_i\) 取出 并拼接成新的字符串 \(t\)。 定义一次操作为选定 \(i, j\)，交换 \(s_i, s_j\)。 给定 \(q\) 个 非独立 查询，每次查询给定一个下标 \(x\)，并将 \(s_x\) 对应的数字翻转。 翻转之后，输出让字符串 \(t\) 字典序最大的操作数的最小值 (对于每个查询，操作是独立的)。 思路 首先，字典序具有贪心性，也就是说，每一位具有 "优先级"，如果 优先级高的位置 对应的值 越高，那么不管后面是多少，字典序一定会更大。 那么，我们考虑给区间内的所有数赋上优先级。 显然，如果一个数在多个位置出现，我们肯定只考虑第一次出现的位置。因而，在遍历的时候，我们就可以跳过已经赋上优先级的数了。 基于上述操作，我们可以用 $set + $ 二分。 赋予优先级后，我们就可以将原来拼接得到的字符串 "离散化" 为一个按照优先级排序后的字符串 \(s\)。 我们接着考虑如何计算。 对于一个 \(0, 1\) 序列，如果 \(1\) 的个数为 \(sum\)，那么如果要将所有 \(1\) 移动到前面，我们需要交换的次数就是 \((sum\ -\ \)前 \(sum\) 个数中 \(1\) 的个数\()\)。 自然，因为不在区间内的数我们无需考虑，那么设在区间内的数的个数为 \(tot\)，交换次数就是 \((\min(sum, tot)\ -\ \)前 \(sum\) 个数中 \(1\) 的个数\()\)。 对于 \(q\) 个非独立查询，我们考虑用树状数组维护前缀和，在每次修改后更新即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; int a[N]; int lowbit(int x)&#123;return x&amp;(-x);&#125; void Update(int n, int d,int x)&#123;for(int i=d;i&lt;=n;i+=lowbit(i)) a[i]+=x;&#125; int Query(int d)&#123;int res=0;for(int i=d;i;i-=lowbit(i))res+=a[i];return res;&#125; int Query(int l,int r)&#123;return Query(r)-Query(l-1);&#125; void solve() &#123; int n, m, q; string s; cin >> n >> m >> q >> s; s = "#" + s; vector&lt;int> p; set&lt;int> st; for(int i=1;i&lt;=n;i++) st.insert(i); for(int i=1;i&lt;=m;i++)&#123; int l, r; cin >> l >> r; auto it = st.lower_bound(l); while(it != st.end() &amp;&amp; *it &lt;= r)&#123; int now = *it; p.pb(now); it ++; st.erase(now); &#125; &#125; int sum = 0; for(auto e : s) if(e == '1') sum ++; vector&lt;int> pri(n + 1, 0); for(int i=0;i&lt;p.size();i++)&#123; pri[p[i]] = i + 1; if(s[p[i]] == '1') Update(n, i + 1, 1); &#125; while(q --)&#123; int x; cin >> x; if(s[x] == '1')&#123; s[x] = '0', sum --; if(pri[x] != 0) Update(n, pri[x], -1); &#125;else&#123; s[x] = '1', sum ++; if(pri[x] != 0) Update(n, pri[x], 1); &#125; int ans = max(0ll, min(sum, (int) p.size()) - Query(1, sum)); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 不会树状数组qaq]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 306</title>
    <url>/blog/posts/766209649/</url>
    <content><![CDATA[Practice. A. Echo 题意 给定一个字符串，遍历所有字符，并按顺序输出两个。 如 \(abc \rightarrow aabbcc\)。 思路 如题。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; string s; cin >> n >> s; for(int i=0;i&lt;n;i++) cout &lt;&lt; s[i] &lt;&lt; s[i]; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 签到 B. Base 2 题意 给定一个长为 \(64\) 的序列 \(A\)，下标从 \(0\) 开始。 输出 \(A_02^0 + A_12^1 + \ldots+A_{63}2^{63}\)。 思路 如题。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; vector&lt;int> in(64); for(int i=0;i&lt;64;i++) cin >> in[64 - i - 1]; unsigned int ans = 0; for(int i=0;i&lt;64;i++) ans = ans * 2 + in[i]; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 记得加个 \(unsigned\)，不然会爆 \(long\ long\) C. Centers 题意 给定一个长为 \(3n\) 的序列 \(A\)，\(A\) 为 \(\{1, 1, 1, 2, 2, 2, \ldots, n, n, n\}\) 打乱顺序后的序列。 对于排列 \(\{1, 2, 3, \ldots,n\}\)，将其按照每个数在序列 \(A\) 中第二次出现的下标升序排序，并输出结果。 思路 如题。 时间复杂度：\(O(3n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> pre(n, -1); vector&lt;pii> mid(n, &#123;-1, - 1&#125;); for(int i=0;i&lt;3*n;i++)&#123; int cur; cin >> cur; cur --; if(pre[cur] == -1) pre[cur] = inf; else if(mid[cur].fs == -1)&#123; mid[cur] = &#123;i + 1, cur + 1&#125;; &#125; &#125; sort(all(mid)); for(auto [ind, what] : mid) cout &lt;&lt; what &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 就是略微有点小麻烦 D. Poisonous Full-Course 题意 给定 \(n\) 道菜，每道菜具有美味值以及类型，类型分为有毒和无毒。 规定需要按顺序吃菜，但可选择是否跳过这道菜，输出满足下面条件的美味值之和的最大值： 吃两道有毒的菜会去世 无毒的菜可以抵消有毒的菜 换言之，连续吃两道有毒的菜会去世。 思路 既然美味值可以为负，我们就无法贪心，因此我们考虑 \(dp\)。 记 \(dp[i][j]\) 为前 \(i\) 道菜的方案中美味值的最大值，\(j\) 表示当前是否刚吃有毒的菜。 那么我们设当前菜的美味值为 \(y\)，我们进行分讨： 当前菜有毒，那么 \(dp[i][0] = dp[i - 1][0], dp[i][1] = \max(dp[i][1], dp[i - 1][0] + y)\)； 当前菜没毒，那么 \(dp[i][0] = \max(dp[i - 1][0], \max(dp[i - 1][0], dp[i - 1][1]) + y), dp[i][1] = dp[i - 1][1]\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;vector&lt;int>> dp(n + 1, vector&lt;int>(2)); //前面是否有毒的 for(int i=1;i&lt;=n;i++)&#123; int x, y; cin >> x >> y; dp[i][0] = dp[i - 1][0], dp[i][1] = dp[i - 1][1]; if(x == 0) dp[i][0] = max(dp[i][0], max(dp[i - 1][0], dp[i - 1][1]) + y); else dp[i][1] = max(dp[i][1], dp[i - 1][0] + y); &#125; cout &lt;&lt; max(dp[n][0], dp[n][1]) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 我居然会写.jpg E. Best Performances 题意 给定一个序列 \(A\)，初始状态下全是 \(0\)。记序列 \(A\) 降序排序后的新序列为 \(B\)。 给定一个整数 \(k\)，现在，给定 \(q\) 次查询，每次查询给定两个整数 \(x, y\)，将 \(A_x := y\)，并输出序列 \(B\) 的前 \(k\) 项和。 思路 我们考虑用多重集来维护。 我们用两个多重集分别维护前 \(k\) 项 以及剩余的项。 那么，在每次更改后，我们分讨并更新多重集以及答案即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k, q; cin >> n >> k >> q; multiset&lt;pii> g, l; vector&lt;int> a(n + 1, 0); int sum = 0; for(int i=1;i&lt;=k;i++) g.emplace(0, i); for(int i=k+1;i&lt;=n;i++) l.emplace(0, i); while(q --)&#123; int x, y; cin >> x >> y; auto gp = g.find(&#123;a[x], x&#125;), lp = l.find(&#123;a[x], x&#125;); if(gp != g.end())&#123; g.erase(gp); sum -= a[x]; a[x] = y; if(l.empty() || y >= (*l.rbegin()).fs)&#123; g.emplace(y, x); sum += y; &#125;else&#123; auto ll = *l.rbegin(); l.erase(l.find(ll)); l.emplace(y, x); g.emplace(ll); sum += ll.fs; &#125; &#125;else&#123; l.erase(lp); a[x] = y; if(g.empty() || y &lt;= (*g.begin()).fs)&#123; l.emplace(y, x); &#125;else&#123; auto gg = *g.begin(); g.erase(g.find(gg)); g.emplace(y, x); l.emplace(gg); sum -= gg.fs; sum += y; &#125; &#125; cout &lt;&lt; sum &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 这分讨就很史 F. Merge Sets 题意 给定 \(n\) 个长为 \(m\) 的序列 \(S_i\)，所有序列中的元素均不相同。 对于序列 \(A, B\)，记 \(C\) 为 \(A \cup B\) 升序排序后的新序列，找出 \(A\) 中的所有元素在 \(C\) 中的新下标 \(k_i\)，下标之和即为 \(f(A, B)\)。 求 \(\displaystyle{\sum_{1 \leq i &lt; j \leq n} f(A_i, S_j)}\)。 思路 对于第 \(i\) 个元素，如果它的序列编号为 \(p\)，我们就需要知道 \(p\) 和 \([p + 1, n]\) 中的序列进行一一组合后，该元素在所有合并序列中的下标之和。 那么，如果设 \(q \in [p + 1, n]\)，序列 \(p, q\) 合并后，新序列中，该元素位于的下标为 \((p\) 中小于它的元素数量 \(+\) \(q\) 中小于它的元素数量 $ + 1)$。 不难发现，大小关系的判断可以通过排序实现。而排序之后，所需求的数量问题即可转化为前缀和问题。 因而，更具体地说： 将 所有元素 以及 他所在序列的编号 一起放入序列中，然后按照元素的大小升序排序； 在遍历的同时记录前缀和。在遍历到第 \(i\) 个元素时，我们记 \(pre[x]\) 为编号为 \(x\) 的序列中有多少个数比这个数小； 若第 \(i\) 个元素对应的序列编号为 \(p\)，那么遍历 \(q \in [p + 1, n]\)，统计 \(pre[p] + pre[q] + 1\) 之和。 自然，上述操作有点过于暴力，若需优化可使用树状数组。 时间复杂度：\(O(nmq),q\in[1,n]\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m; cin >> n >> m; vector&lt;pii > merge(n * m); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; int x; cin >> x; merge[i * m + j] = &#123;x, i&#125;; &#125; &#125; sort(all(merge)); int ans = 0; vector&lt;int> pre(n); for (int i = 0; i &lt; n * m; i++) &#123; auto [val, ind] = merge[i]; pre[ind]++; for (int j = ind + 1; j &lt; n; j++) ans += pre[ind] + pre[j]; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 抽象]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 307</title>
    <url>/blog/posts/1521245927/</url>
    <content><![CDATA[Contestant. Rank 1438. Rating +51. A. Weekly Records 题意 给定 \(14\) 个数字，输出前 \(7\) 个和后 \(7\) 个数的总和。 思路 如题。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; for(int i=0;i&lt;n;i++)&#123; int sum = 0; for(int j=0;j&lt;7;j++)&#123; int cur; cin >> cur; sum += cur; &#125; cout &lt;&lt; sum &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 签到 B. racecar 题意 给定 \(n\) 个字符串，输出是否存在两个字符串，拼接后成为回文串。 思路 如题。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;string> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(i == j) continue; string s; s = a[i] + a[j]; int m = s.size(); bool f = true; for(int p=0;p&lt;m/2;p++)&#123; if(s[p] != s[m - p - 1]) f = false; &#125; if(f)&#123; cout &lt;&lt; "Yes\n"; return; &#125; &#125; &#125; cout &lt;&lt; "No\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 签到（别看错题 C. Ideal Sheet 题意 对于下面的纸张，均为透明方格纸，方格纸上有部分格子涂上了黑色。 给定两张长度有限的纸 \(A, B\)，两张纸部分区域涂上了黑色，规格分别为 \(H_A \times W_A, H_B \times W_B\)。 另给一张长度有限的纸 \(X\) 作为目标纸张，部分区域涂上了黑色，规格分别为 \(H_X \times W_X\)。 现在，在一张透明的无限长的纸张 \(C\) 上，将 \(A, B\) 任意沿着方格粘贴到 \(C\) 上，并按照下面的条件剪切出一张和 \(X\) 规格一致的纸张： 剪下的纸张上面不能有黑色方格，换言之，\(A, B\) 上的所有黑色方格都要用上； 沿方格剪切 输出能否剪切出一张和 \(X\) 一模一样的纸张。 注意，不可以旋转纸张。 思路 考虑到空白区域的处理，我们有两种方式解决： 处理思路1 记 \(H_T = \max(H_A, H_B), W_T = \max(W_A, W_B)\)，我们将 \(X\) 向上下左右拓展到 \((H_X + 2H_T) \times (W_X + 2W_T)\)，即可任意粘贴判断。 处理思路2 我们将 \(A, B, X\) 的多余区域删去，即可任意粘贴判断 判断 我们不妨用二维数组标记当前位置在 \(A, B\) 的对应格子上是否为黑色，那么最后只需判断是否存在 \(X\) 中的所有黑色格子是否都会被标记即可。 注意标记的时候不要覆盖之前遍历的结果。 时间复杂度：\(O(n ^ 6)\) 对应AC代码1 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int an, am; cin >> an >> am; vector&lt;string> A(an); for(int i=0;i&lt;an;i++) cin >> A[i]; int bn, bm; cin >> bn >> bm; vector&lt;string> B(bn); for(int i=0;i&lt;bn;i++) cin >> B[i]; int xn, xm; cin >> xn >> xm; xn += 2 * max(an, bn), xm += 2 * max(am, bm); vector&lt;vector&lt;char>> X(xn, vector&lt;char>(xm, '.')); for(int i=max(an, bn);i&lt;xn-max(an, bn);i++) &#123; string s; cin >> s; for(int j=0;j&lt;s.size();j++)&#123; X[i][j + max(am, bm)] = s[j]; &#125; &#125; for(int i=0;i&lt;=xn-an;i++) for(int j=0;j&lt;=xm-am;j++) &#123; for (int k = 0; k &lt;= xn - bn; k++) for (int o = 0; o &lt;= xm - bm; o++) &#123; vector&lt;vector&lt;bool>> ok(xn, vector&lt;bool>(xm)); bool f = true; for (int p = 0; p &lt; an; p++) &#123; for (int q = 0; q &lt; am; q++) &#123; if(A[p][q] == '#' &amp;&amp; X[i + p][j + q] == '.')&#123; f = false; break; &#125; ok[i + p][j + q] = ok[i + p][j + q] || (A[p][q] == '#'); &#125; if(!f) break; &#125; for (int p = 0; p &lt; bn; p++) &#123; for (int q = 0; q &lt; bm; q++) &#123; if(B[p][q] == '#' &amp;&amp; X[k + p][o + q] == '.')&#123; f = false; break; &#125; ok[k + p][o + q] = ok[k + p][o + q] || (B[p][q] == '#'); &#125; if(!f) break; &#125; if(f)&#123; for (int p = 0; p &lt; xn; p++) &#123; for (int q = 0; q &lt; xm; q++) &#123; if(X[p][q] == '#' &amp;&amp; !ok[p][q])&#123; f = false; break; &#125; &#125; if(!f) break; &#125; if(f)&#123; cout &lt;&lt; "Yes\n"; return; &#125; &#125; &#125; &#125; cout &lt;&lt; "No\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 对应AC代码2 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; auto opt = [](int &amp;an, int &amp;am, vector&lt;string> &amp;A) -> void &#123; int hl = inf, hr = -inf, wl = inf, wr = -inf; bool f = false; for (int i = 0; i &lt; an; i++) for (int j = 0; j &lt; am; j++) &#123; if (A[i][j] == '#') &#123; f = true; hl = min(hl, i); hr = max(hr, i); wl = min(wl, j); wr = max(wr, j); &#125; &#125; if(!f)&#123; an = am = 0; A = vector&lt;string>(0); return; &#125; vector&lt;string> tA(hr - hl + 1); for (int i = hl; i &lt;= hr; i++) for (int j = wl; j &lt;= wr; j++) &#123; tA[i - hl] += A[i][j]; &#125; an = hr - hl + 1, am = wr - wl + 1; A = tA; &#125;; int an, am; cin >> an >> am; vector&lt;string> A(an); for (int i = 0; i &lt; an; i++) cin >> A[i]; opt(an, am, A); int bn, bm; cin >> bn >> bm; vector&lt;string> B(bn); for (int i = 0; i &lt; bn; i++) cin >> B[i]; opt(bn, bm, B); int xn, xm; cin >> xn >> xm; vector&lt;string> X(xn); for (int i = 0; i &lt; xn; i++) cin >> X[i]; opt(xn, xm, X); for (int i = 0; i &lt;= xn - an; i++) for (int j = 0; j &lt;= xm - am; j++) &#123; for (int k = 0; k &lt;= xn - bn; k++) for (int o = 0; o &lt;= xm - bm; o++) &#123; vector&lt;vector&lt;bool>> ok(xn, vector&lt;bool>(xm)); bool f = true; for (int p = 0; p &lt; an; p++) &#123; for (int q = 0; q &lt; am; q++) &#123; if (A[p][q] == '#' &amp;&amp; X[i + p][j + q] == '.') &#123; f = false; break; &#125; ok[i + p][j + q] = ok[i + p][j + q] || (A[p][q] == '#'); &#125; if (!f) break; &#125; for (int p = 0; p &lt; bn; p++) &#123; for (int q = 0; q &lt; bm; q++) &#123; if (B[p][q] == '#' &amp;&amp; X[k + p][o + q] == '.') &#123; f = false; break; &#125; ok[k + p][o + q] = ok[k + p][o + q] || (B[p][q] == '#'); &#125; if (!f) break; &#125; if (f) &#123; for (int p = 0; p &lt; xn; p++) &#123; for (int q = 0; q &lt; xm; q++) &#123; if (X[p][q] == '#' &amp;&amp; !ok[p][q]) &#123; f = false; break; &#125; &#125; if (!f) break; &#125; if (f) &#123; cout &lt;&lt; "Yes\n"; return; &#125; &#125; &#125; &#125; cout &lt;&lt; "No\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 什么答辩题啊 D. Mismatched Parentheses 题意 给定一个带括号以及小写字母的字符串，将 "()" 包含的所有字符以及该括号删除视为一次操作。 输出操作数最多的方案对应的操作后的字符串。 思路 既然需要操作数尽可能多，我们直接进行匹配，并从内向外删除即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; string s; cin >> s; stack&lt;int> q; map&lt;int, int> to; for(int i=0;i&lt;n;i++)&#123; if(s[i] == '(') q.emplace(i); else if(s[i] == ')')&#123; if(q.size() == 0) continue; else &#123; auto e = q.top(); q.pop(); to[e] = i; &#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(to.count(i)) i = to[i]; else cout &lt;&lt; s[i]; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 签到 E. Distinct Adjacent 题意 给定 \(n\) 个人，所有人围成一圈，\(i\) 和 \(i + 1\)，\(1\) 和 \(n\) 相邻。 现在，给定 \(m\) 个数，输出分配的方案数对 \(998244353\) 取模后的结果。 其中，方案应满足相邻的两个人数字不同。 思路 我们考虑 \(dp\)。 我们固定第一个数为 \(x\)，他会有 \(m\) 种取法。 接下来，我们分两种情况进行处理： 当前的数和 \(x\) 相同，那么上一个数就一定和 \(x\) 不相同； 当前的数和 \(x\) 不相同，那么当前就会有两种取法： 上一个数和 \(x\) 不相同，那么我们剩下 \(m - 2\) 种取法 上一个数和 \(x\) 相同，那么我们剩下 \(m - 1\) 种取法。 因而，我们定义 \(dp[i][j]\) 为前 \(i\) 个数的取法，\(j \in \{0, 1\}\) 表示是否和第一个数相同。 那么，初始化为 \(dp[1][1] = m\)，状态转移方程如下： \(dp[i][1] = dp[i - 1][0]\)； \(dp[i][0] = dp[i - 1][0] \times (m - 2) + dp[i - 1][1] \times (m - 1)\) 最后的答案即为 \(dp[n][0]\)。 记得取模。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> dp(n + 1, vector&lt;int>(2)); dp[1][1] = m; for(int i=2;i&lt;=n;i++)&#123; dp[i][1] = dp[i - 1][0]; dp[i][0] = (dp[i - 1][0] * (m - 2) % mod + dp[i - 1][1] * (m - 1) % mod) % mod; &#125; cout &lt;&lt; dp[n][0] &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 算是比较经典的对环 \(dp\) F. Virus 2 题意 给定一个无向图。 时刻 \(0\) 下，有 \(k\) 个人携带病毒。 在 \([1, d]\) 时刻内，每一个时刻，每个人携带的病毒可以沿着边传染到距离不超过 \(x_i\) 的所有人。 输出每个人被感染的时刻，若未感染，输出 \(-1\)。 思路 首先，我们不难想到最短路问题，那么我们不妨按照下面的方式计算： 加入一个 \(0\) 虚拟节点 将该节点和被感染的人相连，边权都为 \(0\) \(0\) 节点到其他人的最短路如果长度小于 \(x_i\)，那么就会被传染 那么，我们用优先队列维护 被感染的人的 所有未被感染的 相邻子节点，按照每个人到被感染的人的边权升序排列。 因而，在每一个时刻，我们就可以筛选出距离不超过 \(x_i\) 的人，并直接将其传染。 自然，也会存在子节点的子节点也可以被传染的情况，因而我们不妨采用 \(\mathtt{Dijkstra}\)，更新一遍所有能被传染的人，并用于下一次传染。 时间复杂度：\(O((d + m) \log n + n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m; cin >> n >> m; vector&lt;vector&lt;pii>> e(n); while(m --)&#123; int u, v, w; cin >> u >> v >> w; u --, v --; e[u].pb(v, w); e[v].pb(u, w); &#125; priority_queue&lt;pii, vector&lt;pii>, greater&lt;>> q1, q2; vector&lt;int> ans(n, -1); int k; cin >> k; while(k --)&#123; int a; cin >> a; a --; ans[a] = 0; for(auto [x, y] : e[a]) if(ans[x] == -1) q1.emplace(y, x); &#125; int d; cin >> d; for(int i=1;i&lt;=d;i++)&#123; int x; cin >> x; while(!q1.empty())&#123; auto [w, v] = q1.top(); if(w > x) break; q1.pop(); if(ans[v] == -1) q2.emplace(w, v); &#125; while(!q2.empty())&#123; auto [w, v] = q2.top(); q2.pop(); if(ans[v] != -1) continue; ans[v] = i; for(auto [p, q] : e[v])&#123; if(ans[p] != -1) continue; if(w + q &lt;= x) q2.emplace(w + q, p); q1.emplace(q, p); &#125; &#125; &#125; for(auto x : ans) cout &lt;&lt; x &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 有意思的]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 308</title>
    <url>/blog/posts/3282374493/</url>
    <content><![CDATA[Practice. A. New Scheme 题意 给定一个长度为 \(8\) 的序列 \(S\)，判断是否满足下面的条件： 不递减 \(100 \leq S_i \leq 675\) 为 \(25\) 的倍数 思路 如题 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; vector&lt;int> s(8); for(int i=0;i&lt;8;i++) cin >> s[i]; for(int i=0;i&lt;7;i++)&#123; if(s[i] > s[i + 1])&#123; cout &lt;&lt; "No\n"; return; &#125; &#125; for(auto e : s)&#123; if(e % 25 != 0 || e &lt; 100 || e > 675)&#123; cout &lt;&lt; "No\n"; return; &#125; &#125; cout &lt;&lt; "Yes\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 如题 B. Default Price 题意 给定 \(m\) 种菜品名称，以及对应的价格 \(p_i\)，未给菜品价格为 \(p_0\)。 现在，给定 \(n\) 个菜品，输出总价。 思路 \(map\) 存一下即可。 时间复杂度：\(O(m + n \log m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m; cin >> n >> m; map&lt;string, int> p; vector&lt;string> a(n); vector&lt;string> b(m); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;m;i++) cin >> b[i]; int x; cin >> x; for(int i=0;i&lt;m;i++) &#123; int cur; cin >> cur; p[b[i]] = cur; &#125; int ans = 0; for(auto e : a) &#123; if(p.count(e)) ans += p[e]; else ans += x; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 如题 C. Standings 题意 给定序列 \(X = \{1, 2, 3, \ldots,n\}\)，以及两个长为 \(n\) 的序列 \(A, B\)，按照下面的方式排序 \(X\) 后输出： 主关键字：\(\frac{A_i}{A_i + B_i}\)，降序； 次关键字：\(X_i\) 的值，升序 思路 这题是估计卡精度的，对于 \(\frac{A_x}{A_x + B_x} \leq \frac{A_y}{A_y + B_y}\)，移项得 \(A_x(A_y + B_y) \leq A_y(A_x + B_x)\)。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f;; const double eps = 1e-19; void solve() &#123; int n; cin >> n; vector&lt;int> c(n); for(int i=0;i&lt;n;i++) c[i] = i; vector&lt;int> a(n), b(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i] >> b[i]; &#125; sort(all(c), [&amp;](int o1, int o2) -> bool&#123; return (__int128)a[o1] * (a[o2] + b[o2]) == (__int128)a[o2] * (a[o1] + b[o1]) ? o1 &lt; o2 : (__int128)a[o1] * (a[o2] + b[o2]) > (__int128)a[o2] * (a[o1] + b[o1]); &#125;); for(auto e: c) cout &lt;&lt; e + 1 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 有被坑到，谢谢 D. Snuke Maze 题意 给定由 \(s, n, u, k, e\) 组成的大小为 \(H \times W\) 的矩阵，判断是否存在一条从 \((1, 1)\) 到 \((H, W)\) 的路径，路径中的第 \(i\) 个元素为字符串 \(snuke\) 的第 \(((i - 1)\mod 5) + 1\) 个字符。 思路 \(\mathtt{dfs}\) 即可，不过不需要回溯。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f;; const double eps = 1e-19; void solve() &#123; int h, w; cin >> h >> w; vector&lt;string> a(h); for(int i=0;i&lt;h;i++) cin >> a[i]; vector&lt;vector&lt;bool>> ok(h, vector&lt;bool>(w)); vector&lt;pii> to = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;; string s = "snuke"; bool f = false; auto dfs = [&amp;](auto dfs, int x, int y, int st) -> void&#123; if(f) return; if(x == h - 1 &amp;&amp; y == w - 1)&#123; cout &lt;&lt; "Yes\n"; f = true; return; &#125; for(auto [dx, dy] : to)&#123; int tx = x + dx, ty = y + dy; if(tx >= 0 &amp;&amp; ty >= 0 &amp;&amp; tx &lt; h &amp;&amp; ty &lt; w &amp;&amp; !ok[tx][ty] &amp;&amp; s[(st + 1) % 5] == a[tx][ty])&#123; ok[tx][ty] = true; dfs(dfs, tx, ty, st + 1); &#125; &#125; &#125;; ok[0][0] = true; dfs(dfs, 0, 0, 0); if(!f) cout &lt;&lt; "No\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 最近怎么老是因为回溯 \(tle\) E. MEX 题意 给定一个长为 \(n\) 且只包含 \(0, 1, 2\) 的序列 \(A\) 以及 一个长为 \(n\) 且只包含 \(M, E, X\) 的字符串 \(S\)。 对于所有长度为 \(3\) 的子序列（不一定连续）\(S_1S_2S_3\)，输出所有拼接后为 \(MEX\) 的字符串对应的 \(mex(A_1, A_2, A_3)\)。 其中，\(mex(x, y, z)\) 表示非负数中不等于 \(x, y, z\) 中的最小值。 思路 假设 \(E\) 的位置固定，那么如果我们知道前面有 \(x\) 个 \(M\) 和 \(y\) 个 \(X\)，以这个 \(E\) 为中心的子序列 \(MEX\) 个数即可根据乘法原理算得：\(xy\)。 那么照这个思路，因为考虑重复时 \(0, 1, 2\) 总共有 \(27\) 种放置方式，我们直接分讨即可。 举个例子，如果对于第 \(i\) 个位置，该位置为 \(E\)，且 \(A_i = 0\)，并且前面有 \(pre[0]\) 个 \(M\) 对应的 \(A\) 序列中的值为 \(0\)， 后面有 \(suf[1]\) 个 \(X\) 对应的 \(A\) 序列中的值为 \(1\)，那么这个情况对应的答案为 \(2 \times pre[0] \times suf[1]\)。 那么，我们用两个二维数组分别维护前缀和后缀个数即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f;; const double eps = 1e-19; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; string s; cin >> s; s = "#" + s; vector&lt;vector&lt;int>> pre(n + 1, vector&lt;int>(3)); vector&lt;vector&lt;int>> suf(n + 2, vector&lt;int>(3)); for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;3;j++) pre[i][j] = pre[i - 1][j]; if(s[i] == 'M') pre[i][a[i]] ++; &#125; for(int i=n;i>= 1;i--)&#123; for(int j=0;j&lt;3;j++) suf[i][j] = suf[i + 1][j]; if(s[i] == 'X') suf[i][a[i]] ++; &#125; int ans = 0; for(int i=1;i&lt;=n;i++)&#123; if(s[i] != 'E') continue; if(a[i] == 0)&#123;//000 001 011 002 022 012 ans += 1 * pre[i][0] * suf[i][0]; ans += 2 * (pre[i][0] * suf[i][1] + pre[i][1] * suf[i][0]); ans += 2 * pre[i][1] * suf[i][1]; ans += 1 * (pre[i][0] * suf[i][2] + pre[i][2] * suf[i][0]); ans += 1 * pre[i][2] * suf[i][2]; ans += 3 * (pre[i][1] * suf[i][2] + pre[i][2] * suf[i][1]); &#125;else if(a[i] == 1)&#123; ans += 2 * pre[i][0] * suf[i][0]; ans += 2 * (pre[i][0] * suf[i][1] + pre[i][1] * suf[i][0]); ans += 0 * pre[i][1] * suf[i][1]; ans += 3 * (pre[i][0] * suf[i][2] + pre[i][2] * suf[i][0]); ans += 0 * pre[i][2] * suf[i][2]; ans += 0 * (pre[i][1] * suf[i][2] + pre[i][2] * suf[i][1]); &#125;else&#123; ans += 1 * pre[i][0] * suf[i][0]; ans += 3 * (pre[i][0] * suf[i][1] + pre[i][1] * suf[i][0]); ans += 0 * pre[i][1] * suf[i][1]; ans += 1 * (pre[i][0] * suf[i][2] + pre[i][2] * suf[i][0]); ans += 0 * pre[i][2] * suf[i][2]; ans += 0 * (pre[i][1] * suf[i][2] + pre[i][2] * suf[i][1]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 就是写起来像依托史 F. Vouchers 题意 给定 \(n\) 个标价为 \(P_i\) 的商品，以及 \(m\) 个满 \(D_i\) 减 \(L_i\) 的券，在每一种券只能使用一次 并且 不能叠加使用 的条件下，输出购买所有商品需要的最小金额。 思路 简单贪心。 我们肯定希望能尽可能使用折扣力度大一点的券，那么对于某一个商品，我们就使用能使用的减价最多的券。 当然，我们也希望券能用多一点，所以我们按照商品的价格升序排序，然后依次使用能使用的减价最多的券。 上述贪心思路是显然正确的，而具体实现方式可以为优先队列。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f;; const double eps = 1e-19; void solve() &#123; int n, m; cin >> n >> m; vector&lt;int> p(n); vector&lt;pii> v(m); int ans = 0; for(int i=0;i&lt;n;i++) cin >> p[i], ans += p[i]; for(int i=0;i&lt;m;i++) cin >> v[i].fs; for(int i=0;i&lt;m;i++) cin >> v[i].sc; sort(all(p)), sort(all(v)); int st = 0; priority_queue&lt;int> q; for(int i=0;i&lt;n;i++)&#123; while(st &lt; m &amp;&amp; v[st].fs &lt;= p[i]) q.emplace(v[st ++].sc); if(!q.empty()) ans -= q.top(), q.pop(); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 居然在 \(F\) 放签到]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 151</title>
    <url>/blog/posts/859667713/</url>
    <content><![CDATA[Contestant. Rank 1719. Rating -8. 被诈骗咯 A. Forbidden Integer 题意 给定三个整数 \(n, k, x\)，在 \([1, k]\) 中任选除了 \(x\) 之外的其他数字，使所选数字的总和为 \(n\)。 思路 我们进行分讨。 首先，如果 \(k = 1\)，那么一定无解。 其次，如果 \(k = 2\)，那么我们分讨一下 \(x = 1, 2\) 的时候的情况，此时如果 \(n\) 为奇数，而 \(x = 1\)，那么无解。 最后，如果 \(k &gt; 2\)，那么我们分讨一下： \(x = 1\)，那么我们放 \(\frac{n}{2} - 1\) 个 \(2\)，然后再放上剩下的数即可等于 \(n\)； 否则，输出 \(n\) 个 \(1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k, x; cin >> n >> k >> x; if(k == 1) &#123; cout &lt;&lt; "NO\n"; return; &#125; if(k == 2)&#123; if(x == 1 &amp;&amp; n % 2 == 1)&#123; cout &lt;&lt; "NO\n"; return; &#125; if(x == 1)&#123; cout &lt;&lt; "YES\n"; cout &lt;&lt; n / 2 &lt;&lt; '\n'; for(int i=0;i&lt;n/2;i++) cout &lt;&lt; 2 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125;else&#123; cout &lt;&lt; "YES\n"; cout &lt;&lt; n &lt;&lt; '\n'; for(int i=0;i&lt;n;i++) cout &lt;&lt; 1 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125;else&#123; if(x == 1)&#123; cout &lt;&lt; "YES\n"; cout &lt;&lt; n / 2 &lt;&lt; '\n'; for(int i=0;i&lt;n/2-1;i++) cout &lt;&lt; 2 &lt;&lt; ' '; if(n % 2 == 1) cout &lt;&lt; 3 &lt;&lt; '\n'; else cout &lt;&lt; 2 &lt;&lt; '\n'; &#125;else &#123; cout &lt;&lt; "YES\n"; cout &lt;&lt; n &lt;&lt; '\n'; for(int i=0;i&lt;n;i++) cout &lt;&lt; 1 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 为什么有这么复杂的分讨捏，为什么捏，为什么有人想写 \(dp\) 捏 B. Come Together 题意 给定 \(A, B, C\) 三个点的坐标，输出 \(A \rightarrow B, A \rightarrow C\) 的最短路中，重叠的格子最多可以有多少。 思路 我们对 \(x, y\) 坐标分别分讨。 对于 \(x\) 坐标： 如果 \(X_a \geq X_b \geq X_c\) 或 \(X_c \geq X_b \geq X_a\)，那么本坐标下需要移动 \(abs(X_b - X_a)\)； 如果 \(X_b \geq X_c \geq X_a\) 或 \(X_a \geq X_c \geq X_b\)，那么本坐标下需要移动 \(abs(X_c - X_a)\)； 否则，不需要移动 \(y\) 坐标同理。 最后因为算上起点和重点，所以再 \(+1\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int xa, ya, xb, yb, xc, yc; cin >> xa >> ya >> xb >> yb >> xc >> yc; int ans = 0; if((yc >= yb &amp;&amp; yb >= ya) || (ya >= yb &amp;&amp; yb >= yc)) ans += abs(yb - ya); else if((yb >= yc &amp;&amp; yc >= ya) || (ya >= yc &amp;&amp; yc >= yb)) ans += abs(yc - ya); if((xc >= xb &amp;&amp; xb >= xa) || (xa >= xb &amp;&amp; xb >= xc)) ans += abs(xb - xa); else if((xb >= xc &amp;&amp; xc >= xa) || (xa >= xc &amp;&amp; xc >= xb)) ans += abs(xc - xa); cout &lt;&lt; ans + 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 无聊分讨，不过肯定可以归纳为一个式子 C. Strong Password 题意 给定一个字符串 \(s\)，以及两个长度均为 \(n\) 的字符串 \(l, r\)。 上述字符串均为 \([0, 9]\) 内数字组成的字符串。 构造一个字符串 \(t\)，满足下面的条件： 长度为 \(n\)； 不是 \(s\) 的子串； \(t[i]\) 代表的数字在 \(l[i]\) 和 \(r[i]\) 之间。 思路 首先，我不拦着你写 \(dfs\)，你只要写得好，应该也许大概可以过。 我们考虑贪心。 首先，我们需要遍历字符串 \(s\)，因此我们用 \(p\) 变量记录我们下一次开始遍历的下标。 那么，我们遍历 \(t\) 的每一位。 对于每一位的所有可能数字，我们从 \(p\) 开始，找到所有数字第一次出现的下标。 最后，如果所有数字都出现了，我们就取下标的最大值，更新 \(p = mx + 1\)，否则我们就可以构造出一个不是子序列的字符串。 下面给出不太严谨的说明： 因为我们只需构造出一个满足条件的就可，那么我们不妨极端一点，对于每一位都尽可能向右取，这样如果还无法构造，就显然是 \(NO\) 了。 同样，这也方便了我们的构造。因为只要有一位找不出对应的字符，他就不是子序列。 时间复杂度：\(O(10n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; string s; cin >> s; int n; cin >> n; string l, r; cin >> l >> r; int p = 0; vector&lt;int> st(10); for(int i=0;i&lt;n;i++)&#123; st.assign(10, inf); for(int j=p;j&lt;s.size();j++)&#123; if(s[j] >= l[i] &amp;&amp; s[j] &lt;= r[i]) st[s[j] - '0'] = min(st[s[j] - '0'], j); &#125; int mx = 0; for(int j=l[i] - '0';j&lt;=r[i] - '0';j++)&#123; if(st[j] == inf)&#123; cout &lt;&lt; "YES\n"; return; &#125; mx = max(mx, st[j]); &#125; p = mx + 1; &#125; cout &lt;&lt; "NO\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 为什么捏，为什么有人想写 \(dp\) 捏，为什么这个蠢比是我捏 D. Rating System 题意 给定一个非 \(0\) 序列，从左到右依次累加，达到 \(k\) 后，如果某一位累加得到的值小于 \(k\)，那么将当前累加之和改为 \(k\)。输出任意一个 \(k\)，使最后累加的和最大。 思路 首先，既然当达到 \(k\) 后，无论怎样减小都不会低于 \(k\)，那么就等效于两个等于 \(k\) 的前缀和之间的所有数都是可以无视的。 这可以等价于后缀和，因为后缀和表征了跳过部分数后的和，并且后缀和为负数时就不满足上面的条件。 那么，更具体地说，(前 \(k\) 个数的前缀和) 以及 (后 \(k\) 个数的后缀和的最大值) 之和 的最大值就是答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1), pre(n + 1), suf(n + 2); for (int i = 1; i &lt;= n; i++) &#123; cin >> a[i]; pre[i] = pre[i - 1] + a[i]; &#125; for (int i = n; i >= 0; i--) suf[i] = suf[i + 1] + a[i]; for (int i = n; i >= 0; i--) suf[i] = max(suf[i], suf[i + 1]); int mx = 0, ans = 0; for (int i = 0; i &lt;= n; i++) &#123; int res = pre[i] + suf[i + 1]; if (res > mx) mx = res, ans = pre[i]; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 有点抽象]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 817 Div. 4</title>
    <url>/blog/posts/872469640/</url>
    <content><![CDATA[Practice. A. Spell Check 题意 给定一个字符串，判断其是否为字符串 \(\mathtt{Timur}\) 任意排列后的字符串。 思路 我们用 \(map\) 存一下这 \(5\) 个字符的出现次数，如果都出现一次，并且长度为 \(5\)，即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; string s; cin >> s; map&lt;char, int> mp = &#123;&#123;'T', 0&#125;, &#123;'i', 0&#125;, &#123;'m', 0&#125;, &#123;'u', 0&#125;, &#123;'r', 0&#125;&#125;; for(char e : s)&#123; if(mp.count(e)) mp[e] ++; else&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; ((mp['T'] == 1 &amp;&amp; mp['i'] == 1 &amp;&amp; mp['m'] == 1 &amp;&amp; mp['u'] == 1 &amp;&amp; mp['r'] == 1) ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 水 B. Colourblindness 题意 对于一个蓝绿色盲，给定两串长度相等的 \(R, G, B\) 字符串，输出是否相同。 思路 将 \(G, B\) 视为 \(1\)，\(R\) 视为 \(0\)，枚举即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; map&lt;char, int> mp = &#123;&#123;'R', 0&#125;, &#123;'G', 1&#125;, &#123;'B', 1&#125;&#125;; int n; cin >> n; string a, b; cin >> a >> b; for(int i=0;i&lt;n;i++)&#123; if(mp[a[i]] != mp[b[i]])&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; return; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 这就不得不提某个愚人节了（ C. Word Game 题意 对于 \(3\) 个人，给定每个人写下的单词数 \(n\)，并给出每个人写下的单词，按照下面的方式给每个人计分，并输出每个人的分数： 对于某个人说出的某个单词： 如果这个单词只被 \(1\) 个人写下，那么这个人得 \(3\) 分； 如果这个单词被 \(2\) 个人写下，那么这两个人各得 \(1\) 分； 如果这个单词被 \(3\) 个人写下，那么所有人都不得分 思路 用 \(map\) 存一下出现次数，然后再枚举所有单词统计分数即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;string> a(n), b(n), c(n); map&lt;string, int> cnt; for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; cnt[a[i]] ++; &#125; for(int i=0;i&lt;n;i++)&#123; cin >> b[i]; cnt[b[i]] ++; &#125; for(int i=0;i&lt;n;i++)&#123; cin >> c[i]; cnt[c[i]] ++; &#125; int A = 0, B = 0, C = 0; for(auto e : a)&#123; if(cnt[e] == 1) A += 3; else if(cnt[e] == 2) A ++; &#125; for(auto e : b)&#123; if(cnt[e] == 1) B += 3; else if(cnt[e] == 2) B ++; &#125; for(auto e : c)&#123; if(cnt[e] == 1) C += 3; else if(cnt[e] == 2) C ++; &#125; cout &lt;&lt; A &lt;&lt; ' ' &lt;&lt; B &lt;&lt; ' ' &lt;&lt; C &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; ctrl c + ctrl v D. Line 题意 给定一个由 \(L, R\) 组成的字符串，定义 \(L\) 表示该位置左边有多少字符，\(R\) 表示该位置右边有多少字符（上述均不包含本身）。 定义字符串的 值 为各字符代表的数量之和。 现在，定义一次操作为选定一个字符，将其改为 \(L\) 或 \(R\)。对于 \(k \in [1, n]\)，输出最多执行 \(k\) 次操作后字符串 值 的最大值。 思路 这是一个很显然的贪心，如果我们不考虑操作次数，最后前一半的字符肯定是 \(R\)，后一半的字符肯定是 \(L\)（若有奇数个，显然中间的字符的选择是无影响的）。 并且，我们可以贪心地认为，我们只要从两边开始向里修改，即可让 值 最大。 当然，如果次数过多了，我们随便挑一个字符将其改为本身即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int ans = 0; string s; cin >> s; for(int i=0;i&lt;n;i++) &#123; char cur = s[i]; if (cur == 'L') ans += i; else ans += n - i - 1; &#125; int l = 0, r = n - 1, cnt = 0; while(l &lt; r)&#123; if(s[l] == 'L')&#123; ans -= l; ans += n - l - 1; cnt ++; cout &lt;&lt; ans &lt;&lt; ' '; &#125; if(s[r] == 'R')&#123; ans -= n - r - 1; ans += r; cnt ++; cout &lt;&lt; ans &lt;&lt; ' '; &#125; l ++, r --; &#125; for(int i=cnt;i&lt;n;i++) cout &lt;&lt; ans &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 简单的贪心 + 双指针 E. Counting Rectangles 题意 给定 \(n\) 个 \(h_i \times w_i\) 的矩形。 现在，给定 \(q\) 次询问，每次询问给定四个整数 \(h_s\ w_s\ h_b\ w_b\)，输出满足 \(h_s &lt; h_i &lt; h_b, w_s &lt; w_i &lt; w_b\) 的所有矩形的面积和。 思路 首先，根据题给范围，我们不可以在每次询问时都遍历一遍区间。 注意范围，我们需要的就是一个矩形范围内的所有矩形的面积和。 因而，我们考虑二维前缀和。 因为长度范围很小，我们直接开一个二维数组，\(a[h][w]\) 表示以原点和 \((h, w)\) 为对角顶点的矩形范围内所有矩形的面积和，套板子即可。 时间复杂度：\(O(n + 1e6 + q)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, q; cin >> n >> q; vector&lt;vector&lt;int>> sum(1010, vector&lt;int>(1010, 0)); for(int i=0;i&lt;n;i++) &#123; int h , w; cin >> h >> w; sum[h][w] += h * w; &#125; for(int i=1;i&lt;=1e3;i++) for(int j=1;j&lt;=1e3;j++)&#123; sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1]; &#125; while(q --)&#123; int hs, ws, hb, wb; cin >> hs >> ws >> hb >> wb; cout &lt;&lt; (sum[hb - 1][wb - 1] - sum[hs][wb - 1] - sum[hb - 1][ws] + sum[hs][ws]) &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 对，没错，我 \(tle\) 过 F. L-shapes 题意 给定一个由 "." 和 "*" 组成的矩阵，定义 "L型" 如下： *. .* ** ** ** ** .* *. 检查矩阵是否满足下面的条件： 只包含 "L型"，不包含其他由 "*" 组成的图形； "L型" 中的 "*" 字符需满足以其为中心的 \(9\) 宫格里都没有 "*"（除了 "L型" 的其他 "*" 字符） 下面给出不满足条件 \(2\) 的例子： ..** .... *.*. *.** **.. ***. 思路 这是一个 \(2 \times 2\) 的图案，考虑数据范围，我们完全可以枚举所有 \(2 \times 2\) 的区域，判断其是否为 \(4\) 个图案的其中一种。 如果我们判定这是一个 "L型" 图案，我们就可以进行分讨，判断外围一圈中指定位置是否出现了 "*"，如果有，直接输出 \(NO\)。 在判定之时，如果是 "L型" 图案，我们顺便标记一下图案中的 "*"，那么，最后如果出现未被标记的 "*"，就是出现了 "非L型"。 下面用 "/" 表示需要判定的位置： &#x2F;&#x2F;&#x2F;. .&#x2F;&#x2F;&#x2F; &#x2F;&#x2F;&#x2F;&#x2F; &#x2F;&#x2F;&#x2F;&#x2F; &#x2F;*.. ..*&#x2F; &#x2F;**&#x2F; &#x2F;**&#x2F; &#x2F;**&#x2F; &#x2F;**&#x2F; ..*&#x2F; &#x2F;*.. &#x2F;&#x2F;&#x2F;&#x2F; &#x2F;&#x2F;&#x2F;&#x2F; .&#x2F;&#x2F;&#x2F; &#x2F;&#x2F;&#x2F;. 时间复杂度：\(O(n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; //直接按2x2扫 int n, m; cin >> n >> m; vector&lt;vector&lt;char>> a(n + 2, vector&lt;char>(m + 2, '.')); vector&lt;vector&lt;bool>> st(n + 2, vector&lt;bool>(m + 2)); for (int i = 1; i &lt;= n; i++) &#123; string s; cin >> s; for (int j = 1; j &lt;= m; j++) a[i][j] = s[j - 1]; &#125; //tl tr //bl br for (int i = 1; i &lt; n; i++) for (int j = 1; j &lt; m; j++) &#123; char tl = a[i][j], tr = a[i][j + 1], bl = a[i + 1][j], br = a[i + 1][j + 1]; if (tl == '*' &amp;&amp; tr == '.' &amp;&amp; bl == '*' &amp;&amp; br == '*') &#123; bool ok = true; ok &amp;= a[i - 1][j - 1] != '*' &amp;&amp; a[i - 1][j] != '*' &amp;&amp; a[i - 1][j + 1] != '*'; ok &amp;= a[i][j - 1] != '*' &amp;&amp; a[i][j + 2] != '*'; ok &amp;= a[i + 1][j - 1] != '*' &amp;&amp; a[i + 1][j + 2] != '*'; ok &amp;= a[i + 2][j - 1] != '*' &amp;&amp; a[i + 2][j] != '*' &amp;&amp; a[i + 2][j + 1] != '*' &amp;&amp; a[i + 2][j + 2] != '*'; if (!ok) &#123; cout &lt;&lt; "NO\n"; return; &#125; st[i][j] = st[i + 1][j] = st[i + 1][j + 1] = true; &#125; if (tl == '.' &amp;&amp; tr == '*' &amp;&amp; bl == '*' &amp;&amp; br == '*') &#123; bool ok = true; ok &amp;= a[i - 1][j] != '*' &amp;&amp; a[i - 1][j + 1] != '*' &amp;&amp; a[i - 1][j + 2] != '*'; ok &amp;= a[i][j - 1] != '*' &amp;&amp; a[i][j + 2] != '*'; ok &amp;= a[i + 1][j - 1] != '*' &amp;&amp; a[i + 1][j + 2] != '*'; ok &amp;= a[i + 2][j - 1] != '*' &amp;&amp; a[i + 2][j] != '*' &amp;&amp; a[i + 2][j + 1] != '*' &amp;&amp; a[i + 2][j + 2] != '*'; if (!ok) &#123; cout &lt;&lt; "NO\n"; return; &#125; st[i + 1][j] = st[i][j + 1] = st[i + 1][j + 1] = true; &#125; if (tl == '*' &amp;&amp; tr == '*' &amp;&amp; bl == '*' &amp;&amp; br == '.') &#123; bool ok = true; ok &amp;= a[i - 1][j - 1] != '*' &amp;&amp; a[i - 1][j] != '*' &amp;&amp; a[i - 1][j + 1] != '*' &amp;&amp; a[i - 1][j + 2] != '*'; ok &amp;= a[i][j - 1] != '*' &amp;&amp; a[i][j + 2] != '*'; ok &amp;= a[i + 1][j - 1] != '*' &amp;&amp; a[i + 1][j + 2] != '*'; ok &amp;= a[i + 2][j - 1] != '*' &amp;&amp; a[i + 2][j] != '*' &amp;&amp; a[i + 2][j + 1] != '*'; if (!ok) &#123; cout &lt;&lt; "NO\n"; return; &#125; st[i][j] = st[i + 1][j] = st[i][j + 1] = true; &#125; if (tl == '*' &amp;&amp; tr == '*' &amp;&amp; bl == '.' &amp;&amp; br == '*') &#123; bool ok = true; ok &amp;= a[i - 1][j - 1] != '*' &amp;&amp; a[i - 1][j] != '*' &amp;&amp; a[i - 1][j + 1] != '*' &amp;&amp; a[i - 1][j + 2] != '*'; ok &amp;= a[i][j - 1] != '*' &amp;&amp; a[i][j + 2] != '*'; ok &amp;= a[i + 1][j - 1] != '*' &amp;&amp; a[i + 1][j + 2] != '*'; ok &amp;= a[i + 2][j] != '*' &amp;&amp; a[i + 2][j + 1] != '*' &amp;&amp; a[i + 2][j + 2] != '*'; if (!ok) &#123; cout &lt;&lt; "NO\n"; return; &#125; st[i][j] = st[i][j + 1] = st[i + 1][j + 1] = true; &#125; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; if (a[i][j] == '*' &amp;&amp; !st[i][j]) &#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 无脑大模拟，出题太缺德 G. Even-Odd XOR 题意 给定无重复数字的序列的长度 \(n\)，构造该序列，满足奇数位上的所有数的异或值等于偶数位上所有数的异或值。 思路 因为 \(n\) 是 \(2e5\) 级别的，那么我们只需找一个大于 \(2e5\) 的 \(2\) 的次方 \(x\)，然后我们按顺序在前 \(n - 2\) 个数中放入 \(1, 2, 3, \ldots\)，并计算奇数位和偶数位各数的异或值，最后和 \(x\) 取异或后输出两个数即可。 当然，存在 \(n\) 为奇数的情况，不过因为任何数 和 \(0\) 异或值都不变，所以我们在前面塞一个 \(0\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int even = 0, odd = 0; if(n % 2 == 1 &amp;&amp; n > 3)&#123; cout &lt;&lt; "0 "; n --; &#125; for(int i=1;i&lt;=n-2;i++)&#123; cout &lt;&lt; i &lt;&lt; ' '; if(i % 2 == 0) even ^= i; else odd ^= i; &#125; cout &lt;&lt; (262144 ^ even) &lt;&lt; ' ' &lt;&lt; (262144 ^ odd) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 有人 wa on 1 好多次，我不说是谁]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - CodeTON Round 5 Div. 1 + 2</title>
    <url>/blog/posts/640192286/</url>
    <content><![CDATA[Contestant. Rank 2247. Rating -18. 好久没有这么坐牢了 qaq A. Tenzing and Tsondu 题意 给定两个长度相等的序列，作为 \(A, B\) 的每个怪物的血量。每一回合，两个人以最优策略派出两个怪物，若两个怪物的血量为 \(x, y\)，那么回合结束后，两个怪物的血量变为 \(\max(x - y, 0), \max(y - x, 0)\)，血量为 \(0\) 的怪物死亡。 若某一玩家的怪物全部死亡，那么判定为输，输出最后的赢家。 思路 首先，我们可以根据数据乱猜，我们只需比较两个玩家的怪物总血量，血量一致就是平局，否则，血量多的一方胜出。 下面给出官方题解的解释： 注意，\(\max(x - y, 0) = x - \min(x, y), \max(y - x, 0) = y - \min(x, y)\)，因而每一回合两个玩家扣除的血量都是相同的，因而只和总血量有关。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m; cin >> n >> m; int a = 0, b = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; a += cur; &#125; for(int i=0;i&lt;m;i++)&#123; int cur; cin >> cur; b += cur; &#125; if(a == b) cout &lt;&lt; "Draw\n"; else if(a &lt; b) cout &lt;&lt; "Tenzing\n"; else cout &lt;&lt; "Tsondu\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜就完事了 B. Tenzing and Books 题意 给定三个序列，规定每次操作为任选一个序列，移走最左边的元素。 任意次操作后，输出是否可以满足拿出的所有元素 按位或 之后值为给定的 \(x\)。 思路 题解所指的 \(|\) 指按位或，而非整除 首先，既然放在 \(B\) 题，绝对是运用了什么性质。 考虑按位或的性质，我们不难发现，如果一个数 \(p\) 可以和其他若干个数按位或后得到 \(x\)，那么在二进制下的同一位中，\(x\) 为 \(0\) 的时候，\(p\) 也一定要为 \(0\)。 这是我们唯一需要考虑的限制。 有趣的是，如果不满足上面的限制，你会发现 \(x | p &gt; x\)。并且，因为按位或运算，得到的数不可能变小，因而我们只要对每一堆数，从左到右找出第一个 \(x | p &gt; x\)，那么它左边的所有数都可以参与运算。 因而，将这些可以参与运算的数全都进行按位或，最后如果还是不等于 \(x\)，就是不可以。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, x; cin >> n >> x; vector&lt;int> a(n + 1); vector&lt;int> b(n + 1); vector&lt;int> c(n + 1); int mxa = 0; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; a[i] |= a[i - 1]; if((a[i] | x) &lt;= x) mxa = a[i]; &#125; int mxb = 0; for(int i=1;i&lt;=n;i++)&#123; cin >> b[i]; b[i] |= b[i - 1]; if((b[i] | x) &lt;= x) mxb = b[i]; &#125; int mxc = 0; for(int i=1;i&lt;=n;i++)&#123; cin >> c[i]; c[i] |= c[i - 1]; if((c[i] | x) &lt;= x) mxc = c[i]; &#125; if((mxa | mxb | mxc) == x) cout &lt;&lt; "Yes\n"; else cout &lt;&lt; "No\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 队友写了 \(\mathtt{bitset}\)，有点玄幻 C. Tenzing and Balls 题意 给定一串序列，定义一次操作为选定两个相等的元素，并将其与包含在两个元素内的所有元素全部删除。 输出最多能删多少元素。 思路 首先，我们不难发现我们不可以删除两个相交的区间。 因而，我们只需考虑删除哪些不重叠的区间，最后得到的答案最大即可。 因而，我们考虑 \(dp\)。 我们可以正算也可以反算，这边采用反着算的方法，算出保留的最小元素数 \(ans\)，然后输出 \(n - ans\)： 我们定义 \(dp[i][j]\) 为 \([1, i]\) 中第 \(i\) 个元素是否作为删除区间的右端点 \((j)\) 保留的元素数的最小值。 那么，如果不删，\(dp[i][0] = \min(dp[i - 1][0], dp[i - 1][1]) + 1\)； 如果删，我们就需要知道我们得跳过多少元素。 因而，我们定义 \(b[x]\) 为 \([1, i - 1]\) 中值为 \(x\) 的所有元素中 \(dp[i][0] - 1\) 最小的一个。 那么，\(dp[i][1] = \min(dp[i][1], b[x])\)。 最后，我们考虑一下初始化。如果我们一点都不操作，那么最后 \(dp[i][0] = dp[i][1] = i\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); vector&lt;vector&lt;int>> dp(n + 1, vector&lt;int>(2)); for (int i = 1; i &lt;= n; i++) &#123; cin >> a[i]; dp[i][0] = dp[i][1] = i; &#125; vector&lt;int> b(n + 1, n + 1); for (int i = 1; i &lt;= n; i++) &#123; dp[i][0] = min(dp[i - 1][0], dp[i - 1][1]) + 1; //不选 if (b[a[i]] != n + 1) dp[i][1] = b[a[i]]; b[a[i]] = min(b[a[i]], min(dp[i - 1][0], dp[i - 1][1])); &#125; cout &lt;&lt; (n - min(dp[n][0], dp[n][1])) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 还真没往 \(dp\) 上想（ D. Tenzing and His Animal Friends 题意 给定 \(n\) 个人，定义一场游戏为选择若干个人并任选游戏时长。 输出在下面给定限制中，总游戏时间最长为多少，以及能组织多少种游戏： 一定要选 \(1\)； 不能选 \(n\)； 满足给定的 \(m\) 个条件，条件以 \(u\ v\ y\) 给出，表示所有游戏中 \(u\) 出现但 \(v\) 不出现 或 \(u\) 不出现但 \(v\) 出现 的总时长和 \(\leq y\)。 思路 首先，因为 \(1\) 一定在游戏中，\(n\) 一定不在游戏中，那么如果没有关于 \(1\ n\) 的直接或间接的限制，最后就是无穷大了。 那么，如果上述限制存在，我们可以证明其一定有解。我们接着分析条件。 第三个条件过于复杂了，我们不妨将其中一种情况的时长减为 \(0\)，那么另一个的最大时间就能确定了。 因而，我们可以从 \(1\) 开始，依次加入节点。那么，对于节点 \(i\)，它具有被加入的时间 \(T_i\)。对于条件 \(u\ v\ y\)，我们可以将其转化为 \(|T_u - T_v| \leq y\)。 上式即为差分约束系统问题，我们可以用最短路算法解决本题。 考虑到数据量小，我们直接用 \(\mathtt{floyd}\)。 显然，结合差分约束的知识，我们不难发现，因为 \(n\) 一定不在游戏中，所以节点 \(p\) 到节点 \(n\) 的最短路就是节点 \(p\) 在所有游戏中的总时间。 因而，我们只要按照其到 \(n\) 的最短路长度升序排序，并将 每次放入的节点 和 上一个放入的节点 的 时间差 作为该场游戏的持续时间，即可让总时间最大。 当然，最大不会超过 \(1\ n\) 之间的最短路长度。 时间复杂度：\(O(n ^ 3)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define psi pair&lt;string, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> dist(n + 1, vector&lt;int>(n + 1, inf)); for(int i=1;i&lt;=n;i++) dist[i][i] = 0; for(int i=0;i&lt;m;i++)&#123; int u, v, y; cin >> u >> v >> y; dist[u][v] = dist[v][u] = min(dist[u][v], y); &#125; //floyd for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); &#125; if(dist[1][n] >= inf)&#123; cout &lt;&lt; "inf\n"; return; &#125; vector&lt;pii> to(n - 1); for(int i=1;i&lt;n;i++) to.pb(min(dist[n][i], dist[1][n]), i - 1); sort(all(to)); vector&lt;psi> ans; int pre = 0; for(int i=0;i&lt;to.size();i++)&#123; int d = to[i].fs - pre; pre = to[i].fs; if(d == 0) continue; string s; for(int j=1;j&lt;=n;j++) s += "0"; for(int j=i;j&lt;to.size();j++) s[to[j].sc] = '1'; ans.pb(s, d); &#125; cout &lt;&lt; dist[1][n] &lt;&lt; ' ' &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto [s, d] : ans) cout &lt;&lt; s &lt;&lt; ' ' &lt;&lt; d &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 只可意会（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 880 Div. 2</title>
    <url>/blog/posts/126571544/</url>
    <content><![CDATA[Practice. A. Destroyer 题意 定义每个机器人具有一个参数：它的前面有多少机器人。 机器人可以排成很多行，因而我们可以得到最后的参数序列。 现在，给定打乱后的参数序列，输出是否合法。 思路 很显然，我们只需统计每个参数的出现次数，按照参数升序排序后，如果出现次数不递减，那么就是合法的，否然不合法。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(110); int mx = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; mx = max(mx, cur); a[cur] ++; &#125; int pre = a[0]; bool f = true; for(int i=1;i&lt;=mx;i++)&#123; if(a[i] > pre)&#123; f = false; break; &#125; pre = a[i]; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 就是题目抽象了点 B. Astrophysicists 题意 给定 \(k\) 个金币，每个金币等价于 \(g\) 个银币。给定 \(n\) 个人，规定需要将所有银币分发给所有人。 对于任意一个人所分发的银币数量 \(x\)，我们定义 \(r = x\mod g\)，按照下面的规则得到盈利/亏损： 如果 \(r \geq \lceil \frac{g}{2} \rceil\)，那么亏损 \(g - r\)； 否则，盈利 \(r\) 输出最后能盈利最多多少钱，如果亏损，输出 \(0\)。 思路 我们不妨不考虑分配的总额，那么最后要让盈利尽可能多，每个人分发 \(\lfloor \frac{g-1}{2} \rfloor\) 即可。 那么，考虑上总额，如果总额不够，依然是盈利的，我们将答案和总额取最小值即可。 但如果总额过多，我们记多出 \(p\) 银币。 因为存在取模操作，因而我们可以把多出的银币全都给一个人。 此时，我们将会失去一个人的盈利，并亏损一部分银币，我们进行分讨即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k, g; cin >> n >> k >> g; int ans = min((g - 1) / 2 * n, k * g), left = (k * g - ans) % g; if(left > 0)&#123; ans -= (g - 1) / 2; left = (left + (g - 1) / 2) % g; if(left &lt; ceil((double) g / 2)) ans += left; else ans -= g - left; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 抽象的，通俗易懂的，巧妙的 C. k-th equality 题意 对于二元加法 \(A + B = C\)，给定 \(A, B, C\) 的位数以及一个整数 \(k\)，输出按字典序排序的满足位数的第 \(k\) 个式子。 思路 首先，第一反应绝对是推式子，但，这题的 \(A,B,C\) 范围小到...可以暴搜。 我们对 \(A\) 爆搜，并统计对于当前 \(A\) 的选择，有多少个对应的式子，以此遍历得到答案。 显然，令 \(x = \max(A, B)\)，我们只有两种情况：\(x = C, x + 1 = C\)，前后者的区别是是否进位，我们分讨即可。 那么，除了这两种情况，其他情况均为无解。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const vector&lt;int> p = &#123;1, 10, 100, 1000, 10000, 100000, 1000000&#125;; void solve() &#123; int a, b, c, k; cin >> a >> b >> c >> k; bool ok = false; for(int i = p[a - 1]; i &lt; p[a]; i ++)&#123; //对a爆搜 int l = max(p[b - 1], p[c - 1] - i), r = min(p[b] - 1, p[c] - i - 1); if(l > r) continue; if(r - l + 1 &lt; k) k -= (r - l + 1); else&#123; cout &lt;&lt; i &lt;&lt; " + " &lt;&lt; l + k - 1 &lt;&lt; " = " &lt;&lt; i + l + k - 1 &lt;&lt; '\n'; ok = true; break; &#125; &#125; if(!ok) cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 不能爆搜的话得对四种情况分讨，挺麻烦，但好像能做]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 879 Div. 2</title>
    <url>/blog/posts/1261634407/</url>
    <content><![CDATA[Contestant'. Rank 753. Rating +35. A. Unit Array 题意 给定一个由 \(1, -1\) 组成的数组 \(a\)，定义操作为选择一个元素，并将其改为它的相反数。 现在，输出最小的操作数，使最后的数组满足下面的条件： \(a_1 + a_2 + \ldots + a_n \ge 0\) \(a_1 \cdot a_2 \cdot \ldots \cdot a_n = 1\) 思路 我们简化一下条件： \(1\) 的个数大于等于 \(-1\) 的个数； \(-1\) 的个数为偶数 因而，我们分讨即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int p = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur == 1) p ++; &#125; int q = n - p; if(p >= q &amp;&amp; q % 2 == 0)&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; &#125;else&#123; int ans = 0; if(p &lt; q) &#123; ans += (q - p + 1) / 2; q -= (q - p + 1) / 2; &#125; if(q % 2 == 1) ans ++; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 但是分讨后式子得推一下（ B. Maximum Strength 题意 给定两个大数 \(L, R\)，找出 \(a, b\)，满足 \(L \leq a \leq b \leq R\)，并且 \(a\) 与 \(b\) 的所有位之差的绝对值之和最大，输出这个最大值。 思路 我们考虑贪心。 首先，对于单独一位，不难发现 \(9 - 0\) 得到的差值最大，那么我们自然希望能构造尽可能多的 \(9, 0\)。 我们不妨将其放在最后几位，构造形如 \(\ldots000, \dots999\) 的数。 如何构造？举个例子： 114514 114810 你会发现，\(1145\)\(\color{rgb(124,179,66)}{99}\)\(, 1148\)\(\color{rgb(124,179,66)}{00}\) 即为我们需要的构造。 因而，我们得到下面的结论： 以字符串方式读入大数，循环补齐前导0； 从头开始遍历，找出第一个不相同的位置，记录差值 \(dis\)； 从第一个不相同的位置的下一个位置开始，每一位差值都视为 \(9\)； 最后的答案就是 \(dis\) 加上若干个 \(9\) 证明是显然的。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; string a, b; cin >> a >> b; int n = max(a.size(), b.size()); int difa = n - a.size(), difb = n - b.size(); for(int i=0;i&lt;difa;i++) a = "0" + a; for(int i=0;i&lt;difb;i++) b = "0" + b; int ans = 0; for(int i=0;i&lt;n;i++)&#123; //找出第一个不同的位置，前面先算0 if(ans != 0)&#123; ans += 9; continue; &#125; if(a[i] == b[i]) continue; ans = abs(a[i] - b[i]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 群友：如果你觉得这是数位 \(dp\)，那你一定是学算法学魔怔了 C. Game with Reversing 题意 定义在两个长度相等的字符串 \(S, T\) 上的博弈： \(Alice\) 可选定任意一个字符串的任意一个元素，并将其替换为任意一个字符； \(Bob\) 可选定任意一个字符串，并将其整个翻转 定义任意一个玩家必须执行对应的操作，输出让两个字符串变为相同需要的操作总和。 为此，\(Alice\) 会让两个字符串变得尽可能相同，而 \(Bob\) 相反，会让两个字符串变得尽可能不同。 思路 我们考虑翻转操作的特点： 对同一个字符串执行两次翻转，等于没有翻转； 对不同的两个字符串各执行一次翻转，等效于没有翻转（因为如果翻转后相等，那么就等价于翻转前相等） 因而，我们不难发现，\(Bob\) 执行两次操作就约等于没操作，他只能让两个字符串在某个顺序要变为一致时，提前翻转一下，来让操作数变多一点。 我们考虑只翻转 \(T\)，那么，我们只需分别统计让 \(S\) 变为 \(T\) 和 翻转 \(T\) 所需的操作数，然后针对奇偶性分讨即可。 注意，分讨的时候，如果翻转后两个字符串一致，最后的操作数是 \(2\)，而非 \(0\) (\(Alice\) 随便选一个，改成一样的字符，然后由 \(Bob\) 翻转)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; string a, b; cin >> a >> b; string c = b; reverse(all(c)); int cnt1 = 0 , cnt2 = 0; for(int i=0;i&lt;n;i++)&#123; if(a[i] != b[i]) cnt1 ++; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i] != c[i]) cnt2 ++; &#125; if(cnt1 != 0) &#123; if (cnt1 % 2 == 0) cnt1 = cnt1 * 2; else cnt1 = (cnt1 - 1) * 2 + 1; &#125; if(cnt2 != 0) &#123; if (cnt2 % 2 == 1) cnt2 = cnt2 * 2; else cnt2 = (cnt2 - 1) * 2 + 1; &#125;else cnt2 = 2; cout &lt;&lt; min(cnt1, cnt2) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; Bob: 我博弈了个寂寞]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 881 Div. 3</title>
    <url>/blog/posts/3606802234/</url>
    <content><![CDATA[Contestant(alt). Rank 459. Rating +64. A. Sasha and Array Coloring 题意 给定一个序列，将其用任意数量的颜色染色，染色后，统计每一种颜色中最大值和最小值的差，取和后得到结果。输出最大的结果。 思路 很显然，直接排个序，然后不断将两头的元素取出作为一种颜色做差即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; &#125; sort(all(a)); int ans = 0; for(int i=0;i&lt;n/2;i++) ans += a[n - i - 1] - a[i]; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 签到 B. Long Long 题意 给定一个序列，定义操作为选择一段区间，并将这个区间内的所有元素取相反数。输出任意次操作后的序列的最大总和，并输出要达到这样的总和需要至少操作几次。 思路 首先，总和最大肯定是绝对值之和。 如果我们选择两个负数作为区间的两端，那么如果中间有正数，我们就需要多次操作，显然我们还不如直接选择这两个负数单独操作。 因而，我们考虑对连续的负数区间进行一次操作，最后的操作数就是满足条件的区间数。 值得一提的是，负数区间可以包含 \(0\)，但我们不统计只包含 \(0\) 不包含负数的区间。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); int sum = 0, cnt = 0; bool f = false; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; sum += abs(a[i]); if(a[i] &lt; 0) f = true; if(a[i] > 0 &amp;&amp; f) f = false, cnt ++; &#125; if(f) cnt ++; cout &lt;&lt; sum &lt;&lt; ' ' &lt;&lt; cnt &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 也是签到 C. Sum in Binary Tree 题意 对于一个满二叉树，定义标号方式为按行从左到右编号。 因而我们可以得到前 \(15\) 个元素构造得到的二叉树如下： 现在，给定一个点 \(x\)，输出从根节点 \(1\) 到 \(x\) 的路径上的节点标号之和。 思路 因为每一层的节点数量都是 \(2\) 的次方，不难发现我们只需不断将 \(x\) 除以 \(2\) 向下取整，直到 \(x\) 变为 \(0\)，并统计操作前的所有 \(x\) 的总和，即可得到答案。 时间复杂度：\(O(log_2 n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int ans = 0; while (n > 0) &#123; ans += n; n /= 2; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 差点没看懂题 D. Apple Tree 题意 给定一棵树，对于 \(q\) 次询问，每次给出两个节点 \(x, y\)，输出二元组 \((a, b)\) 的个数，满足 \(a\) 在 \(x\) 或 \(x\) 的子树中，\(b\) 在 \(y\) 或 \(y\) 的子树中。 思路 我们直接 \(\mathtt{dfs}\) + \(dp\) 即可，\(dp[i]\) 表示第 \(i\) 个节点子树的节点数量加上自己。 那么 \(dp[x] \times dp[y]\) 即为答案。 时间复杂度：\(O(m + q)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> dp(n + 1); vector&lt;vector&lt;int>> e(n + 1); for(int i=1;i&lt;n;i++)&#123; int u, v; cin >> u >> v; e[u].pb(v), e[v].pb(u); &#125; auto dfs = [&amp;](auto dfs, int s, int f) -> void&#123; if(s != 1 &amp;&amp; e[s].size() == 1) dp[s] ++; for(auto v : e[s])&#123; if(v == f) continue; dfs(dfs, v, s); dp[s] += dp[v]; &#125; &#125;; int q; cin >> q; dfs(dfs, 1, 0); while(q --)&#123; int a, b; cin >> a >> b; cout &lt;&lt; dp[a] * dp[b] &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 这题面...在考验我的耐心 E. Tracking Segments 题意 对于一个长为 \(n\) 的序列，一开始序列内元素都是 \(0\)。 给定 \(m\) 个区间，以及 \(q\) 次操作。每次操作给定一个下标 \(x\)，并将 \(x\) 位置的元素改为 \(1\)。 输出在哪次操作后，存在至少一个区间内的元素中 \(1\) 的个数严格大于 \(0\)。 思路 显然，如果操作次数越少，满足条件的区间就更少，反之更多。 因此，此处存在单调性。 我们考虑二分答案，并对操作进行判断。 判断过程可以使用前缀和，在用差分构建完后，我们只需遍历区间，找出是否有一个区间满足条件即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m; cin >> n >> m; vector&lt;pii> a(m + 1); for(int i=0;i&lt;m;i++) cin >> a[i].fs >> a[i].sc; int q; cin >> q; vector&lt;int> qu(q); for(int i=0;i&lt;q;i++) cin >> qu[i]; auto check = [&amp;](int x)&#123; vector&lt;int> sum(n + 1); for(int i=0;i&lt;x;i++) sum[qu[i]] = 1; for(int i=1;i&lt;=n;i++) sum[i] += sum[i - 1]; for(int i=0;i&lt;m;i++)&#123; auto [l, r] = a[i]; if(sum[r] - sum[l - 1] > r - l + 1 - (sum[r] - sum[l - 1])) return true; &#125; return false; &#125;; int l = 1, r = q, mid; int ans = -1; while(l &lt;= r)&#123; mid = (l + r) >> 1; if(check(mid)) r = mid - 1, ans = mid; else l = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 太久不做二分答案了，一时没想到 F1. Omsk Metro (simple version) 题意 对于一个无向图，定义点权均为 \(1\) 或 \(-1\)。 初始状态下只有一个根节点，点权为 \(1\)，定义询问如下： \(+\ V_i\ X_i\)，在 \(V_i\) 节点上插入一个点权为 \(X_i\) 的点，新的点的标号为当前最大标号 \(+ 1\)； \(?\ U_i\ V_i\ K_i\)，输出从 \(U_i\) 到 \(V_i\) 这条路径上是否有一段子路径（连续子序列）满足点权和为 \(K_i\)。 给定 \(q\) 个询问，执行对应操作。 在 \(simple\) 版本中，第二种询问的 \(U_i\) 恒为 \(1\)，即根节点。 思路 首先，既然一个端点固定是根节点，我们就可以将这张图抽象为一颗树，从根节点到所有叶节点的路径都可以单独提出来作为一个序列来看待，那么，我们直接考虑某一条路径： 不难发现，当我们添加节点的时候，因为点权只有 \(1, -1\)，那么最后 \(k\) 的取值一定是一段连续的区间，并且随着我们添加节点，区间在不断扩张。 换句话说，我们可以维护 \(k\) 取值的左右端点，在加入节点时扩展左右端点，此时我们不难发现左右端点的取得具有递推性。 因而，我们考虑在图上 \(dp\)。 我们定义 \(dp\_mn[p][v]\) 为 从 \(1\) 节点到 \(v\) 节点中是否以 \(v\) 作为区间端点 的左端点，\(dp\_mx\) 同理。 那么，我们可以得到下面的状态转移方程： \(dp\_mx[0][x] = \max(dp\_mx[0][v], dp\_mx[1][v])\\dp\_mx[1][x] = \max(dp\_mx[1][v]+x, x)\) \(dp\_mn\) 同理，将 \(\max\) 改成 \(\min\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int q; cin >> q; vector&lt;vector&lt;int>> dp_mx(2, vector&lt;int>(q + 2)), dp_mn(2, vector&lt;int>(q + 2)); dp_mx[1][1] = dp_mn[1][1] = 1; dp_mn[0][1] = dp_mx[0][1] = 0; int mx = 1; while (q--) &#123; char op; cin >> op; if (op == '+') &#123; int v, x; cin >> v >> x; mx ++; dp_mx[0][mx] = max(dp_mx[0][v], dp_mx[1][v]); dp_mx[1][mx] = max(dp_mx[1][v] + x, x); dp_mn[0][mx] = min(dp_mn[0][v], dp_mn[1][v]); dp_mn[1][mx] = min(dp_mn[1][v] + x, x); &#125; else &#123; int u, v, k; cin >> u >> v >> k; if (min(dp_mn[0][v], dp_mn[1][v]) &lt;= k &amp;&amp; max(dp_mx[0][v], dp_mx[1][v]) >= k) cout &lt;&lt; "YES\n"; else cout &lt;&lt; "NO\n"; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 抽象之，做的时候一直想着前缀 F2. Omsk Metro (hard version) 待补充，区别是不一定有一个端点是根节点]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 878 Div. 3</title>
    <url>/blog/posts/2588096581/</url>
    <content><![CDATA[Contestant(alt). Rank 209. Rating +155. A. Cipher Shifer 题意 给定一个字符串，定义操作如下： 选择一个字符； 在该字符后面插入若干和该字符不一样的字符； 将选择的字符插入 如，对于 \(a\)，我们可以操作为 \(abcda\)，\(a, bcd, a\) 对应上面的三个操作。 现在，给出操作后的字符串，还原为原字符串。 思路 既然不会出现一样的字符，那么我们直接暴力枚举，配对头和尾即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; string s; cin >> s; int pre = -1; string ans = ""; for(int i=0;i&lt;n;i++)&#123; if(s[i] == pre)&#123; pre = -1; &#125;else if(pre == -1)&#123; pre = s[i]; ans += pre; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 题目怎么这么阅读理解（ B. Binary Cafe 题意 给定 \(k\) 个商品，第 \(i\) 个商品的价格为 \(2 ^ i\)，在总价格不超过给定 \(n\) 的条件下，输出购买方案的总数。 思路 二进制数有一个特点：任意一位的权重 等于 小于他权重的所有位的权重和 \(+1\)。 那么，如果第 \(p\) 位可以选上，从 \(0\) 开始计数的话，前面 \(p\) 个也一定能选上。 也就是说，\((2 ^ p - 1) + 1 = 2 ^ p\) 既是方案数，也是价格总数。 因此，\(\min(2 ^ k, n)\) 就是答案。 显然，因为 \(n\) 范围已知，所以可以特判 \(k\) 的大小，防止爆 \(long\ long\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; if(k >= 60) cout &lt;&lt; n + 1 &lt;&lt; '\n'; else cout &lt;&lt; min((int) pow(2, k), n + 1) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 比较抽象 C. Ski Resort 题意 给定长为 \(n\) 的序列以及两个整数 \(k, q\)，输出不包含大于 \(q\) 的元素且长度大于等于 \(k\) 的所有连续子序列的个数。 思路 显然，我们直接扫一遍，并记录以当前位置为区间尾部，区间内不包含大于 \(q\) 元素的最大长度 \(cnt\)，那么以当前位置为子序列尾部的字符列个数就是 \(cnt - k + 1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k, q; cin >> n >> k >> q; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; int ans = 0, cnt = 0; for(auto e : a)&#123; if(e &lt;= q) cnt ++; else cnt = 0; if(cnt >= k) ans += cnt - k + 1; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 怎么比 \(B\) 还水 D. Wooden Toy Festival 题意 给定三个工匠，每个工匠有固定的加工样式 \(x\)，加工一个样式 \(y\) 需要 \(|y - x|\) 时间，同一个工匠可以在同一时刻加工任意数量的工件。 对于 \(n\) 个人，每个人有需要加工的一个样式，在任意选择工匠的加工样式的条件下，输出最后耗费的最长时间的最小值。 思路 既然我们可以自由确定工匠的加工样式，那么我们就可以升序排序所有人需要加工的样式，然后分成连续的三段，由三个工匠加工。 观察题面，求最大值的最小值，我们不难想到二分答案。 如果我们确定了答案，也就是耗费的最长时间，那么我们不妨用这个最长时间去划分段落。如果我们划分出三段，那么这就可以作为答案，否则，如果小于三段，这个最大值就太大了，否则就太小了，显然具有单调性。 因而，我们直接二分即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(all(a)); int ans = 0; auto check = [&amp;](int mid) -> bool&#123; int cnt = 1, sum = a[0] + mid; for(auto e : a)&#123; if(abs(e - sum) > mid)&#123; sum = e + mid; cnt ++; &#125; &#125; return cnt &lt;= 3; &#125;; int l = 0, r = a[n - 1], mid; while(l &lt;= r)&#123; mid = (l + r) >> 1; if(check(mid))&#123; r = mid - 1; ans = mid; &#125;else l = mid + 1; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 二分二分 E. Character Blocking 题意 给定两个长度相等的字符串，编号为 \(1, 2\)，定义询问如下： \(1\ \ pos\)，锁定两个字符串 \(pos\) 位置的字符 \(t\) 秒； \(2\ \ 1/2\ \ pos1\ \ 1/2\ \ pos2\)，将对应标号的对应位置的字符交换 \(3\)，询问跳过锁定的字符后两个字符串是否相同 对于第二个操作： \(2\ 1\ 3\ 2\ 4\)，就是把第 \(1\) 个字符串的 \(3\) 位置字符和第 \(2\) 个字符串的 4 位置字符交换； \(2\ 2\ 3\ 2\ 4\)，就是把第 \(2\) 个字符串的 \(3\) 位置字符和 4 位置字符交换。 现在，给定锁定时间 \(t\)，以及 \(q\) 个询问，一个询问占用 \(1\) 秒，执行对应的操作。 思路 我们不妨用 \(set\) 维护当前不同的字符出现在哪些下标，那么只要最后 \(set\) 为空，两个字符串就是相同的。 那么，我们来考虑如何更新它： 首先我们可以预处理出当前不相同的位置，然后先放入 \(set\) 中； 显然，同一个时刻不会有多个位置被锁定，也不会由多个位置被解锁，所以我们可以用某种数据结构来维护当前的锁定状态，我们将需要锁定的开始时间以及下标放入该数据结构中，并在每个时刻判断最初放入的锁定字符是否到达锁定时间，满足先入先出的条件，我们选择队列。 因而，我们用队列维护当前的锁定状态，如果有一个位置被锁定，那么这个位置的字符就可以被当作相同，我们将其从 \(set\) 中移除；同样的，当一个位置解除锁定的时候，我们判断一下这个位置的字符是否相等，不相等就放入 \(set\) 中； 至于交换，我们直接模拟即可，交换后判断一下这两个位置是否相同，并更新 \(set\)。 按上述操作模拟即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; vector&lt;string> s(3); cin >> s[1] >> s[2]; int n = s[1].size(); s[1] = "#" + s[1], s[2] = "#" + s[2]; set&lt;int> st; for(int i=1;i&lt;=n;i++)&#123; if(s[1][i] != s[2][i]) st.emplace(i); &#125; int t, q; cin >> t >> q; queue&lt;pii> qu; for(int i=1;i&lt;=q;i++)&#123; int cur; cin >> cur; if(!qu.empty())&#123; auto [dead, pos] = qu.front(); if(dead == i)&#123; if(s[1][pos] != s[2][pos]) st.emplace(pos); qu.pop(); &#125; &#125; if(cur == 1)&#123; int pos; cin >> pos; if(st.count(pos))&#123; st.erase(pos); qu.emplace(i + t, pos); &#125; &#125;else if(cur == 2)&#123; int w1, p1, w2, p2; cin >> w1 >> p1 >> w2 >> p2; swap(s[w1][p1], s[w2][p2]); if(s[1][p1] != s[2][p1]) st.emplace(p1); else if(st.count(p1)) st.erase(p1); if(s[1][p2] != s[2][p2]) st.emplace(p2); else if(st.count(p2)) st.erase(p2); &#125;else&#123; cout &lt;&lt; (st.empty() ? "YES\n" : "NO\n"); &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 模拟模拟！ F. Railguns 题意 给定一个 \(n \times m\) 的平面，以及起点 \((0,0)\) 和终点 \((n,m)\)，定义一次操作为：从 \((i,j)\) 位置移动到 \((i+1,j)\) 或 \((i,j+1)\) 或不移动。 给定 \(r\) 个射击，每个射击会在给定 \(t\) 时刻末发射，射击是横向或纵向的，因此给出方向 \(d\) 以及射击的某一行或某一列的标号 \(coord\)。 输出人物避开所有射击从起点走到终点的时间最小值。 待补充（不能白翻译吧 G1. In Search of Truth (Easy Version) 待补充 G2. In Search of Truth (Hard Version) 待补充]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 150</title>
    <url>/blog/posts/1144671639/</url>
    <content><![CDATA[Practice. A. Game with Board 题意 给定 \(n\) 个 \(1\)，定义操作为选定至少两个相同的数，将其从序列中移除，并插入他们的和。 对于 \(Alice\) 和 \(Bob\) 之间的博弈，规定 \(Alice\) 先手，当某个玩家 无法 执行操作时，该玩家 获胜。 输出最后获胜的玩家。 思路 首先，如果 \(n\) 比较大的时候，\(Alice\) 就可以选择 \(n - 2\) 个 \(1\)，这样 \(Bob\) 只能将剩余的两个 \(1\) 选上，最后序列剩余两个不同的数，从而 \(Alice\) 必胜。 上面的必胜策略需要保证 \(n - 2 &gt; 2\)，也就是 \(n &gt; 4\) 的时候 \(Alice\) 有必胜策略。 我们不难发现，当 \(2 \leq n \leq 4\) 的时候，无论 \(Alice\) 怎么选，最后 \(Bob\) 一定会无法操作，因而 \(Bob\) 必胜。 因而，判断 \(n\) 的大小即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;vector> #include &lt;iostream> #include &lt;algorithm> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; cout &lt;&lt; (n > 4 ? "Alice" : "Bob") &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 不要看错题（ B. Keep it Beautiful 题意 给定一个序列，定义满足下面任意一个条件的序列是美丽的： 整个序列不递减； 从头开始选择一段连续的子序列，将其和剩余的子序列交换位置，得到的新序列不递减 现在，给定一个操作序列，定义操作如下： 给定一个数 \(x\)，如果将其插入到当前序列的最后，得到的新序列是美丽的，那么执行插入操作，否则不插入。 对于每一次操作，输出是否可以操作成功，用二进制字符串表示。 思路 显然，我们分讨模拟即可。 我们维护当前序列的头 \(st\) 和尾 \(ed\) 对应的数值，如果我们没有交换过位置，那么我们只需满足 \(x \geq ed\)。 那如果不满足，我们就需要交换位置，显然要满足条件的话，我们就只能把 \(x\) 作为新序列的头，把前面的全都移到后面去。因而，如果之前就执行过交换操作，这次插入操作就失败了。 那么，如果交换过位置，且满足 \(x \geq ed\)，我们就需要添加一个条件 \(x \leq st\)，保证交换后依然美丽。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int st; cin >> st; int ed = st; n --; cout &lt;&lt; 1; bool f = false; while(n --)&#123; int x; cin >> x; if(x >= ed)&#123; if(f &amp;&amp; x > st) cout &lt;&lt; 0; else&#123; cout &lt;&lt; 1; ed = x; &#125; &#125;else&#123; if(!f &amp;&amp; x &lt;= st)&#123; cout &lt;&lt; 1; f = true; ed = x; &#125;else cout &lt;&lt; 0; &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 模拟模拟 C. Ranom Numbers 题意 给定一个由 "\(A\)", "\(B\)", "\(C\)", "\(D\)", "\(E\)" 组成的字符串，其中 \(ABCDE\) 对应的值分别为 \(1, 10, 100, 1000, 10000\)，因而五个字符具有大小关系。 给定字符串的值的运算方式： 遍历每一位的字符。如果该字符 小于等于 后面的所有字符，那么取正号，否则取负号。将每一位乘上符号后累加得到字符串的值。 现在，需要选择一个字符，将其修改为任意五个字符的其中一个，输出修改后的最大值。 思路 由后面的状态约束前面的状态，我们不难想到 \(dp\)。 为了方便，我们不妨反转字符串，这样我们就可以从前往后递推了。 如上，我们可以定义一个三维 \(dp\)，\(dp[i][mx][c]\) 表示第 \(i\) 位在前面所有字符的最大值是 \(mx\) 且前面是否有修改的状态下的最大值，\(c\) 表示前面是否修改过。 那么，我们只需枚举第 \(i\) 位置放什么字符，以及前面是否有出现修改，因而可以得出第 \(i\) 位置是否 可以 并 需要 修改，并更新前 \(i\) 个字符的最大值。 最后，\(dp[n]\) 的所有状态的最大值就是答案。 当然，因为只有相邻的两个 \(dp[i]\) 有递推关系，所以我们用两个 \(dp\) 数组也是可以的，从而优化空间复杂度。 时间复杂度：\(O(10n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define ppii pair&lt;int, pii> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const vector&lt;int> p = &#123;1, 10, 100, 1000, 10000&#125;; void solve() &#123; string s; cin >> s; reverse(all(s)); int n = s.size(); s = "#" + s; vector&lt;vector&lt;vector&lt;int>>> dp(n + 1, vector&lt;vector&lt;int>>(5, vector&lt;int>(2, -inf))); dp[0][0][0] = 0; for(int i=1;i&lt;=n;i++)&#123; int self = s[i] - 'A'; for(int mx = 0; mx &lt; 5; mx ++)&#123; //枚举前面的最大值 for(int c = 0; c &lt;= 1; c ++)&#123; //前面有没有改过 for(int now = 0; now &lt; 5; now ++)&#123; //当前位置填什么 if(now != self &amp;&amp; c == 1) continue; int mx2 = max(mx, now), ok = (now != self || c == 1) ? 1 : 0; dp[i][mx2][ok] = max(dp[i][mx2][ok], dp[i - 1][mx][c] + (now >= mx ? 1 : -1) * p[now]); &#125; &#125; &#125; &#125; int ans = -inf; //玛德蠢了打了个0 for(int mx = 0; mx &lt; 5; mx ++)&#123; for(int c = 0; c &lt;= 1; c ++)&#123; ans = max(ans, dp[n][mx][c]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 第一眼读假，草 D. Pairs of Segments 找个时间再做，待补充]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 876 Div. 2</title>
    <url>/blog/posts/3178984334/</url>
    <content><![CDATA[Contestant'. Rank 785. Rating +41. A. The Good Array 题意 定义满足下面条件的二进制数组 \(a\) 是好的： 枚举 \(i \in [1, n]\)，前 \(i\) 个数至少有 \(\lceil \frac{i}{k} \rceil\) 个为 \(1\)，后 \(i\) 个数至少有 \(\lceil \frac{i}{k} \rceil\) 个为 \(1\)。 给定 \(k\)，输出好数组中 \(1\) 的最少个数。 思路 首先，第一个和最后一个一定是 \(1\)。 那么，对于前 \(n - 1\) 个数，至少有 \(\lceil \frac{n - 1}{k} \rceil\) 个 \(1\)。 因此，答案即为 \(\lceil \frac{n - 1}{k} \rceil + 1\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; cout &lt;&lt; (n - 1) / k + ((n - 1) % k == 0 ? 0 : 1) + 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 抽象 B. Lamps 题意 给定 \(n\) 盏灯，一开始所有灯都是熄灭的。 每盏灯有两个参数 \(a_i, b_i\)，有三个状态：亮、灭、坏。 定义一次操作如下： 选择一个没坏的熄灭的灯 \(i\)，将其打开，得到 \(b_i\) 个积分； 记 \(x\) 为上述操作后的没坏的亮的灯的个数，将所有满足 \(a_p \leq x\) 的灯砸坏，无论是否灯打开。 任意次操作后，输出最大积分数。 思路 既然我们会把 \(a_i\) 小的灯砸烂，那么我们不妨直接从 \(a_i\) 小的开始放。 我们从小到大枚举所有 \(a_i\) 的值，然后将 \(a\) 值等于 \(a_i\) 的所有灯按照 \(b_i\) 降序排列。 我们依次取出，不难发现，当我们取出 \(a_i\) 个灯的时候刚好满足条件，此时所有灯都会被砸烂。 因而，我们枚举 \(a_i\) 的值，对前 \(a_i\) 个数的 \(b_i\) 求和即可。 比较省事的方法是用 \(n\) 个优先队列。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;priority_queue&lt;int, vector&lt;int>, less&lt;>>> q(n + 1); for(int i=0;i&lt;n;i++)&#123; int x, y; cin >> x >> y; q[x].emplace(y); &#125; int ans = 0; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(q[i].empty()) break; ans += q[i].top(); q[i].pop(); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 写法有点抽象 C. Insert Zero and Invert Prefix 题意 给定一个二进制序列 \(a\)，通过下面的 \(n\) 次操作，将一个空序列 \(b\) 变为 \(a\)： 选择一个下标 \(i\)； 将 \([1, i]\) 内所有元素取反； 在 \(i\) 的后面插入一个 \(0\) 用选择的下标来表征每次操作，输出满足条件的一个方案。 思路 首先，显然我们无法将序列的最后一个数变为 \(1\)，因为我们一定会在取反后插入一个 \(0\)。 其次，举个例子，对于 \(1\ 1\ 0\)，最简单的方法是： 先在开头执行两次操作，也就是 \(0\ 0\)，此时序列为 \(0\ 0\)； 在结尾执行一次操作，也就是 \(2\)，此时序列为 \(1\ 1\ 0\)。 更复杂地，对于任意 \([\, \overbrace{1, 1, \ldots, 1}^{k}, 0 \,]\)，我们都可以先放入 \(k\) 个 \(0\)，最后在 \(k\) 位置执行一次操作，将前面放入的 \(0\) 全部变为 \(1\)，最后放入一个 \(0\)。 有趣的是，我们的操作对后面的元素是无影响的，也就是说，我们只需将 \(a\) 拆分成若干个上述形式的段，然后从右向左执行操作即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; if(a[n] == 1)&#123; cout &lt;&lt; "NO\n"; return; &#125; cout &lt;&lt; "YES\n"; int cnt = 0; for(int i=n-1;i>=0;i--)&#123; if(a[i] == 0)&#123; cout &lt;&lt; cnt &lt;&lt; ' '; cnt = 0; &#125;else &#123; cnt ++; cout &lt;&lt; 0 &lt;&lt; ' '; &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 比前面的题好想多了（ D. Ball Sorting 题意 给定一个 \(n\) 的排列 \(a\)，对于整数 \(k\)，按照下面的操作进行排序： 在排列中任意添加 \(k\) 个 \(0\)； 在一次操作中，可选择一个和 \(0\) 相邻的元素，并将其移动到任何位置。 对于 \(k \in [1, n]\)，输出第二种操作最少需要几次，才能让排列升序。 思路 首先，既然需要最少操作，不妨找到最长递增子序列，因而我们会发现，我们只需用该序列的元素将排列分段，每一段放上一个 \(0\)，即可让需要的 \(0\) 个数最少。如果个数不够，那怎么去掉呢？如何优先选择呢？ 上面的思路很显然，但存在一种情况：有多个最长递增子序列。因而，这种 "暴力" 的方法不可行。 既然上面的操作需要 \(dp\) 了，我们不妨想想如何用 \(dp\) 直接解决。 上面，我们提到了分段的概念，那么我们可以将其应用到单个元素的状态区分上。 对于一个元素，他有下面三种状态： 和它相邻的元素比他小，那么它可以作为前面那个元素所在递增段的一部分； 和他前面不相邻的元素比他小，那么它可以成为新的一个递增段； 前面没有一个元素比他小，那么它注定会被移动 因而，我们定义 \(dp[i][j]\) 为前 \(i\) 个位置分了 \(j\) 段，可得出下面的状态转移方程： 如果 \(a[i - 1] &lt; a[i]\)，那么 \(dp[i][j] = dp[i - 1][j]\)； 对于 \(p \in [0, i - 1]\)，如果 \(a[k] &lt; a[i]\)，那么 \(dp[i][j] = \min(dp[i][j], dp[k][j - 1] + i - k - 1)\)，其中 \(i - k - 1\) 为 \(i, k\) 之间元素的数量。 时间复杂度：\(O(n ^ 3)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 2); a[n + 1] = inf; vector&lt;vector&lt;int>> dp(n + 2, vector&lt;int>(n + 1, inf)); dp[0][0] = 0; for(int i = 1; i &lt;= n; i ++)&#123; cin >> a[i]; dp[0][i] = 0; &#125; for(int i = 1; i &lt;= n + 1; i ++)&#123; //遍历到哪个元素 for(int j = 0; j &lt;= n; j ++)&#123; //分多少块 if(a[i - 1] &lt; a[i]) dp[i][j] = dp[i - 1][j]; //相邻满足递增，不分块 if(j > 0) for(int k = 0; k &lt; i; k ++) if(a[k] &lt; a[i]) dp[i][j] = min(dp[i][j], dp[k][j - 1] + (i - k - 1)); //不相邻，分块 &#125; &#125; for(int j = 1; j &lt;= n; j ++) cout &lt;&lt; dp[n + 1][j] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 被一开始的思路卡死了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 877 Div. 2</title>
    <url>/blog/posts/453802042/</url>
    <content><![CDATA[Contestant'. Rank 1872. Rating -13. 罚时吃饱了 A. Blackboard List 题意 有一块黑板，初始状态下只有两个数字。 定义操作为任选黑板上的两个数字，将两者的差的绝对值写到黑板上。 现在，给定打乱顺序后的黑板上的数字序列，输出其中任意一个初始状态的数字。 思路 首先，因为我们写上去的数字一定是非负数，所以如果序列中有负数，那直接输出。 否则，那么不会出现正数减负数的情况，也就是说，我们写上去的数一定是小于初始状态下的最大数字的。 因此，如果序列都是非负数，最大值就是答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int mx = 0; bool f = false; while(n --)&#123; int x; cin >> x; if(x &lt; 0 &amp;&amp; !f)&#123; f = true; cout &lt;&lt; x &lt;&lt; '\n'; &#125;else mx = max(mx, x); &#125; if(!f) cout &lt;&lt; mx &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 签到变得不签了（ B. Minimize Permutation Subarrays 题意 给定一个 \(n\) 的排列，定义操作为选择两个数，并将其互换位置（可以是同两个数换位置）。 输出一个方案，使最后所有连续子序列中排列的个数最少。 思路 首先，如果要让排列尽量少，那么我们考虑将 \(1\ 2\) 分的尽可能开，或者将 \(1\ n\) 尽可能靠近。 上述操作等价于将 \(n\) 放入 \(1\ 2\) 之间。 显然，如果满足上述操作，我们就可以贪心地认为个数最少了。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;int> ind(n + 1); for(int i=1;i&lt;=n;i++) &#123; int cur; cin >> cur; ind[cur] = i; &#125; if(ind[1] > ind[2]) swap(ind[1], ind[2]); if(ind[n] &lt; ind[1]) cout &lt;&lt; ind[1] &lt;&lt; ' ' &lt;&lt; ind[n] &lt;&lt; '\n'; else if(ind[n] > ind[1] &amp;&amp; ind[n] &lt; ind[2]) cout &lt;&lt; "1 1\n"; else cout &lt;&lt; ind[2] &lt;&lt; ' ' &lt;&lt; ind[n] &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 贪错了两次，但刚好都是答案的其中一部分 C. No Prime Differences 题意 给定矩阵的大小 \(n \times m\)，构造一个矩阵，满足所有相邻的两个数的差的绝对值都不是质数。 思路 首先，如果 \(n\) 是偶数，那么我们直接按顺序 从左到右 从上到下 放入即可，最后横向差 \(1\)，纵向差偶数。 如果 \(m\) 是偶数，我们按顺序 从上到下 从左到右 放入，最后横向差偶数，纵向差 \(1\)。 否则，也就是 \(n\) 和 \(m\) 都是奇数的时候，我们考虑下面的构造： 首先，我们尽可能让横向的差值为 \(1\)，因而我们会想到下面的构造方法： \(\begin{matrix}1&amp;2&amp;3&amp;4&amp;5\\7&amp;8&amp;9&amp;10&amp;?\end{matrix}\) 很有趣，我们将 \(?\) 的位置放上跳过的 \(6\)，恰好是满足条件的。 那么，扩大我们的打表吧： \(\begin{matrix}1&amp;2&amp;3&amp;4&amp;5\\7&amp;8&amp;9&amp;10&amp;6\\13&amp;14&amp;15&amp;11&amp;12\\19&amp;20&amp;16&amp;17&amp;18\\...\end{matrix}\) 不难发现均满足条件。 因此，如上方式即可得到答案。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, m; cin >> n >> m; if(n % 2 == 1 &amp;&amp; m % 2 == 1) &#123; vector&lt;vector&lt;int>> ans(n + 1, vector&lt;int>(m + 1)); for (int j = 1; j &lt;= m; j++) ans[1][j] = j; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; ans[i][j] = ans[i - 1][j] + ((ans[i - 1][j] == (i - 1) * m) ? 1 : m + 1); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) cout &lt;&lt; ans[i][j] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125;else if(m % 2 == 0)&#123; int now = 1; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cout &lt;&lt; now ++ &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; &#125;else&#123; int now = 1; vector&lt;vector&lt;int>> ans(n + 1, vector&lt;int>(m + 1)); for(int j=1;j&lt;=m;j++)&#123; for(int i=1;i&lt;=n;i++)&#123; ans[i][j] = now ++; &#125; cout &lt;&lt; '\n'; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) cout &lt;&lt; ans[i][j] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 一直在想 \(4 \times 4\) 为单位的规律，属实是被之前的构造题束缚思路了（ D. Bracket Walk 题意 给定一个由括号组成的字符串，定义操作为在某一位向左或向右移动一格（两个端点只能向内走）。 定义起点为 \(1\)，终点为 \(n\)，在每个格子可以经过任意次的条件下，得到行走路径。 将路径用每一位上的括号表征，可得到一串新的括号组成的字符串，如果这个字符串中的所有括号均被配对，那么即有解。 给定 \(q\) 个 累积 询问，每个询问给出一个下标，输出将这个下标对应的括号"取反"后，是否有解。 思路 首先，显然括号需要两两配对，并且在后退 \(x\) 格后我们仍需走 \(x\) 格回到最初开始后退的那个点，所以总步数一定是偶数。 或者换句话说，如果给定字符串长度为奇数，直接输出 \(NO\)。 其次，在后退并复位的过程中，我们不难发现，针对 () 的后退是毫无意义的，有意义的只有 (( 和 ))。 那么，我们只需维护连续相同的括号即可。 考虑下面的 \(set\) 维护： 给定下面的两个条件： 奇数位 \(i\) 对应的字符为 ) 偶数位 \(i\) 对应的字符为 ( 我们将满足任意一个条件的下标 \(i\) 记录下来，存入 \(set\) \(A\) 中。 结论是：如果 \(A\) 为空，或者 \(A\) 中的最小元素为偶数 且最大元素为奇数，那么就是有解。 下面给出证明： 如果 \(A\) 为空，那么字符串就是 ()()()()...，显然有解； 如果 \(A\) 中的最小元素为奇数，那么字符串会变成类似 ()()())... 的形式，此时，显然前面没有多余的 ( 与之配对，也没有出现 (( 来后退； 最大元素为偶数的时候同上，也无法配对； 如果 \(A\) 中的最小元素为偶数 且最大元素为奇数，那么我们不难发现，一定会出现 (( 和 ))。因为字符串长度是偶数，所以不可能出现奇数个未配对的括号，因而，我们只需让 (( 和 )) 回退的次数的差值为未配对的括号数的一半即可，此时显然是有解的。 时间复杂度：\(O((n + q) \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n ,q; cin >> n >> q; string s; cin >> s; s = "#" + s; set&lt;int> a; for(int i=1;i&lt;=n;i++)&#123; if(i % 2 == 1 &amp;&amp; s[i] == ')') a.emplace(i); if(i % 2 == 0 &amp;&amp; s[i] == '(') a.emplace(i); &#125; while(q --)&#123; int x; cin >> x; if(a.count(x)) a.erase(x); else a.emplace(x); if(n % 2 == 1) cout &lt;&lt; "NO\n"; else if(a.empty() || (*a.begin() % 2 == 0 &amp;&amp; *a.rbegin() % 2 == 1)) cout &lt;&lt; "YES\n"; else cout &lt;&lt; "NO\n"; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 这个做法很有趣（其实赛时想到了一半多了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 875 Div. 2</title>
    <url>/blog/posts/2489256331/</url>
    <content><![CDATA[Contestant'. Rank 1013. Rating +32. A. Twin Permutations 题意 给定一个排列 \(a\)，构造另一个排列 \(b\)，满足 \(a_i + b_i\) 不递减。 思路 那也就可以是相等。 因为是长度相等的排列，因而一定可以得到 \(n\) 个和为 \(n + 1\) 的组合。 因而，输出 \(n - a_i + 1\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; cout &lt;&lt; (n - cur + 1) &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 签到签到 B. Array merging 题意 给定两个序列，定义一次操作为选择一个序列，并将序列的头元素取出，放入新序列的尾部。当所有元素被取出后，输出最长相等元素连续子序列的长度。 思路 首先，操作等价于将某个序列的元素按顺序插入另一个序列中，那么可以证明的是，我们只能合并两个连续相等的子序列，无法合并多个。 那么，我们遍历找出每一种元素在两个序列中的连续最大长度，最后将两个序列中的每一个元素的长度加起来，和答案取最大值即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; map&lt;int, int> cnt1, cnt2; vector&lt;int> a(n + 1); int cnt = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; if (a[i] != a[i - 1]) cnt = 0; if (cnt == 0 || a[i] == a[i - 1]) cnt++; cnt1[a[i]] = max(cnt1[a[i]], cnt); &#125; cnt = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; if (a[i] != a[i - 1]) cnt = 0; if (cnt == 0 || a[i] == a[i - 1]) cnt++; cnt2[a[i]] = max(cnt2[a[i]], cnt); &#125; int ans = 0; for(int i=1;i&lt;=2 * n;i++)&#123; ans = max(ans, cnt1[i] + cnt2[i]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 草，一开始读假了 C. Copil Copac Draws Trees 题意 对于一棵 \(n\) 个点的树，给定其 \(n - 1\) 个边。 初始状态下，图中只有点 \(1\)，定义一次操作为按输入顺序枚举所有边，如果这个边有一个端点在图中，那么将这条边和另一个端点加入图中，否则跳过这条边。 输出建立这棵树需要的最小操作数。 思路 首先，显然这是一棵根为 \(1\) 的有根树，只要父节点不存在，这条边也一定不存在。 我们将每条边按照输入顺序编号，那么我们不难发现下面几点： 对于一个节点，它的每个子树的操作是互不干扰的； 只要上一条边的编号小于这条边的编号，那么这两条边都可以在一次操作内完成，否则需要多一次操作 因而，我们考虑树型 \(dp\)。 我们从根节点开始 \(\mathtt{dfs}\)，并遍历所有子树。 对于某一个点，如果它的子节点和它的边的编号小于它的父节点和它的编号，那么这棵子树的 \(dp\) 值需要 \(+1\)。 对于所有子树，我们取 \(dp\) 的最大值即可。 最后，输出 \(dp[1] + 1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; vector&lt;vector&lt;pii>> e(n + 1); for(int i=1;i&lt;n;i++)&#123; int u, v; cin >> u >> v; e[u].pb(v, i), e[v].pb(u, i); &#125; vector&lt;int> dp(n + 1); vector&lt;bool> st(n + 1); auto dfs = [&amp;](auto self, int x, int p, int id) -> void&#123; if(st[x]) return; st[x] = true; for(auto t : e[x])&#123; if(t.fs == p) continue; self(self, t.fs, x, t.sc); dp[x] = max(dp[x], dp[t.fs] + (id > t.sc ? 1 : 0)); &#125; &#125;; dfs(dfs, 1, -1, -inf); cout &lt;&lt; dp[1] + 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 口胡乱写居然过了（ D. The BOSS Can Count Pairs 题意 给定两个序列 \(a, b\)，输出二元组 \((i, j)\) 的个数，满足 \(1 \leq i &lt; j \leq n, a_i \cdot a_j = b_i+b_j\)。 思路1 首先，数据范围很好的将这道签到题变成了难题。 那么，普通的 \(O(n ^ 2)\) 是绝对无法通过的，那么在显然需要二重遍历的情况下，我们考虑优化某一维的计算。 因为 \(b_i \leq n, b_j \leq n\)，所以 \(b_i + b_j = a_i \cdot a_j \leq 2n\)。 因此，\(\min(a_i, a_j) \leq \sqrt{2n}\)。 所以，我们转而考虑对 \(a_j\) 的可能的值的枚举。 定义 \(fr[x][y]\) 为 \((x, y)\) 二元组的个数，\(lim = \sqrt{2n}\)。 针对重复计算，我们枚举 \(a_i\)，对 \(a_j\) 进行分讨： \(a_j = a_i\)，那么有 \(\displaystyle{\frac{\sum_{i=1}^{n}fr[a_i][a_i \cdot a_i - b_i]-\sum_{i=1}^{lim}fr[i][\frac{i \cdot i}{2}]}{2}}\) 在上式中，我们筛除了 \(a_i\) 和 \(a_j\) 互换的重复和 \((a_i, b_i) = (a_j, b_j) \rightarrow b_i = b_j\) 的重复； \(a_j \neq a_i\)，因为重复的原因，我们直接计算 \(a_i &gt; a_j\) 的情况，那么有： \(\displaystyle{\sum_{i=1}^n \sum_{j=1}^{min(a_i-1,\frac{2\cdot n}{a_i})}fr[j][a_i \cdot j-b_i]}\) 最后，答案就是两者之和。 时间复杂度：\(O(n \sqrt{n})\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; ll n; cin >> n; vector&lt;ll> a(n + 1), b(n + 1); for(ll i=1;i&lt;=n;i++) cin >> a[i]; for(ll i=1;i&lt;=n;i++) cin >> b[i]; ll lim = (ll) sqrt(2 * n); vector&lt;vector&lt;int>> fr(lim + 1, vector&lt;int>(n + 1)); for(ll i=1;i&lt;=n;i++) if(a[i] &lt;= lim) fr[a[i]][b[i]] ++; ll ans1 = 0, ans2 = 0; for(ll i=1;i&lt;=n;i++)&#123; if(a[i] * a[i] - b[i] >= 0 &amp;&amp; a[i] * a[i] - b[i] &lt;= n) ans1 += fr[a[i]][a[i] * a[i] - b[i]]; if(i &lt;= lim &amp;&amp; i % 2 == 0) ans1 -= fr[i][i * i / 2]; for(ll j=1;j&lt;=min(a[i] - 1, 2 * n / a[i]);j++)&#123; if(a[i] * j - b[i] >= 0 &amp;&amp; a[i] * j - b[i] &lt;= n) ans2 += fr[j][a[i] * j - b[i]]; &#125; &#125; cout &lt;&lt; ans1 / 2 + ans2 &lt;&lt; '\n'; &#125; int main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 思路2 这边放一个队友的简要思路： 首先，我们固定 \(a_i\)，那么只要 \(a_j + 1\)，\(b_j\) 就会加上 \(a_i\)。 也就是说，这一趟我们只需枚举 \(\frac{n}{a_i}\)，而如果 \(a_i\) 比较小，那么这一趟枚举的次数是可观的。 那么， 我们考虑预处理一部分的答案，即使用 \(O(nk)\) 的复杂度先暴力跑一部分的答案。 如上，加上数组的初始化，我们得到该思路的复杂度约为：\(O(2nk + \frac{n ^ 2}{k})\)，因而 \(k = \sqrt{2n}\) 时取到较优解。 时间复杂度：约\(O(2n \sqrt{2n} + \frac{2n}{k})\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const ll N = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; ll hs(ll x, ll y)&#123; return x * 979797 + y; &#125; void solve() &#123; ll n; cin >> n; ll lim = (ll) sqrt(2 * n); vector&lt;ll> a(n + 1), b(n + 1); vector&lt;vector&lt;int>> q(lim + 1, vector&lt;int>(n + 1)); unordered_map&lt;ll, ll> cnt; for (int i = 1; i &lt;= n; i++) cin >> a[i]; for (int i = 1; i &lt;= n; i++) cin >> b[i], cnt[hs(a[i], b[i])]++; for (int k = 1; k &lt;= lim; k++) &#123; for (int i = 1; i &lt;= n; i++) &#123; ll bj = a[i] * k - b[i]; if (a[i] * k > b[i] &amp;&amp; bj &lt;= n) q[k][bj]++; &#125; &#125; ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; if (a[i] * a[i] == b[i] + b[i]) ans--; if (a[i] &lt;= lim) &#123; ans += q[a[i]][b[i]]; continue; &#125; ll y = (-b[i]) % a[i], x = (b[i] + y) / a[i]; for (; x &lt;= n &amp;&amp; y &lt;= n &amp;&amp; a[i] * x &lt;= 2 * n &amp;&amp; b[i] + y &lt;= 2 * n; x++, y += a[i]) &#123; if (y > 0 &amp;&amp; cnt.count(hs(x, y))) ans += cnt[hs(x, y)]; &#125; &#125; cout &lt;&lt; ans / 2 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 傻逼题，卡全局long long]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 149</title>
    <url>/blog/posts/620610674/</url>
    <content><![CDATA[Contestant'. Rank 1622. Rating +15. A. Grasshopper on a Line 题意 给定一个数轴，终点 \(x\) 以及一个整数 \(k\)，定义一次操作为从当前位置向右移动 \(p\) 格，满足 \(p\mod k \neq 0\)。输出从原点走到 \(x\) 所需的最小的操作数以及方案。 思路 如果 \(x\) 不能被整除，一步即达。 可以被整除的话，\(x - 1\) 肯定不会被整除（互质），因此选择先走一格再走 \(x - 1\) 格。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 1e7 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; if(n % k == 0) cout &lt;&lt; 2 &lt;&lt; '\n' &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; n - 1 &lt;&lt; '\n'; else cout &lt;&lt; 1 &lt;&lt; '\n' &lt;&lt; n &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 和之前的某个签到题很像 B. Comparison String 题意 给定一个由 \(&lt;\) 和 \(&gt;\) 组成的字符串，定义如果第 \(i\) 位为 \(&lt;\)，那么 \(a_i &lt; a_{i + 1}\)，否则 \(a_i &gt; a_{i + 1}\)。 构造一个满足条件的序列 \(a\)，输出不同数字的最少个数。 思路 很显然，如果出现了单调的区间，那么这段长为 \(k\) 的区间内一定有 \(k\) 格不同的数字，不同单调序列的元素可以共用，因此答案即为所有单调区间的长度的最大值。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 1e7 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; string s; cin >> s; int ans = 1, sum = 1; for(int i=0;i&lt;n;i++)&#123; if(s[i] == s[i + 1]) sum ++; else sum = 1; ans = max(ans, sum); &#125; cout &lt;&lt; ans + 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 不可模拟，模拟有坑 C. Best Binary String 题意 给定一个二进制字符串，其中有若干位被替换为 \(?\)。 定义对于一个二进制串，一次操作为选定一个区间并将这个区间内的数字左右翻转，代价为 \(1\)。 输出一种 \(?\) 的替换方案，使让字符串不递减的代价最小。 思路 首先，如果将问号替换成前面的数，就可以让代价最小，这是显然的。 那么，如果第一个是问号，显然我们不希望再多一个 \(1\)，因此直接放 \(0\)。 反过来也行，最后一位放 \(1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 1e7 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; string s; cin >> s; int n = s.size(); if(s[0] == '?') s[0] = '0'; char pre = s[0]; for(int i=1;i&lt;n;i++)&#123; if(s[i] == '?')&#123; s[i] = pre; &#125;else pre = s[i]; &#125; cout &lt;&lt; s &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 一开始写的思路差点就对了，淦 D. Bracket Coloring 题意 给定一个由左右括号组成的字符串，定义满足下面条件任意一个即为 "美丽的"： 符合语法规则； 将字符串逆序输出后得到新的字符串，新的字符串满足语法规则 定义可将字符串涂色，涂色后，任取一种颜色，将该颜色的所有括号拿出后得到的新字符串都是 "美丽的"。 输出最少颜色种数，以及对应的一种方案。 需满足涂入的颜色编号小于等于颜色种数。 思路 我们不妨直接模拟，用队列存上一个最近的可配对的括号，因而我们进行分讨： 遇到 \((\)： 如果上一个括号为 \((\)，那么放入队列中等待配对； 如果上一个括号为 \()\)，那么配对，并归入第一种颜色 遇到 \()\)： 如果上一个括号为 \()\)，那么放入队列中等待配对； 如果上一个括号为 \((\)，那么配对，并归入第二种颜色 可以证明，最多只需两种颜色，如果上述操作后仍有没有配对的括号，那就无解。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 1e7 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; string s; cin >> s; queue&lt;pci> q1, q2; vector&lt;int> ans(n, 1); bool f1 = false, f2 = false; for(int i=0;i&lt;n;i++)&#123; char now = s[i]; if(now == '(')&#123; if(q1.empty() || q1.front().fs == '(') q1.emplace(now, i); else&#123; auto e = q1.front(); q1.pop(); ans[e.sc] = ans[i] = 2; f1 = true; &#125; &#125;else&#123; if(q1.empty() || q1.front().fs == ')') q1.emplace(now, i); else&#123; q1.pop(); f2 = true; &#125; &#125; &#125; if(q1.empty())&#123; cout &lt;&lt; (f1 &amp;&amp; f2 ? 2 : 1) &lt;&lt; '\n'; if(f1 &amp;&amp; f2) for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; else for(int i=0;i&lt;n;i++) cout &lt;&lt; 1 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125;else cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜的居然过了（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 福师大第20届校赛</title>
    <url>/blog/posts/2502331975/</url>
    <content><![CDATA[One contestant of team004. Rank 1. Solved 7/12. A. Tree Destruction 图论+组合数，待补充 B. Encore 计算几何，待补充 C. Konnakol 题意 无穷次重复斐波那契数列的前八项，构成一个序列。 给定整数 \(n, k\)，提取出前 \(n\) 个数，输出第 \(k\) 个数。 思路 首先，\(n\) 是没用的。 其次，取模即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; vector&lt;int> p = &#123;1, 1, 2, 3, 5, 8, 13, 21&#125;; int sb, x; cin >> sb >> x; cout &lt;&lt; p[(x - 1) % 8] &lt;&lt; "/8\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 骗人 \(\times 1\) D. Data Mining and Big Data 题意 给定一个只包含 \(0\) 或 \(1\) 的字符串，长度为 \(2^k, k \in [0, 2]\)，定义一次操作为：将当前的字符串中的所有二进制数取反，并拼接到原字符串的后面。 按照如上操作进行若干次后，可得一个 \(1024GB\) 的数据，输出数据中 \(0\) 的个数。 思路 显然，最后 \(0\) 和 \(1\) 的个数是相等的，那么我们直接输出长度的一半即可。 不用敲样例，答案就是 \(1 &lt;&lt; 32\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; string s; cin >> s; cout &lt;&lt; (1ll &lt;&lt; 32) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 不会真有人敲错吧（ E. Function 题意 初始状态下，令方程 \(f(x) = 0\)。 给定 \(q\) 个询问，每个询问会给定操作序号，以及操作所需的参数： 给定两个整数 \(a, b\)，将 \(f(x)\) 更新为 \(f(x) + |x - a| + b\)； 输出让 \(f(x)\) 的值最小的 \(x\)，以及 \(f(x)\) 的最小值。 对于询问，执行对应的操作。 思路 我们把 \(|x - a|\) 和 \(b\) 分成两部分考虑。 首先很明显，无论 \(x\) 是什么，右边的值都不会受到影响，因此我们可以在更新的时候顺便记录右边的值的总和。 其次，在更新了 \(n\) 次后，左边的值的总和为 \(|x - a_1| + |x - a_2| + \ldots + |x - a_n|\)。 不难发现，要让这个值最小，\(x\) 就是 \(a_1, a_2, \ldots, a_n\) 的中位数。 因此，本题最后归结到，如何动态维护中位数。 对于这个，考虑到码量，我们会优先选择对顶堆，而非线段树。 何为对顶堆？小根堆维护前 \(\frac{n}{2}\) 大的数，剩余的数由大根堆维护。 那么，我们只要保持大小根堆的大小的差值不大于 \(1\)，即可保证大根堆的队头就是中位数。 在维护大小根堆的同时，我们根据元素的位置维护左半部分的和即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 1e7 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int q; cin >> q; priority_queue&lt;int> g; priority_queue&lt;int, vector&lt;int>, greater&lt;>> l; int sum1 = 0, sum2 = 0; while(q --)&#123; int op; cin >> op; if(op == 1)&#123; int a, b; cin >> a >> b; sum2 += b; if(!l.empty() &amp;&amp; a > l.top())&#123; l.emplace(a), sum1 += a; &#125;else&#123; g.emplace(a), sum1 -= a; &#125; if(g.size() > l.size() + 1)&#123; l.emplace(g.top()), sum1 += g.top() * 2, g.pop(); &#125; if(l.size() > g.size())&#123; g.emplace(l.top()), sum1 -= l.top() * 2, l.pop(); &#125; &#125;else&#123; cout &lt;&lt; g.top() &lt;&lt; ' '; int ans = sum1 + sum2; if(g.size() > l.size()) ans += g.top(); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 妙捏 F. A * B Problem 题意 给定三个数 \(a, b, c\)，定义一次操作为：选择两个数，将某个数 \(+1\)，另一个数 \(-1\)。 输出最小的操作数，使得存在某两个数的乘积为第三个数。 思路 我们设最后得到的 \(a, b, c\) 满足 \(ab = c\)。 那么 \(a + b + ab = sum\)。 左右各加 \(1\)，化简得到 \((a + 1)(b + 1) = sum + 1\)。 也就是说，\(a + 1\) 是 \(sum + 1\) 的因子。 因此，如果这道题的数据量不大，那么解法就是线性筛+分解质因数+\(\mathtt{dfs}\)枚举因子。 wait，你可能会疑惑，为什么可以 \(\mathtt{dfs}\)。 事实上，\(1e18\) 的因子数量的数量级只有 \(1e5\) 左右，因此暴力是可行的。 好，看一下数据范围 \(1e18\)，寄。 这边需要用到 Pollard Rho 算法，用 \(O(n ^ {\frac{1}{4}})\) 的复杂度完成分解质因数。 因此，在得到因子后，我们将 \(a, b, c\) 进行排列，并与之前的 \(a, b, c\) 分别进行作差取绝对值后 求和除 \(2\)，最后取最小值即可。 时间复杂度：\(O(n ^ {\frac{1}{4}}p)\) ,p为因子个数 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() /* ************************************************* * Miller_Rabin 算法进行素数测试 * 速度快可以判断一个 &lt; 2^63 的数是不是素数 * **************************************************/ const int S = 8; //随机算法判定次数一般 8∼10 就够了 // 计算 ret = (a*b)%c a,b,c &lt; 2^63 int mult_mod(int a, int b, int c) &#123; a %= c; b %= c; int ret = 0; int tmp = a; while (b) &#123; if (b &amp; 1) &#123; ret += tmp; if (ret > c)ret -= c;//直接取模慢很多 &#125; tmp &lt;&lt;= 1; if (tmp > c)tmp -= c; b >>= 1; &#125; return ret; &#125; // 计算 ret = (a^n)%mod int pow_mod(int a, int n, int mod) &#123; int ret = 1; int temp = a % mod; while (n) &#123; if (n &amp; 1)ret = mult_mod(ret, temp, mod); temp = mult_mod(temp, temp, mod); n >>= 1; &#125; return ret; &#125; // 通过 a^(n−1)=1(mod n)来判断 n 是不是素数 // n − 1 = x ∗ 2 // 中间使用二次判断 // 是合数返回 true, 不一定是合数返回 false bool check(int a, int n, int x, int t) &#123; int ret = pow_mod(a, x, n); int last = ret; for (int i = 1; i &lt;= t; i++) &#123; ret = mult_mod(ret, ret, n); if (ret == 1 &amp;&amp; last != 1 &amp;&amp; last != n - 1)return true;//合数 last = ret; &#125; if (ret != 1)return true; else return false; &#125; //************************************************** // Miller_Rabin 算法 // 是素数返回 true,(可能是伪素数) // 不是素数返回 false //************************************************** bool Miller_Rabin(int n) &#123; if (n &lt; 2)return false; if (n == 2)return true; if ((n &amp; 1) == 0)return false;//偶数 int x = n - 1; int t = 0; while ((x &amp; 1) == 0) &#123; x >>= 1; t++; &#125; srand(time(NULL)); /* *************** */ for (int i = 0; i &lt; S; i++) &#123; int a = rand() % (n - 1) + 1; if (check(a, n, x, t)) return false; &#125; return true; &#125; //********************************************** // pollard_rho 算法进行质因素分解 //********************************************* int factor[1000005];//质因素分解结果（刚返回时时无序的） int tol;//质因素的个数，编号 0∼tol-1 int gcd(int a, int b) &#123; int t; while (b) &#123; t = a; a = b; b = t % b; &#125; if (a >= 0)return a; else return -a; &#125; //找出一个因子 int pollard_rho(int x, int c) &#123; int i = 1, k = 2; srand(time(NULL)); int x0 = rand() % (x - 1) + 1; int y = x0; while (1) &#123; i++; x0 = (mult_mod(x0, x0, x) + c) % x; int d = gcd(y - x0, x); if (d != 1 &amp;&amp; d != x)return d; if (y == x0)return x; if (i == k) &#123; y = x0; k += k; &#125; &#125; &#125; //对 n 进行素因子分解，存入 factor. k 设置为 107 左右即可 void findfac(int n, int k) &#123; if (n == 1)return; if (Miller_Rabin(n)) &#123; factor[tol++] = n; return; &#125; int p = n; int c = k; while (p >= n)p = pollard_rho(p, c--);//值变化，防止死循环 k findfac(p, k); findfac(n / p, k); &#125; //-------- ACM Template of kuangbin p. 30 ---------- const int inf = 0x3f3f3f3f3f3f3f3f; vector&lt;int> keys; map&lt;int, int> fact_map; set&lt;int> fact_set; int qp(int a, int b) &#123; int res = 1; while (b > 0) &#123; if (b &amp; 1) res *= a; a *= a; b >>= 1; &#125; return res; &#125; void factorize(int x)&#123; fact_map.clear(); keys.clear(); tol = 0; findfac(x, 107); for(int i=0;i&lt;tol;i++) &#123; if(fact_map[factor[i]] == 0) keys.pb(factor[i]); fact_map[factor[i]] ++; &#125; &#125; void dfs(int x, int step)&#123; if(step == fact_map.size())&#123; fact_set.emplace(x); return; &#125; for(int i=0;i&lt;=fact_map[keys[step]];i++)&#123; dfs(x * qp(keys[step], i), step + 1); &#125; &#125; void solve() &#123; int a, b, c; cin >> a >> b >> c; int sum = a + b + c; factorize(sum + 1); fact_set.clear(); dfs(1, 0); int ans = inf; for(auto e : fact_set) &#123; if(e == 1) continue; int aa = e - 1, bb = (sum + 1) / e - 1, cc = sum - aa - bb; ans = min(ans, (abs(aa - a) + abs(bb - b) + abs(cc - c)) / 2); ans = min(ans, (abs(aa - a) + abs(bb - c) + abs(cc - b)) / 2); ans = min(ans, (abs(aa - b) + abs(bb - a) + abs(cc - c)) / 2); ans = min(ans, (abs(aa - b) + abs(bb - c) + abs(cc - a)) / 2); ans = min(ans, (abs(aa - c) + abs(bb - a) + abs(cc - b)) / 2); ans = min(ans, (abs(aa - c) + abs(bb - b) + abs(cc - a)) / 2); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t--) solve(); &#125; 但凡数据量小就很签（（ G. CET-4 赛时的样例出错，\(\mathtt{OJ}\) 上的重现赛的题面已修正 题意 \(n\) 选 \(r\) 问题中答对 \(x\) 道题的概率。 思路 首先，因为如果某道题选错，可能会影响后续的正确选项的选择，所以简单的组合数是不对的。 我们不妨考虑广义容斥的做法，或者说，这就是一道广义容斥的模板题。 考虑到我比较若，这边把官方题解搬过来了，并略微做了点修改。 我们设 \(β(x)\) 为有 \(x\) 个条件的满足的方案数。 则恰好有 \(x\) 个方案满足的方案数为 \(\displaystyle{f(x)=\sum_{i=x}^{n}(-1)^{i-x}β(x) {i\choose x}}\)。 对应到本题，求解步骤即为： \(β(x)\) 的意思是至少对 \(x\) 题，也就是先从 \(r\) 个空中选出 \(i\) 个是对的，然后对于剩下的 \(n-i\) 个选项，我们再选出 \(r-i\) 个填入剩下的空。 那么方案数为 \(\displaystyle{ {r \choose i} { {n-i} \choose {r-i} } (r-i)!}\) 。 代入公式，\(\displaystyle{f(x)=\sum_{i=x}^{r}{i \choose x}(-1)^{i-x}{r \choose i}{n-i\choose r-i }(r-i)!}\) 。 全部的方案数量为 \(\displaystyle{ {n \choose r} r! }\)，因此将 \(f(x)\) 和这个作除即可得到答案。 当然也可以用 dp 实现。 时间复杂度：看你怎么预处理 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e6 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; int fact[N], fact_inv[N]; int qp(int a, int b) &#123; int res = 1; while (b > 0) &#123; if (b &amp; 1) res = (res * a) % mod; a = (a * a) % mod; b >>= 1; &#125; return res; &#125; int inv(int x)&#123; return qp(x, mod - 2); &#125; void init()&#123; fact[0] = fact_inv[0] = 1; for(int i=1;i&lt;=2e6;i++)&#123; fact[i] = fact[i - 1] * i % mod; fact_inv[i] = inv(fact[i]); //当然这边还可以优化 &#125; &#125; int C(int n, int m)&#123; return fact[n] * fact_inv[n - m] % mod * fact_inv[m] % mod; &#125; void solve() &#123; int n, r, x; cin >> n >> r >> x; int p = 0; for(int i=x;i&lt;=r;i++)&#123; int now = C(i, x) * C(r, i) % mod * C(n - i, r - i) % mod * fact[r - i] % mod; if((i - x) % 2 == 0) p = (p + now) % mod; else p = (p + mod - now) % mod; &#125; cout &lt;&lt; p * inv(C(n, r) * fact[r] % mod) % mod &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 论我想了半天4选1对1题的概率为什么是1/6这件事 H. Group Theory 题意 定义一次操作为将整个序列向右移动一格，并将最后一个元素放到序列的开头。 给定一个字符序列，输出进行任意次操作后是否能将序列变为回文。 思路 数据量很小，所以是一道签到题。 与其模拟放置的过程，我们不妨直接在左边和右边分别复制一遍原序列，并遍历这个新序列，若出现了长度为 \(n\) 的回文序列，那么就是可行。 时间复杂度：\(O(\frac{3}{2}n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; if(n == 0)&#123; cout &lt;&lt; "YES\n"; return; &#125; vector&lt;string> a(3 * n + 3); for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; a[n + i] = a[n * 2 + i] = a[i]; &#125; bool f = false; for(int i=0;i&lt;2*n;i++)&#123; bool cur = true; for(int j=0;j&lt;n/2;j++)&#123; if(a[i + j] != a[i + (n - j - 1)])&#123; cur = false; break; &#125; &#125; if(cur)&#123; f = true; break; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 签到签到 I. Balls 题意 给定 \(n\) 个盒子，每个盒子里最多有 \(3\) 个球。 定义操作为等概率选一个盒子（包括空的），并取出一个球。 给定每个盒子内的球数，输出将所有球取出的数学期望。 思路 首先，我们来考虑 \(4\) 维 dp，其中 \(dp[i][j][k][p]\) 代表还剩 \(0, 1, 2, 3\) 个球分别对应的盒子个数 \(i, j, k, p\) 该状态的数学期望。 该状态可由下面的子状态转移得到： 从一个包含 \(3\) 个球的盒子中取出一个球，对应期望为 \(\frac{p}{n}dp[i][j][k + 1][p - 1]\)； 从一个包含 \(2\) 个球的盒子中取出一个球，对应期望为 \(\frac{k}{n}dp[i][j + 1][k - 1][p]\)； 从一个包含 \(1\) 个球的盒子中取出一个球，对应期望为 \(\frac{j}{n}dp[i + 1][j - 1][k][p]\)； 从一个包含 \(0\) 个球的盒子中取出一个球，对应期望为 \(\frac{i}{n}dp[i][j][k][p]\)； 加上自己可作为单独的一个状态的期望 \(1\)，最后整理得到式子： \(dp[i][j][k][p] = \frac{n}{j + k + p} + \frac{j}{j + k + p}dp[i + 1][j - 1][k][p] + \frac{k}{j + k + p}dp[i][j + 1][k - 1][p] + \frac{k}{j + k + p}dp[i][j][k + 1][p - 1]\) 有趣的是，\(i + j + k + p = n\)，因此我们可以拿掉一维。 最后得到状态转移方程： \(dp[i][j][k] = \frac{n}{i + j + k} + \frac{i}{i + j + k}dp[i - 1][j][k] + \frac{j}{i + j + k}dp[i + 1][j - 1][k] + \frac{k}{i + j + k}dp[i][j + 1][k - 1]\) 时间复杂度：\(O(n ^ 3)\) 对应AC代码 #include&lt;bits/stdc++.h> #define int long long using namespace std; double f[305][305][305]; int a[5], n; signed main() &#123; cin >> n; for(int i = 1, x; i &lt;= n; i++) cin >> x, a[x]++; for(int k = 0; k &lt;= n; k++) &#123; for(int j = 0; j &lt;= n; j++) &#123; for(int i = 0; i &lt;= n; i++) &#123; if(i || j || k) &#123; if(i) f[i][j][k] += f[i - 1][j][k] * i / (i + j + k); if(j) f[i][j][k] += f[i + 1][j - 1][k] * j / (i + j + k); if(k) f[i][j][k] += f[i][j + 1][k - 1] * k / (i + j + k); f[i][j][k] += 1.0 * n / (i + j + k); &#125; &#125; &#125; &#125; cout &lt;&lt; setprecision(10); cout &lt;&lt; fixed &lt;&lt; (f[a[1]][a[2]][a[3]]); return 0; &#125; 自己写的dp状态重复了（也就是以一种递归的方式正推），十分头大于是找了一篇洛谷的题解研究了一波（（ J. Wish You Can Have Fun Today 题意 输出 "Wish We Can Have Fun Today." 思路 如题，别打错。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; cout &lt;&lt; "Wish We Can Have Fun Today.\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 有人在比赛的刚开始把这题交错位置了，我不说是谁（ K. Chessboard City 题意 给定一个由 \(n\) 个横向街道和 \(m\) 个纵向街道组成的矩形城市，定义一条横向或纵向的街道只能有一个标记，只能标记在十字路口上。 给定标记总数 \(k\)，输出方案数。 思路 排列组合的签到题。 先从 \(n\) 个横向街道里选择 \(k\) 个街道，不考虑顺序，再从 \(m\) 个纵向街道里选择 \(k\) 个街道，考虑顺序，最后取模即可。 也就是说，答案是 \(C^k_nA^k_m\)。 注意需要线性求逆元哦，估计就卡死在这里了吧。 时间复杂度：看你怎么预处理 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 1e7 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; int fact[N], inv[N], fact_inv[N]; int qp(int a, int b) &#123; int res = 1; while (b > 0) &#123; if (b &amp; 1) res = (res * a) % mod; a = (a * a) % mod; b >>= 1; &#125; return res; &#125; void init()&#123; fact[0] = inv[0] = fact_inv[0] = fact[1] = inv[1] = fact_inv[1] = 1; for(int i=2;i&lt;=1e7;i++) &#123; fact[i] = fact[i - 1] * i % mod; inv[i] = inv[mod % i] % mod * (mod - mod / i) % mod; fact_inv[i] = fact_inv[i - 1] * inv[i] % mod; &#125; &#125; int C(int n, int m)&#123; return fact[n] * fact_inv[n - m] % mod * fact_inv[m] % mod; &#125; int A(int n, int m)&#123; return fact[n] * fact_inv[n - m] % mod; &#125; void solve() &#123; int n, m, k; cin >> n >> m >> k; cout &lt;&lt; C(n, k) * A(m, k) % mod &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 签到签到 L. Game 题意 给定 \(n\) 个商店，每个商店将会在 \(0.5, 1.5, 2.5, \ldots\) 时刻售出一份库存游戏。 给定家到每个商店需要的时间，以及每个商店的库存，输出买到游戏的最短时刻，以及对应的商店的编号（有多个满足条件输出全部）。 思路 首先，如果到达时间大于库存量，那么到的时候就卖光了。 其次，我们直接暴力枚举找出最小值以及对应的商店即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 1e7 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; int mn = inf; set&lt;int> ans; for(int i=0;i&lt;n;i++)&#123; int a, b; cin >> a >> b; if(a > b) continue; if(a &lt; mn)&#123; mn = a, ans.clear(), ans.emplace(i + 1); &#125;else if(a == mn) ans.emplace(i + 1); &#125; if(mn == inf)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; cout &lt;&lt; mn &lt;&lt; '\n'; for(auto e: ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 居然没看到反面有题哈哈哈哈（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 874 Div. 3</title>
    <url>/blog/posts/1575178804/</url>
    <content><![CDATA[Contestant'. Rank 847. Rating +31(+81 -50). 又一次成为痛苦号（ A. Musical Puzzle 题意 给定一个字符串，输出所有相邻两个字符组成的不同字符串的个数。 思路 如题，用 \(map\) 即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7; void solve()&#123; int n; cin >> n; string s; cin >> s; map&lt;string, int> cnt; for(int i=0;i&lt;n - 1;i++)&#123; cnt[to_string(s[i]) + s[i + 1]] ++; &#125; cout &lt;&lt; cnt.size() &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 题目看半天才看懂，淦 B. Restore the Weather 题意 给定 \(n\) 天的实际温度和预估温度，其中，实际温度按天升序给出，预估温度打乱顺序后给出。 给定整数 \(k\)，满足每一天的实际温度和预估温度的差的绝对值不超过 \(k\)，输出任意一种满足条件的预估温度的排列。 其中，满足一定有解。 思路 \(k\) 是没有用的。 为何呢？因为满足一定有解，我们升序排序后，依次配对即可，这样就可以让每天的差值最小。 注意配对的时候下标变化。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7; void solve()&#123; int n, k; cin >> n >> k; vector&lt;pii> a(n); vector&lt;int> b(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i].fs; a[i].sc = i; &#125; for(int i=0;i&lt;n;i++) cin >> b[i]; sort(all(a)), sort(all(b)); vector&lt;int> w(n); for(int i=0;i&lt;n;i++) w[a[i].sc] = i; for(int i=0;i&lt;n;i++)&#123; cout &lt;&lt; b[w[i]] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 注意下标的变换，不要绕晕（ C. Vlad Building Beautiful Array 题意 给定一个序列 \(a\)，定义序列 \(b\) 中 \(b_i\) 为 \(a_i\) 和 \(a_i - a_j\) 中任选其一，其中 \(j \in [1, n]\) 可任意选择。 输出能否构造一个奇偶性相同的正整数序列 \(b\)。 思路 首先，既然要满足所有元素都是正整数，那么我们升序排序一下。 那么，对于 \(a_i - a_j\)，\(j \in [1, i - 1]\)。 考虑用 \(a_1\) 作为 \(b_1\)，那么如果 \(a_1\) 是奇数，我们一定可以将剩余不是奇数的 \(a_i\) 变为奇数。 如果 \(a_1\) 是偶数，那么其他元素都不可以是奇数，因为我们没办法改变 \(a_1\) 的奇偶性，而奇数减偶数还是奇数。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(all(a)); for(int i=1;i&lt;n;i++)&#123; if(a[i] % 2 != a[0] % 2 &amp;&amp; (a[i] - a[0]) % 2 != a[0] % 2)&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 搓题解的时候才发现下标居然打错了，还没被fst((( D. Flipper 题意 给定一个序列 \(a\)，定义操作为选定一个区间 \([l, r]\)，其中 \(1 \leq l \leq r \leq n\)，将整个区间翻转，并将剩余两侧的元素换个位置。 输出操作后最大字典序的序列。 思路 首先，不难发现的是，第一个元素在操作后一定不会在第一个位置，除非只有一个元素。 考虑到字典序的贪心性：如果某一位的两个元素能判定大小，后面的元素都不用考虑。 那么，我们就希望尽可能将最大的元素放在第一位。 由上分析，我们从第二个元素开始，找出最大的元素，并从这个元素开始，将之后的元素全都放到答案的开头。 如上，比对 \(2\ 3\ 1 \ 5\ 4\)，\(5\ 4\) 将会放在答案的开头。 其次，区间内一定有一个元素，那么最大的元素的前一个元素一定会在区间中，比如说上述例子的 \(1\) 一定包含在区间中。 接下来我们来考虑左端点的选择： 我们从最大的元素前面的第 \(2\) 个元素开始向前遍历，不难发现我们会按照这个倒序的顺序继续将元素放入答案中，而剩余的元素是按原顺序从序列的开头开始放入的。 因此，我们只需比较当前遍历到的元素是否大于序列中的第一个元素，如果小于，因为我们需要把大的元素放入答案，所以区间就不会覆盖这个元素，我们也就确定了所需的区间。 形象地说，如果剩余的序列是 \(4, 5, 1, 9, 8\)，因为 \(8 &gt; 4, 9 &gt; 4, 1 &lt; 4\)，所以我们选择 \(9, 8\) 作为区间翻转，\(4, 5, 1\) 按顺序放入，得到 \(8, 9, 4, 5, 1\)。 由上，我们会发现第二个样例过不去。 为何呢？因为区间右端点可以是 \(n\)，那么可以等效于将区间内的元素翻转并将前面剩余的拼到后面。 那么，如果最大值在最后一个元素，显然我们会出现两个选择： 区间右端点为 \(n\)； 区间右端点为 \(n - 1\) 也就是说，第二个样例对应的选择是第一个，此时就出现了 \(3 &lt; 4\) 的比较，从而得到了答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); int mx = 1; for(int i=0;i&lt;n;i++) &#123; cin >> a[i]; if(i > 0 &amp;&amp; a[i] > a[mx]) mx = i; &#125; for(int i=mx;i&lt;n;i++) cout &lt;&lt; a[i] &lt;&lt; ' '; int dist = mx - 1 - (mx == n - 1 ? 0 : 1); for(;dist>=0;dist--)&#123; if(a[dist] &lt; a[0]) break; &#125; dist = max(dist, 0ll); for(int i=mx-1;i>dist;i--) cout &lt;&lt; a[i] &lt;&lt; ' '; for(int i=0;i&lt;=dist;i++) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; WA on 1. E. Round Dance 题意 给定 \(n\) 个人，每个人的左右分别有一个邻居（可以是同一个邻居）。每个人只记得自己的一个邻居，并只能和自己的邻居一起跳舞。 令两个跳舞的人之间连一条边，那么如果出现了环，就视为一个 "Round Dance"。 输出 "Round Dance" 的最小和最大个数。 思路 我们将每个人记得的那个邻居之间连一个无向边，构成一个不完全联通的无向图，那么我们可以得到几个连通块。 对照题给条件，既然一个人只能有两个邻居，那么很明显，连通块要么是一整个环，要么是只含有 由两个元素组成的环 的基环树。 如果连通块为一整个环，那么显然这个环中每个人的邻居都是唯一确定的，肯定只能单独作为一个 "Round Dance"。 如果为一个基环树，那么我们一定可以找到一个只确定了一个邻居的人，并把多出的边和他连起来；我们也可以和其他的基环树相连，构成一条链。 因此，最小值就是整环的个数 \(+1\) 并与最大值取最小值，最大值就是连通块的个数。 为了方便遍历，在计算最小值的时候，不妨建一个有向图。 p.s. 这题可以用并查集完成。 时间复杂度：\(O(m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;set&lt;int>> e1(n + 1, set&lt;int>()), e2(n + 1, set&lt;int>()); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; e1[i].emplace(cur); e2[i].emplace(cur); e2[cur].emplace(i); &#125; int mn = 0, mx = 0; vector&lt;bool> st1(n + 1); auto dfs1 = [&amp;](auto self, int start, int x, int p, int step) -> bool&#123; bool res = false; for(auto t : e1[x])&#123; if(t == p) continue; if(st1[t])&#123; if(t == start &amp;&amp; step > 2) res = true; continue; &#125; st1[t] = true; if(self(self, start, t, x, step + 1)) res = true; &#125; return res; &#125;; for(int i=1;i&lt;=n;i++)&#123; if(st1[i]) continue; st1[i] = true; if(dfs1(dfs1, i, i, -1, 1)) mn ++; &#125; vector&lt;bool> st2(n + 1); auto dfs2 = [&amp;](auto self, int x, int p) -> void&#123; for(auto t : e2[x])&#123; if(t == p || st2[t]) continue; st2[t] = true; self(self, t, x); &#125; &#125;; for(int i=1;i&lt;=n;i++)&#123; if(st2[i]) continue; st2[i] = true; dfs2(dfs2, i, -1); mx ++; &#125; cout &lt;&lt; mn + (mn == mx ? 0 : 1) &lt;&lt; ' ' &lt;&lt; mx &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 好久没有出图论题了（ E. Ira and Flamenco 题意 给定一个多重集，以及一个整数 \(m\)，输出从多重集中取出 \(m\) 个不同的元素且任意两个元素的差的绝对值都小于 \(m\) 的方案数。 思路 首先，要满足差值的绝对值小于 \(m\)，我们就需要满足最大值和最小值的差小于 \(m\)。 因此，我们不妨遍历最左边的元素，并以这个元素确定当前能取的元素的范围，然后用组合数求解即可。 当然，这里需要取不同的元素，我们可以用下面的结论： 从一个含 \(n\) 个不同元素的多重集中取 \(m\) 个不同元素的组合数，可以看作从 \(n\) 个不同元素中取 \(m\) 个元素的组合数，再乘以每个元素出现的次数的乘积，即：\(\binom{n}{m} \times \prod_{i=1}^{n}a_i\) 。 对于范围的确定，我们既可以用滑动窗口，也可以用二分。 组合数需要 \(O(1)\) 计算，因而需要预处理。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; int fact[N], fact_inv[N]; int qp(int a, int b) &#123; int res = 1; while (b > 0) &#123; if (b &amp; 1) res = (res * a) % mod; a = (a * a) % mod; b >>= 1; &#125; return res; &#125; int inv(int n) &#123; return qp(n, mod - 2); &#125; int C(int n, int m)&#123; return (fact[n] * fact_inv[n - m] % mod) * fact_inv[m] % mod; &#125; void init()&#123; fact[0] = fact_inv[0] = 1; for(int i=1;i&lt;=2e5;i++)&#123; fact[i] = fact[i - 1] * i % mod; fact_inv[i] = inv(fact[i]); &#125; &#125; void solve()&#123; int n, m; cin >> n >> m; vector&lt;int> a(n + 1, inf); map&lt;int, int> cnt; for(int i=0;i&lt;n;i++) cin >> a[i], cnt[a[i]] ++; sort(all(a)); a.resize(n = unique(all(a)) - a.begin()); vector&lt;int> prod(n); prod[0] = cnt[a[0]]; for(int i=1;i&lt;n;i++) prod[i] = prod[i - 1] * cnt[a[i]] % mod; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int k = lower_bound(all(a), a[i] + m) - a.begin() - 1; if(k - i &lt; m - 1) continue; ans = (ans + cnt[a[i]] * C(k - i, m - 1) % mod * prod[k] % mod * inv(prod[i]) % mod) % mod; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 这个结论有点抽象 G. Ksyusha and Chinchilla 题意 给定一棵树，将其切割为若干个 三个元素组成的链（如下图），输出切割方案，如果无法切割输出 \(-1\)。 思路 首先，既然要让切割尽可能方便，我们肯定会去切割掉连接点尽可能少的边。 因此，我们不妨从叶节点开始向上遍历，找到含有三个元素的父节点，并砍掉父节点上面的边。 这个过程可以用树型 \(dp\) 实现。 具体来说，我们从任意一个顶点开始 \(dfs\)，在 \(dp\) 的过程中，传递需要从哪条边到达这个点。 那么，如果出现值为 \(3\) 的情况，我们就把传递过来的这条边砍掉，并把这个点的 \(dp\) 值改为 \(0\)。 因而，只要出现值大于 \(3\) 的情况，我们就割不了了。 当然，我们可以一开始预判一下点数是否是 \(3\) 的倍数，不然肯定有多出来的点。 时间复杂度：\(O(n + m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;vector&lt;pii>> e(n + 1); for(int i=1;i&lt;n;i++)&#123; int u, v; cin >> u >> v; e[u].pb(v, i), e[v].pb(u, i); &#125; if(n % 3 != 0)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; vector&lt;bool> st(n + 1); vector&lt;int > dp(n + 1); bool f = true; set&lt;int> ans; auto dfs = [&amp;](auto self, int x, int p, int r) -> void&#123; dp[x] = 1; for(auto [t, id] : e[x])&#123; if(t == p || st[t]) continue; st[t] = true; self(self, t, x, id); dp[x] += dp[t]; &#125; if(dp[x] > 3) f = false; else if(dp[x] == 3 &amp;&amp; r != -1)&#123; ans.emplace(r); dp[x] = 0; &#125; &#125;; st[1] = true; dfs(dfs, 1, -1, -1); if(!f)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto x : ans) cout &lt;&lt; x &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 这题怎么比上一题简单多了（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>LitCTF - Prime</title>
    <url>/blog/posts/1159249413/</url>
    <content><![CDATA[Prime 题意 给定一个数 \(a\)，按照算术基本定理分解后给出指数序列，输出最小的 \(n\)，满足 \(n! \bmod a = 0\)。 思路 首先，指数序列的长度很小，不妨直接打表（不打表的话无脑线性筛筛一下即可）。 其次，既然需要被 \(p\) 整除，那么阶乘中就需要有对应数量的因子。 举个例子，如果 \(p\) 的质因子 \(7\) 的指数为 \(4\)，那么阶乘中就最好有 \(1 \times 7, 2 \times 7, 3 \times 7, 4 \times 7\)，也就是说，我们期望 \(n\) 至少为 \(28\)。 想到这里，数据量比较特殊的时候，底数和指数乘积的最大值就是答案。 那么，如果指数大于等于底数呢？就像上述例子，出现 \(7 \times 7\) 的时候，我们需要的 \(7\) 的个数就小于等于指数的大小了，因此我们不能直接取底数和指数的乘积。 这边有两个思路： 数位 \(dp\) 线性预处理； 设底数为 \(x\)，指数为 \(p\)，对于所需的最大 \(x \times p\)，二分 \(p\)。 本题数据量特别友好，我们直接二分就行。 我们在 \([1, p]\) 内进行二分。对于 \(mid\)，我们计算 \(i \in [1, mid], i \times p\) 中 \(p\) 因子的总数： 总数是什么呢？观察一下可以发现，它就是以 \(mid\) 为首项，\(\frac{1}{x}\) 为公比的等比数列的前 \(n\) 项和。 因而我们可以解得答案。 值得一提的是，上述计算方式和进制有关联，这为数位 \(dp\) 提供了思路。 时间复杂度：\(O(n \log m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; vector&lt;int> pri = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541&#125;; void solve()&#123; int m; cin >> m; int ans = 1; auto check = [&amp;](int x, int p, int mid) -> bool &#123; int ans = 0; for (int i = 1; i &lt;= mid; i *= x) ans += (mid / i); return ans >= p; &#125;; for(int t=0;t&lt;m;t++) &#123; int x = pri[t], p; cin >> p; int l = 1, r = p, mid; while(l &lt; r)&#123; mid = (l + r) >> 1; if(check(x, p, mid)) r = mid; else l = mid + 1; &#125; ans = max(ans, x * r); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 更强的数据可以看这里：#530. 「LibreOJ β Round #5」最小倍数 - 题目 - LibreOJ (loj.ac)]]></content>
      <categories>
        <category>类算法竞赛题解</category>
      </categories>
      <tags>
        <tag>LitCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 818 Div. 2</title>
    <url>/blog/posts/724238676/</url>
    <content><![CDATA[Practice. A. Madoka and Strange Thoughts 题意 给定整数 \(n\)，输出二元组 \((a, b)\) 的个数，满足 \(\frac{\operatorname{lcm}(a, b)}{\operatorname{gcd}(a, b)} \leq 3\)。 思路 我们不妨打个表： n cnt 1 1 2 3 3 3 4 3 5 1 6 5 7 1 8 3 9 3 10 3 11 1 12 5 13 1 ... ... 不难发现出现了循环。 更具体地说，令 \(sum = \{0, 1, 4, 7, 10, 11\}\)，那么答案就是 \(16(\frac{n}{6}) + sum[n \% 6]\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> md = &#123;0, 1, 4, 7, 10, 11&#125;; cout &lt;&lt; 16 * (n / 6) + md[n % 6] &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 狠狠地打表 B. Madoka and Underground Competitions 题意 给定一个由 "." 和 "X" 组成的矩阵的大小 \(n \times n\)，矩阵内横向和竖向每 \(k\) 个位置内至少有一个 \(X\)，以及给定的一个坐标 \((r, c)\) 一定为 \(X\)。 输出一个方案，使 \(X\) 的个数最少。 思路 既然要最少，我们直接空 \(k - 1\) 个放一个 \(X\) 即可。 那么我们直接从给定坐标开始一行一行放即可。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, k, r, c; cin >> n >> k >> r >> c; vector&lt;vector&lt;bool>> ans(n + 1, vector&lt;bool>(n + 1)); for(int x = r, y = c; y >= 1; y --, x ++)&#123; for(int p = x; p >= 1; p -= k)&#123; if(p > n) continue; ans[p][y] = true; &#125; for(int p = x; p &lt;= n; p += k)&#123; if(p &lt; 0) continue; ans[p][y] = true; &#125; &#125; for(int x = r, y = c; y &lt;= n; y ++, x --)&#123; for(int p = x; p >= 1; p -= k)&#123; if(p > n) continue; ans[p][y] = true; &#125; for(int p = x; p &lt;= n; p += k)&#123; if(p &lt; 0) continue; ans[p][y] = true; &#125; &#125; for(int i = 1; i &lt;= n; i ++)&#123; for(int j = 1; j &lt;= n; j ++) cout &lt;&lt; (ans[i][j] ? 'X' : '.'); cout &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 喜报，RTE! C. Madoka and Formal Statement 题意 给定两个序列 \(a, b\)，定义一次操作为选定一个数 \(a_i\)，满足 \(a_i \leq a_{(i \% n) + 1}\)，并将 \(a_i\) 加上 \(1\)。 输出是否可以进行若干次操作，将 \(a\) 变为 \(b\)。 思路 观察可得下面两个条件： \(b_i \geq a_i\)； 如果 \(b_i\) 变大了，那么它的后一个数不能比这个数 \(-1\) 小。 满足条件即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n + 1), b(n + 1); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;n;i++) cin >> b[i]; a[n] = a[0], b[n] = b[0]; for(int i=0;i&lt;n;i++) &#123; if(a[i] > b[i] || (b[i] - b[i + 1] > 1 &amp;&amp; a[i] != b[i]))&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜即可乱猜即可]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 819 Div. 1 + 2</title>
    <url>/blog/posts/2622508116/</url>
    <content><![CDATA[Practice. A. Mainak and Array 题意 给定一个序列 \(a\)，定义操作为选定一个连续字符列，并将其旋转任意次，输出恰好进行一次操作后 \(a_n - a_1\) 的最大值。 思路 首先，如果选定整个序列作为旋转序列，那么显然对于两个相邻的数，前者减后者就可以作为执行操作后的 \(a_n - a_1\)，取最大值即可。 其次，我们可以固定头或者尾，如果固定头，我们就可以旋转除头以外的其他元素，将最大值旋转到 \(a_n\)，反之同理，最后再取最大值即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); int mn = inf, mx = -inf; for(int i=0;i&lt;n;i++) &#123; cin >> a[i]; mn = min(mn, a[i]); mx = max(mx, a[i]); &#125; int ans = max(a[n - 1] - mn, mx - a[0]); for(int i=0;i&lt;n;i++) &#123; int pre = (i + n - 1) % n; ans = max(ans, a[pre] - a[i]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 我测，怎么错这么多 B. Mainak and Interesting Sequence 题意 定义若一个序列满足对于任意 \(a_i\)，严格小于 \(a_i\) 的所有数的异或值都为 \(0\)，那么这个序列是有趣的。 现在，给定序列的总和以及序列的长度，构造一个序列满足序列有趣。 思路 首先，两个相同的数异或以后为 \(0\)，那么我们不妨构造一个序列，满足包含偶数个较小的数和若干个较大的数。 或者更简单地，我们直接塞上偶数个 \(1\) 即可。 那么，我们对长度进行分讨，如果长度为奇数，那么我们直接塞上 \(n - 1\) 个 \(1\)，最后放上 \(m - n + 1\) 即可； 如果长度为偶数，那么我们在前面塞上 \(n - 2\) 个 \(1\)，最后放上两个 \(\frac{m - n + 2}{2}\) 即可。 当然，后者需要我们确保总和也是偶数。 有趣的是，可以证明，当长度为奇数，总和为偶数的时候是无解的。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, m; cin >> n >> m; if(n > m || (n % 2 == 0 &amp;&amp; m % 2 == 1))&#123; cout &lt;&lt; "No\n"; return; &#125; cout &lt;&lt; "Yes\n"; if(n % 2 == 1)&#123; for(int i=0;i&lt;n-1;i++) cout &lt;&lt; 1 &lt;&lt; ' '; cout &lt;&lt; m - n + 1 &lt;&lt; '\n'; &#125;else&#123; for(int i=0;i&lt;n-2;i++) cout &lt;&lt; 1 &lt;&lt; ' '; cout &lt;&lt; (m - n + 2) / 2 &lt;&lt; ' ' &lt;&lt; (m - n + 2) / 2 &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜即可（但我怎么猜错那么多次啊啊啊啊 C. Jatayu's Balanced Bracket Sequence 题意 题目绕死了，直接给出简化版： 给定一个满足语法规则的括号字符串，输出不同的括号的个数。 此处不同代表其开始符 "\((\)" 前面没有 "\()\)"。 思路 如题，遍历即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; string s; cin >> n >> s; int now = 0; for(int i=0;i&lt;s.size();i++)&#123; if(s[i] == '(' &amp;&amp; (i == 0 || s[i - 1] == '(')) now ++; &#125; cout &lt;&lt; now &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 你就说你有没有在考阅读理解罢（半恼]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 135</title>
    <url>/blog/posts/1644830366/</url>
    <content><![CDATA[Practice. A. Colored Balls: Revisited 题意 给定 \(n\) 个染有颜色的球，定义操作为选定两个不同颜色的球并将两个球拿走。 在满足总和为奇数的情况下，输出只剩下一种颜色的球后，球的颜色编号。 思路 显然，我们将数量小的和数量次小的球拿走，最后肯定会剩下数量最多的那个颜色。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;pii> cnt(n); for(int i=0;i&lt;n;i++) &#123; cin >> cnt[i].fs; cnt[i].sc = i + 1; &#125; sort(all(cnt)); cout &lt;&lt; cnt[n - 1].sc &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 很蠢 B. Best Permutation 题意 对于一个排列 \(p\)，定义它的值的计算方式如下： 令 \(x = 0\)； 枚举 \(p_i\)，如果 \(x &lt; p_i\)，那么 \(x = x + p_1\)，否则 \(x = 0\)。 最后，\(x\) 即为 \(p\) 的值 现在，给定排列的长度，构造一个值最大的排列并输出。 思路 显然，我们不难发现，最后的 \(x\) 一定为 \(n + n - 1\)，我们找不出其他排列满足这个条件。 那么，我们来考虑如何构造： 我们将 \(n - 1, n\) 放在序列的最后，那么如果剩余的数的个数为偶数，我们直接按顺序放入 \(i, i - 1\) 即可，这样即可每隔两个数清空 \(x\)。 如果个数为奇数，那么我们不妨塞上 \(1, 2, 3\)，然后继续放即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; if(n == 4) cout &lt;&lt; "2 1 3 4\n"; else&#123; if(n % 2 == 1) cout &lt;&lt; "1 2 3 "; for(int i=n-2;i>=(n % 2 == 1 ? 4 : 1);i--) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; n - 1 &lt;&lt; ' ' &lt;&lt; n &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 主打一个差点看错题 C. Digital Logarithm 题意 定义 \(f(x)\) 等于 十进制下 \(x\) 所有位数之和。 给定两个序列 \(a, b\)，定义一次操作为选定任意 \(a_i\) 并将其赋值为 \(f(a_i)\)，或选定任意 \(b_i\) 并将其赋值为 \(f(b_i)\)。 输出最小的操作数，使两个序列升序排序后相等。 思路 我们可以用优先队列实现。 我们先将所有 \(a_i, b_i\) 分别放入两个优先队列中，然后枚举 \(a, b\) 中的头元素。 如果头元素相等，那么把这对数取出，否则，我们对较大的头元素执行一次操作，然后继续遍历，最后一定可以得到答案。 不难证明这样操作得到的答案就是最小的。 时间复杂度：小于\(O(3n \log (3n))\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; priority_queue&lt;int> a, b; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; a.emplace(cur); &#125; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; b.emplace(cur); &#125; int ans = 0; while(!a.empty())&#123; if(a.top() == b.top())&#123; a.pop(); b.pop(); continue; &#125; ans ++; if(a.top() > b.top())&#123; a.emplace(to_string(a.top()).size()); a.pop(); &#125;else&#123; b.emplace(to_string(b.top()).size()); b.pop(); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 我写的更模拟（ D. Letter Picking 题意 给定一个字符串，以及两个玩家 \(Alice, Bob\)。 \(Alice\) 先手。每次操作中，玩家可以选择字符串的第一个或最后一个字符，将其取出并拼接到自己的字符串的前面。 两个人足够聪明，输出最后字典序最小的玩家。 思路 我们不妨换个角度考虑这题： 如果我们从最后的状态向前推，那么就等价于我们将拿出的字符拼接到两个选手的字符串后面。 这就好办了，只要前面没有出现平局，那么后面无论怎么操作都无法改变胜负。 因而，我们考虑从小区间递推到大区间的思路，也就是区间 \(dp\)。 我们定义 \(dp[i][j]\) 为 \([i, j]\) 区间内的胜负情况，\(-1\) 为 \(Alice\) 赢，\(0\) 为平局，\(1\) 为 \(Bob\) 赢，那么 \(dp[0][n]\) 就是答案。 那么，我们只需分讨递推即可。 对于 \(A\) 的不同选择，我们分别取最小值。 对于 \(B\) 的不同选择，我们分别取最大值。 然后，如果前一个状态是平局，我们就判断当前的胜负，否则我们就从上一个状态递推得到答案。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; int calc(char a, char b)&#123; return a == b ? 0 : (a > b ? 1 : -1); &#125; void solve()&#123; string s; cin >> s; int n = s.size(); vector&lt;vector&lt;int>> dp(n + 1, vector&lt;int>(n + 1)); for(int len=2;len&lt;=n;len+=2)&#123; for(int l=0;l+len&lt;=n;l++)&#123; int r = l + len; dp[l][r] = 1; //Alice choose the left int now = -1; if(dp[l + 1][r - 1] != 0) now = max(now, dp[l + 1][r - 1]); else now = max(now, calc(s[l], s[r - 1])); if(dp[l + 2][r] != 0) now = max(now, dp[l + 2][r]); else now = max(now, calc(s[l], s[l + 1])); dp[l][r] = min(dp[l][r], now); //Alice choose the right now = -1; if(dp[l + 1][r - 1] != 0) now = max(now, dp[l + 1][r - 1]); else now = max(now, calc(s[r - 1], s[l])); if(dp[l][r - 2] != 0) now = max(now, dp[l][r - 2]); else now = max(now, calc(s[r - 1], s[r - 2])); dp[l][r] = min(dp[l][r], now); &#125; &#125; cout &lt;&lt; (dp[0][n] == 0 ? "Draw\n" : (dp[0][n] == 1 ? "Bob\n" : "Alice\n")); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 还真没想到倒着搞，该加训了（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 873 Div. 2</title>
    <url>/blog/posts/4014169129/</url>
    <content><![CDATA[Contestant'. Rank 1390. Rating +9(+109 -100). A. Divisible Array 题意 给定整数 \(n\)，构造一个长度为 \(n\) 的数组 \(a\)，满足 \(a_i \bmod i = 0\)，且总和 \(sum\) 满足 \(sum \bmod n = 0\)。 思路 构造一个 \(2, 4, \ldots, 2n\) 的数组，\(sum = \frac{(2 + 2n)n}{2} = n(n + 1)\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10; void solve()&#123; int n; cin >> n; for(int i=1;i&lt;=n;i++) cout &lt;&lt; i * 2 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 倒也有其他思路，这个最好写 B. Permutation Swap 题意 给定一个未排序的排列，输出最大的 \(k\)，满足按照 "\(a_i\) 和 \(a_{i + k}\)" 之间可交换的方式进行排序后，可将排列升序。 思路 如果一个数 \(x\) 位于 \(y\) 位置，他想要到 \(x\) 位置，那么 \(abs(y - x) \bmod k = 0\)。 那么，如果所有数都要满足这个条件，我们只需求 \(gcd\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10; void solve()&#123; int n; cin >> n; int ans = -1; for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; cur = abs(cur - i); if(cur == 0) continue; if(ans == -1) ans = cur; else ans = gcd(ans, cur); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 瞎猜就完事了 C. Counting Orders 题意 给定两个长度相等的序列 \(a, b\)，其中 \(a\) 中无重复元素，输出满足所有 \(a_i\) 均大于 \(b_i\) 的 \(a\) 的所有排列的个数。 思路 我们将 \(a, b\) 升序排序，那么，对于每一个 \(a_i\)，我们找出 \(b\) 中满足 \(a_i &gt; b_i\) 的个数 \(cnt\)，这个个数就是 \(a_i\) 能放的位置。 因而，答案就是 \(cnt_1 \cdot(cnt_2 - 1) \cdot(cnt_3 - 2) \cdots (cnt_n - (n - 1))\) （考虑前面几个数已经放了，而且前几个数能放的区间一定在当前能放的区间里面）。 找位置可以线性也可以二分。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7; void solve()&#123; int n; cin >> n; vector&lt;int> a(n), b(n); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;n;i++) cin >> b[i]; sort(all(a)), sort(all(b)); int ans = 0, cnt = 0; for(int i=n-1;i>=0;i--)&#123; int pos = n - (upper_bound(all(a), b[i]) - a.begin()); if(pos &lt;= cnt)&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; if(ans == 0) ans = pos - cnt; else ans = (ans * (pos - cnt)) % mod; cnt ++; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜即可 D1. Range Sorting (Easy Version) 题意 给定一个序列 \(p\)，定义操作为选定一个区间 \([l, r]\)，并将里面的数排序，代价为 \(r - l\)。 输出对于序列的 所有连续子序列，任意次操作后，使其升序所需的最小代价的总和。 思路 首先，我们固定子序列的头，然后依次枚举尾。 不难发现，如果一段区间不需要参与排序，那么他一定是单调的，并且，除去这段区间后，没有比区间内的数小的数。 当然，这个区间内也不能包含比剩余数小的数。 我们维护一个单调栈，在弹出元素的时候，将元素和当前元素取最大值，最后放入栈中的是这个最大值。 这样即可满足上述的所有条件（比较抽象）。 取最大值是为了满足最后一个条件，而单调栈的维护满足了剩下的条件。 对于一段枚举的区间 \([i, j]\)，最小代价就是 \(j - i - size\)，其中 \(size\) 是单调栈的大小。 时间复杂度：\(O(n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 2e5 + 10, mod = 1e9 + 7; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; int ans = 0; for(int i=0;i&lt;n;i++)&#123; stack&lt;int> st; for(int j=i;j&lt;n;j++)&#123; int mx = a[j]; while(!st.empty() &amp;&amp; a[j] &lt; st.top())&#123; mx = max(mx, st.top()), st.pop(); &#125; st.emplace(mx); ans += j - i + 1 - st.size(); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 太妙了！]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 148</title>
    <url>/blog/posts/1408955620/</url>
    <content><![CDATA[Contestant'. Rank 1580. Rating +23(+173 -150). A. New Palindrome 题意 给定一个回文串，输出是否可以将其重新排序，变成另一个回文串。 思路 只要回文串中有两种不同的字符，且这两个字符出现次数都大于 \(1\)，那么就可以。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; string s; cin >> s; int cnt = 0; for(int i=0;i&lt;s.size();i++) if(s[i] != s[0]) cnt ++; cout &lt;&lt; (cnt >= 2 ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 什么手速题 B. Maximum Sum 题意 给定一个无重复元素的序列，定义操作为下列操作任选其一： 删除序列中最小的 两 个数； 删除序列中最大的 一 个数 输出一次操作后序列的和的最大值。 思路 枚举所有删除后的序列的和即可，至于求和，可以用前缀和。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, m; cin >> n >> m; vector&lt;int> a(n); vector&lt;int> sum(n + 1); for(int i=0;i&lt;n;i++) &#123; cin >> a[i]; &#125; sort(all(a)); for(int i=0;i&lt;n;i++) sum[i + 1] = sum[i] + a[i]; int ans = 0; for(int l=0;l&lt;=m;l++)&#123; int r = m - l; ans = max(ans, sum[n - r] - sum[2 * l]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 为什么我想着用双指针啊哈哈哈，为什么有人和我想的一样然后觉得样例错了还去问啊哈哈哈 C. Contrast Value 题意 对于一个序列 \(a\)，定义其 "对比度" 为 \(|a_1-a_2|+|a_2-a_3|+\cdots+|a_{n-1}-a_n|\)。 找出一个长度最小的 \(a\) 的子序列，使其和 \(a\) 的对比度一致，输出长度。 思路 显然，对于一段单调的区间，只有区间的头和尾对 "对比度" 有贡献，因此中间的数直接删掉即可。 或者换句话说，拐点的个数就是答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int pre; cin >> pre; int now = -1, cnt = 0; for(int i=2;i&lt;=n;i++)&#123; int cur; cin >> cur; if(cur == pre) continue; if(cur > pre &amp;&amp; now == 0)&#123; cnt ++; now = 1; &#125;else if(cur &lt; pre &amp;&amp; now == 1)&#123; cnt ++; now = 0; &#125; if(now == -1)&#123; cnt ++; now = (cur > pre ? 1 : 0); &#125; pre = cur; &#125; cout &lt;&lt; cnt + 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 怎么三道水题之后都是坐牢题啊！ImbalancedForces（迫真 D1. Red-Blue Operations (Easy Version) 题意 给定 \(n\) 个格子，给定每个格子内的数字，格子一开始都是红色的。 对于 \(k\) 次操作，定义第 \(i\) 次操作如下： 选定一个格子 按格子的颜色进行不同的操作： 如果格子是红色的，那么将格子内的元素 \(+i\)，并将该格子变为蓝色； 如果格子是蓝色的，那么将格子内的元素 \(-i\)，并将该格子变为红色 现在，对于 \(q\) 个独立询问，每个询问给定整数 \(k\)，输出恰好进行 \(k\) 次操作后，所有格子内元素的最小值 的最大值。 思路 简化问题 - 1 首先，如果 \(k\leq n\)，那么我们只需依次对没操作过的格子进行操作即可。 那么，很显然，我们对前 \(k\) 小的格子进行操作即可，且我们自然希望最小的能加上最大的数。 更具体地说，我们将格子对应的序列 \(a\) 升序排序，并将 \(k, k-1,\ldots,1\) 按顺序加到 \(a_i\) 中，最后遍历找出序列中的最小值即可。 简化问题 - 2 其次，我们来考虑 \(k &gt; n\) 的时候，多余操作的如何处理。 对于一个红色的格子，我们可以对其进行两次操作，使其 \(+i\ -(i+1) = -1\)。 那么，我们不难发现，既然这样能让两次操作后对序列的影响最小，我们就可以把 "\(-1\)" 应用到当前最大的数上。 也就是说，我们可以先循环执行 \(-1\) 的操作，直到刚好剩余 \(n\) 个操作，最后按照 \(k \leq n\) 的方法做即可。 当然，上述思路只对 \(k - n\) 是偶数的情况有效，若它为奇数，那么我们有两个选择： 多执行一次减操作 少执行一次加操作 显然，后者能产生更大的最小值。 因此，总结为：先循环执行 \(-1\) 的操作，直到刚好剩余 \(n - (k - n)\mod 2\) 个操作，最后按照 \(k \leq n\) 的方法做即可。 优化复杂度 - 1 如果 \(k\) 不大，那么我们直接用 \(\mathtt{multiset}\) 模拟即可。 但这里的 \(k\) 是 \(1e9\) 级别的，这就迫使我们去找一个 \(O(1)\) 或 \(O(logn)\) 的解法。 后者可以通过二分实现，这边不做解释。 我们不妨模拟一下 \(-1\) 操作的过程：我们找出序列的最大值，拿掉这个数，并将其 \(-1\)，然后将这个新的数塞到序列中并排序序列。 那么，不难发现，除非这个最大值等于最小值，否则无论怎么减，操作后的数一定大于等于原来的最小值。 因此，想要让最小值减小，首先我们需要将整个序列全都减到和最小值相等为止。 这样，我们再依次将每个数 \(-1\)，\(n\) 次 \(-1\) 操作后，最小值就 \(-1\) 了。 总结 考虑到 \(-1\) 操作和 按顺序加的操作 是相互独立的，我们可以先执行 按顺序加的操作。 那么，对于每次询问，我们只需先遍历序列中的所有数，将 \(a_i\) 加上 \(k - i + 1\)（如果 \(k - n\) 是奇数，那么最后一个数不加），统计出总和以及最小值。那么按照优化的思路即可 \(O(1)\) 得到答案。 以上，即可通过 \(D1\)。 时间复杂度：\(O(nq)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, q; cin >> n >> q; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(all(a)); while(q --)&#123; int k; cin >> k; int left = k - n; int mn = inf, sum = 0; for(int i=0;i&lt;n;i++) &#123; int now = (i == n - 1 &amp;&amp; left % 2 == 1) ? a[i] : a[i] + max(0ll, (k - i)); mn = min(mn, now); sum += now; &#125; if(left &lt;= 0)&#123; cout &lt;&lt; mn &lt;&lt; ' '; continue; &#125; left += left % 2; left >>= 1; cout &lt;&lt; min(mn, (sum - left) / n) &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 令人感慨，没看到 \(k\) 的范围，硬模拟 \(t\) 咯！ D2. Red-Blue Operations (Hard Version) 题意 同 \(D1\)，区别是 \(n, q\) 的数据范围更大了。 思路 前面的思路和 \(D1\) 一致。 优化复杂度 - 2 观察 \(D1\) 的代码，我们不难发现，只有统计总和以及最小值的步骤是 \(O(n)\) 的，因而我们考虑优化这个。 我们不妨构造一个 \(pre\) 数组，代表处理前 \(k\) 个数后，整个序列 的最小值。接下来我们来看看如何构造： 首先，对于 \(a_i\)，如果我们处理前 \(i\) 个数，那么，在处理之后，\(a_i\) 会 \(+1\)。 其次，对于上一次处理后的序列，本次处理等价于将前 \(i\) 个数都 \(+1\)。 那么，如果我们不考虑前 \(i\) 个数之外的其他数，前 \(i\) 个数的最小值具有递推性：\(x_i = \min(x_{i - 1} + 1, a_i + 1)\)。 考虑其他数，因为我们排过序，所以 \(a_{i + 1}\) 就是这些数中的最小值。 因此，\(pre_i = \min(x_i, a_{i + 1})\)。 \(ok\)，那么如果 \(k \leq n\)，我们就可以直接输出答案了。 如果 \(k &gt; n\) 呢？ 首先，我们不妨在递推的时候顺便统计一下序列 \(a\) 的总和 \(sum\)，那么最后的 \(sum&#39;\) 就是 \(sum\) 加上 \(k, k - 1,\ldots, k - n + 1\) 的和。 显然，我们可以用等差数列求和公式直接计算。 之前，我们预处理得到的 \(pre_n\) 就是原序列依次加上 \(n, n-1, \ldots,1\) 中的最小值，而现在我们要加上的是 \(k, k - 1,\ldots, k - n + 1\)，显然对于每个元素，加上的数的差值都是 \(n - k\)，因此现在的最小值 \(mn = pre_n + (n - k)\)。 还没有结束，如果 \(k - n\) 为奇数，那么 \(sum&#39;\) 要减去 \((n - k + 1)\)。并且，因为最大数 \(a_n\) 没有加上 \((n - k + 1)\)，所以最后 \(mn\) 还要和 \(a_n\) 取个最小值。 如上，即可线性得到答案。 时间复杂度：\(O(n + q)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, q; cin >> n >> q; vector&lt;int> a(n + 1, inf); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(all(a)); vector&lt;int> pre(n + 1); //处理前k个后序列的最小值 int pre_mn = inf, sum = 0; //前k-1个数的最小值（+1后有可能成为前k个数的最小值，需递推特判 for(int i=0;i&lt;n;i++)&#123; pre_mn = min(pre_mn + 1, a[i] + 1); pre[i + 1] = min(pre_mn, a[i + 1]); sum += a[i]; &#125; while(q --)&#123; int k; cin >> k; int left = k - n; if(left &lt;= 0)&#123; cout &lt;&lt; pre[k] &lt;&lt; ' '; continue; &#125; //从+k到+(k-n+1) int now_sum = sum + (k + left + 1) * n / 2; int mn = pre[n] + left; //+n到+1 -> +k到+(k-n+1) if(left % 2 == 1)&#123; now_sum -= (left + 1); mn = min(mn, a[n - 1]); &#125; left += left % 2; left >>= 1; cout &lt;&lt; min(mn, (now_sum - left) / n) &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 有趣的题捏]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 872 Div. 2</title>
    <url>/blog/posts/1228167069/</url>
    <content><![CDATA[Contestant'. Rank 1357. Rating +14 (+264 -250). A. LuoTianyi and the Palindrome String 题意 给定一个字符串，输出最长的非回文子串的长度。 思路 很显然，如果整个字符串是回文串，那么我们拿掉一个字符即可，长度为 \(n - 1\)； 如果不是，那么整个字符串就是非回文串，长度为 \(n\)。 当然，如果整个字符串都是由一个字母组成的，那么无法将其变为非回文，无解输出 \(-1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; string s; cin >> s; bool f = false; int n = s.size(); for(int i=1;i&lt;n;i++)&#123; if(s[0] != s[i]) f = true; &#125; if(!f)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; for(int i=0;i&lt;n/2;i++)&#123; if(s[i] != s[n - i - 1]) f = false; &#125; cout &lt;&lt; (f ? n - 1 : n) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 很签到，虽然要绕一下 B. LuoTianyi and the Table 题意 给定一个 \(n \times m\) 的矩阵，以及 \(n \times m\) 个元素组成的序列。将序列中所有元素填入矩阵中，满足下面的式子最大，并输出这个最大值： \(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}\left(\max\limits_{1 \le x \le i, 1 \le y \le j}a_{x,y}-\min\limits_{1 \le x \le i, 1 \le y \le j}a_{x,y}\right)\) 思路 思维题。 如果要让最大值减最小值的值最大，那么我们一定会用最大的值减去最小的值。 对于上述式子，我们不难发现，只要满足下面的两种情况，即为最大值： 左上角为最大值，其相邻两个元素为最小值和次小值； 左上角为最小值，其相邻两个元素为最大值和次大值 我们取两者的最大值即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, m; cin >> n >> m; vector&lt;int> a(n * m); for(int i=0;i&lt;n*m;i++) cin >> a[i]; sort(all(a)); if(n > m) swap(n, m); int ans1 = (n * (m - 1)) * (a[n * m - 1] - a[0]) + (n - 1) * (a[n * m - 1] - a[1]); int ans2 = (n * (m - 1)) * (a[n * m - 1] - a[0]) + (n - 1) * (a[n * m - 2] - a[0]); cout &lt;&lt; max(ans1, ans2) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 偏思维的题捏 C. LuoTianyi and the Show 题意 给定三种操作如下： 坐在当前最左边的人的左边，如果最左边的人左边无位置，那么坐到最右边； 坐在当前最右边的人的右边，如果最右边的人右边无位置，那么坐到最左边； 坐到指定位置 现在，给定 \(n\) 个人的操作，操作用一个数字表征，其中操作 \(1\) 为 \(-1\)，操作 \(2\) 为 \(-2\)，操作 \(3\) 为一个正整数，代表坐到该位置。 如果不可以坐，那么这个人离场。 输出按任意顺序排座后最多能坐多少人。 思路 首先，重复的正整数我们直接筛去，因为不会重叠。 那么，对于第一个数，我们有两个选择： 执行操作 \(3\)，对此我们可以标记操作 \(3\) 的所有下标，并枚举这些下标。既然我们确定了一个点，那么我们只能从这个点开始向左右拓展。 为计算方便，我们可以用 \(pre, suf\) 数组记录前 \(i\) 个数和后 \(n - i + 1\) 个数去掉操作 \(3\) 后有多少空位置。 那么， \(\min(pre[i], cnt_1) + \min(suf[i], cnt_2) + cnt_{12}\) 就是当前位置的答案。 一直执行操作 \(1\) 或操作 \(2\)，并在经过和结束后执行操作 \(3\)，那么，\(\min(\max(cnt_1, cnt_2) + cnt_{12}, m)\) 就是该选择的答案 最后，我们取最大值即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, m; cin >> n >> m; int cnt1 = 0, cnt2 = 0; vector&lt;bool> st(m + 1); int cnt = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur == -1) cnt1 ++; else if(cur == -2) cnt2 ++; else if(!st[cur]) st[cur] = true, cnt ++; &#125; vector&lt;int> pre(m + 2), suf(m + 2); for(int i=2;i&lt;=m;i++)&#123; pre[i] = pre[i - 1] + (st[i - 1] ? 0 : 1); &#125; for(int i=m-1;i>=1;i--)&#123; suf[i] = suf[i + 1] + (st[i + 1] ? 0 : 1); &#125; int ans = min(max(cnt1, cnt2) + cnt, m); for(int i=1;i&lt;=m;i++)&#123; if(st[i]) ans = max(ans, min(pre[i], cnt1) + min(suf[i], cnt2) + cnt); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 一开始想着确定两个点，想复杂了 D1. LuoTianyi and the Floating Islands (Easy Version) 题意 给定一棵无根树，给定整数 \(n, k\)，其中 \(n\) 为节点个数，\(k\) 为标记点的个数。确定标记点放置位置后，若某些点满足到所有标记点的距离之和为所有点中最小，那么这些点符合条件。输出符合条件的点的数量的期望。 本题中，\(k_{max} = 3\)。 思路 首先，\(k = 1\) 的时候很显然，标记点能确定的位置有 \(n\) 个，当标记点被确定后，距离最小的点只可能是标记点，因此期望为 \(\frac{n}{n} = 1\)。 由此，\(k = 3\) 的时候也是这样，期望为 \(1\)。 有趣的是，当 \(k\) 为奇数时，期望均为 \(1\)，此处不给出证明。 那么，我们来考虑 \(k = 2\) 的情况： 首先，\(n\) 个点中选 \(2\) 个，很明显分母是 \(C_n^2\)。 其次，如果我们 不考虑方向，那么，对于一条边，我们可以很轻松地通过 \(Dfs\) 求出其某一方向的连通块的点的个数 \(x\)。 那么，这条边就被经过了 \(x(n-x)\) 次。 这是很显然的，但有趣的是这么一求，我们的答案偏小了。 不妨对着样例一模拟一遍，我们不难发现缺少了从 \(2, 3, 4\) 节点向 \(1\) 方向的边，这恰好就是 \(C_n^2\)。 或者说，因为距离为 \(d\) 的两点间算上端点总共有 \(d + 1\) 个点，因而这么计算，起点或者终点对应的距离肯定有一个没被计算。 那么，最后的答案就是 \(\displaystyle{\frac{\sum_{i = 1}^n dp_i(n - dp_i) + C_n^2}{C_n^2}}\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pci pair&lt;char, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(),x.end() const int N = 110, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; int qp(int a, int b) &#123; int res = 1; while (b > 0) &#123; if (b &amp; 1) res = (res * a) % mod; a = (a * a) % mod; b >>= 1; &#125; return res; &#125; int inv(int n) &#123; return qp(n, mod - 2); &#125; void solve()&#123; int n, k; cin >> n >> k; vector&lt;vector&lt;int>> e(n + 1); for(int i=0;i&lt;n-1;i++)&#123; int u, v; cin >> u >> v; e[u].pb(v), e[v].pb(u); &#125; if(k % 2 == 1)&#123; cout &lt;&lt; 1 &lt;&lt; '\n'; return; &#125; vector&lt;int> dp(n + 1); auto dfs = [&amp;](auto self, int c, int p) -> void&#123; dp[c] = 1; for(auto x : e[c])&#123; if(x == p) continue; self(self, x, c); dp[c] += dp[x]; &#125; &#125;; dfs(dfs, 1, 1); int ans = 0; for(int i=1;i&lt;=n;i++) ans = (ans + (dp[i] * (n - dp[i]) % mod)) % mod; ans = (ans + n * (n - 1) / 2 % mod) % mod; ans = ans * inv(n) % mod; ans = ans * inv(n - 1) % mod; ans = ans * 2 % mod; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 太抽象了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 871 Div. 4</title>
    <url>/blog/posts/2445273141/</url>
    <content><![CDATA[Contestant'. Rank 472. Rating +58 (+408 -350). 这场没WA!!! 开心捏 A. Love Story 题意 对于字符串 "codeforces"，给定一个与其长度相等的字符串，按位遍历，输出不同位置的个数。 思路 如题，暴力即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; string s; cin >> s; string cf = "codeforces"; int cnt = 0; for(int i=0;i&lt;s.size();i++)&#123; if(s[i] != cf[i]) cnt ++; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 签到签到 B. Blank Space 题意 给定一个 \(01\) 序列，输出连续 \(0\) 长度的最大值。 思路 不妨绕一下，在开头和末尾加上 \(1\)，那么我们只需枚举 \(1\)，求出间距的最大值 \(-1\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n + 2, 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; int pre = 0, cnt = 0; for(int i=1;i&lt;=n+1;i++)&#123; if(a[i] == 1)&#123; cnt = max(cnt, i - pre - 1); pre = i; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 枚举 \(0\) 怕写错就换了个思路 C. Mr. Perfectly Fine 题意 现在有两个知识点需要修学。 给定 \(n\) 本书，每本书具有时间代价 \(m_i\)，以及对于两个知识点是否可以修学到。后者用两位二进制表示，如 \(01\) 表示可以花费 \(m_i\) 的时间来修学到知识点 \(2\)。同一个时刻只能学习一本书。 输出两个知识点均修学所需的最小时间代价。 思路 我们遍历输入，分别找出 \(10, 01, 11\) 对应的时间代价最小值 \(l, r, lr\)。 那么，\(ans = \min(l + r, lr)\)。 为了方便判断能否均修学，我们可以初始化三个变量的值为 \(inf\)，然后只需判断最后的 \(ans\) 是否大于等于 \(inf\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int l = inf, r = inf, lr = inf; for(int i=0;i&lt;n;i++)&#123; int m; string s; cin >> m >> s; if(s == "10") l = min(l, m); else if(s == "01") r = min(r, m); else if(s == "11") lr = min(lr, m); &#125; int ans = min(l + r, lr); if(ans >= inf) cout &lt;&lt; -1 &lt;&lt; '\n'; else cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 题目有点绕 D. Gold Rush 题意 给定一堆金子，金子数量为 \(n\)，定义一次操作为选定某一堆金子并将其恰好划分为 \(x, 2x\)。输出任意次操作后能否出现一堆金子的个数为 \(m\)。 思路 首先，既然能划分，那么这个数一定是 \(3\) 的倍数。 不难发现，最后的若干堆金子一定是 \(n\) 整除 \(k\) 个 \(3\) 后，再乘上 \(p, p \in [0, k]\) 个 \(2\) 后得到的。 那么，我们只需暴力，在每次整除 \(3\) 后都枚举一遍 \(p\)，判断是否可以相等即可。 时间复杂度：不会算 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; int two[64]; void init()&#123; two[0] = 1; for(int i=1;i&lt;64;i++)&#123; two[i] = two[i - 1] * 2; &#125; &#125; void solve()&#123; int n, m; cin >> n >> m; if(n == m)&#123; cout &lt;&lt; "YES\n"; return; &#125; int k = 0; while(n % 3 == 0)&#123; k ++, n /= 3; if(m % n != 0) continue; for(int i=0;i&lt;=k;i++)&#123; if(n * two[i] == m)&#123; cout &lt;&lt; "YES\n"; return; &#125; &#125; &#125; cout &lt;&lt; "NO\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while (t --) solve(); &#125; 卡了一会儿 E. The Lakes 题意 给定一个 \(n \times m\) 的矩阵，元素为非负数。 对于当前位置，定义移动的限制为： 只能向上下左右移动一位； 不能移动到 \(0\)； 不能越界； 不能移动到之前经过的点 定义一条路径为任选一个不为 \(0\) 的点，并进行符合要求的若干次移动后的最大路径，这条路径的贡献为所有在该路径上的点的值的和。 输出最大的路径贡献。 思路 一道很裸的搜索题。 就这样，手搓一下 \(dfs\) 的板子即可。 至于起点的话，按顺序枚举，跳过已经遍历过的点和为 \(0\) 的点即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; int two[64]; void init()&#123; two[0] = 1; for(int i=1;i&lt;64;i++)&#123; two[i] = two[i - 1] * 2; &#125; &#125; void solve()&#123; int n, m; cin >> n >> m; if(n == m)&#123; cout &lt;&lt; "YES\n"; return; &#125; int k = 0; while(n % 3 == 0)&#123; k ++, n /= 3; if(m % n != 0) continue; for(int i=0;i&lt;=k;i++)&#123; if(n * two[i] == m)&#123; cout &lt;&lt; "YES\n"; return; &#125; &#125; &#125; cout &lt;&lt; "NO\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while (t --) solve(); &#125; 无脑搓板子（ F. Forever Winter 题意 定义雪花图如下： 无向图； 选定一个点为雪花的中心点； 中心点和 \(x\) 个点连接； 对于这 \(x\) 个点，均有 其他 \(y\) 个点和它连接 现在，给定一个雪花图，输出上述定义中的 \(x, y\)。 保证 \(\min(x, y) \geq 2\) 思路 我们遍历所有的叶节点，也就是度为 \(1\) 的点，这些点个数总和就是 \(xy\)。 对于一个叶节点，他一定只有一个点和其相连，也就是定义中那 \(x\) 个点的其中一个。 那么，我们只需统计所有叶节点所连接的不同点的个数，个数即为 \(x\)。 由上，可相除求得 \(y\)。 可以证明，对于题目所给限制，上述算法一定成立。 时间复杂度：\(O(n + m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> e(n + 1); vector&lt;int> in(n + 1); for(int i=0;i&lt;m;i++)&#123; int u, v; cin >> u >> v; e[u].pb(v); e[v].pb(u); in[u] ++, in[v] ++; &#125; vector&lt;bool> st(n + 1); int x = 0, y = 0; for(int i=1;i&lt;=n;i++)&#123; if(in[i] == 1) &#123; y ++; if(!st[e[i][0]]) x ++, st[e[i][0]] = true; &#125; &#125; cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y / x &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 抽象 G. Hits Different 题意 将 \(2023\) 个格子按照下图的规律放置成一个金字塔： 定义一个点的所有顶部的点为 当前层标记的所有点 与上一层相邻的点 并依次递归到最顶部为止 后被标记的所有点。 如上图，对于 \(9\)，除了它本身，其余被标红的点就是它所有顶部的点。 给定 \(n\)，输出其本身以及其所有顶部点的值之和。 题目明示开 \(long\ long\)。 思路 首先，我们不难发现，我们要求和的点就是一个倒三角内的所有点。 这个倒三角很有趣，我们以例图为例，来看看规律如何： 从 \(9\) 开始，向右上角枚举，最后枚举到了 \(6\)，也就是第三行的末尾； 对于 \(9, 6\)，向左上角求和，恰好都有 \(3\) 个数，\(3\) 就是 \(6\) 的行数； 向左上角枚举，扣除 当前行数，向右上角枚举，扣除 (当前行数 \(-1\)) 通过归纳猜想我们可以得出，我们循环从 \(n\) 开始，依次扣除 (当前行数 \(-1\))，直到遍历到第 \(x\) 行的末尾，并记录我们遍历了 \(cnt\) 个数。 那么，最后的答案就是 \(cnt\) 个前缀和长度为 \(x\) 的和。 此处为按照 \(1 \rightarrow 3 \rightarrow 6\) 为一行，\(1 \rightarrow 2 \rightarrow 4\) 为一列的方式计算每行的前缀和。 那么，前缀和我们完全可以预处理，枚举即可。 时间复杂度：不大 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int N = 3e3, M = 4e6, inf = 0x3f3f3f3f3f3f3f3f; int sum[N][N]; int line[M]; bool ed[M]; void init()&#123; int start = 1; for(int i=1;i&lt;=2e3;i++)&#123; int cur = start; for(int j=1;j&lt;=2e3-i+1;j++)&#123; sum[i][j] = sum[i][j - 1] + cur * cur; cur += i + j; &#125; start += i; &#125; int now = 0; for(int i=1;i&lt;=2e3;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; now ++; line[now] = i; &#125; ed[now] = true; &#125; &#125; void solve()&#123; int n; cin >> n; int tmp = n, cnt = 1; while(!ed[tmp])&#123; tmp -= line[tmp] - 1; cnt ++; &#125; int to = line[tmp]; int ans = 0; for(int i=1;i&lt;=cnt;i++) ans += sum[i][to]; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while (t --) solve(); &#125; 纯纯找规律（ H. Don't Blame Me 题意 给定序列 \(a\) 以及整数 \(k\)，输出子序列的个数，满足序列中所有数按位与以后得到的数的二进制中有 \(k\) 个 \(1\)。 思路 根据题目所给数据范围，可以推测这道题需要状压枚举。 考虑到非连续子序列，我们可以推测这道题需要 \(dp\)。 下面给出状压 \(dp\) 的解法： 首先，对于当前位置，它既可以作为某些子序列的一部分，也可以不作为任何子序列的一部分，当然也可以作为新序列的开头。 因此，我们定义 \(dp[i][j]\) 为前 \(i\) 个数的所有子序列在 \(i\) 位为值 \(j\) 的个数，进行分讨： 作为某些子序列的一部分，我们枚举 \(msk \in [1, 63]\)，并将 \(dp[i][msk \&amp; a[i]]\) 加上 \(dp[i - 1][msk]\)； 不作为任何子序列的一部分，那么跳过这个元素，\(dp[i][msk]\) 加上 \(dp[i - 1][msk]\)； 作为新序列的开头，\(dp[i][a[i]]\) 加上 \(1\)。 最后，我们枚举所有二进制下 \(1\) 的个数为 \(k\) 的数 \(msk\)，并统计 \(dp[n][msk]\) 的总和即可。 时间复杂度：\(O(2^6n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int N = 3e3, M = 4e6, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; int set_bit(int x)&#123; int cnt = 0; while(x > 0)&#123; if(x % 2 == 1) cnt ++; x /= 2; &#125; return cnt; &#125; void solve()&#123; int n, k; cin >> n >> k; vector&lt;vector&lt;int>> dp(n + 1, vector&lt;int>(1 &lt;&lt; 6, 0)); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; for(int msk = 0; msk &lt; (1 &lt;&lt; 6); msk ++)&#123; //状压枚举 dp[i][msk] = (dp[i][msk] + dp[i - 1][msk]) % mod; //作为某些子序列中不出现的元素 dp[i][msk &amp; cur] = (dp[i][msk &amp; cur] + dp[i - 1][msk]) % mod; //作为某些子序列的一部分 &#125; dp[i][cur] = (dp[i][cur] + 1) % mod; //新开一个子序列 &#125; int ans = 0; for(int msk = 0; msk &lt; (1 &lt;&lt; 6); msk ++)&#123; if(set_bit(msk) == k) ans = (ans + dp[n][msk]) % mod; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 你还真别说，我赛时确实想到了状压 \(dp\)，不会写罢了(x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 870 Div. 2</title>
    <url>/blog/posts/3735766708/</url>
    <content><![CDATA[Contestant'. Rank 1818. Rating +61(+561 -500). A. Trust Nobody 题意 定义一群人中有一定数量的人撒谎。对于每个人 \(i\)，会给出他所说的撒谎的人至少有 \(a_i\) 人。输出撒谎的人的数量。 思路 我们直接遍历撒谎的人的数量 \(x\)，然后枚举 \(a_i &gt; x\) 的数量，从而如果数量和 \(x\) 一致，我们就找到了答案。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() const int N = 2e6, mod = 1e9 + 7; void solve()&#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=0;i&lt;=n;i++)&#123; int cnt = 0; for(int j=1;j&lt;=n;j++)&#123; if(a[j] > i) cnt ++; &#125; if(i == cnt) &#123; cout &lt;&lt; i &lt;&lt; '\n'; return; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 一开始题目看错了，卡了半天（ B. Lunatic Never Content 重题了。原题链接：Abu Tahun Mod problem 题意 给定一个序列，找出最大的 \(x\)，满足将序列中所有元素对 \(x\) 取模后得到的新序列回文。 思路 首先，对于两个数，如果我们希望取模后的值相等，那么这两个数应该可以写成 \(k_1x + p, k_2x + p\)。 想让 \(x\) 尽可能大，那么就需要 \(k_1\) 和 \(k_2\) 尽可能小。 于是，我们不妨将差值的绝对值作为 \(x\)，这样即可让 \(x\) 尽可能大。 那么因此，我们会得到多组限制。 如果对于两个限制 \(x_1 = abs(a_i - a_{n - i + 1}), x_2 = abs(a_j - a_{n - j + 1})\)，要满足这两个限制，新的 \(x&#39; = gcd(x_1, x_2)\)， 为何呢？不难证明如果两个数\(\mod x\) 后的值相等，那么如果 \(y\) 是 \(x\) 的因数，两个数\(\mod y\) 后的值也相等。 当然，如果差值为 \(0\)，就不需要参与计算了。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() const int N = 2e6, mod = 1e9 + 7; void solve()&#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; if(n == 1)&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; int ans = abs(a[1] - a[n]); for(int i=2;i&lt;=n/2;i++)&#123; if(ans) ans = gcd(ans, abs(a[i] - a[n + 1 - i])); else ans = abs(a[i] - a[n + 1 - i]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 好快的签 C. Dreaming of Freedom 题意 给定 \(n\) 个人和 \(m\) 个选择，每轮中每个人可以对任意一个选择投票，每轮结束后将会保留投票数最多的几个选择，并继续下一轮。如果可以无穷继续下去，输出 \(NO\)；否则如果最后可以确定一个选择，输出 \(YES\)。 思路 我们遍历 \(n\) 的所有质因子 \(x\)，如果 \(x \leq m\)，那么我们扔掉 \(m - x\) 个选择，对于剩下的 \(x\) 个选择，只需每个选择都有 \(\frac{n}{x}\) 票即可无穷继续下去。 那么，如果暴力枚举因子，我们会超时。 也许会想到枚举到根号，但如果我们恰好碰到了个质数 \(n\)，我们就寄了。 为何呢？因为质因子 \(n\) 没有被我们枚举到。 为了避免这样，我们直接加一个特判，如果 \(n \leq m\)，输出 \(NO\) 即可。 当然，如果 \(n = 1\)，一定可以确定一个选择（因为只有一个），所以再加一个特判。 时间复杂度：\(O(\log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() void solve()&#123; int n, m; cin >> n >> m; if(m == 1 || n == 1)&#123; cout &lt;&lt; "YES\n"; return; &#125; if(n &lt;= m)&#123; cout &lt;&lt; "NO\n"; return; &#125; for (int i = 2; i * i &lt;= n; i ++) &#123; if(n % i == 0)&#123; if(i &lt;= m)&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 被坑死了 D. Running Miles 题意 给定一个序列，确定一个长度大于等于 \(3\) 的区间 \([l, r]\)，区间的价值为最大的三个数减去 \(r - l\)。 输出最大的价值。 思路 我们不妨直接将 \(-r, +l\) 体现到序列中。 具体地说，我们确定中间的元素 \(a_i\)，那么前 \(i - 1\) 个元素中加上其下标后的最大值和后 \(n - i - 1\) 个元素中减去其下标后的最大值与 \(a_i\) 的和即为当前的最大价值。 对于最大值的初始化，我们可以用 "前缀和"。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() #define r_all(x) x.rbegin(), x.rend() const int inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; vector&lt;int> l(n + 2, -inf), r(n + 2, -inf); for(int i=1;i&lt;=n;i++) l[i] = max(l[i - 1], a[i] + i); for(int i=n;i>=1;i--) r[i] = max(r[i + 1], a[i] - i); int ans = -inf; for(int i=1;i&lt;=n;i++) ans = max(ans, l[i - 1] + a[i] + r[i + 1]); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while (t --) solve(); &#125; 学习了学习了（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 820 Div. 3</title>
    <url>/blog/posts/3779885126/</url>
    <content><![CDATA[Practice. A. Two Elevators 题意 给定两个电梯，电梯从一层移动到相邻层需要一秒。当前人位于第一层；第一个电梯位于 \(a\) 层；第二个电梯位于 \(b\) 层，但是该电梯会先前往 \(c\) 层。 输出最先到达第一层的电梯的耗时。 思路 第一个电梯耗时 \(a - 1\)，第二个梯子耗时 \(abs(b - c) + c - 1\)。 取最小值即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pdd pair&lt;double, double> #define fs first #define sc second void solve() &#123; int a, b , c; cin >> a >> b >> c; int p = abs(a - 1), q = abs(c - b) + abs(c - 1); if(p == q) cout &lt;&lt; 3 &lt;&lt; '\n'; else if(p > q) cout &lt;&lt; 2 &lt;&lt; '\n'; else cout &lt;&lt; 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; b不一定小于c，要取绝对值 B. Decode String 题意 对于一个字符串，给定如下的加密方式： 遍历所有字符； 对于一个字符，设 \(x_i\) 为从 \(a\) 开始编号的数值； 如果 \(x_i \geq 10\)，将 \(x_i\) 乘上 \(10\)； 将所有 \(x\) 按顺序拼接起来 现在，给定加密后的结果，输出原字符串。 思路 首先，小于 \(10\) 的数不会出现末尾为 \(0\) 的情况，而出现了末尾是 \(0\)，前面两个数就是原字符对应的编号。 所以，我们直接倒序遍历，若找到 \(0\)，跳过 \(0\) 并读取前两个数并转换，若不是 \(0\)，那么将这个数转换。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define pdd pair&lt;double, double> #define fs first #define sc second void solve() &#123; int n; cin >> n; string s; cin >> s; string ans; for(int i = n - 1; i >= 0; i --)&#123; char now = s[i]; if(now == '0')&#123; ans = (char) ((s[i - 2] - '0') * 10 + (s[i - 1] - '0') - 1 + 'a') + ans, i -= 2; &#125;else&#123; ans = (char) (s[i] - '0' - 1 + 'a') + ans; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 通俗 C. Jumping on Tiles 题意 给定一个字符串，规定操作为从该位置跳到另一个位置，代价为两个位置对应字符在字母表中位置的差的绝对值。 输出从字符串左端跳到右端的代价和的最小值，以及该代价下能跳过的最多位置（不可以重复跳到同一个位置）。 思路 显然，我们只需按照字典序跳着走即可，那么我们不妨记录每个字母出现的次数以及对应的下标，然后从起点的字母按顺序遍历到终点的字母，边遍历边将所有下标都加入答案中，最后根据答案序列计算代价即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; string s; cin >> s; int n = s.size(); vector&lt;vector&lt;int>> a(26); for(int i=0;i&lt;n;i++) a[s[i] - 'a'].emplace_back(i); vector&lt;int> ans; int step = s[0] &lt; s[n - 1] ? 1 : -1; for(int i=s[0]-'a';i*step&lt;=((int)(s[n-1]-'a'))*step;i += step)&#123; for(auto e : a[i]) ans.emplace_back(e); &#125; int sum = 0; for(int i=1;i&lt;ans.size();i++) sum += abs((int) (s[ans[i]] - s[ans[i - 1]])); cout &lt;&lt; sum &lt;&lt; ' ' &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto e : ans) cout &lt;&lt; e + 1 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 跳一跳 D. Friends and the Restaurant 题意 给定 \(n\) 个朋友，每个朋友需要花 \(a_i\) 的时间，个人时间预期为 \(b_i\)，由此给定长度为 \(n\) 的两个序列 \(a, b\)。 定义每次可取出至少两个朋友，只要所有人花费的时长小于等于预期时间的总和，那么这些朋友就可以一起去餐馆吃饭。 输出最多可取出多少对满足条件的朋友，且一个人最多只能在一对朋友里。 思路 首先，我们不难会想到构建一个新的数组 \(c\)，满足 \(c_i = b_i - a_i\)，然后将其排个序。 我们不妨直接两两配对，因为既然三个人能配对，那么将其拆开去和其他的人组合一定贡献更大。 其次，如果我们从大到小遍历，并从最小值开始从小到大寻找能进行配对的数，那么我们可以发现我们跳过的数对后续的遍历都没有任何贡献。 具体来说，当我们从小到大遍历的时候，既然这个数不满足要求，那么因为另一个数是递减的，我们一定找不出答案。 因此，我们直接贪心地降序排序，然后枚举左端点，移动右指针即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; a[i] = cur - a[i]; &#125; sort(a.rbegin(), a.rend()); int l = 0, r = n - 1; int cnt = 0; while(l &lt; r)&#123; while(l &lt; r &amp;&amp; a[l] + a[r] &lt; 0) r --; if(l &lt; r &amp;&amp; a[l] + a[r] >= 0) cnt ++; else break; l ++, r --; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 但是升序排序是不可行的哦 E. Guess the Cycle Size 题意 互动游戏。 对于一个由 \(n\) 个节点连接而成的一个无向环，节点的顺序未知。 定义询问为指定两个点，返回值为联结两个点的两条边随机选一，随机是等概率的。如果给定的两个点中至少有一个点超出范围，那么输出 \(-1\)。 对于 \(1e18\) 级别的 \(n\)，在 \(50\) 次询问内，输出 \(n\) 的值。 思路 这是一道很有趣的题。 首先，这道题没有 \(100\%\) 能通过的算法，但 \(99.999851\%\) 的通过概率可以视为正确。 具体来说，因为随机是等概率的，所以我们可以进行 \(25\) 次询问，每次询问 \(1\ i, i\ 1\)，如果两者的返回值不相等，那么我们就找到了答案。 若我们从 \(2\) 开始逐一递增枚举 \(i\)，那么只要我们得到了 \(-1\)，前一个 \(i\) 就是答案。 这样，我们可以以一个很高的概率 "通过" 此题。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; int ask(int l, int r)&#123; cout &lt;&lt; "? " &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; cout.flush(); int x; cin >> x; return x; &#125; void solve()&#123; int ans = 0; for (int i = 2; i &lt;= 26; i++) &#123; long long x = ask(1, i); long long y = ask(i, 1); if (x == -1) &#123; ans = i - 1; break; &#125; if (x != y) &#123; ans = x + y; break; &#125; &#125; cout &lt;&lt; '!' &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; '\n'; cout.flush(); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 真的过了吗？真的没过吗？如过 F. Kirei and the Linear Function 题意 给定一个十进制数字构成的字符串 \(s\) 以及一个整数 \(w\)，定义 \(v(l, r)\) 为 \(s_{[l ,r]}\) 转为数字后的值，可以有前导零。 现在给定 \(q\) 个询问，每次询问给定 \(l, r, k\)，找到最小的 \(L_1, L_2\)，满足 \(L_1 \neq L_2, v(L_1, L_1 + w - 1) \times v(l, r) + v(L_2, L_2 + w - 1) \equiv k \pmod 9\)。 思路 首先，有一个结论是：一个数模 \(9\) 的值等于其十进制下所有位数字相加之和模 \(9\) 的值。 并且，因为我们求的是模 \(9\) 意义下的值，那么我们可以将所有 \(v(l, r)\) 都模上 \(9\)。 那么这题就好办了，我们直接求前缀和 \(sum\)，那么 \(v(l, r) = (sum[r] - sum[l - 1]) \bmod 9\)。 我们在询问之前，可以预处理所有 \(v(L, L + w - 1) \bmod 9\) 值对应的 \(L\)，那么对应询问，我们直接暴力枚举 \(v(L_1, L_1 + w - 1) \bmod 9\)，可以发现 \(v(L_2, L_2 + w - 1) \bmod 9\) 是唯一确定的。 那么，我们只要判断 \(v(L_1, L_1 + w - 1) \bmod 9\) 和 \(v(L_2, L_2 + w - 1) \bmod 9\) 是否相等即可，相等取前两个，不相等各自取第一个。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; string s; cin >> s; int n = s.size(); s = " " + s; int w, m; cin >> w >> m; vector&lt;int> sum(n + 1); for(int i=1;i&lt;=n;i++) sum[i] = sum[i - 1] + (s[i] - '0'); vector&lt;vector&lt;int>> ind(9); for(int i=1;i+w-1&lt;=n;i++)&#123; ind[(sum[i + w - 1] - sum[i - 1]) % 9].pb(i); &#125; while(m --)&#123; int l, r, k; cin >> l >> r >> k; int v = (sum[r] - sum[l - 1]) % 9; pii ans = &#123;inf, inf&#125;; for(int i=0;i&lt;9;i++)&#123; int j = ((k - v * i % 9) % 9 + 9) % 9; if(i == j)&#123; if(ind[i].size() &lt; 2) continue; if(ans.fs > ind[i][0]) ans = &#123;ind[i][0], ind[i][1]&#125;; &#125;else&#123; if(ind[i].empty() || ind[j].empty()) continue; if(ans.fs > ind[i][0]) ans = &#123;ind[i][0], ind[j][0]&#125;; &#125; &#125; if(ans.fs == inf) cout &lt;&lt; -1 &lt;&lt; ' ' &lt;&lt; -1 &lt;&lt; '\n'; else cout &lt;&lt; ans.fs &lt;&lt; ' ' &lt;&lt; ans.sc &lt;&lt; '\n'; &#125; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 主要是第一个结论 G. Cut Substrings 题意 给定一个字符串 \(s\) 和一个模式串 \(t\)，定义一次操作为选定 \(s\) 中一个与模式串 \(t\) 匹配的子串，并将这个子串所有字符修改为 "."。 输出最小的操作数，使得 \(s\) 中没有可以和模式串 \(t\) 匹配的子串，并输出方案数。 思路 因为数据量较小，我们考虑将所有匹配的点都暴力枚举出来。 那么，我们可以得到若干个 \(s\) 上的区间。 可以发现，如果两个区间相交，那么删除任意一个区间都可以让这两个区间无法匹配。 那么反着来说，两个不相交的区间的操作是独立的。 那么我们考虑动态规划，其中 \(dp[i]\) 为必须要选定 \(i\) 的条件下，让前 \(i\) 个区间的无法匹配的最小操作数，\(val[i]\) 为对应的方案数。 我们考虑枚举 \(i\)，并找出第一个和 \(i\) 不相交的区间 \(j\)，然后枚举和 \(j\) 相交的所有区间 \(k\)（包含 \(j\) 本身）。 可以发现，\(i\) 和 \(j, k\) 不相交，\(j, k\) 相交。那么很显然 \(dp[k] = \min(dp[k], dp[i] + 1)\)。 与此对应地，如果 \(dp[k] &gt; dp[i] + 1\)，那么 \(val[k] = val[i]\)，否则如果 \(dp[k] = dp[i] + 1\)，那么 \(val[k] += val[i]\)。 但是这里存在一个问题，我们不知道最后的状态在哪一个位置。 因而，我们考虑多放入一个区间，区间左端点为 \(n + m\)，即保证不和前面区间相交。那么最后该区间的 \(dp\) 值 \(-1\) 就是我们需要的答案了。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; string s, t; cin >> s >> t; int n = s.size(), m = t.size(); s = " " + s, t = " " + t; vector&lt;int> p(1, -inf); for (int i = 1; i + m - 1 &lt;= n; i ++) &#123; bool f = true; for (int j = 1; j &lt;= m; j ++) &#123; if (s[i + j - 1] != t[j]) &#123; f = false; break; &#125; &#125; if (f) p.pb(i); &#125; p.pb(n + m); n = p.size() - 1; vector&lt;int> dp(n + 1, inf), val(n + 1); dp[0] = 0; val[0] = 1; for (int i = 0; i &lt; n; i ++) &#123; int j = i + 1; while (j &lt;= n &amp;&amp; p[j] &lt;= p[i] + m - 1) j ++; for (int k = j; k &lt;= n &amp;&amp; p[k] &lt;= p[j] + m - 1; k ++) &#123; if (dp[i] + 1 &lt; dp[k]) &#123; dp[k] = (dp[i] + 1) % mod; val[k] = val[i]; &#125; else if (dp[i] + 1 == dp[k]) &#123; val[k] = (val[k] + val[i]) % mod; &#125; &#125; &#125; cout &lt;&lt; dp[n] - 1 &lt;&lt; ' ' &lt;&lt; val[n] &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 神奇的 \(dp\)]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 869 Div. 2</title>
    <url>/blog/posts/2274952185/</url>
    <content><![CDATA[Contestant. Rank 474. Rating +86. A. Politics 题意 对于 \(n\) 个人，有 \(m\) 个意见，每个人需要对意见做表率（\(+\)表示同意，\(-\) 表示不同意）。 在对一个意见做完表率后，如果同意的人多，那么不同意的人将会离开；如果不同意的人多，那么同意的人将会离开；如果人数一样多，那么所有人都离开。 规定可以在所有人表率前，拿掉一些人。设第一个人为自己，那么输出自己能留到最后的条件下最后剩余的人数的最大值。 思路 首先，如果有其他人的任意一个意见的表率和自己不一样，那么最后自己或者那个不一样的人会离开，所以，所有意见的表率和自己都相同的人的个数加上 \(1\) 就是答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, k; cin >> n >> k; vector&lt;string> s(n); for(int i=0;i&lt;n;i++) cin >> s[i]; int ans = 0; for(int i=0;i&lt;n;i++) if(s[0] == s[i]) ans ++; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 抽象 B. Indivisible 题意 给定一个整数 \(n\)，构造一个 \(n\) 的排列，满足对于任意 \(1 \leq l &lt; r \leq n\)，\((a_l + a_{l + 1} + \ldots + a_r) \bmod (r - l + 1) \neq 0\)。 思路 我们先来考虑两个连续的数，既然它们不能被 \(2\) 整除，那么我们不妨直接用一个奇数和一个偶数拼接。 或者换句话说，排列为奇偶相间的。 对于三个连续的数，不能被 \(3\) 整除，那么这三个数不可以是 \(a - 1, a, a + 1\)。 从这里就已经出现一定的规律了，我们不妨按照 \(2, 1, 4, 3, \ldots, 2n, 2n - 1\) 的方法构造，很巧，其他约束均满足。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; if(n == 1) cout &lt;&lt; 1 &lt;&lt; '\n'; else&#123; int cnt = (1 + n) * n / 2; if(cnt % n == 0) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; for(int i=1;i&lt;=n/2;i++) cout &lt;&lt; i * 2 &lt;&lt; ' ' &lt;&lt; i * 2 - 1 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜即可 C. Almost Increasing Subsequence 题意 如果一个序列中不包含任何 连续的 三元组 \((x, y, z)\) 满足 \(x \geq y \geq z\)，那么定义该序列 几乎递增。 现在，给定一个序列以及若干询问，对于 \([l_i, r_i]\) 的区间询问，输出该区间中几乎递增的序列的最大长度。 思路 因为三元组是连续的，所以我们可以直接计算出前 \(x\) 个数中几乎递增的序列的长度。 或者说，这里采用了一种类似于前缀和的做法： 如果 \(a_{i - 2} \geq a_{i - 1} \geq a_i\)，那么 \(sum_i = sum_{i - 1}\)； 否则，\(sum_i = sum_{i - 1} + 1\)。 但是这样相减是不够的，如果左边界出现了不满足条件的三元组，这时答案会偏小。因为三元组的一部分包含在区间中时，并不会不满足条件。 因此，我们可以顺便记录统计的时候当前位置是否出现了不满足条件的三元组，即标记 \(f_i = true\)，那么如果 \(f_l = true\)，答案 \(+1\)；如果 \(f_{l + 1} = true\)，答案再 \(+1\)（当然，\(l + 1\) 要在区间中）。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, q; cin >> n >> q; vector&lt;int> a(n + 1), ans(n + 1); vector&lt;bool> st(n + 1); for (int i = 1; i &lt;= n; i++) cin >> a[i]; ans[0] = 0; ans[1] = 1; ans[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; ans[i] = ans[i - 1]; if (a[i - 2] >= a[i - 1] &amp;&amp; a[i - 1] >= a[i]) st[i] = true; else ans[i] ++; &#125; while (q --) &#123; int l, r; cin >> l >> r; int w = ans[r] - ans[l - 1]; if (st[l]) w ++; if (r != l &amp;&amp; st[l + 1]) w ++; cout &lt;&lt; w &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 好妙 D. Fish Graph 题意 给定一个无向不完全联通图，找出一个 "鱼"，并输出它的所有边。找不到输出 \(NO\)。 其中，"鱼" 定义为一个环加上其中一个点所多连出的两条边。注意，这两条边不可以和环中的其他点连接。 思路 首先，数据量很小，我们不妨直接枚举两个点 \(u, v\)，并忽略 \(u - v\) 这条边。我们从 \(u\) 节点开始 \(dfs\)，若能到 \(v\)，那么就存在了环。 此时，我们将 \(u\) 作为特殊点，那么在开始 \(dfs\) 前，我们还得满足 \(u\) 的度数大于等于 \(4\)。 设 \(dfs\) 的路径点集为 \(step\)，\(u\) 的所有子节点为 \(extra\)。 首先，我们只需随便选 \(extra\) 中的 \(4\) 个，因为最多只会有两条边在路径中。 那么，我们枚举 \(extra\)，如果 \(extra\) 中的点都不在 \(step\) 中，那么很凑巧，去掉 \(extra\) 中在路径中的两个点，剩余的两个点和这个环就可以构成一个答案。 但如果出现了，因为题目要求多出的两条边不可以和环中的其他点连接，我们就需要另行处理。 显然，我们只需考虑一种情况，也就是当 \(extra\) 中包含了路径中的两个点，但是有一条边和环中的其他点相连的时候。 此时，我们找到了一个更小的环，如果我们将这个更小的环作为答案，那么 \(extra\) 中剩余的一个点和原来在路径中的一个点就可以作为多出来的那两条边了。 因此，按照上述算法，可以保证一定可以找出一条鱼。 最后，我们将 \(step\) 和 \(extra\) 稍做处理即可得到答案。 时间复杂度：\(O(m \cdot (n + m))\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second #define pb emplace_back #define all(x) x.begin(), x.end() void solve()&#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> e(n); for(int i=0;i&lt;m;i++)&#123; int u, v; cin >> u >> v; u --, v --; e[u].pb(v), e[v].pb(u); &#125; for(int u=0;u&lt;n;u++)&#123; if(e[u].size() &lt; 4) continue; for(auto v : e[u])&#123; vector&lt;int> now, step; bool ok = false; vector&lt;bool> vis(n); auto dfs = [&amp;](auto self, int p)&#123; vis[p] = true; now.pb(p); if(p == v) &#123; //绕回v了 step = now; ok = true; return; &#125; for(auto to : e[p])&#123; if(vis[to] || (p == u &amp;&amp; to == v)) continue; self(self, to); //lambda递归调用 if(ok) return; &#125; now.pop_back(); &#125;; dfs(dfs, u); if(!ok) continue; vector&lt;int> extra = e[u]; extra.resize(4); //挑4个即可 int mn = step.size(); for(auto x : extra)&#123; //根据这4个来重新调整环（因为环内可能还有小环，我们拿小环更好，可以保证一定满足条件 auto it = find(all(step), x); if(it != step.begin() + 1)&#123; mn = min(mn, (int)(it - step.begin()) + 1); &#125; &#125; step.resize(mn); partition(all(extra), [&amp;](int x)&#123; return count(all(step), x) == 0; &#125;); //删掉在环中的那些点 extra.resize(2); cout &lt;&lt; "YES" &lt;&lt; '\n' &lt;&lt; step.size() + 2 &lt;&lt; '\n'; int pre = step.back(); for(auto x : step)&#123; cout &lt;&lt; x + 1 &lt;&lt; ' ' &lt;&lt; pre + 1 &lt;&lt; '\n'; pre = x; &#125; cout &lt;&lt; u + 1 &lt;&lt; ' ' &lt;&lt; extra[0] + 1 &lt;&lt; '\n' &lt;&lt; u + 1 &lt;&lt; ' ' &lt;&lt; extra[1] + 1 &lt;&lt; '\n'; return; &#125; &#125; cout &lt;&lt; "NO" &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 参考了官方题解对出现 "更小环" 时的处理]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 868 Div. 2</title>
    <url>/blog/posts/569247821/</url>
    <content><![CDATA[Contestant. Rank 1585. Rating +7. A. A-characteristic 题意 给定一个由 \(±1\) 组成的数组 \(a\)，定义特征 \(A\) 为数组 \(a\) 中满足 \(a \leq i &lt; j \leq n\) 且 \(a_i \cdot a_j = 1\) 的个数。 给定个数，构造这个数组。 思路 直接暴力枚举 \(-1\) 的个数，因为可以无视顺序，我们直接在输出 \(-1\) 后剩下的全填上 \(1\) 即可。 因为 \((-1) \cdot (-1) = 1, 1 \cdot 1 = 1\)，所以我们不妨初始化 \(p\) 数组，其中 \(p_i = p_{i - 1} + i - 1\)，那么 \(p_i + p_{n - i} = k\) 时就找到了答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> p(110); for(int i=2;i&lt;=100;i++) p[i] = p[i - 1] + i - 1; for(int i=0;i&lt;=n;i++)&#123; if(p[i] + p[n - i] == k)&#123; cout &lt;&lt; "YES\n"; for(int x=1;x&lt;=i;x++) cout &lt;&lt; "-1 "; for(int x=i;x&lt;n;x++) cout &lt;&lt; "1 "; cout &lt;&lt; '\n'; return; &#125; &#125; cout &lt;&lt; "NO\n"; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 傻逼（指出题 B. Sort with Step 题意 给定一个 排列 以及整数 \(k\)，规定 \(a_i\) 可以和 \(a_{i + k}\) 交换。 如果在若干次交换后可以让排列升序，那么输出 \(0\)； 否则，如果在交换之前可以任选两个数交换一次，该条件下可以让排列升序，那么输出 \(1\)； 否则，输出 \(-1\)。 思路 首先，既然这是一个排列，那么如果可以升序，一定满足 \(a_i \bmod k = i \bmod k\)。 那么，我们直接统计不满足该条件的个数，如果为 \(0\)，输出 \(0\)；如果为 \(2\)，输出 \(1\)，否则输出 \(-1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n + 1); int f = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; if(a[i] % k != i % k) f ++; &#125; if(f == 0) &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; &#125;else if(f == 2)&#123; cout &lt;&lt; 1 &lt;&lt; '\n'; &#125;else cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 如果不是排列那我就似了 C. Strongly Composite 题意 对于一个合数，如果它的所有因子满足质数的个数小于等于合数的个数，那么定义该数为强合数。 现在，给定一个序列 \(a\)，构造一个序列 \(b\)，并输出它的长度： \(a_1 \cdot a_2 \cdot \ldots \cdot a_n = b_1 \cdot b_2 \cdot \ldots \cdot b_m\)； \(b\) 中所有数都是强合数； \(b\) 的长度尽可能最大 思路 首先，我们不妨分解质因数，并统计所有质因数的个数。 因为两个相同的质数相乘后，我们会得到一个因子满足质数个数为 \(1\) 且合数个数也为 \(1\) 的强合数，所以我们在统计之后枚举所有个数 \(cnt_p\)，统计 \(\lfloor \frac{cnt_p}{2} \rfloor\) 的总和，作为答案的一部分。 对于剩余的数的集合，不难发现没有重复数字，而三个不同的质数相乘后，我们会得到一个因子满足质数个数为 \(3\) 且合数个数为 \(4\) 的强合数，此时对于剩余的数的个数 \(sum\)，\(\lfloor \frac{sum}{3} \rfloor\) 就是答案的另一部分。 因此，\(ans = \sum \lfloor \frac{cnt_p}{2} \rfloor + \lfloor \frac{sum}{3} \rfloor\)。 当然，对于分解质因数，我们可以用线性筛。 时间复杂度：不大 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; vector&lt;int> pri; vector&lt;bool> vis(N); void init(int n) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) pri.emplace_back(i); for (auto j : pri) &#123; if (i * j > n) break; vis[i * j] = true; if (i % j == 0) break; &#125; &#125; &#125; void solve() &#123; int n; cin >> n; map&lt;int, int> cnt; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; for (auto x : pri) &#123; if (cur % x == 0) &#123; while (cur % x == 0) cur /= x, cnt[x] ++; &#125; &#125; if (cur != 1) &#123; cnt[cur] ++; &#125; &#125; int ans = 0, sum = 0; for(auto e : cnt)&#123; ans += e.sc / 2; sum += e.sc % 2; &#125; cout &lt;&lt; sum / 3 + ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(1e5); int t = 1; cin >> t; while(t --) solve(); &#125; 有点水，但又有点不水（x D. Unique Palindromes 题意 对于一个至少有三个字符的字符串 \(s\)，定义 \(p(s, m)\) 为 \(s\) 的前 \(m\) 个字符的所有连续子串中 不同回文串 的个数。 现在，给定最多 \(20\) 个限制，一条限制包括 \(m_i\) 和 \(p(s, m_i)\) 的值，输出满足限制的一个字符串。 思路 首先，题目说了回文串不同才计数，那么对于 \(n\) 个连续相同的子串，就有 \(n\) 个不同的回文串（如 \(a, aa, aaa, aaaa, \dots\)）。 很有趣，题目给了限制的最大个数，这让我们不难联想到字母表的个数，\(20 &lt; 26\)。 那么，对于两个相邻的限制，我们可以求出多出的回文串的个数，并填上连续的对应个数的字符。我们不妨从 \(d\) 开始，第一个限制我们都放 \(d\)，第二个限制我们都放 \(e\)，以此类推，字母表是够我们用的。 那么空出来的地方，我们就一定得保证不会多出来回文串了。 可以很简单的观察到，我们只要循环放 \(abc\) 即可，如 \(\color{rgb(149,117,205)}{a}\color{rgb(124,179,66)}{b}\color{rgb(0,172,193)}{c}\)\(dd\)\(\color{rgb(149,117,205)}{a}\color{rgb(124,179,66)}{b}\)\(eee\)\(\color{rgb(0,172,193)}{c}\color{rgb(149,117,205)}{a}\color{rgb(124,179,66)}{b}\)\(ff\)，这样就可以满足我们的需求了。 这样，只要每次多出来的回文数的个数大于等于空出来的位置，我们都可以完成构造。 当然，如果空间不够了，其实可以证明一定无解，这边不给出证明。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, k; cin >> n >> k; vector&lt;int> x(k + 2), c(k + 2); for(int i=1;i&lt;=k;i++) cin >> x[i]; for(int i=1;i&lt;=k;i++) cin >> c[i]; x[++ k] = n, c[k] = c[k - 1]; int pre = 0; for(int i=1;i&lt;=k;i++)&#123; if(x[i] - c[i] &lt; pre)&#123; cout &lt;&lt; "NO\n"; return; &#125; pre = x[i] - c[i]; &#125; string ans = "abc"; int now = 0; c[0] = 3; for(int i=1;i&lt;=k;i++)&#123; for(int j=1;j&lt;=c[i]-c[i-1];j++) ans += (char) ('c' + i); int l = ans.size(); for(int j=1;j&lt;=x[i]-l;j++) ans += (char) ('a' + (now ++ % 3)); &#125; cout &lt;&lt; "YES\n" &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 其实是不会证（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 867 Div. 3</title>
    <url>/blog/posts/2694924338/</url>
    <content><![CDATA[Contestant(alt). Rank 1774. Rating +20. A. TubeTube Feed 题意 给定两个序列 \(a, b\)，选择 \(a_i\) 的代价为 \(a_i + i\) (从 \(0\) 开始)，价值为 \(b_i\)。输出代价不超过 \(t\) 的条件下的最大价值。 思路 我们找出所有代价不超过 \(t\) 的价值，并遍历这些价值，找出最大值即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, t; cin >> n >> t; vector&lt;int> p; vector&lt;int> e(n); for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur + i &lt;= t) p.emplace_back(i); &#125; for(int i=0;i&lt;n;i++) cin >> e[i]; if(p.empty())&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; int mx = p[0]; for(auto &amp;x : p) &#123; if(e[mx] &lt; e[x]) mx = x; &#125; cout &lt;&lt; mx + 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 很水 B. Karina and Array 题意 给定一串整数序列，定义序列的美丽值为所有相邻两数乘积的最大值。在可以任意删除元素且最后至少剩余两个元素的条件下，输出最大的美丽值。 思路 很显然，我们直接排个序，对前两个和最后两个分别取乘积，并取最大值即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a.begin(), a.end()); int ans = -inf; ans = max(ans, a[0] * a[1]); ans = max(ans, a[n - 2] * a[n - 1]); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 还是很水 C. Bun Lover 题意 给定一个肉桂卷的大小 \(n\)，输出边长的总和。 具体来说，如下图，棕色线段的长度就是答案： 思路 我们将其拆分成两段，如下图（来自官方题解）： 可以发现粉色和青色段最后都会向里折1格，我们将其展开，那么长度恰好成为了一个等差数列的前 \(n\) 项和。 具体来说，青色的长度为 \(1 + 2 + \dots + n = \frac{n \cdot (n + 1)}{2}\)，粉色的长度为 \(1 + 2 + \dots + (n + 1) = \frac{(n + 1) \cdot (n + 2)}{2}\) 因此，最后的结果为 \(\frac{(n + 1) \cdot (n + 2)}{2} + \frac{n \cdot (n + 1)}{2} + 1 = \frac{(n + 1) \cdot (n + 2) + n \cdot (n + 1)}{2} + 1 = \frac{2 \cdot (n + 1)^2}{2} + 1 = (n + 1)^2 + 1\) 不过当然，像我这样盲猜有规律然后直接乱写也是可以的，这样你可以得到 \(26 + (n + 6)(n - 4)\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; cout &lt;&lt; 26 + (11 + 11 + (n - 5) * 2) * (n - 4) / 2 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 无脑Ocean在线乱猜 D. Super-Permutation 题意 给定排列 \(a\) 的长度，构造一个新序列 \(b\)，其中 \(b_i = ((a_1 + a_2 + \ldots + a_i) \bmod n) + 1\)。 若能找出一个排列 \(a\)，满足构造出的新序列 \(b\) 为一个排列，那么输出 \(a\)，否则输出 \(-1\)。 思路 我们先来猜测一下如何构造： 首先，为了方便拿到 \(1\)，我们将第一个数指定为 \(n\)。 那么我们接下来就可以放上 \(n - 1\) 和 \(2\)，此时 \(n + n - 1 = 2n - 1, 2n - 1 + 2 = 2n + 1\)，\((2n - 1) \bmod n + 1 = n, (2n + 1) \bmod n + 1 = 2\)，此时我们拿到了 \(n, 2\)。 我们继续放上 \(n - 3\) 和 \(4\)，此时 \(2n + 1 + n - 3 = 3n - 2, 3n - 2 + 4 = 3n + 2\)，\((3n - 2) \bmod n + 1 = n - 1, (3n + 2) \bmod n + 1 = 3\)，此时我们拿到了 \(n - 1, 3\)。 依次类推，我们可以构造出排列 \(\{n, n - 1, 2, n - 3, 4, \ldots \}\)，以此得到序列 \(b = \{1, n, 2, n - 1, 3, \dots \}\)。 不难发现，上述构造方法对 \(1\) 和偶数都一定有解，而除 \(1\) 之外的奇数都无解。 事实上，我们来单独考虑这种无解情况，\(b_n = (a_1 + a_2 + \ldots + a_n) \bmod n + 1= (1 + 2 + \ldots + n) \bmod n + 1 = \frac{(1 + n)n}{2} \bmod n + 1\)。 如果 \(n\) 为 \(1\) 或者偶数，那么分母对 \(n\) 有效，可以写作 \((1 + n) \frac{n}{2} \bmod n + 1\)，我们无法在提出 \(n\) 后让式子为整数。 而相反地，当 \(n\) 为除 \(1\) 之外的奇数时，上述式子变成了 \(n \frac{1 + n}{2} \bmod n + 1\)，我们可以提出 \(n\)，此时 \(b_n\) 变为了 \(1\)。 猜测的第一句话其实是一定需要满足的，我们假设 \(a_k = n\)，此时 \(b_k = (b_{k - 1} - 1 + a_k) \bmod n + 1= b_{k - 1}\)，那么为了防止 \(b\) 元素重复，\(k\) 只能为 \(1\)。 那么，\(b_1\) 只能为 \(1\)。 不难发现，当 \(n\) 为除 \(1\) 之外的奇数时，\(b_1 = b_n\)，因此无解。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;bool> st(n + 1); vector&lt;int> ans(n); ans[0] = n; st[n] = true; bool ok = true; for(int i=1;i&lt;n;i+=2) &#123; ans[i] = n - i; if(st[n - i]) ok = false; st[n - i] = true; &#125; for(int i=2;i&lt;n;i+=2)&#123; ans[i] = i; if(st[i]) ok = false; st[i] = true; &#125; if(!ok) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 根据题意构造（x），根据猜测构造（√） E. Making Anti-Palindromes 题意 定义反回文串为一个长为 \(n\) 的字符串 \(s\)，满足对于任意 \(i \in [1, n]\) 都有 \(s_i \neq s_{n - i + 1}\)。 给定一个字符串，定义操作为选定任意两个不同位置的字符并交换它们，输出将字符串变为反回文串所需的最小的操作数。若无解输出 \(-1\)。 思路 首先，\(n\) 是奇数时，一定无解。 其次，只要有一个字母出现次数大于 \(\frac{n}{2}\)，那么也是无解，毕竟一定会出现至少一对相同的字母。 那么，我们统计 \(s_i = s_{n + 1 - i}\) 的个数为 \(k\)，以及对于所有字符 \(c\)，\(s_i = s_{n + 1 - i}\) 的个数的最大值 \(m\)，借此，我们可以先缩小一下范围： \(ans \geq m\)，因为这 \(m\) 对一定得和其他不同的字符对进行交换； \(ans \geq \lceil \frac{k}{2} \rceil\)，因为我们至少得两两配对。 那么显然，如果满足可以两两配对的条件，\(ans_{min} = \lceil \frac{k}{2} \rceil\)。 但如果不满足，那么我们不难发现，只要我们将数量少的字符对和其他数量少的字符对的进行交换，那么最后一定只会多出数量最多的那个字符对，也就是我们之前统计的数量为 \(m\) 的那个字符。 那么，最后约束就只剩下 \(m\) 了，\(ans_{min} = m\)。 因此，最后答案就是 \(\max(m, \lceil \frac{k}{2} \rceil)\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; string s; cin >> s; if(n % 2 == 1)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; vector&lt;int> cnt(26), oc(26); int m = 0, k = 0; for(int i=0;i&lt;n/2;i++) &#123; oc[s[i] - 'a'] ++, oc[s[n - i - 1] - 'a'] ++; if (s[i] == s[n - i - 1]) cnt[s[i] - 'a']++, k++; &#125; for(int i=0;i&lt;26;i++)&#123; m = max(m, cnt[i]); if(oc[i] > n / 2)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; &#125; cout &lt;&lt; max(m, (k + 1) / 2) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 好绕，好高级，我好若 F. Gardening Friends 题意 给定一棵根为 \(1\) 且边权都是 \(k\) 的树，定义树的价值为所有点到根节点的 最大长度。 定义一次操作为将根修改为相邻的任意节点，代价为 \(c\)。 输出任意次操作后，树的价值 与 代价和 的差值的最大值。 思路 首先，我们可以用 \(\mathtt{bfs}\) 先找出以 \(1\) 为根的最长链，记端点为 \(s\)。 那么，我们再以 \(s\) 为根进行 \(\mathtt{bfs}\)，显然最长链就是整棵树的最长链了。 我们记这个最长链的另一个端点为 \(t\)，若我们以 \(t\) 为根再进行一次 \(\mathtt{bfs}\)，那么对于所有的点，我们都可以快速求出以它为根的最长链长度了。 那么，我们枚举所有点，若长度为 \(p\)，并且和 \(1\) 相距 \(q\)，那么我们更新最大值 \(k * p - c * q\)。 为何能快速求出呢？因为在正反两次 \(\mathtt{bfs}\) 树的最长链时，我们可以更新出 每个点的所有链中 的 两条最长链，然后我们就可以取最大值。 时间复杂度：\(O(n)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n, k, c; cin >> n >> k >> c; vector&lt;vector&lt;int>> e(n + 1); for(int i=1;i&lt;n;i++)&#123; int u, v; cin >> u >> v; e[u].pb(v), e[v].pb(u); &#125; auto bfs = [&amp;](int s)&#123; queue&lt;int> q; q.ep(s); vector&lt;int> d(n + 1, -1); d[s] = 0; while(!q.empty())&#123; int x = q.front(); q.pop(); for(auto y : e[x])&#123; if(d[y] != -1) continue; d[y] = d[x] + 1; q.ep(y); &#125; &#125; return d; &#125;; auto d1 = bfs(1); int s = max_element(all(d1)) - d1.begin(); auto ds = bfs(s);//找出最长链 int t = max_element(all(ds)) - ds.begin(); auto dt = bfs(t); int ans = 0; for(int i=1;i&lt;=n;i++) ans = max(ans, k * max(ds[i], dt[i]) - d1[i] * c); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 也是个很有意思的图论 G1. Magic Triples (Easy Version) 详见G2，区别是G1的数据量更小 G2. Magic Triples (Hard Version) 题意 定义如果一个三元组 \((i, j, k)\) 满足下面的条件，那么这个三元组是有魔力的： \(1 \leq i, j, k \leq n\)； \(i, j, k\) 各不相同； 存在一个正整数 \(b\)，满足 \(a_i \cdot b = a_j, a_j \cdot b = a_k\)。 给定一个序列，输出所有三元组中有魔力的个数。 思路 首先，我们完全可以在确定一个数的条件下，枚举正整数 \(b\) 来计算答案。 那么我们不妨确定 \(j\)，并枚举 \(b\)，那么 \(a_i = \frac{a_j}{b}, a_k = ba_j\)。 很显然，如果我们从小到大枚举，是一定会超时的。 考虑到 \(b\) 一定是整数，所以我们在计算 \(b\) 的时候可以顺便计算 \(\frac{a_j}{b}\)，那么复杂度可以降到 \(\log a_j\)。 当然，考虑到重复问题，我们单独计算 \(b = 1\) 的贡献。 在 \(1e6\) 的范围内，复杂度可行，但对于 \(1e9\) 的数据，我们一定得做优化了。 考虑到 \(a_k = ba_j \leq \max(a)\)，我们可以一定程度复杂度，此时可以 \(AC\)。 时间复杂度：\(小于O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int mx = 0; map&lt;int, int> mp; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; mp[cur] ++; mx = max(mx, cur); &#125; int ans = 0; for(auto [a, cnt] : mp) &#123; ans += max(0ll, cnt * (cnt - 1) * (cnt - 2)); if(a != 1 &amp;&amp; mp.count(1) &amp;&amp; mp.count(a * a)) ans += cnt * mp[1] * mp[a * a]; for (int b = 2; b &lt;= a / b &amp;&amp; a * b &lt;= mx; b ++)&#123; if(a % b != 0) continue; if(mp.count(a / b) &amp;&amp; mp.count(a * b)) ans += cnt * mp[a / b] * mp[a * b]; if(b != a / b &amp;&amp; mp.count(b) &amp;&amp; mp.count(a * a / b)) ans += cnt * mp[b] * mp[a * a / b]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 卡过去力！]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 147</title>
    <url>/blog/posts/3276138869/</url>
    <content><![CDATA[Contestant. Rank 2617. Rating -37. A. Matching 题意 给定一个匹配字符串，包含 \(?\) 和 \([0, 9]\) 内的数字，\(?\) 可用任意数字替换。 输出字符串可以代表的数字的总数，其中数字不可以出现前导 \(0\)。 思路 很显然，难点在最后一句话，但这只和第一个字符是不是 \(?\) 有关。 如果不是 \(?\)，那么显然不会出现前导 \(0\)，最后的答案就是 \(10 ^ x\)，其中 \(x\) 是 \(?\) 的个数。 如果是 \(?\)，那么该位不可以出现 \(0\)，而其余位置是否为 \(0\) 我们无需考虑，所以最后的答案是 \(\frac{9}{10} 10 ^ x\)。 不过当然，如果第一位是 \(0\)，那么一个符合条件的数都没有了。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define psi pair&lt;string, int> #define fs first #define sc second const int N = 1e5 + 10; void solve()&#123; string s; cin >> s; int ans = 1; int n = s.size(); for(int i=0;i&lt;n;i++)&#123; if(s[i] == '?') ans *= 10; &#125; if(s[0] == '?') ans = ans / 10 * 9; if(s[0] == '0') ans = 0; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 很快啊，很简单啊（x B. Sort the Subarray 题意 定义操作为选择一段连续的子区间并将其中的所有元素升序排序。 现在给定操作前后的序列，输出最长的可能操作区间的左右端点。 思路 首先，我们比对两个序列，先找出不相同的起始位置和结束位置，得到区间 \([l_0, r_0]\)。 然后，我们拓展这个区间，其中，左区间向左拓展的条件是 \(a_{l_0 - 1} \leq a_{l_0}\)，右区间同理。 最后得到的区间就是答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define psi pair&lt;string, int> #define fs first #define sc second const int N = 1e5 + 10; void solve()&#123; int n; cin >> n; vector&lt;int> p(n), q(n); for(int i=0;i&lt;n;i++) cin >> p[i]; int b = -1, e = -1; for(int i=0;i&lt;n;i++) &#123; cin >> q[i]; if(p[i] != q[i])&#123; if(b == -1) b = e = i; else e = i; &#125; &#125; if(b == -1)&#123; int mx = 1, pre = p[0], cnt = 1, e = 1; for(int i=1;i&lt;n;i++)&#123; if(p[i] >= pre) cnt ++; else&#123; if(mx &lt; cnt)&#123; mx = cnt; e = i; &#125; cnt = 1; &#125; pre = p[i]; &#125; if(mx &lt; cnt)&#123; mx = cnt; e = n; &#125; cout &lt;&lt; e - mx + 1 &lt;&lt; ' ' &lt;&lt; e &lt;&lt; '\n'; &#125;else&#123; while(b - 1 >= 0 &amp;&amp; q[b] >= q[b - 1]) b --; while(e + 1 &lt; n &amp;&amp; q[e] &lt;= q[e + 1]) e ++; cout &lt;&lt; b + 1 &lt;&lt; ' ' &lt;&lt; e + 1 &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 怎么老打错变量，罚时吃饱力（悲 C. Tear It Apart 题意 给定一个字符串，定义操作为选择任意数量的不相邻的位置并将对应位置的字符删除。 输出最小操作数，使最后的字符串所有字符相同。 思路 首先，我们可以枚举我们要保留的那个字符，并删去其他的字符。 那么，我们只需考虑如何删的问题了。 显然，我们可以将需要删除的字符分成若干段，在第一次删除时，我们只需对每一段从第一个开始隔一位删就可以让能删的字符数最多，这显然成立（如 \(\color{rgb(124,179,66)}{b}\)\(c\)\(\color{rgb(124,179,66)}{d}\)\(a\)\(\color{rgb(124,179,66)}{b}\)\(c\)\(\color{rgb(124,179,66)}{d}\)\(b\)）。 那么，我们可以重复上面的操作，直到删完为止。 我们可以发现，操作数只和数量最多的那一段有关，而且最后的结果有 \(\log_2\) 的关系。 观察发现，\(\lceil \log_2 cnt_{max} \rceil\) 即为答案。 当然，直接用while循环也不是不可以（ 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define psi pair&lt;string, int> #define fs first #define sc second const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; string s; cin >> s; int n = s.size(); bool f = true; for(int i=1;i&lt;n;i++) if(s[i] != s[i - 1]) f = false; if(f) &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; int ans = inf; s = " " + s + " "; for(int w=0;w&lt;=25;w++)&#123; char now = (char) (w + 'a'); s[0] = s[n + 1] = now; int mx = 1, cnt = 0; for(int i=0;i&lt;=n + 1;i++)&#123; if(s[i] == now)&#123; mx = max(mx, cnt); cnt = 0; &#125;else cnt ++; &#125; int cur = 0; while(mx > 0)&#123; cur ++; mx /= 2; &#125; ans = min(ans, cur); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 观察可得，显然易得（x D. Black Cells 题意 给定一个数轴，对于起点 \(0\)，有下面的三个代价均为 \(1\) 的操作： 向右移动一格 按下shift 松开shift，此时按下到松开这段时间内经过的格子都会被染成黑色。 现在，给定数轴上的 \(n\) 段区间，只能将区间内的格子染上黑色，且需要染 \(k\) 个格子。 输出最小代价和。 思路 首先，不跳过区间的做法绝对不是最优的。 那么，我们会希望跳过区间的代价小于不跳过区间的代价。 但是，显然无论跳不跳过，我们都必须经过这个区间，所以问题归结到按下和松开shift的代价。 假设我们跳过了 \([l_i, r_i]\) 区间，此时代价为 \(a\)；如果我们不跳过，那么我们会多出 \(2\) 次按shift的代价，但是最后就不会多出至少 \(len\) 个需要多染的格子了。 那么最后问题归结于 \(a&#39;=a+2-len\) 和 \(a\) 的大小关系了。 显然，当长度为 \(1\) 时，我们能跳就跳；而长度为 \(2\) 时代价一致，长度大于 \(2\) 时我们能不跳就不跳。 我们可以枚举所有区间，然后进行分类讨论。 我们边枚举边记录算上当前区间的话之前有 \(c\) 个长为 \(1\) 的区间，去掉长为 \(1\) 区间后其他区间的和为 \(s\)。 那么，如果 \(s + c &lt; k\)，在这里停下来是不够的。如果 \(s &lt; k\) 但 \(s + c \geq k\)，那么一部分 \(1\) 是需要保留的，我们可以得到当前的最小代价为 \(end + 2((i - c) + (k - s))\)。如果 \(s \geq k\)，那么我们将所有的 \(1\) 都跳过即可，此时最小代价为 \(end - (s - k) + 2(i - c)\)。 当然，我们也可以使用优先队列解这题。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, k; cin >> n >> k; vector&lt;int> l(n), r(n); for(int i=0;i&lt;n;i++) cin >> l[i]; for(int i=0;i&lt;n;i++) cin >> r[i]; int s = 0, c = 0, ans = inf; for(int i=0;i&lt;n;i++)&#123; if(r[i] - l[i] + 1 == 1) c ++; else s += r[i] - l[i] + 1; if(s + c &lt; k) continue; if(s &lt; k &amp;&amp; s + c >= k) ans = min(ans, r[i] + 2 * (i + 1 - c + k - s)); else ans = min(ans, r[i] - (s - k) + 2 * (i + 1 - c)); &#125; cout &lt;&lt; (ans == inf ? -1 : ans) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 有点贪心的感觉]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 821 Div. 2</title>
    <url>/blog/posts/809255780/</url>
    <content><![CDATA[Practice. A. Consecutive Sum 题意 给定一个序列 \(a\)，以及整数 \(k\)，定义操作为选择 \(i, j\)，满足 \(i \bmod k = j \bmod k\)，并将 \(a_i\) 和 \(a_j\) 交换。 输出任意次操作后，所有长为 \(k\) 的连续子序列的和的最大值。 思路 我们直接枚举 \(p \in [0, k - 1]\)，并求出所有 \(i \bmod k = p\) 位置上 \(a_i\) 的最大值，并输出总和即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, k; cin >> n >> k; vector&lt;int> a(k); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; a[i % k] = max(a[i % k], cur); &#125; int ans = 0; for(int i=0;i&lt;k;i++) ans += a[i]; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 就好了 B. Rule of League 题意 规定对于 \(n\) 个选手，一共有 \(n - 1\) 场对决，第 \(i\) 场为上一场的赢家和第 \(i + 1\) 号选手之间的对决。 给定三个整数 \(n, a, b\)，其中 \(n\) 为选手数，所有选手要么赢了 \(a\) 场，要么赢了 \(b\) 场。 输出每场的赢家，若有多个方案，任选其一输出。 思路 显然，我们需要满足 \(\min(a,b)=0, (n - 1) \% \max(a,b) = 0\)。 那么，我们完全可以让第 \(2 + ky\) 号选手连续赢 \(y\) 场，这样即可满足条件。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, x, y; cin >> n >> x >> y; if(x > y) swap(x, y); if(x != 0 || y == 0 || (n - 1) % y != 0)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; &#125;else&#123; for(int i=2;i&lt;=n;i+=y)&#123; for(int j=0;j&lt;y;j++) cout &lt;&lt; i &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜即可 C. Parity Shuffle Sorting 题意 给定一个序列，定义操作如下： 选择两个下标 \(l, r\)，其中 \(1 \leq l &lt; r \leq n\)。 如果 \(a_l + a_r\) 为奇数，那么将 \(a_r\) 改为 \(a_l\)，否则相反。 输出将序列变为不递减序列的一种方案，满足方案数不超过序列的长度。 思路 我们不妨将序列全都改成一样的。 首先，我们将左右两个端点变为一样的，这只需选择 \(1, n\)，我们无需考虑端点的奇偶性。 其次，我们枚举剩余的元素，如果它和端点的和为奇数，那么我们选择 \(1, i\)，将 \(a_i\) 改为 \(a_1\)；如果为偶数，那么我们选择 \(i, n\)，将 \(a_i\) 改为 \(a_n\)，最后所有元素都会变为同一个值，且所需操作数为 \(n - 1 &lt; n\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; cout &lt;&lt; n - 1 &lt;&lt; '\n'; if(n > 1) cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; n &lt;&lt; '\n'; int f = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(i > 0 &amp;&amp; i &lt; n - 1)&#123; if((cur + f) % 2 == 1) cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; i + 1 &lt;&lt; '\n'; else cout &lt;&lt; i + 1 &lt;&lt; ' ' &lt;&lt; n &lt;&lt; '\n'; &#125;else f = cur; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 也是乱猜，但是很有道理（x D1. Zero-One (Easy Version) 题意 给定两个长度相等的二进制字符串 \(a, b\)，定义操作如下： 选择两个下标 \(l, r\)，其中 \(l &lt; r\)； 将 \(a_l\) 修改为 \(1 - a_l\)，\(a_r\) 修改为 \(1 - a_r\)； 如果 \(l + 1 = r\)，那么这次操作代价为 \(x\)，否则代价为 \(y\)。 本题满足 \(x \geq y\)。 输出最小的代价和，使 \(a\) 变为 \(b\)。 思路 首先，本题等效于将 \(a\) 和 \(b\) 按位异或后得到的二进制字符串 \(c\) 中所有 \(1\) 变为 \(0\) 的代价和。 其次，修改是成对的，也就是说，如果 \(1\) 的个数是奇数，那么无解。 那么，这里存在两种操作： 选择两个进行一次操作； 选择任意一个其他元素作为跳板，进行两次操作 因为操作相邻元素的代价是大于操作不相邻元素的，所以当个数多于 \(2\) 的时候，我们完全不需要考虑操作相邻的，因为我们一定可以避免取相邻的对。 而当个数为 \(2\) 时，如果相邻，我们就需要考虑执行哪种操作了，操作 \(1\) 的代价为 \(x\)，操作二的代价为 \(2y\)，那么我们取最小值即可。当然，如果不相邻，答案就是 \(y\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, x, y; cin >> n >> x >> y; string a, b; cin >> a >> b; vector&lt;int> dif; for(int i=0;i&lt;n;i++)&#123; if(a[i] != b[i]) dif.emplace_back(i); &#125; int cnt = dif.size(), ans; if(cnt % 2 == 1) ans = -1; else if(cnt == 2) ans = dif[0] + 1 == dif[1] ? min(x, 2 * y) : min(x * (dif[1] - dif[0]), y); else ans = cnt / 2 * y; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 依然还是乱猜（什]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 822 Div. 2</title>
    <url>/blog/posts/30693881/</url>
    <content><![CDATA[Practice. A. Select Three Sticks 题意 给定 \(n\) 根火柴，定义操作为选定一根火柴，并将其长度加 \(1\) 或减 \(1\)。输出最小的操作数，使得所有火柴中有至少三根火柴的长度相等。 思路 很显然，我们只需将火柴按长短升序排序，然后枚举所有相邻的三元组，找出 将 左右两个元素 加减 到 与中间的元素相同 所需的操作数 的最小值 即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a.begin(), a.end()); int ans = inf; for(int i=0;i&lt;n-2;i++)&#123; ans = min(ans, a[i + 2] - a[i]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 就乱猜（ B. Bright, Nice, Brilliant 题意 给定一个 \(n\) 层的金字塔，第 \(i\) 层有 \(i\) 个房间，每个房间可选择是否点亮，点亮可以将该房间以及其 "子树" 的亮度 \(+1\)，如下图： 现在，给定金字塔的层数，输出每个房间是否点亮 \((0/1)\)，满足所有房间的亮度相同，且点亮的房间数最大。 思路 显然，我们只能按照下面的方法构造： \(\ \ \ \ \ \ \ \ 1 \\\ \ \ \ \ \ 1\ \ 1\\ \ \ \ \ 1\ \ 0\ \ 1\\\ \ 1\ \ 0\ \ 0\ \ 1\\ 1 \ \ 0\ ...\ 0\ \ 1\) 否则，中间一定会越来越大。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; cout &lt;&lt; 1 &lt;&lt; '\n'; for(int i=2;i&lt;=n;i++)&#123; cout &lt;&lt; 1 &lt;&lt; ' '; for(int j=0;j&lt;i-2;j++) cout &lt;&lt; 0 &lt;&lt; ' '; cout &lt;&lt; 1 &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 别问，问就是猜的 C. Removing Smallest Multiples 题意 给定一个长为 \(n\) 的二进制字符串，代表 \(1 - n\) 中的数字是否在序列中。 对于上述字符串描述的序列，定义操作为选择任意一个 \(k \in [1, n]\)，将序列中最小的 \(k\) 的倍数删去，代价为 \(k\)。 输出最小的代价和，将 \(n\) 的排列变为该序列。 思路 显然，一个数被他的最小因数删去是代价最小的，但我们也需要保证 比这个数更小的 它的最小因数的倍数 不在序列中，否则我们会优先删去不可以删去的元素。 所以我们可以从小到大枚举 \(k\)。 对于 \(k\)，我们枚举 \(k\) 的所有倍数（包括 \(k\) 本身），并将所有倍数的答案和 \(k\) 取最小值。 在枚举倍数的时候，只要这个倍数在字符串中对应位置为 \(1\)，那么我们直接结束枚举，因为我们会删除不必要的元素。 最后，我们直接遍历每个数的代价，求和即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; string s; cin >> s; s = " " + s; vector&lt;int> ans(n + 1, inf); int res = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j += i) &#123; if (s[j] == '1') break; ans[j] = min(ans[j], i); &#125; if (ans[i] != inf) res += ans[i]; &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 挺快的（ D. Slime Escape 题意 给定 \(n\) 个史莱姆，每个史莱姆有对应的血量，血量可以为负。给定目标史莱姆的位置，满足该史莱姆的血量为正。 规定目标史莱姆可以向左右任意移动，但每次只能移动一格，移动到对应格时会吸收该格的史莱姆（不可以重复吸收），吸收后，目标史莱姆的血量将会加上被吸收的史莱姆的血量（吸收负血量史莱姆将会扣除目标史莱姆的血量）。 输出目标史莱姆是否可以以非负的血量来到左端点或右端点。 思路 我们用双指针 \(l, r\) 表征目标史莱姆拓展的区域，显然当 \(l \leq 0\) 或 \(r \geq n\) 时到达了端点。 那么，我们只需模拟史莱姆的移动即可，我们默认向左走，那么如果不可以向左，我们就尝试向右，不能移动就结束。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n + 2), pre(n + 2); for(int i=1;i&lt;=n;i++) cin >> a[i], pre[i] = pre[i - 1] + a[i]; int l = k - 1, r = k; int l_pre = pre[l], r_pre = pre[r]; while(l > 0 &amp;&amp; r &lt; n)&#123; if(r_pre - pre[l - 1] >= 0) l_pre = min(l_pre, pre[-- l]); else if(pre[r + 1] - l_pre >= 0) r_pre = max(r_pre, pre[++ r]); else break; &#125; cout &lt;&lt; (l > 0 &amp;&amp; r &lt; n ? "NO\n" : "YES\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 这就A了？]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 823 Div. 2</title>
    <url>/blog/posts/2812498512/</url>
    <content><![CDATA[Practice. A. Planets 题意 对于一个序列，定义操作为下面二选一： 序列的其中一个元素减一，代价为 \(1\)； 将某一个元素改为 \(0\)，代价为 \(c\)。 现在，给定一个序列 \(a\)，根据 \(a_i\) 的值出现的次数构造新的序列 \(c\) (\(c_i\) = \(cnt_i\))，输出将序列 \(c\) 所有元素修改为 \(0\) 所需的最小代价。 思路 判断每个元素的大小与 \(c\) 的关系，答案就是 \(\displaystyle{\sum_{i=1}^n min(cnt_i, c)}\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110; void solve()&#123; int n, c; cin >> n >> c; vector&lt;int> cnt(N); for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; cnt[cur] ++; &#125; int ans = 0; for(int i=0;i&lt;N;i++)&#123; ans += cnt[i] >= c ? c : cnt[i]; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 签到 B. Meeting on the Line 题意 给定 \(n\) 个人在数轴上的位置，以及每个人的等待时间 \(t_i\)，找出一个点 \(x_0\)，满足所有人中 每个人离 \(x_0\) 的距离 \(dist_i\) 与 \(t_i\) 的和 的最大值 最小。 思路 首先，如果没有 \(t\) 数组，那么这道题具有结论：\(x_0 = \frac{x_{max} + x_{min}}{2}\)。 此结论可以用类似递推的方式证明，有关归纳证明参考 这里。 那么，我们先假设 \(x_0\) 已知，来看看单独一个人的情况： 如果这个人位于 \(x_0\) 左侧，那么他需要的总时长为 \(x_0 - (x_i - t_i)\)；反之，他需要 \(- x_0 + (x_i + t_i)\)。 观察上述式子，我们不妨用 \(x_i - t_i\) 和 \(x_i + t_i\) 替换 \(x_i\)。 由于结论 \(x_0 = \frac{x_{max} + x_{min}}{2}\)，也就是 \(- x_0 + x_{max} = x_0 - x_{min}\)， 我们不难发现，因为 \(\max(x_i - t_i, x_i + t_i) = x_i + t_i, \min(x_i - t_i, x_i + t_i) = x_i - t_i\)，所以 取最大值和最小值时 一定可以满足 我们所取的值 就是我们在上述情况 \(1\) 中所提到的每个人需要的总时长。 因而，我们只需按照上述操作计算即可，复杂度是线性的。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> x(n), p(2 * n); for(int i=0;i&lt;n;i++) cin >> x[i]; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; p[i * 2] = x[i] + cur; p[i * 2 + 1] = x[i] - cur; &#125; int mn = inf, mx = -inf; for(int i=0;i&lt;2*n;i++) mn = min(mn, p[i]), mx = max(mx, p[i]); cout &lt;&lt; (mn + mx) / 2 &lt;&lt; ((mn + mx) % 2 == 0 ? "" : ".5") &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 好抽象的做法（ C. Minimum Notation 题意 给定一个由 \(0-9\) 内数字构成的字符串，定义操作为选择任意一个下标 \(i\)，删除 \(s_i\)，并将 \(\min(9, s_i + 1)\) 插入到任意位置。 输出任意次操作后，字符串的最小字典序。 思路 首先，除了 \(8, 9\)，我们不能对他元素操作多于一次。 其次，我们一定需要让最小的元素在开头。 那么，我们找出最小的元素 \(x\) 的初始位置，然后向后遍历，找出最后一个 \(x\) 出现的位置，然后从这个位置开始，继续找第二小的元素的初始位置和结束位置，如此循环直到遍历到字符串末尾。这样，我们可以取出一个子序列，这个子序列内的元素我们都不需要操作。 而对于其他的元素，我们只需将其加 \(1\) 并插入到对应的位置，让最后的字符串 "非降序" 即可。 上述的一个简单做法就是将取出的子序列对应的下标做上标记，然后从前往后遍历，将未标记的值加上 \(1\)。遍历结束后，将字符串升序排序即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; string s; cin >> s; int n = s.size(); vector&lt;vector&lt;int>> pre(10, vector&lt;int>(n + 1)); vector&lt;int> ed(10, -1), cnt(10, 0); for(int i=1;i&lt;=n;i++)&#123; ed[s[i - 1] - '0'] = i; cnt[s[i - 1] - '0'] ++; for(int j=0;j&lt;10;j++)&#123; pre[j][i] = pre[j][i - 1]; if(j == s[i - 1] - '0') pre[j][i] ++; &#125; &#125; int start = 0; string res; for(int i=0;i&lt;10;i++)&#123; if(ed[i] &lt;= start) continue; for(int j=0;j&lt;pre[i][ed[i]] - pre[i][start];j++) res += (char)(i + '0'); cnt[i] -= pre[i][ed[i]] - pre[i][start]; start = ed[i]; &#125; for(int i=0;i&lt;10;i++)&#123; for(int j=0;j&lt;cnt[i];j++) res += (char)(min(9ll, i + 1) + '0'); &#125; sort(res.begin(), res.end()); cout &lt;&lt; res &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 反而比B题简单 D. Prefixes and Suffixes 题意 给定两个长为 \(n\) 的字符串 \(a, b\)，定义操作为选择一个 \(k \in [1, n]\)，将 \(a\) 的前 \(k\) 个字符和 \(b\) 的后 \(k\) 个字符交换。 输出任意次操作后能否将两个字符串变为相同的字符串。 思路 我们先观察样例的操作特点，不难 得到下面的结论： 我们在不断交换 \(\{a_i, b_{n - i - 1}\}\) 的左右顺序，并更改着 \(i\) 的大小。 那么，我们只需统计 \(\{\min(a_i, b_{n - i - 1}), \max(a_i, b_{n - i - 1})\}\) 的个数，如果这个个数是偶数，那么我们一定可以将其安排在类似于 "回文" 的对称位置。 或者更具体地说，我们统计得到了 \(\color{rgb(149,117,205)}{\{a, c\}}\), \(\color{rgb(186,104,200)}{\{a, c\}}\), \(\color{rgb(124,179,66)}{\{b, d\}}\), \(\color{rgb(76,175,80)}{\{b, d\}}\), \(\color{rgb(0,172,193)}{\{b, d\}}\), \(\color{rgb(3,155,229)}{\{b, d\}}\)，那么我们一定能构造其为 \(\color{rgb(149,117,205)}{a} \color{rgb(124,179,66)}{b} \color{rgb(0,172,193)}{b} \color{rgb(3,155,229)}{d} \color{rgb(76,175,80)}{d} \color{rgb(186,104,200)}{c}\), \(\color{rgb(186,104,200)}{a} \color{rgb(76,175,80)}{b} \color{rgb(3,155,229)}{b} \color{rgb(0,172,193)}{d} \color{rgb(124,179,66)}{d} \color{rgb(149,117,205)}{c}\) （不唯一）。 上述例子的 "回文" 性体现在，如果我们将 \(abbddc\) 中 \(c\) 用 \(a\) 替换，\(d\) 用 \(b\) 替换，那么会得到 \(abbbba\)，这是回文的。 如果是奇数的话，显然我们只能把他放在中间，因而奇数个数的对最多只能有一个。 满足上述条件即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 110, inf = 0x3f3f3f3f3f3f3f3f; void solve() &#123; int n; cin >> n; string s1, s2; cin >> s1 >> s2; map&lt;pii, int> cnt; for(int i=0;i&lt;n;i++)&#123; pii now = &#123;s1[i], s2[n - i - 1]&#125;; if(now.fs > now.sc) swap(now.fs, now.sc); cnt[now] ++; &#125; int f = 0; for(auto e : cnt)&#123; if(e.sc % 2 == 1)&#123; f ++; if(e.fs.fs != e.fs.sc) f = -inf; &#125; &#125; cout &lt;&lt; (f >= 0 &amp;&amp; f &lt;= 1 ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 绕，但是有趣]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - 湘潭大学2023新生赛</title>
    <url>/blog/posts/1207844194/</url>
    <content><![CDATA[Practice. A. 签到啦~ 题意 给定一个序列以及一个整数 \(d\)，输出总和大于等于 \(d\) 的元素的数量的最小值。 思路 排序+枚举。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; int n, w; cin >> n >> w; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a.rbegin(), a.rend()); int ans = 0; for(int i=0;i&lt;n;i++)&#123; ans ++; w -= a[i]; if(w &lt;= 0) break; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 打卡打卡（其实后面题目也不比这个难多少 B. 熙巨打票 题意 给定两个机器，机器在操作结束后需要 \(a\) 分钟的冷却时间，每个操作需要 \(b\) 分钟。 给定操作的数量，输出完成最后一个操作的时刻。 思路 首先，如果 \(a \leq b\)，那么我们直接无视冷却时间，因为我们轮换着用机器即可。 如果 \(a &gt; b\)，我们可以画图，不难发现，除了前两个操作不需要加时间，接着每两个操作都需要 \(a + b\) 分钟。 当然，考虑到这个，我们需要分奇偶性做，奇数下会多一个操作时间 \(b\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; int a, b, n; cin >> a >> b >> n; if(a &lt;= b) cout &lt;&lt; b * n &lt;&lt; '\n'; else cout &lt;&lt; b * (2 - n % 2) + (a + b) * ((n - 1) / 2) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 做的时候漏考虑了点（ C. 三元分配 题意 给定三个部门的员工数量，按照下面的要求配对所有的员工，若不能配对输出 \(P\)，否则输出 \(R\)： 单一部门内可配对； 两个部门员工数量之和为质数可配对 思路 首先，如果总和为奇数，那么一定无法将所有员工都配对。 那么，我们来考虑总和为偶数的情况： 全都是偶数，那么一定是可以配对的； 两个奇数，一个偶数，那么很明显，除非奇数的和为 \(2\)，那么我们可以直接把这俩员工配对，否则和一定不是质数。这时，我们就需要用这个唯一的偶数来分配。具体来说，我们只需满足这个唯一的偶数大于等于 \(2\)，那么我们只需分别拿出一个员工和这两个奇数来配对，那么就会剩下三个偶数，此时一定可以分配完。当然，需要满足这个唯一的偶数分别和两个奇数相加的和都是质数。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 4e5 + 10; vector&lt;int> pri; vector&lt;bool> vis(N), is_pri(N); void init() &#123; for(int i=2; i&lt;=4e5; i++) &#123; if(!vis[i]) pri.emplace_back(i), is_pri[i] = true; for(int j=0; j&lt;pri.size(); j++) &#123; if(i * pri[j] > 4e5) break; vis[i * pri[j]] = true; if(i % pri[j] == 0) break; &#125; &#125; &#125; void solve() &#123; int a, b, c; cin >> a >> b >> c; if((a + b + c) % 2 == 1) cout &lt;&lt; "P\n"; else if(a % 2 == 0 &amp;&amp; b % 2 == 0 &amp;&amp; c % 2 == 0) cout &lt;&lt; "R\n"; else if((a + b + c) == 2) cout &lt;&lt; "R\n"; else if(((a + b) == 2 &amp;&amp; c % 2 == 0) || ((a + c) == 2 &amp;&amp; b % 2 == 0) || ((b + c) == 2 &amp;&amp; a % 2 == 0)) cout &lt;&lt; "R\n"; else if((a % 2 == 0 &amp;&amp; is_pri[a + b] &amp;&amp; is_pri[a + c] &amp;&amp; a >= 2) || (b % 2 == 0 &amp;&amp; is_pri[b + a] &amp;&amp; is_pri[b + c] &amp;&amp; b >= 2) || (c % 2 == 0 &amp;&amp; is_pri[c + a] &amp;&amp; is_pri[c + b] &amp;&amp; c >= 2)) cout &lt;&lt; "R\n"; else cout &lt;&lt; "P\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 过于复杂的分类讨论（ D. "逆"天求和 题意 给定一个质数 \(p\)，输出 \([1, p - 1]\) 内所有数在模 \(p\) 的值位于 \([1, p - 1]\) 内的逆元之和。 思路 很有趣，我们直接打表找规律，发现是个等差数列求和，套公式提交直接就过了（ 这边不给出证明，需要费马小定理的逆用。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; int n; cin >> n; cout &lt;&lt; (1 + n - 1) * (n - 1) / 2 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 确实很逆天 E. 读中国数字 题意 给定一个不超过 \(9999\ 9999\ 9999\) 的数，输出它的中文大写按照题给映射后的结果。 思路 我们按照下面的规则模拟即可： 每 \(4\) 位为一个单元，如果这个单元中出现了两个非 \(0\) 数夹了若干个 \(0\)，那么需要在中间加上 "零"。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; string s; cin >> s; while(s.size() % 4 != 0) s = "0" + s; string ans = ""; string l[3] = &#123;"Y", "W", ""&#125;; bool st1 = false, st0 = false; for(int level=0;level&lt;s.size()/4;level++)&#123; string p[4] = &#123;"K", "B", "T", ""&#125;; bool f = false; for(int i=0;i&lt;4;i++)&#123; char now = s[level * 4 + i]; if(st1 &amp;&amp; now == '0' &amp;&amp; i &lt; 3) st0 = true; if(now != '0')&#123; if(st0 &amp;&amp; st1)&#123; ans += "0"; st0 = st1 = false; &#125; ans += now; ans += p[i]; f = st1 = true; &#125; &#125; if(f) ans += l[3 - s.size() / 4 + level]; st0 = false; &#125; cout &lt;&lt; (ans == "" ? "0" : ans) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 这个零太搞人了（ F. 您有一封新邮件待接收 题意 给定一个有向图，输出位于环中的所有元素，按照升序以及给定的映射输出。 思路 因为数据量很小，我们直接暴力 \(Dfs\)，记录经过 \(100\) 次的节点，并在第 \(101\) 次经过时停止搜索即可。 时间复杂度：\(O(不大)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 4e5 + 10; vector&lt;int> e[N]; void dfs(int x, vector&lt;int> &amp;vis, set&lt;int> &amp;ans) &#123; vis[x] ++; if(vis[x] == 100) ans.emplace(x); else if(vis[x] > 100) return; for(auto c : e[x]) dfs(c, vis, ans); &#125; void solve() &#123; int n, m; cin >> n >> m; vector&lt;string> s(n); for(int i=0; i&lt;n; i++) cin >> s[i]; for(int i=1; i&lt;=n; i++) &#123; int k; cin >> k; e[i].clear(); e[i].reserve(k); while(k --) &#123; int x; cin >> x; e[i].emplace_back(x); &#125; &#125; vector&lt;int> vis(n + 1); set&lt;int> ans; dfs(m, vis, ans); if(ans.empty()) cout &lt;&lt; "No one is disturbed!" &lt;&lt; '\n'; else &#123; cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto c : ans) cout &lt;&lt; s[c - 1] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); //init(); int t = 1; cin >> t; while(t --) solve(); &#125; 怎么这么暴力（ H. 我爱XTU 题意 给定一个由 \(X,T,U\) 组成的字符串，输出三个字母数量相同的子串的个数。 思路 我们很容易就想到了前缀和。 那么我们不妨令 \(SX_i, ST_i, SU_i\) 为前 \(i\) 个数中 \(X,T,U\) 出现的个数。 对于区间 \([l, r]\)，需要满足 \(SX_r - SX_{l - 1} = ST_r - ST_{l - 1} = SU_r - SU_{l - 1}\)。 对于左边的等式，化简可得 \(SX_r - ST_r = SX_{l - 1} - ST_{l - 1}\)。 同样的，\(SX_r - SU_r = SX_{l - 1} - SU_{l - 1}\)。 这两个式子同时满足即可。 也就是说，对于二元组 \(&lt;SX_p - ST_p, SX_p - SU_p&gt;\)，我们只需找出有多少个 \(&lt;SX_q - ST_q, SX_q - SU_q&gt;\) 与之相等即可，这里我们可以用到 \(map\)。 当然，对于 \(l - 1 = 0\) 的情况，此时二元组为 \(&lt;0, 0&gt;\)，我们在遍历之前加上这个即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 4e5 + 10; void solve() &#123; map&lt;pii, int> cnt; cnt[&#123;0, 0&#125;] ++; string s; cin >> s; int n = s.size(), ans = 0; int sx = 0, st = 0, su = 0; for(int i=0;i&lt;n;i++)&#123; char now = s[i]; if(now == 'X') sx ++; else if(now == 'T') st ++; else if(now == 'U') su ++; pii cur = &#123;sx - st, st - su&#125;; ans += cnt[cur]; cnt[cur] ++; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); //init(); int t = 1; cin >> t; while(t --) solve(); &#125; 有个一摸一样的题：数据结构]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 298</title>
    <url>/blog/posts/437490184/</url>
    <content><![CDATA[Practice. A. Job Interview 题意 给定一个由 \(o, -, x\) 构成的字符串，判断字符串是否至少含有一个 \(o\)，且不包含 \(x\)。 思路 如题。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; string s; cin >> s; bool ans1 = false, ans2 = false; for(char e : s)&#123; if(e == 'o') ans1 = true; if(e == 'x') ans2 = true; &#125; cout &lt;&lt; (ans1 &amp;&amp; !ans2 ? "Yes\n" : "No\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 打卡打卡 B. Coloring Matrix 题意 给定两个 \(n \times n\) 的矩阵 \(A, B\)，定义操作为将当前矩阵顺时针旋转 \(90°\)。输出对 \(A\) 进行任意次操作后，是否存在一种情况，使得对于所有 \(A_{i, j} = 1\)，满足 \(B_{i, j} = 1\)。 思路 如题，模拟即可。 时间复杂度：\(O(4n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;vector&lt;int>> a(n ,vector&lt;int>(n)), b(n ,vector&lt;int>(n)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin >> a[i][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin >> b[i][j]; bool ans = true; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; if(a[i][j] == 1 &amp;&amp; b[i][j] == 0) ans = false; &#125; if(ans) &#123; cout &lt;&lt; "Yes\n"; return; &#125; ans = true; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; if(a[j][n - i - 1] == 1 &amp;&amp; b[i][j] == 0) ans = false; &#125; if(ans) &#123; cout &lt;&lt; "Yes\n"; return; &#125; ans = true; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; if(a[n - i - 1][n - j - 1] == 1 &amp;&amp; b[i][j] == 0) ans = false; &#125; if(ans) &#123; cout &lt;&lt; "Yes\n"; return; &#125; ans = true; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; if(a[n - j - 1][i] == 1 &amp;&amp; b[i][j] == 0) ans = false; &#125; if(ans) &#123; cout &lt;&lt; "Yes\n"; return; &#125; cout &lt;&lt; "No\n"; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 复制粘贴.jpg C. Cards Query Problem 题意 给定 \(q\) 个询问，询问为下面三者任选一： \(1\ i\ j\)，将 \(i\) 写到一张空白的卡牌上并将其塞到 \(j\) 盒子； \(2\ i\)，升序输出 \(i\) 盒子内所有卡牌的数字； \(3\ i\)，升序输出所有包含数字 \(i\) 的盒子编号，不可以重复； 按照上述条件执行对应操作。 思路 直接模拟即可。 其中，盒子可使用 \(multiset\)，卡牌可使用 \(set\)。 注意对应关系。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, q; cin >> n >> q; map&lt;int, multiset&lt;int>> box; map&lt;int, set&lt;int>> card; while(q --)&#123; int tp; cin >> tp; if(tp == 1)&#123; int i, j; cin >> i >> j; card[i].emplace(j); box[j].emplace(i); &#125;else if(tp == 2)&#123; int i; cin >> i; for(auto e : box[i]) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125;else if(tp == 3)&#123; int i; cin >> i; for(auto e : card[i]) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 别绕晕即可 D. Writing a Numeral 题意 给定一个字符串 \(S\)，初始状态下 \(S\) 为 \(1\)。 现在，给定 \(q\) 个询问，询问为下面三者任选一： \(1\ x\)，将 \(x\) 拼接到 \(S\) 的最后； \(2\)，删除 \(S\) 开头的数字； \(3\)，输出 \(S\) 转换为数字并\(\mod 998244353\) 后的值； 按照上述条件执行对应操作。 思路 我们可以用队列来维护 \(S\) 序列，以此记录开头的数字到底是什么。 这样，我们就可以直接模拟寻问 \(1\) 对应的操作。 而对于询问 \(2\)，我们直接减掉对应的值即可。其中，位数就是队列的长度 \(-1\)，我们可以用快速幂求出 \(10 ^ t\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; int qp(int a, int b)&#123; int ans = 1; while(b > 0)&#123; if(b &amp; 1) ans = ans * a % mod; a = a * a % mod; b >>= 1; &#125; return ans; &#125; void solve() &#123; int q; cin >> q; int ans = 1; queue&lt;int> nums; nums.emplace(1); while(q --)&#123; int t; cin >> t; if(t == 1)&#123; int x; cin >> x; nums.emplace(x); ans = (ans * 10 % mod + x) % mod; &#125;else if(t == 2)&#123; ans = (ans + mod - nums.front() * qp(10, nums.size() - 1) % mod) % mod; nums.pop(); &#125;else if(t == 3)&#123; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 这怎么可以用 \(java\) 的大数爆算啊，对吧（x E. Unfair Sugoroku 待补充 F. Rook Score 题意 给定一个无限大的矩阵以及其中的 \(n\) 个点的值，除此之外，其余点的值全是 \(0\)。对于一个点 \((R, C)\)，对应的总和为 \(sumR_R + sumC_C - val_{R, C}\)，即这个点所在的行和列的元素总和（交点只被计算一次）。找出一个点，满足总和最大，并输出最大总和。 思路 首先，我们固定 \(C\)，那么我们只需找出最大的 \(sumR\) 即可。 如果行和列的交点的元素值为 \(0\)，那么我们就能保证这个总和一定是最大的，因为其他的总和不减掉交点也一定比他小。 然而，如果不为 \(0\)，那么我们需要减掉交点，这时，我们得到的答案并非就是最大的，我们需要继续枚举次大值。 如上，我们循环枚举，直到交点值为 \(0\) 或者枚举完即可。 有趣的是，我们按照上述操作，再枚举 \(C\) 即可，复杂度是可行的。 时间复杂度：\(O(np)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; map&lt;pii, int> v; map&lt;int, int> mc, mr; for(int i=0;i&lt;n;i++)&#123; int R, C, X; cin >> R >> C >> X; v[&#123;R, C&#125;] = X; mr[R] += X; mc[C] += X; &#125; vector&lt;pii> vr; vr.reserve(mr.size()); //有意思的函数（不是reverse捏 for(auto r : mr) vr.emplace_back(r.second, r.first); sort(vr.rbegin(), vr.rend()); int ans = 0; for(auto C : mc)&#123; int c = C.fs, sum = C.sc; for(auto R : vr)&#123; ans = max(ans, sum + R.fs - v[&#123;R.sc, c&#125;]); if(v[&#123;R.sc, c&#125;] == 0) break; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 就离谱]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 866 Div. 2</title>
    <url>/blog/posts/1909551888/</url>
    <content><![CDATA[Contestent. Rank 1674. Rating -30. 开局爽翻，越打越坐牢（ A. Yura's New Name 题意 给定一个由 "^" 和 "_" 构成的字符串，输出至少需要插入多少个 "^" 或 "_"，使字符串可被划分为若干个个 "^^" 和 "^_^"。 思路 首先，我们可以确定开头和结尾一定是 "^"，那么如果不是，统计数量。 其次，我们两个两个遍历，如果出现了两个 "_"，那么中间一定要插一个 "^"，连续的 "^" 我们不用管。 当然，我们需要特判一下只有一个 "^" 的情况（不难发现上面的做法恰好只漏了这个条件），这个情况只需补上一个 "^" 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; string s; cin >> s; int n = s.size(); int ans = 0; if(n == 1 &amp;&amp; s[0] == '^') &#123; ans ++; &#125;else &#123; if (s[0] == '_') ans++; for (int i = 1; i &lt; n; i++) &#123; if (s[i - 1] == s[i] &amp;&amp; s[i] == '_') ans++; &#125; if (s[n - 1] == '_') ans++; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜+签到 B. JoJo's Incredible Adventures 题意 给定一个长度为 \(n\) 的二进制字符串，依次循环将字符串右移一位，得到 \(n - 1\) 个新的字符串。 将所有字符串按照右移的位数升序从上往下排列，构成一个 \(n \times n\) 的矩阵。 输出矩阵中一个面积最大的矩形的面积，满足矩形内所有元素都是 \(1\)。 思路 首先，我们无法让断续的 \(1\) 构造出面积很大的矩形，因为中间有 \(0\)，不难发现就算只有一个 \(0\)，也会让面积大打折扣。 因此，我们贪心地认为：只有长度最长的连续 \(1\) 才能构造出面积最大的矩形。 我们通过 打表 找规律可以发现，这个矩形的面积是和上述连续 \(1\) 的长度有关的。 \(S = \frac{len + 1}{2}(\frac{len}{2} + 1)\)。 当然，我们需要特判一下只有 \(0\) 和只有 \(1\) 的情况，前者为 \(0\) 后者为 \(n \times n\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; string s; cin >> s; int n = s.size(); bool have0 = false, have1 = false; for(char e : s) &#123; if(e == '0') have0 = true; else have1 = true; &#125; if(!have0) &#123; cout &lt;&lt; n * n &lt;&lt; '\n'; return; &#125; if(!have1)&#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; s += s; n *= 2; int mx = 0, cur = 1; for(int i=1;i&lt;n;i++)&#123; if(s[i] == '1' &amp;&amp; s[i - 1] == '1') cur ++; else&#123; mx = max(mx, cur); cur = 1; &#125; &#125; cout &lt;&lt; ((mx + 1) / 2) * (mx / 2 + 1) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 贪心？其实是乱猜（x C. Constructive Problem 题意 给定一个序列，定义 \(MEX(a)\) 为 \(a\) 中未出现的最小非负整数。定义操作为选定一个连续区间，并将区间内的所有数都更改为同一个数。在操作只能执行一次的条件下，判断是否可以将 \(MEX&#39;(a)\) 变为 \(MEX(a) + 1\)。 思路 首先，如果 \(MEX + 1\) 在原序列中只出现一次，那么直接把他改成 \(MEX\) 即可。 其次，如果 \(MEX + 1\) 未在原序列中出现，那么我们分两种情况考虑： 最大值大于 \(MEX + 1\)，那么我们直接把最大值换成 \(MEX\) 就好了； 最大值小于等于 \(MEX + 1\)，那么 \([0, MEX)\) 中至少得有一个数的数量大于 \(1\)，然后我们将这个多余的数换成 \(MEX\) 即可。 否则，我们就需要将最左边的 \(MEX + 1\) 和最右边的 \(MEX + 1\) 之间的所有数全都替换成 \(MEX\)。 替换需要满足一个条件，即替换后 \([0, MEX)\) 内的所有数仍然至少存在一个在序列内。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n), cnt(n + 10); int mx = 0; for (int i = 0; i &lt; n; i++) &#123; cin >> a[i]; if (a[i] &lt;= n + 1) cnt[a[i]]++; mx = max(mx, a[i]); &#125; int mex = 0; for (int i = 0; i &lt;= n; i++) &#123; if (!cnt[i]) &#123; mex = i; break; &#125; &#125; if (n == 1) &#123; cout &lt;&lt; (a[0] == 1 ? "YES\n" : "NO\n"); return; &#125; if (cnt[mex + 1] == 1) &#123; cout &lt;&lt; "YES\n"; return; &#125;else if (cnt[mex + 1] == 0) &#123; if (mx > mex + 1) cout &lt;&lt; "YES\n"; else &#123; for (int i = 0; i &lt; mex; i++) &#123; if (cnt[i] > 1) &#123; cout &lt;&lt; "YES\n"; return; &#125; &#125; cout &lt;&lt; "NO\n"; &#125; return; &#125; vector&lt;int> del(n + 7); bool pre = false; for (int i = 0; i &lt; n; i++) &#123; if (a[i] == mex + 1) pre = true; if (pre &amp;&amp; a[i] &lt;= n + 1) del[a[i]]++; if (del[mex + 1] == cnt[mex + 1]) break; &#125; for (int i = 0; i &lt; mex; i++) &#123; if (cnt[i] == del[i]) &#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 欠考虑了欠考虑了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 137</title>
    <url>/blog/posts/2349105074/</url>
    <content><![CDATA[Practice. A. Password 题意 给定 \([0, 9]\) 中的几个元素，按照升序排列给出。排除这些元素后，剩余的元素可作为密码的一部分。 其中，密码为 \(4\) 位数，只包含两种数字，且每种数字出现两次。 输出密码可行解的个数。 思路 首先，我们假设只包含数字 \(a, b\)，那么有 \(aabb, abba, bbaa, abab, baba\) 这 \(6\) 种可行解。 其次，我们统计出剩余 \(k\) 种数字，那么选两个的方案数就是 \(C^2_k\)。 因此，答案就是 \(6C^2_k\)。 不过，既然元素个数已经告诉我们了，那么 \(k = 10 - n\)。 因此我们完全不用管元素是什么。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve()&#123; int n; cin >> n; for(int i=0;i&lt;n;i++)&#123; int tmp; cin >> tmp; //啥用没有 &#125; cout &lt;&lt; (10 - n) * (9 - n) / 2 * 6 &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; Happy Happy Happy B. Permutation Value 题意 给定一个整数 \(n\)，构造一个排列，满足其所有连续子序列中排列的个数最少。 思路1 很直接的思路就是让连续的数用其他元素隔开。 并且，为了尽可能不构造出排列，我们就最好先隔一位填按顺序上答案，然后在剩余的位置按顺序填上剩余的数。 如 \(4\ 1\ 5\ 2\ 6\ 3\)。 时间复杂度：\(O(n)\) 思路2 我们可能会想到倒着输出，这样确实可以让前面的那些取法都不是排列，但是我们只要选择右边界为右端点，那么我们会多出 \(n - 1\) 个排列，因为有 \(1\)。 那么，很直接的思路就是把 \(1\) 直接移到第一个，然后倒序输出即可，不难发现和思路 \(1\) 得到的数量是一致的。 如 \(1\ 6\ 5\ 4\ 3\ 2\)。 时间复杂度：\(O(n)\) 对应AC代码（思路1） #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve()&#123; int n; cin >> n; if(n % 2 == 1) cout &lt;&lt; 1 &lt;&lt; ' '; for(int i=0;i&lt;n/2;i++)&#123; cout &lt;&lt; n / 2 + i + 1 + n % 2 &lt;&lt; ' ' &lt;&lt; i + 1 + n % 2 &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 思路2是题解做法（没想到居然这么简单 C. Save the Magazines 题意 给定一个长为 \(n\) 的二进制字符串 \(s\) 以及一个包含 \(n\) 个元素的序列 \(a\)。定义对于所有 \(i \in [2, n]\)，可进行下面的两个操作任选一： 若 \(s_{i - 1} = 0, s_i = 1\)，交换 \(a_{i - 1}\) 和 \(a_i\)（即传递 \(1\) 到前者）； 不进行操作 规定同一个 \(1\) 只能被传递一次。 遍历操作后的 \(s\)，若 \(s_i = 1\)，累计 \(ans += a_i\)。 输出 \(ans\) 的最大值。 思路 我们不妨遍历所有连续的 \(1\)，然后找出其中的最小值，将这个最小值剔除，用前面的 \(0\) 代替。 或者更容易实现地，我们遍历找出连续的 \(1\) 前面相邻的那个 \(0\)，并从这个 \(0\) 开始寻找最小值，并统计总和，最后这一段的价值就是 \(sum - min\)。 为了更加方便，我们不妨在第一个元素前插入 \(0\)，那么 \(0\) 一定是最小的，如果开头是 \(1\) 也不会影响答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; void solve()&#123; int n; cin >> n; string s; cin >> s; s = '0' + s; int ans = 0; for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=0;i&lt;=n;)&#123; int mn = a[i]; int sum = a[i]; int j = i + 1; while(j &lt;= n &amp;&amp; s[j] == '1')&#123; mn = min(mn, a[j]); sum += a[j]; j ++; &#125; i = j; ans += sum - mn; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 有个大蠢比没看到只能向前交换然后一直在想 \(dp\)，我不说是谁（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 865 Div. 2</title>
    <url>/blog/posts/1077504397/</url>
    <content><![CDATA[Contestant. Rank 900. Rating +46. A. Ian Visits Mary 题意 给定一个点 \((a, b)\)，最多另找一个点作为支点，满足原点到该点的连线不经过其他点，或者原点到支点、支点到该点的连线都不经过其他点。 输出该点，或者支点和该点。 思路 （怎么解释得这么抽象） \((0, 0) \rightarrow (a - 1, 1) \rightarrow (a, b)\) 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int a, b; cin >> a >> b; cout &lt;&lt; 2 &lt;&lt; '\n'; cout &lt;&lt; a - 1 &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; '\n'; cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 抽象 B. Grid Reconstruction 题意 给定一个 \(2 \times n\) 的矩阵，将 \([1, 2n]\) 内的数字填入矩阵。 规定可以向下或向右移动，记从原点运动到 \((2, n)\) 经过的所有方格的数字为一个序列 \(a\)，序列 \(a\) 的贡献为 \(a_1 - a_2 + a_3 - a_4 + \ldots = \sum_{i=1}^k a_i \cdot (-1)^{i+1}\)。 输出一种填写方案，满足该方案下贡献的最小值为所有方案中最大。 思路 首先，我们下去后就上不来了，那么只要尽量导引其走向我们期望的最大值即可。 下面是一种构造方法： \(\begin{array}{l}2n &amp; 2 &amp; 2n - 2 &amp; 4 &amp; 2n - 4 \ldots \\ 1 &amp; n + 1 &amp; 3 &amp; n + 3 &amp; 5 \ldots\end{array}\) 很显然，既然要更小，那么从 \(2\) 开始就会向下走，可以证明这种情况是最大的。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;vector&lt;int>> ans(2, vector&lt;int>(n)); for(int i=0;i&lt;n;i+=2) ans[1][i] = i + 1; for(int i=1;i&lt;n;i+=2) ans[1][i] = n + i; for(int i=0;i&lt;n;i+=2) ans[0][i] = n * 2 - i; for(int i=1;i&lt;n;i+=2) ans[0][i] = i + 1; for(int i=0;i&lt;2;i++) &#123; for (int j = 0; j &lt; n; j++) cout &lt;&lt; ans[i][j] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 乱猜.jpg C. Ian and Array Sorting 题意 给定一个序列 \(a\)，对于所有相邻的两个元素，定义一次操作为将这两个元素的值均加上或减去 \(1\)。 输出任意次操作后能否将序列变为不递减。 思路 首先，对于三个元素 \(a_{i - 1}, a_i, a_{i + 1}\)，如果 \(a_i &lt; a_{i - 1}\)，我们就可以将 \(a_i, a_{i + 1}\) 加上 \(a_{i - 1} - a_i\)，这样就可以让前 \(i\) 个数不递减。 同理，如果 \(a_{i + 1} &lt; a_i\)，我们就可以将 \(a_i, a_{i - 1}\) 加上 \(a_{i + 1} - a_i\)，这样就可以让后 \(i\) 个数不递减。 前者可以从前向后遍历，但不能保证最后一个数会不会小于倒数第二个数；后者可以从后向前遍历，但不能保证第一个数是否大于第二个数。 如果我们依次进行上面的操作，那么我们就能保证从前向后遍历存在的问题被解决了，并且我们已经在第一次遍历的时候保证第一个数小于等于第二个数了，所以从后往前遍历存在的问题也被解决了。 因此，依次进行上面的两个操作即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=1;i&lt;n-1;i++)&#123; if(a[i] &lt; a[i - 1])&#123; a[i + 1] -= a[i]; a[i] -= a[i]; a[i + 1] += a[i - 1]; a[i] += a[i - 1]; &#125; &#125; for(int i=n-2;i>=1;i--)&#123; if(a[i + 1] &lt; a[i])&#123; a[i - 1] -= a[i]; a[i] -= a[i]; a[i - 1] += a[i + 1]; a[i] += a[i + 1]; &#125; &#125; cout &lt;&lt; (a[0] &lt;= a[1] ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 说是乱猜和贪心，但其实也挺有道理的（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 136</title>
    <url>/blog/posts/4211298084/</url>
    <content><![CDATA[Practice. A. Immobile Knight 题意 规定一个棋子只能沿着 \(1 \times 2\) 矩形的对角线行走。 给定一个棋盘的尺寸，输出让棋子无法行走的点的位置。如果点不存在，输出任意点。 思路 能走的尺寸数量有限，我们直接分类讨论，这边定义较短边为 \(n\)，较长边为 \(m\)。 \(n = 1\)，那么随便哪个点都是答案； \(n = 2或3, m = 3\)，那么中心点就是答案 其余情况，随便输出即可。 注意，输出的点一定要在棋盘内，否则是无效答案。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; bool f = n > m; if(n > m) swap(n , m); if(n == 1) cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; '\n'; else if(n == 2 &amp;&amp; m &lt;= 3 || n == 3 &amp;&amp; m == 3) &#123; if(f) swap(n, m); cout &lt;&lt; (n + 1) / 2 &lt;&lt; ' ' &lt;&lt; (m + 1) / 2 &lt;&lt; '\n'; &#125; else cout &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 分类讨论即可~ B. Array Recovery 题意 定义 \(d\) 序列为原非负序列 \(a\) 构造而成，构造满足 \(d_1 = a_1, d_i = |a_i - a_{i - 1}|\)。 给定 \(d\)，判断是否能唯一确定 \(a\)，若能，输出 \(a\)。 思路 首先，我们化简右式，得到 \(a_i = a_{i - 1} ± d_i\)。 因为 \(a\) 的所有元素都是非负的，因而 \(a_{i - 1} ± d_i \geq 0\)。 那么很明显了，我们既然要唯一确定 \(a\)，那么我们只能 \(+ d_i\)，而 \(- d_i\) 的条件就是 \(a_{i - 1} \geq d_i\)。 因而，只要 \(a_{i - 1} \geq d_i\)，那么就无法唯一确定，否则我们按顺序构造出原序列 \(a\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; //让它只能递增 int n; cin >> n; vector&lt;int> ans(n); cin >> ans[0]; bool f = true; for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; ans[i] = ans[i - 1] + cur; if(cur != 0 &amp;&amp; ans[i - 1] >= cur) f = false; &#125; if(f)&#123; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125;else cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 简单的构造题捏 C. Card Game 题意 给定 \(n\) 张牌，\(n\) 为偶数，每个牌具有一个数字，所有牌的数字组成的序列是长为 \(n\) 的排列。 现在，给定两个玩家 \(A, B\)，每个玩家拥有 \(\frac{n}{2}\) 张牌，规定奇数局 \(A\) 先手，偶数局 \(B\) 先手。每一局每个玩家要打出一张牌并弃置，规定后手要打出比先手大的牌，否则先手赢。所有回合结束后，若没有玩家赢，那么平局。 在所有牌的分配方案中，统计 \(A, B\) 赢的方案数以及平局的方案数，并输出这三个数\(\mod 998244353\)。 思路 首先，平局只有一种方案，我们约定一个由 \(A, B\) 组成的字符串为从 \(1\) 开始按顺序分牌的方案，那么这个方案就是 \(BAABBAABBA\ldots\) 观察不难得到，只要某个方案有一个位置的字符和上面不一样，那么就可以断定已经有玩家胜利了，并且这个位置之后的元素可以任意分配。 也就是说，我们可以采用递归的方法计算。如果前 \(n\) 个数已经确定，那么我们只需计算组合数 \(C^\frac{n}{2}_{n-1}, C^\frac{n}{2}_{n-2}\)，然后交叉累计即可（即按照 \(BA, AB, BA,\ldots\) 的顺序计算）。 当然会涉及到求组合数，因为本题数据量不大，但是数据范围大，我们不妨用 \(java\) 的大数。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; private static BigInteger fact(int to)&#123; BigInteger ans = BigInteger.ONE; for(int i=2;i&lt;=to;i++) ans = ans.multiply(BigInteger.valueOf(i)); return ans; &#125; private static BigInteger C(int n, int k)&#123; return fact(n).divide(fact(n - k)).divide(fact(k)); &#125; private static BigInteger[] calc(int n)&#123; if(n == 2) return new BigInteger[]&#123;BigInteger.ONE, BigInteger.ZERO, BigInteger.ONE&#125;; else&#123; BigInteger[] pre = calc(n - 2); return new BigInteger[]&#123;C(n - 1, n / 2).add(pre[1]), C(n - 2, n / 2).add(pre[0]), BigInteger.ONE&#125;; &#125; &#125; private static void solve(Console console) throws Exception &#123; BigInteger mod = BigInteger.valueOf(998244353); int n = console.nextInt(); for(BigInteger ans : calc(n)) console.print(ans.mod(mod) + " "); console.println(); &#125; public static void main(String[] args) throws Exception &#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0) solve(console); console.close(); &#125; //快读模板 此处略去 public static class Console implements Closeable &#123;&#125; &#125; 有点暴力.jpg]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 297</title>
    <url>/blog/posts/2326564761/</url>
    <content><![CDATA[Contestant. Rank 1053. Rating +125. A. Double Click 题意 定义两个点击时刻 \(s_1, s_2\) 的差小于等于某个值 \(D\) 时视为在靠后的时间点 \(s_2\) 时触发双击。 给定一个点击时刻的序列，判断哪个时刻触发了第一次双击。无双击输出 \(-1\)。 思路 如题，模拟即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, d; cin >> n >> d; int ans = -1; int pre; cin >> pre; for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur - pre &lt;= d &amp;&amp; ans == -1) ans = cur; pre = cur; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 再点一次返回到主页面 B. chess960 题意 给定一个由 \(KQRRBBNN\) 经过任意排列后的字符串，输出其是否满足下面的要求： \(B\) 的两个下标的奇偶性不同； \(K\) 在两个 \(R\) 中间 思路 如题，模拟即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; string s; cin >> s; int k, q; vector&lt;int> r, b, n; for(int i=0;i&lt;8;i++)&#123; char x = s[i]; if(x == 'K') k = i; else if(x == 'Q') q = i; else if(x == 'R') r.emplace_back(i); else if(x == 'B') b.emplace_back(i); else if(x == 'N') n.emplace_back(i); &#125; bool ans = true; if(b[0] % 2 == b[1] % 2) ans = false; if(k &lt; r[0] || k > r[1]) ans = false; cout &lt;&lt; (ans ?"Yes\n" : "No\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 两面包夹芝士 C. PC on the Table 题意 给定 \(H\) 个由 "." 和 "T" 组成的字符串，规定两个相邻的 \(T\) 可以替换为 \(PC\)，输出替换次数最多的一种方案。 思路 直接暴力枚举替换即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; for(int i=0;i&lt;n;i++)&#123; string s; cin >> s; for(int j=1;j&lt;m;j++)&#123; if(s[j] == s[j - 1] &amp;&amp; s[j] == 'T')&#123; s[j - 1] = 'P'; s[j] = 'C'; j ++; &#125; &#125; cout &lt;&lt; s &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; PC? D. Count Subtractions 题意 给定两个数 \(A, B\)，规定一次操作为将较大的数减去较小的数。 输出让两数相等的最小操作数。 思路 这题可以等价为重复操作直到某一个数变为 \(0\)，那么我们将计算得到的结果 \(-1\) 即可。 若 \(A &gt; B\)，那么在 \(A\) 减到小于等于 \(B\) 后，值恰好为 \(A \bmod b\)，此时操作数就是 \(\lfloor\frac{a}{b}\rfloor\)。 如上，我们暴力即可。 时间复杂度：反正还行吧（ 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int a, b; cin >> a >> b; int ans = 0; while(a != 0 &amp;&amp; b != 0) &#123; if(b > a) swap(a, b); ans += a / b; a %= b; &#125; cout &lt;&lt; ans - 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 暴力暴力 E. Kth Takoyaki Set 题意 给定一个序列，通过任选数量、任选元素相加得到新的序列，序列升序且无重复元素，输出序列中第 \(k\) 个数，其中 \(k\) 给定。 思路 我们可以直接暴力。 首先，我们希望可以找到一个与当前最大值最接近的那个数，或者说，将组成最大值的某个数替换，这样通过递推就可以使构造出来的序列的相邻元素差值最小。 所以，我们不妨用 \(set\) 去重并顺便排序，对于查找与当前最大值最接近的那个数，我们可以用二分。 思路具有一定的贪心性，此处暂时不给出证明（ 时间复杂度：\(O(pn \log p)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; set&lt;int> st; st.emplace(0); while(st.size() != k + 1)&#123; int mx = *st.rbegin(), now = inf; for(int i=0;i&lt;n;i++)&#123; now = min(now, *st.upper_bound(mx - a[i]) + a[i]); &#125; st.emplace(now); &#125; cout &lt;&lt; *st.rbegin() &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 其实是不会证（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 824 Div. 2</title>
    <url>/blog/posts/1644457156/</url>
    <content><![CDATA[Practice. A. Working Week 题意 给定 \(n\) 个格子，规定第 \(1\) 个格子不能标记，第 \(n\) 个格子一定被标记。按照要求标记三个点后，格子被划分成三段，记长度为 \(l_1, l_2, l_3\)。 输出 \(\min(|l_1 - l_2|, |l_2 - l_3|, |l_3 - l_1|)\) 的最大值。 思路 显然，我们可以在第二个点做上标记，这样就可以让差值尽可能大。 那么，我们来考虑剩下那个点。因为对称性，我们不妨令 \(l_2 \leq l_3\)。 很明显，\(\min(|l_1 - l_2|, |l_2 - l_3|, |l_3 - l_1|) = \min(l_2 - 1, n - 4 - 2l_2)\) 如果前者更小，那就需要满足 \(l_2 \leq \frac{n}{3} - 1\)，那么 \(l_2 - 1\) 的最大值就是 \(\frac{n}{3} - 2\)。 如果后者更小，那就需要满足 \(l_2 \geq \frac{n}{3} - 1\)，那么 \(n - 4 - 2l_2\) 的最大值就是 \(n - 4 - 2(\frac{n}{3} - 1) = \frac{n}{3} - 2\)。 所以，答案就是 \(\frac{n}{3} - 2\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve()&#123; int n; cin >> n; cout &lt;&lt; n / 3 - 2 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 其实也可以猜出来（x B. Tea with Tangerines 题意 给定长度为 \(n\) 的序列 \(a\)，其中 \(a_i\) 可切割为任意段。在切割结束后，需要满足任意两段中 较小的那段的 两倍 严格小于 较长那段。输出需要切割的最小次数。 思路 首先，我们先设最小那段为 \(x\)，在按照同一长度 \(2x-1\) 切割后，我们有可能会多出一小段长度小于 \(x\) 的，但我们显然可以各取前面长为 \(2x - 1\) 的那几段的一部分来填补，而且一定不会让前面的那几段减到比 \(x\) 小。 那么，答案就是 \(\displaystyle{\sum_{i=1}^{n}\left\lceil\frac{a_i}{2 \cdot x - 1}\right\rceil}\) 显然，我们希望尽可能减少切割次数，也就是说至少有一段是不用切的。 那么，升序排序 \(a\) 后，\(\displaystyle{\sum_{i=1}^{n}\left\lceil\frac{a_i}{2 \cdot a_1 - 1}\right\rceil}\) 就是答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long void solve()&#123; int n; cin >> n; int ans = 0, a0; cin >> a0; for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; ans += (cur - 1) / (2 * a0 - 1); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t = 1; cin >> t; while(t --) solve(); &#125; 有点抽象 C. Phase Shift 题意 给定一个由大写字母组成的字符串，构造一个字符串映射，满足映射对应的有向图为一个包含 \(A - Z\) 内所有字母的单环。 输出映射后字典序最小的结果。 思路 我们可以暴力枚举每一位，对于该位，如果我们并没有创建映射，我们就暴力按字母表顺序枚举所有字母，找出第一个没有被创建且和原字母不一样的字母并创建映射；如果创建了映射，我们直接使用该映射即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n; string t; cin >> n >> t; vector&lt;int> e(26, -1), re(26, -1); for(int i=0;i&lt;n;i++)&#123; int cur = t[i] - 'a'; if(e[cur] == -1) &#123; for (int j = 0; j &lt; 26; j++) &#123; if (re[j] == -1) &#123; int last = j, cnt = 0; while (e[last] != -1) last = e[last], cnt++; if (last != cur || cnt == 25) &#123; e[cur] = j, re[j] = cur; break; &#125; &#125; &#125; &#125; t[i] = (char) (e[cur] + 'a'); &#125; cout &lt;&lt; t &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 就很暴力（x D. Meta-set 题意 给定 \(n\) 个长度为 \(m\) 的序列，序列元素由 \(0, 1, 2\) 构成。 若一个 由 \(3\) 个不同序列 组成的三元组 满足 对于 所有序列的 第 \(i\) 个元素组成的 新序列 均为相等的值或为 \(012\) 的排列，那么这个三元组是好的。 输出序列的所有五元组中 有至少两个好三元组 的个数。 思路 （题意还是介绍得有点绕，可以去看原题的样例） 首先，数据量并不大，\(O(n ^ 2)\) 的复杂度是完全可以接受的，那么我们不妨去枚举所有的三元组中的其中两个序列，然后我们就可以按照题意构造出第三个序列，我们直接记录构造出的这个序列可以对应多少个 "两个序列"。 记录完后，我们直接枚举所有序列，对于对应的个数 \(cnt\)，我们就可以得到 \(C^2_{cnt}\) 个满足条件的五元组。 时间复杂度：\(O(n^2 \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, k; cin >> n >> k; vector&lt;vector&lt;int>> a(n, vector&lt;int>(k)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;k;j++) cin >> a[i][j]; map&lt;vector&lt;int>, int> cnt; for(int i=0;i&lt;n;i++) for(int j=i+1;j&lt;n;j++)&#123; vector&lt;int> need(k); for(int t=0;t&lt;k;t++)&#123; need[t] = a[i][t] == a[j][t] ? a[i][t] : 3 - a[i][t] - a[j][t]; &#125; cnt[need] ++; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; if(cnt[a[i]] >= 2) ans += cnt[a[i]] * (cnt[a[i]] - 1) / 2; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 有点像状压]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 825 Div. 2</title>
    <url>/blog/posts/3295897463/</url>
    <content><![CDATA[Practice. A. Make A Equal to B 题意 给定两个长度为 \(n\) 的二进制序列 \(a, b\)，定义操作如下： 选择任意 \(i\)，将 \(a_i\) 改为 \(1 - a_i\)； 任意排序 \(a\) 输出操作数的最小值。 思路 很显然，我们直接统计两个序列中 \(0, 1\) 的个数，然后在 将 \(0\) 的个数变为一致需要的操作数 和 将 \(1\) 的个数变为一致需要的操作数 中取最小值即可。此时，答案为最小操作数 \(+ 1\)。 当然，如果只需改一次，我们就不用排序了，所以我们顺便计算一下按原顺序排列的情况下有多少数不一样，最后和答案取最小值即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; int c1 = 0, c2 = 0, d1 = 0, d2 = 0; vector&lt;int> a(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; if(a[i] == 0) c1 ++; else c2 ++; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur != a[i]) ans ++; if(cur == 0) d1 ++; else d2 ++; &#125; ans = min(ans, (abs(c1 - d1) + abs(c2 - d2)) / 2 + 1); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 思路后面那个容易没考虑到捏 B. Playing with GCD 题意 给定一个长度为 \(n\) 的数组 \(a\)，输出是否能构造出一个长度为 \(n + 1\) 的数组 \(b\)，满足 \(a_i = gcd(b_i, b_{i + 1})\)。 思路 首先，只有当 \(gcd(lcm(a_{i - 1}, a_i), lcm(a_i, a_{i + 1})) = a_i\) 的时候才有解，否则我们会很轻松将 \(a_i\) 变为 \(k a_i\)，甚至为 \(1\)。 那么，我们直接计算出所有的 \(b_i\)，然后枚举即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1), b(n + 2); for(int i=1;i&lt;=n;i++) cin >> a[i]; b[1] = a[1], b[n + 1] = a[n]; for(int i=2;i&lt;=n;i++) b[i] = lcm(a[i - 1], a[i]); bool f = true; for(int i=1;i&lt;=n;i++)&#123; if(gcd(b[i], b[i + 1]) != a[i]) f = false; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 但其实我并不会严格证明（x C1. Good Subarrays (Easy Version) 题意 定义 如果一个序列 \(p\) 满足所有 \(p_i \geq i\)，那么这个序列是好的。 给定一个序列 \(a\)，输出它的所有连续子序列中 好序列 的个数。 思路 我们固定左边界来计算右边界能到达哪里，显然，当 \(a_r &lt; r - l + 1\) 时 \(r\) 不满足题意。 因为右边界肯定不会回退（既然 \(p_i \geq i\)，那么 \(p_i &gt; i - 1\)），那么我们可以直接循环，得到一个 \(O(n)\) 复杂度的解法。 这种暴力做法不可以用到 \(C2\) 中，而是需要改进为 \(dp\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++)cin >> a[i]; int ans = 0; int r=1; for(int l = 1;l&lt;=n;l++) &#123; while (r &lt;= n &amp;&amp; a[r] >= r - l + 1) r++; ans += r - l; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 就很无脑]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 864 Div. 2</title>
    <url>/blog/posts/3863896633/</url>
    <content><![CDATA[Contestant. Rank 1888. Rating +1. 查重后刚好加了一分（跟白打没区别 A. Li Hua and Maze 题意 给定一个 \(n \times m\) 的矩阵以及两个点 \((x_1, y_1), (x_2, y_2)\)。其中，两点满足 \(|x_1-x_2|+|y_1-y_2|\geq 2\)。在矩阵中插入若干个障碍，使得两点不连通。 输出需要插入的最少障碍数。 思路 很显然，我们把起点或者终点包起来即可。 不要写错就是 \(win\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, m, x1, y1, x2, y2; cin >> n >> m >> x1 >> y1 >> x2 >> y2; int ans = 4; if(x1 == 1 || y1 == 1 || x2 == 1 || y2 == 1 || x1 == n || y1 == m || x2 == n || y2 == m) ans = 3; if(((x1 == 1 || x1 == n) &amp;&amp; (y1 == 1 || y1 == m)) || ((x2 == 1 || x2 == n) &amp;&amp; (y2 == 1 || y2 == m))) ans = 2; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 我为什么会写错啊啊啊啊啊啊（艹 B. Li Hua and Pattern 题意 给定一个 \(n \times n\) 的矩阵，以及矩阵中若干标记点的坐标。定义一次操作可以取消或加上标记，现在给定操作数 \(k\)，在操作数用完的条件下，输出是否可以让整个矩阵旋转 \(180°\) 后和旋转前一样。 思路 首先，\(180°\) 旋转后，如果 \(n\) 为奇数，那么中心点是不会变的，也就是说 \(k\) 多余时可以全都操作在中心点上。 其次，题面等价于“将原矩阵旋转 \(180°\) 后进行操作，使其和原矩阵一致”。 那么，我们旋转后统计不一样的格子的个数 \(cnt\)。 我们不难发现，\(cnt\) 一定是偶数，因为具有对称性。而恰恰因为这个，我们只需 \(\frac{cnt}{2}\) 次操作即可让矩阵满足条件。 那么，如果操作数不够，就直接输出 \(NO\)。 否则，\(n\) 为偶数的时候，我们就需要考虑剩余操作数的奇偶性。因为在同一个点上操作两次等价于没有操作，所以当剩余的数量为偶数时，输出 \(YES\)，否则是 \(NO\)。 \(n\) 是奇数的时候，就和思路的第一句话所说的那样，直接判 \(YES\) 即可。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, k; cin >> n >> k; vector&lt;vector&lt;int>> a(n, vector&lt;int>(n)), b(n, vector&lt;int>(n)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; cin >> a[i][j]; b[n - i - 1][n - j - 1] = a[i][j]; &#125; int dif = 0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(a[i][j] != b[i][j]) dif ++; dif /= 2; if(dif > k)&#123; cout &lt;&lt; "NO\n"; return; &#125; k -= dif; cout &lt;&lt; (n % 2 == 1 || k % 2 == 0 ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 我怎么就没想到 \(n\) 的奇偶性呢 C. Li Hua and Chess 题意 这是一道互动题。 给定一个 \(n \times m\) 的矩阵，定义一个棋子一次可以从 \(8\) 个方向移动一格或 \(\sqrt 2\) 格。 现在，在最多询问 \(3\) 次的前提下，每次询问给出一个坐标，将会得到目标棋子走到这个坐标的最少次数。 判断目标棋子的位置，并输出坐标。 思路 首先，我们从 \((1, 1)\) 展开我们的询问。 我们会得到一个数 \(t\)，通过画图我们可以看到，同一次数对应的下标集合是 \(L\) 型的，而超出 \(\min(n, m)\) 后对应的集合是一个 长或宽为 \(1\) 的长方形。 对于后者，我们可以根据 \(n, m\) 的大小确定 \(t + 1\) 是所求点的横/纵坐标，那么我们只需将未知的坐标记为 \(1\)，继续询问，所得到的 \(p + 1\) 即为未知的那个坐标，最后输出即可。 对于前者，我们最多还需问两次（不问白不问，我们直接问 \(2\) 次吧）： 询问 \((t + 1, t + 1)\)，我们得到 \(p\)，那么 \((t + 1 - p, t + 1), (t + 1, t + 1 - p)\) 其中之一就是我们需要的答案 我们询问任意一个，如 \((t + 1 - p, t + 1)\)，如果得到 \(0\)，那么这个点就是我们要的，否则另外一个点就是我们要的。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; cout &lt;&lt; "? 1 1\n"; cout.flush(); int t; cin >> t; if(t >= min(n, m))&#123; if(n > m)&#123; cout &lt;&lt; "? " &lt;&lt; t + 1 &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; '\n'; cout.flush(); int p; cin >> p; cout &lt;&lt; "! " &lt;&lt; t + 1 &lt;&lt; ' ' &lt;&lt; p + 1 &lt;&lt; '\n'; cout.flush(); &#125;else&#123; cout &lt;&lt; "? " &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; t + 1 &lt;&lt; '\n'; cout.flush(); int p; cin >> p; cout &lt;&lt; "! " &lt;&lt; p + 1 &lt;&lt; ' ' &lt;&lt; t + 1 &lt;&lt; '\n'; cout.flush(); &#125; &#125;else&#123; cout &lt;&lt; "? " &lt;&lt; t + 1 &lt;&lt; ' ' &lt;&lt; t + 1 &lt;&lt; '\n'; cout.flush(); int p; cin >> p; cout &lt;&lt; "? " &lt;&lt; t + 1 - p &lt;&lt; ' ' &lt;&lt; t + 1 &lt;&lt; '\n'; cout.flush(); int q; cin >> q; if(q == 0) cout &lt;&lt; "! " &lt;&lt; t + 1 - p &lt;&lt; ' ' &lt;&lt; t + 1 &lt;&lt; '\n'; else cout &lt;&lt; "! " &lt;&lt; t + 1 &lt;&lt; ' ' &lt;&lt; t + 1 - p &lt;&lt; '\n'; cout.flush(); &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 是哪个大铸币想着用 \(3\) 个边角去算啊，我不说是谁（x]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 826 Div. 3</title>
    <url>/blog/posts/2191281532/</url>
    <content><![CDATA[Practice. A. Compare T-Shirt Sizes 题意 比较 \(T\) 恤的尺码。 其中，\(XXL &gt; XL, XXS &lt; XS\)。 思路 我们记 \(M = 0\)，其余的按照 \(X\) 的个数计算即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string a, b; cin >> a >> b; int na = a.size(), nb = b.size(); map&lt;char, int> mp = &#123;&#123;'S', -1&#125;, &#123;'M', 0&#125;, &#123;'L', 1&#125;&#125;; int va = mp[a[na - 1]] * na, vb = mp[b[nb - 1]] * nb; cout &lt;&lt; (va == vb ? '=' : (va > vb ? '>' : '&lt;')) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 无脑做即可 B. Funny Permutation 题意 给定整数 \(n\)，构造一个长为 \(n\) 的排列 \(a\)，满足 \(a_i\) 的至少一个相邻元素的值为 \(a_i ±1\)，且 \(a_i \neq i\)。 思路 首先，如果没有第二个条件，我们直接按顺序输出即可。 如果考虑第二个条件，如果 \(n\) 为偶数，那我们直接倒着输出即可。 但 \(n\) 为奇数的时候，我们就需要规避中间那个数不满足条件的情况了。 如何规避呢？我们只需先按顺序构造序列，然后把前 \(\frac{n + 1}{2}\) 个数移到最后就可以了。 可以证明，这种构造对任意长度的排列均满足。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; if (n == 3) cout &lt;&lt; -1 &lt;&lt; '\n'; else &#123; for(int i=n;i>n/2 + n % 2;i--) cout &lt;&lt; i &lt;&lt; ' '; for(int i=1;i&lt;=n/2+n%2;i++) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 很有趣的构造题（x C. Minimize the Thickness 题意 给定一个序列，将其分割为若干段 元素和相等 的片段，输出最长片段的长度最小值。 思路 很暴力。我们直接枚举第一段的长度，然后去分割，找出最长片段。最后我们统计最小值即可。 时间复杂度：\(O(n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> sum(n + 1); for(int i=1;i&lt;=n;i++) &#123; int cur; cin >> cur; sum[i] = sum[i - 1] + cur; &#125; auto check = [n, sum](int cnt)&#123; bool ans = true; int pre = 0, mx = cnt; for(int i=1;i&lt;=n;i++)&#123; if(sum[i] - sum[pre] > sum[cnt])&#123; ans = false; break; &#125;else if(sum[i] - sum[pre] == sum[cnt])&#123; mx = max(mx, i - pre); pre = i; &#125; &#125; return make_pair(mx, ans &amp;&amp; pre == n); &#125;; int ans = n; for(int i=1;i&lt;=n;i++)&#123; auto e = check(i); if(e.sc) ans = min(ans, e.fs); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 无脑暴力.cpp D. Masha and a Beautiful Tree 题意 给定一个满二叉树的所有叶节点的编号，规定编号序列为长度为 \(n\) 的排列。 判断是否可以通过 若干次 交换 任意 左右子树的位置 来让排列升序，若可以，输出最小操作数。 思路 显然，我们不难发现，两个父亲一样的叶节点的值相差 \(1\)。 有趣的是，我们规定这些父亲节点（即第二层叶节点）的值为子节点的最大值除以 \(2\)，那么依然需要满足上面的条件。 也就是说，我们只需从最底层向上合并并判断即可。 在每次判断的时候，我们比较一下左右两个节点的大小，如果左边的大，那么就需要一次操作，统计即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> ori(n); for(int i=0;i&lt;n;i++) cin >> ori[i]; int p = 0, tp = n; while(tp > 0) tp /= 2, p ++; int ans = 0; for(int i=1;i&lt;p;i++)&#123; int cnt = n / pow(2, i); vector&lt;int> now(cnt); for(int j=0;j&lt;cnt;j++)&#123; if(abs(ori[j * 2] - ori[j * 2 + 1]) != 1)&#123; ans = -1; break; &#125; if(ori[j * 2] > ori[j * 2 + 1]) ans ++; now[j] = (ori[j * 2] + 1) / 2; &#125; if(ans == -1) break; ori = now; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 找规律.jpg E. Sending a Sequence Over the Network 题意 给定一种处理方式：将给定序列拆成若干段，在每段的前面或后面插入这一段的长度。 现在，给定一个序列，判断是否为处理后的序列。 思路 我们不妨考虑递推，即 \(dp\)，用递推的方式记录当前位置之前的元素是否满足条件。 那么， 如果这个数是个数： 他是前面序列的个数，那么 \(dp[i]\ |= dp[i - a_i - 1]\) （该序列有效，那么 \(dp_i\) 和跳过这个序列的前一个序列的 \(dp\) 值有关） 他是后面序列的个数，那么 \(dp[i + a_i]\ |= dp[i - 1]\)。 最后，\(dp[n]\) 即为答案。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> dp(n + 1); dp[0] = true; for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; if(i - cur >= 1) dp[i] |= dp[i - cur - 1]; if(i + cur &lt;= n) dp[i + cur] |= dp[i - 1]; &#125; cout &lt;&lt; (dp[n] ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 嘶，想到了还真不难]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 146</title>
    <url>/blog/posts/3024280035/</url>
    <content><![CDATA[Contestant. Rank 3437. Unrated. A. Coins 题意 给定 \(n, k\)，输出是否可以找到一对整数 \(x, y\)，满足 \(2 \cdot x + k \cdot y = n\)。 思路 移项可得，\(x = \frac{n - ky}{2}\)。 那么，只要分母是偶数即可。 也就是说，我们考虑 \(n, k\) 的奇偶性：当 \(n\) 为奇数，\(k\) 为偶数的时候就无法满足。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, k; cin >> n >> k; if(n % 2 == 0) cout &lt;&lt; "YES\n"; else&#123; if(k % 2 == 0) cout &lt;&lt; "NO\n"; else cout &lt;&lt; "YES\n"; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 移个项就ok力 B. Long Legs 题意 给定坐标 \((x, y)\)，定义操作如下三选一： \((x, y) \rightarrow (x + m, y)\) \((x, y) \rightarrow (x, y + m)\) \(m = m + 1\) 输出从坐标原点到 \((x, y)\) 需要的最小操作数。 思路 我们先假设最后的 \(m\) 值已知，对于横坐标 \(x\)： 如果 \(x \% m = 0\)，那么走 \(\frac{x}{m}\) 步即可 如果 \(x \% m \neq 0\)，那么我们会多出 \(x - \lfloor \frac{x}{m} \rfloor m\) 步，不难发现多出来的步数小于 \(m\)。 那么，我们直接在 \(m\) 递增到 \(x - \lfloor \frac{x}{m} \rfloor m\) 的时候走一步即可。因此，最后需要 \(\lceil \frac{x}{m} \rceil\) 步。 对于 \(m\)，暴力枚举即可。 有趣的是，我们只需枚举到 \(3e5\)，对于枚举到的 \(i\)，我们分别将 \(m\) 赋为 \(i, \frac{\max(a, b)}{i}\) 计算即可。 时间复杂度：\(O(3e5)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; int cal(int a, int b, int&amp; ans, int i) &#123; int cur = i - 1; if(a % i != 0) cur ++; if(b % i != 0) cur ++; cur += a / i + b / i; ans = min(ans, cur); return ans; &#125; void solve() &#123; int a, b; cin >> a >> b; if(a > b) swap(a, b); int ans = inf; for(int i=0;i&lt;=3e5;i++)&#123; ans = cal(a, b, ans, i + 1); if(i != 0) ans = cal(a, b, ans, b / i + 1); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 笑死，卡半天快速算 \(m\) 的方法，结果只要暴力。暴力没写好还 \(fst\) 了（恼 C. Search in Parallel 题意 给定 \(n\) 中颜色，两个机器人可以按照指定序列按照给定的时间间隔 \(s_1, s_2\) 访问颜色。 现在，给定每个颜色需要访问的次数，输出两个机器人的访问序列，使最后需要的总时长最小。 思路 贪心。 我们先按照需要访问的次数排个序，然后依次遍历。 如果这个数放到第一个机器人的序列中，那么循环一次需要 \(s_1(n_a + 1)\) 个单位时间。同理，第二个需要 \(s_2(n_b + 1)\)。 那么，我们一定希望需要的时间更少，所以我们比较上面的值，然后放到较小的那个对应的序列中即可。 如何证明呢？因为之后放入元素后，会导致循环一次的时间变大，所以尽早放入是最佳选择。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, s1, s2; cin >> n >> s1 >> s2; vector&lt;pii> r(n); for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; r[i] = &#123;cur, i + 1&#125;; &#125; sort(r.rbegin(), r.rend()); vector&lt;int> a, b; for(int i=0;i&lt;n;i++)&#123; if((a.size() + 1) * s1 &lt; (b.size() + 1) * s2) a.emplace_back(r[i].sc); else b.emplace_back(r[i].sc); &#125; cout &lt;&lt; a.size() &lt;&lt; ' '; for(auto e : a) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; cout &lt;&lt; b.size() &lt;&lt; ' '; for(auto e : b) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 无脑乱猜即可（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 863 Div. 3</title>
    <url>/blog/posts/1424911393/</url>
    <content><![CDATA[Contestant(alt). Rank 993. Rating +168. A. Insert Digit 题意 给定一个数 \(a\)，以及一个 \([0, 9]\) 的数 \(b\)，将 \(b\) 插入 \(a\)，输出最大的数。 思路 我们从后往前找出最后一个小于 \(b\) 的数，放在这个数前面就可以让结果最大。 当然，如果没有比它小的数，直接放在最后即可。 时间复杂度：\(O(n)\) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n; char d; string w; cin >> n >> d >> w; int idx = n; for(int i=n-1;i>=0;i--)&#123; if(w[i] &lt; d) &#123; idx = i; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(i == idx) cout &lt;&lt; d; cout &lt;&lt; w[i]; if(i == n - 1 &amp;&amp; idx == n) cout &lt;&lt; d; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 很简单的贪心捏（我怎么做了这么久 B. Conveyor Belts 题意 给定一个 \(n \times n\) 的矩阵，\(n\) 为偶数。将矩阵从外向里分层为 \(\frac{n}{2}\) 圈，如下图所示： 给定两个点，输出从一个点走到另一个点需要跨越的边界的最少数量。 思路 首先，这个图是对称的，那么我们只需把点全都对阵到左上角即可。 那么，我们规定最外层是第 \(1\) 层，以此类推，我们可以得到： 对于 \((x, y)\)，它位于第 \(\min(x, y)\) 层。 那么，我们取差值的绝对值即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n, x1, y1, x2, y2; cin >> n >> x1 >> y1 >> x2 >> y2; if(x1 > n / 2) x1 = n - x1 + 1; if(y1 > n / 2) y1 = n - y1 + 1; if(x2 > n / 2) x2 = n - x2 + 1; if(y2 > n / 2) y2 = n - y2 + 1; int i1 = min(x1, y1), i2 = min(x2, y2); cout &lt;&lt; abs(i1 - i2) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 我怎么那么蠢，会卡这么久（ C. Restore the Array 题意 定义对于一个数组 \(a\)，循环遍历 \([1, n-1]\)，将所有 \(\max(a_i, a_{i + 1})\) 提取出来作为新的数组。 现在给定操作后的数组，构建出一个可能的原数组，保证一定能构造出。 思路 记原数组为 \(a\)，新数组为 \(b\)。 那么，我们来考虑 \(\max(\min(b_{i - 1}, b_i), \min(b_i, b_{i + 1}))\)，我们可以经过分类讨论得到最后的答案为 \(b_i\)。 也就是说，\(a_i = \min(b_i, b_{i + 1})\)。 对于边界，\(\max(b_1, \min(b_1, b_2)) = b_1, \max(\min(b_{n - 2}, b_{n - 1})) = b_{n - 1}\)。 也就是说，\(a_1 = b_1, a_n = b_{n - 1}\)。 按照上述结论构造即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n - 1); for(int i=0;i&lt;n - 1;i++) cin >> a[i]; for(int i=0;i&lt;n;i++)&#123; if(i == 0) cout &lt;&lt; a[0] &lt;&lt; ' '; else if(i == n - 1) cout &lt;&lt; a[n - 2] &lt;&lt; ' '; else cout &lt;&lt; min(a[i - 1], a[i]) &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 有煞笔，我不说是谁 D. Umka and a Long Flight 题意 记 \(F(x)\) 为第 \(x\) 个斐波那契数。给定长为 \(F(n)\)，宽为 \(F(n + 1)\) 的矩阵，矩阵中 \((x, y)\) 被标记。将矩阵分割为 \(n - 1\) 个子矩阵，满足下面的条件： 被标记的点位于一个长为 \(1\) 或 宽为 \(1\) 的矩阵内 无长宽均重复的矩阵 所有矩阵的边长都是斐波那契数 输出是否可以满足条件。 思路 显然，要变为边长为 \(1\) 的矩阵，我们就需要按斐波那契数的计算方式分割。 我们将宽切割为 \(F(n), F(n - 1)\)，判断点落在哪个区域，为方便计算，我们直接改变点的坐标，让点落在较小的区域即可。 切割之后，我们翻转横纵坐标即可。 这样操作的话，我们可以发现，\(y \in (F(n) - F(n - 1), F(n - 1)]\) 时， 也就是卡在中间的情况，这时最后构造出的分隔方法无法满足条件 \(2\)。 如上，循环判断即可。 斐波那契数可以预先初始化。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; int f[50]; void init()&#123; f[1] = f[2] = 1; for(int i=3;i&lt;=49;i++) f[i] = f[i - 1] + f[i - 2]; &#125; void solve() &#123; int n, x, y; cin >> n >> x >> y; int t = n + 1; while(t > 1)&#123; if(y &lt;= f[t] &amp;&amp; y > f[t + 1] - f[t])&#123; cout &lt;&lt; "NO\n"; return; &#125; if(y >= f[t]) y -= f[t]; t --; swap(x, y); &#125; if(t == 1) cout &lt;&lt; "YES\n"; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 复杂但是很形象之 E. Living Sequence 题意 去掉所有包含 \(4\) 的数字，从大到小排序后，对于所有询问，输出第 \(x\) 个数。 思路 等价于去掉 \(9\)，也就是说，在 \(8\) 的时候就进一了，不难发现就是 \(9\) 进制。 转 \(9\) 进制后，将所有大于等于 \(4\) 的数字加一即可。 时间复杂度：\(O(\log_9n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> ans; while(n > 0)&#123; ans.emplace_back(n % 9); n /= 9; &#125; for(int i=ans.size()-1;i>=0;i--)&#123; if(ans[i] >= 4) cout &lt;&lt; ans[i] + 1; else cout &lt;&lt; ans[i]; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 为什么这题比 A 还简单（x F. Is It Flower? 题意 定义 \(k\) 环如下： 中心为一个 \(k\) 个点组成的环； 中心环上每一个点都作为另一个单独的 \(k\) 个点组成的环的顶点 \(3\) 环如下图： 现在，给定一个图，判断是否是 \(k\) 环图。 思路 首先我们可以进行特判，\(k\) 环图的点的数量为 \(k ^ 2\)，边的个数为 \(k + k ^ 2\)，且中间环上所有点的度数都是 \(4\)，其余点的度数都是 \(2\)。 后两个条件不好判断，但我们可以先判断是否存在度数不是 \(2, 4\) 的点。 特判结束后，我们考虑找出中间环，然后删掉这个环上的边（保留顶点），最后就会剩下 \(k\) 个点数为 \(k\) 的环。 因而，我们需要做的就是： 判断是否只存在一个连通块； 删去中间的环上的边，保留顶点； 枚举所有剩下的环，判断长度 时间复杂度：\(O(n + m)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 998244353, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); template&lt;class T> T ex_sqrt(T x) &#123; //返回精度更高的sqrt T sqrtX = sqrt(x) - 1; while (sqrtX + 1 &lt;= x / (sqrtX + 1)) sqrtX++; return sqrtX; &#125; void solve() &#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> e(n + 1); for(int i=0;i&lt;m;i++)&#123; int u, v; cin >> u >> v; e[u].pb(v), e[v].pb(u); &#125; if(ex_sqrt(n) * ex_sqrt(n) != n)&#123; cout &lt;&lt; "NO\n"; return; &#125; int k = ex_sqrt(n); if(k + k * k != m)&#123; cout &lt;&lt; "NO\n"; return; &#125; for(int i=1;i&lt;=n;i++)&#123; if(e[i].size() != 2 &amp;&amp; e[i].size() != 4)&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; vector&lt;bool> st(n + 1); auto sz = [&amp;](auto self, int x) -> int&#123; st[x] = true; int ans = 1; for(auto y : e[x])&#123; if(st[y]) continue; ans += self(self, y); &#125; return ans; &#125;; if(sz(sz, 1) != n)&#123; cout &lt;&lt; "NO\n"; return; &#125; for(int i=1;i&lt;=n;i++) &#123; if (e[i].size() == 2) continue; for (int j = 0; j &lt; e[i].size(); j++) &#123; int x = e[i][j]; if (e[x].size() == 2) continue; swap(e[i][j], e[i].back()); e[i].pop_back(); j --; for (auto &amp;y: e[x]) &#123; if (y == i) &#123; swap(y, e[x].back()); e[x].pop_back(); break; &#125; &#125; &#125; &#125; st = vector&lt;bool>(n + 1); for(int i=1;i&lt;=n;i++)&#123; if(st[i]) continue; if(sz(sz, i) != k)&#123; cout &lt;&lt; "NO\n"; return; &#125; &#125; cout &lt;&lt; "YES\n"; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 《2100》难度 G1. Vlad and the Nice Paths (easy version) 详见 \(G2\)，区别是本题可以 \(O(n ^ 3)\) 通过 G2. Vlad and the Nice Paths (hard version) 题意 给定一个序列 \(a\)，以及一个整数 \(k\)，从左向右任意取 \(p\) 个数，满足下面的条件： \(p\) 是 \(k\) 的倍数； 将取出的数按照 \(k\) 长度为一组分组，满足每一组内所有元素相等 输出最大的 \(p\) 对应的方案数。 思路 首先，如果我们一组一组考虑，可以发现答案是具有递推性的。 递推性不止在方案数上，对于 \(p\) 的大小也是。 我们先来看如何递推 \(p\)，且令 \(p[i]\) 为当前位置 \(p\) 的最大值： 枚举 \(i\) 作为当前位，并从 \(i - 1\) 开始向前枚举 \(j\) 作为当前组的开头，也就是说当前组为 \([j, i]\)，其中 \(j, i\) 分别为左右端点； 在枚举 \(j\) 的时候，统计 \(a_{[j ,i]}\) 中有多少元素和 \(a_i\) 相同，我们记数量为 \(cnt\)； 如果 \(cnt = k\)，那么我们形成了一个独立的组 \([j, i]\)，此时我们直接从 \(p[j - 1]\) 递推答案，\(p[i] = p[j - 1] + 1\)； 如果 \(cnt \geq k\)，那么此时存在从 \([j ,i]\) 里挑 \(k\) 个相同数的选择，但是我们也可以在 \([j ,i]\) 里挑一个数作为开头，而且理论上后者可能更大，因而如果我们发现递推的时候，上一个状态 \(p[j - 1] + 1 &lt; p[i]\)，我们就可以直接停止再向前枚举 \(j\) 了； 注意我们一开始的定义，因为 \(p[i]\) 为当前位置 \(p\) 的最大值，所以我们需要和 \(p[i - 1]\) 取最大值，从而递推下来，保证 \(p\) 序列一定是不递减的。 那么对于方案数，我们记前 \(i\) 个数的最大 \(p\) 对应的方案数为 \(dp[i]\)，来看看我们刚才是如何递推的： 如果 \(p[i] = p[i - 1]\)，那么显然 \(dp[i] += dp[i - 1]\)； 如果在枚举的时候，\(cnt \geq k\)，那么我们可以以 \(j, i\) 为开头和结尾，中间任选 \(k - 2\) 个，那么方案数可以乘上 \(C_{cnt - 2}^{k - 2}\) 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #define chatgpt "bits/stdc++.h" #include chatgpt using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); int C[5010][5010]; void init()&#123; // 预处理组合数 for (int i = 0; i &lt;= 5000; i++) &#123; C[i][0] = 1; C[i][i] = 1; for (int j = 1; j &lt; i; j++) &#123; C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod; &#125; &#125; &#125; void solve() &#123; int n, k; cin >> n >> k; vector&lt;int> a(n + 1); for(int i=1;i&lt;=n;i++) cin >> a[i]; vector&lt;vector&lt;int>> dp(n + 1, vector&lt;int>(2)); //0为考虑组合的答案，1为记录可以形成最多多少组 dp[0][0] = 1; for(int i=1;i&lt;=n;i++)&#123; int cnt = 1; for(int j=i-1;j>=1;j--)&#123; if(a[j] == a[i])&#123; cnt ++; if(cnt == k)&#123; //可以形成新的组合[j,i] dp[i][1] = dp[j - 1][1] + 1; &#125; if(cnt >= k)&#123; if(dp[j - 1][1] &lt; dp[i][1] - 1) break; dp[i][0] += dp[j - 1][0] * C[cnt - 2][k - 2] % mod; dp[i][0] %= mod; &#125; &#125; &#125; if(dp[i][1] &lt; dp[i - 1][1])&#123; dp[i][0] = 0, dp[i][1] = dp[i - 1][1]; &#125; if(dp[i][1] == dp[i - 1][1])&#123; dp[i][0] += dp[i - 1][0]; dp[i][0] %= mod; &#125; &#125; cout &lt;&lt; dp[n][0] &lt;&lt; '\n'; &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while (t--) solve(); &#125; 也是一眼就觉得是 \(dp\)，一眼写半天写不出来]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 862 Div. 2</title>
    <url>/blog/posts/2241746691/</url>
    <content><![CDATA[Contestant. Rank 2150. Rating -3. A. We Need the Zero 题意 给定序列 \(a\)，判断是否存在一个数 \(x\)，使 \((a_1 \oplus x) \oplus (a_2 \oplus x) \oplus ... \oplus (a_n \oplus x) = 0\)。若存在，输出这个数，否则输出 \(-1\)。 思路 很显然，异或是具有交换律的，也就是说，我们不妨记 \(p = a_1 \oplus a_2 \oplus ... \oplus a_n\)。 因为两个相同的数异或值为 \(0\)，所以我们只需考虑 \(n\) 的奇偶性。 如果 \(n\) 为奇数，那么我们只需让 \(x = p\)，否则就需要 \(p = 0\)，不然无解。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; ans ^= cur; &#125; cout &lt;&lt; (ans != 0 &amp;&amp; n % 2 == 0 ? -1 : ans) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 找找规律~ B. The String Has a Target 题意 给定一个由小写字母组成的字符串，任选一个字母并将其移动到字符串的开头，使整个字符串的字典序最小。输出这个最小的字典序。 思路 显然，我们只需把一个小的字符移上来就好了。 或者，更具体地说，我们只需找出字符串中最小的那个字符，然后将其移动到第一个即可。 当然，如果第一个使最小的，不管即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; string s; cin >> n >> s; int mn = 0; for(int i=1;i&lt;n;i++)&#123; if(s[i] &lt;= s[mn]) mn = i; &#125; cout &lt;&lt; s[mn]; for(int i=0;i&lt;=mn-1;i++) cout &lt;&lt; s[i]; for(int i=mn + 1;i&lt;n;i++) cout &lt;&lt; s[i]; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 《Div. 2 B题》 C. Place for a Selfie 题意 给定若干数量两种函数的系数，函数分别为 \(y = kx, y = a x ^ 2 + b x + c\)。 对于所有的二次函数，找出一条直线，使其与二次函数没有交点。若能找到，输出斜率 \(k\)。 思路 首先，对于直线和二次函数，我们将其联立，可得 \(a x ^ 2 + (b - k) x + c = 0\)。 也就是说，只要满足 \(\Delta = (b - k) ^ 2 - 4 a c &lt; 0\) 即可。 提取出 \(k\)，我们可得 \(b - \sqrt{4ac} &lt; k &lt; b + \sqrt{4ac}\)。 那么，我们只需二分，找出边界即可。 对于二分，我们可以用 原数字和相反数的 \(upperbound\)，这样即可快速求出。 注意，合理使用 \(int\) 类型的强制转换，\(double\) 只会向 \(0\) 的方向取整，而不都是向下取整。 时间复杂度：\(O(n \log m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; vector&lt;int> p(n + 2, inf); p[0] = -inf; vector&lt;int> q(n + 2, -inf); q[0] = inf; for(int i=1;i&lt;=n;i++) &#123; cin >> p[i]; q[i] = -p[i]; &#125; sort(p.begin(), p.end()); sort(q.begin(), q.end()); while(m --)&#123; double a, b, c; cin >> a >> b >> c; if(a * c &lt; 0)&#123; cout &lt;&lt; "NO\n"; continue; &#125; double sq = sqrt(4 * a * c); double lk = b - sq, rk = b + sq; if(rk &lt;= p[1] || lk >= p[n])&#123; cout &lt;&lt; "NO\n"; continue; &#125; int l = upper_bound(p.begin(), p.end(), (int) floor(lk)) - p.begin(), r = n - (upper_bound(q.begin(), q.end(), (int) floor(-rk)) - q.begin()) + 1; if(l > r)&#123; cout &lt;&lt; "NO\n"; &#125;else&#123; cout &lt;&lt; "YES\n"; cout &lt;&lt; p[l] &lt;&lt; '\n'; &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 草，相反数 \(upperbound\) 真好用（x D. A Wide, Wide Graph 题意 给定一个边权为 \(1\) 的无向无环图，对于 \(k \in [1, n]\)，输出以距离 \(k\) 为边连结得到的图中连通块的个数。 如 \(1 -2 -3 -4 -5\)，\(k = 2\) 的时候 \(1 -3, 2 - 4, 3 - 5\)，可以发现连通块个数为 \(1\)。 思路 我们不妨考虑 \(k = 1\) 的情况，然后逐一递增。 首先，对于一个点，若它到所有点的最大距离 \(p &lt; k\)，那么这个点无法被连接上，而反之，就可以被连上。 如果一个点连不上了，那么连通块的个数会增加。有趣的是，既然这个点无法和其他点连接，那么他一定是孤立的单点。 为什么呢？因为我们在逐一减小剔除的时候，已经把它旁边的全都拿掉了，那么自然会成为单点。 那么，我们不妨用 \(Dfs\) 的方法，找出所有点到其他点的最大距离，然后排个序，计算答案即可。 我们可以正反跑两遍，来找出最大的距离。 时间复杂度：不会分析捏 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; vector&lt;int> e[N]; void dfs(int x, int f, int st, int &amp;mx, vector&lt;int> &amp;out)&#123; out[x] = st; if(out[mx] &lt; out[x]) mx = x; for(auto w : e[x])&#123; if(w == f) continue; dfs(w, x, st + 1, mx, out); &#125; &#125; void solve() &#123; int n; cin >> n; for(int i=0;i&lt;n-1;i++)&#123; int u, v; cin >> u >> v; u --, v --; e[u].emplace_back(v); e[v].emplace_back(u); &#125; int a = 0; vector&lt;int> tv(n); dfs(0, -1, 0, a, tv); vector&lt;int> f1(n), f2(n); int b = 0, ti = 0; dfs(a, -1, 0, b, f1); dfs(b, -1, 0, ti, f2); for(int i=0;i&lt;n;i++) f2[i] = max(f1[i], f2[i]); sort(f2.begin(), f2.end()); int ans = 0; for(int i=1;i&lt;=n;i++)&#123; while(ans &lt; n - 1 &amp;&amp; f2[ans] &lt; i) ans ++; cout &lt;&lt; ans + 1 &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 嘶，有点抽象（ F1. Survival of the Weakest (easy version) 题意 定义 \(F(a_1, a_2, \ldots, a_n)\) 为任意两个元素相加得到的新集合的前 \(n - 1\) 小项构成的新集合。给定一个序列，求出 \(n - 1\) 次操作后最终的值的最大值。 思路 首先！我们来试试暴力！ 暴力如何解呢？我们将新集合构造出来，然后排序，最后取前 \(n - 1\) 项覆盖原集合。 排序直接用 \(multiset\) 就好了，会快一点。 不过，这里会有一个问题，因为我们需要排序，所以我们不可以取模，但这样会导致爆 \(int\)。 那么，我们不妨在每次做完后，将所有元素减掉最小值，那么最后我们不难发现最小值被减去了 \(\min \times 2 ^ {n - 1}\) 次，最后的答案加上即可。 很好，这样很简单，但是太慢了。 那么，我们不妨观察一下，如何卡过去 如何优化。 首先，固定第二个元素遍历的时候，\(a_2 \geq a_1\)，那么我们可以贪心地认为 \(\frac{n}{2}\) 后面的元素是不用考虑的，瞎猜即可。 归纳得到结论：遍历到 \(\frac{n}{i}\) 为止。 具体证明我不会（瞎猜的 用了 \(2.5s\) 卡过去的（不建议参考这个思路 时间复杂度：卡过去的（ 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 1e9 + 7; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n), p(n + 1, 1); for (int i = 0; i &lt; n; i++) cin >> a[i]; for (int i = 1; i &lt;= n; i++) p[i] = (p[i - 1] * 2) % mod; sort(a.begin(), a.end()); n++; int tot = 0; while (n-- > 2) &#123; multiset&lt;int> ans; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt;= min(n - 1, n / (i + 1)); j++) &#123; ans.insert(a[i] + a[j]); &#125; &#125; int mn = *ans.begin(); auto it = ans.begin(); for (int i = 0; i &lt; n - 1; i++) &#123; a[i] = *it - mn; it++; &#125; tot = (tot + mn * p[n - 2]) % mod; &#125; cout &lt;&lt; (tot + a[0]) % mod &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 卡过去了就离谱]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - CodeTON Round 4 Div. 1 + 2</title>
    <url>/blog/posts/3139923560/</url>
    <content><![CDATA[Contestant(alt). 开摆Rank 5778. Rating -11(+89 -100). A. Beautiful Sequence 题意 给定一个序列，输出是否存在一个子序列，存在一个元素满足 \(a_i = i\)。 思路 显然，我们只需遍历一遍序列，找出一个 \(a_i\)，满足 \(a_i \leq i\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; bool f = false; for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; if(cur &lt;= i) f = true; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 水 B. Candies 题意 对于一个数 \(x\)，定义操作如下： \(x :=2x + 1\) \(x := 2x - 1\) 给定一个若干次操作后的数，判断初始值是否为 \(1\)，并输出方案。 思路 首先，得到的数都是奇数，所以我们从这里下手即可。 我们判断 \(\frac{x-1}{2}\) 的奇偶性，若为奇数，那么 \(x := \frac{x-1}{2}\)，否则 \(x := \frac{x + 1}{2}\) 。 可以断定，只要一开始 \(x\) 不是偶数，最后的结果一定是 \(1\)。 时间复杂度：\(O(\log_2n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; if(n % 2 == 0) &#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; vector&lt;int> ans; while(n > 1)&#123; if((n - 1) / 2 % 2 == 0) n = (n + 1) / 2, ans.emplace_back(1); else n = (n - 1) / 2, ans.emplace_back(2); &#125; reverse(ans.begin(), ans.end()); cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 你说我这脑子怎么就转不过来呢 C. Make It Permutation 题意 给定一个序列，定义操作为下面两者任选其一： 删除一个元素，代价为 \(c\)； 插入一个元素，代价为 \(d\)。 找出代价最小的一种方案，使最后的序列变为任意长度的排列，输出最小代价。 思路 贪心。 我们先记最后的答案为 \(cost\)。 首先，我们不妨先把序列排个序，然后用 \(unique\) 剔除重复元素，毕竟重复元素是一定要删去的，我们记剔除这些元素的总代价为 \(rm\)。 然后，我们从大到小遍历，处理相邻的两个数。对于这两个数，我们定义差值为 \(dist\)，以及右边那个数的后面还有 \(cnt\) 个数字。那么，我们有两种处理： \(dist=1\)，那么不用管之 \(dist &gt; 1\)，我们需要比较一下删除这个元素和补上缺少的数的代价。 需要注意的是，如果我们决定删除这个数，那么后面的数都要一并删去。因为后面的数不删去的话，需要补全的数就更多了，而我们已经判定删除的代价更小。也就是说，删除后总代价更新为 \(rm + c (cnt + 1)\)。 而补全数字的代价为 \(d(dist-1)\)，也就是说，更新后的总价值为 \(cost+d(dist-1)\)。 因此，我们比较 \(cost+d(dist-1)\) 和 \(rm + c (cnt + 1)\) 即可。 需要注意的是，当第一个数不是 \(1\) 的时候，我们不能删完所有数，所以一定会出现补全的代价。 到这里并没有结束，你会发现样例过不去。 这里有个有趣的点，我们为何不直接删掉所有数，然后放一个 \(1\) 进去呢？我们将其和答案取最小值即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, c, d; cin >> n >> c >> d; //反着做，看看删掉和补充哪个赚 vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a.begin(), a.end()); int rm = a.size(), sz = unique(a.begin(), a.end()) - a.begin(); rm -= sz; if(a[0] != 1) a.insert(a.begin(), 0ll), sz ++; int cost = rm * c; for(int i=sz-1;i>0;i--)&#123; int dis = a[i] - a[i - 1] - 1; if(a[i - 1] != 0 &amp;&amp; cost + dis * d > rm * c + c * (sz - i))&#123; cost = rm * c + c * (sz - i); &#125;else cost += dis * d; &#125; cout &lt;&lt; min(d + c * n, cost) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 简单的贪心捏，就是我怎么老搞错（ D. Climbing the Tree 题意 定义一个蜗牛在爬树，每天上升 \(a\)，下降 \(b\)，当某一天距离树的顶部小于等于 \(a - 1\) 时，即可爬到顶。树的高度记为 \(h\)。 定义询问为下者二选一： \(1\ a\ b \ n\)，表示给定一组限制，在 \(a, b\) 的条件下在第 \(n\) 爬到顶。若限制不满足前面得到的范围，输出 \(0\)；否则输出 \(1\)，并更新 \(h\) 的可能范围； \(2\ a\ b\)，判定这个条件下所需天数是否有唯一解，有的话输出，否则输出 \(-1\)。 思路 首先，这是一道数学题。 我们先来考虑第一个： 如果它要在第 \(n\) 天到达，首先前提是第 \(n - 1\) 天不会到达，也就是说，\(h \geq (a - b)(n - 1) + b\)； 其次，爬到顶的条件是距离树的顶部小于等于 \(a - 1\)，也就是说，\(h \leq (a - b)(n - 1) + (a - 1)\)。 所以，若原求得的区间和 \([(a - b)(n - 1) + b, (a - b)(n - 1) + (a - 1)]\) 有交集，那么更新区间为两者交集，否则输出 \(0\)。 我们记得到的 \(h \in [lh, rh]\)。 我们再来看看第二个： 首先，如果能一步登天，即 \(a - 1 \geq rh\)，那么直接输出 \(1\) 即可。 否则，我们只需满足一个不等式：\((a - b)(n - 1) + b \leq h \leq (a - b)(n - 1) + (a - 1)\)。 化简可得： $ \[\begin{cases} n \leq \frac{h - b}{a - b} + 1 \\ n \geq \frac{h - (a - 1)}{a - b} + 1\end{cases}\] $ 那么，我们把 \(rh\) 带入第一个式子，\(lh\) 带入第二个式子，即可求出 \(n\) 的所有可能范围。 那么，我们判断一下左右端点取整后是否相等即可。注意，右端点向下取整，左端点向上取整，因为这样取整后得到的区间是在原区间内的最长区间。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int q; cin >> q; int lh = -1, rh = inf; while(q --)&#123; int tp; cin >> tp; if(tp == 1)&#123; int a, b, n; cin >> a >> b >> n; int now = (a - b) * (n - 1); int now_l = n == 1 ? 0 : now + b, now_r = n == 1 ? a - 1 : now + a - 1; if(a &lt;= b || now_l > rh || now_r &lt; lh) cout &lt;&lt; 0 &lt;&lt; ' '; else&#123; cout &lt;&lt; 1 &lt;&lt; ' '; lh = max(lh, now_l), rh = min(rh, now_r); &#125; &#125;else&#123; int a, b; cin >> a >> b; if(a > rh) &#123; cout &lt;&lt; 1 &lt;&lt; ' '; continue; &#125; int min_x = (int) ceil((double) (lh - (a - 1)) / (double) (a - b)) + 1, max_x = (int) floor((double) (rh - (b)) / (double) (a - b)) + 1; if(min_x != max_x) cout &lt;&lt; -1 &lt;&lt; ' '; else cout &lt;&lt; min_x &lt;&lt; ' '; &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 别用 C++ 64位交即可.]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - 2023愚人节场</title>
    <url>/blog/posts/3616853689/</url>
    <content><![CDATA[Contestant. Rank WASTED. Unrated. A. Are You a Robot? 题意 给定一个图片，输出图片里的单词。 思路 如图，为"\(security\)"。 头脑复杂度：\(O(0)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; cout &lt;&lt; "security\n"; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 人也不一定看得出第一个字母是s（划掉 B. Was it Rated? 题意 给定一个 \([1, 25]\) 内的数字，输出对应的答案。 思路 \(Rated?\)，\(Codeforces\) 前 \(25\) 场只有 \(15, 20, 21\) 场是 \(Unrated\)，因此这三场输出 \(NO\) 即可。 头脑复杂度：\(O(n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; map&lt;int, bool> mp = &#123; &#123;1, true&#125;, &#123;2, true&#125;, &#123;3, true&#125;, &#123;4, true&#125;, &#123;5, true&#125;, &#123;6, true&#125;, &#123;7, true&#125;, &#123;8, true&#125;, &#123;9, true&#125;, &#123;10, true&#125;, &#123;11, true&#125;, &#123;12, true&#125;, &#123;13, true&#125;, &#123;14, true&#125;, &#123;15, false&#125;, &#123;16, true&#125;, &#123;17, true&#125;, &#123;18, true&#125;, &#123;19, true&#125;, &#123;20, false&#125;, &#123;21, false&#125;, &#123;22, true&#125;, &#123;23, true&#125;, &#123;24, true&#125;, &#123;25, true&#125; &#125;; cout &lt;&lt; (mp[n] ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 属于是没想到（x C. Digits 题意 给定 \(t\) 组数据，每组数据有 \(n\) 个数，\(n\) 不给出。观察输入输出，输出答案。 思路 我们可以发现，按照 \(3, 1, 4\) 的方法分隔，每组的数相乘就是输出的值。 我们不妨猜测 \(n\) 为圆周率，按规律做即可。 头脑复杂度：\(O(\inf)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int t; cin >> t; string s = "31415926535897932384626433832795"; for(int i=0;i&lt;t;i++)&#123; int n = s[i] - '0'; int ans = 1; while(n --)&#123; int cur; cin >> cur; ans *= cur; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 这属实没料到 D. Trivial Conjecture 题意 角谷猜想，给定整数 \(k\)，输出一个数，使得进行操作后前 \(k\) 个数不出现 \(1\)。 思路 首先，角谷猜想能告诉我们一个正整数按照题给操作是一定会变为 \(1\) 的，而且操作数远小于原数字。 那么，上面有一个值得注意的点：正整数。 有意思的是，题目又没说一定要输出正整数。 输出 \(0\) 即可。 头脑复杂度：\(O(-1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int tmp; cin >> tmp; cout &lt;&lt; 0 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 我是大蠢比 E. Not a Geometry Problem 题意 给定三个数，计算方法未知。 输出一个数，设这个数为 \(a\)，标准答案为 \(b\)，那么只要满足 \(\frac{|a-b|}{\max(1,|b|)} \le 10^6\)，答案即为正确。 思路 \(a = 0\) 就可以让整个式子变为 \(1\)。 头脑复杂度：\(O(0)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 怎么我赛时的时候题面是俄文（? F. Factorization 题意 给定一个数，输出它的最大质因数。 数为下面两者任选其一： \(4167792762229302596005813\) 或 \(\begin{aligned}&amp;502326648535222453054166634657971818804572580\\&amp;255694785590270206376893052666523759828749572\\ &amp;821869200397402455443130219791674914146276480\\&amp;544216264509037323019703862145022909043607926\\&amp;185591029614599889902115472391135622402044979\\&amp;347133959392884686037208893694733655782993294\\&amp;168167973855585231709683012084723677082273198\\&amp;866111120369101303677409522966567521782715484\\&amp;001992772768993119841291702786496058775824381\\&amp;444079748162416745495656333618343487208147794\\&amp;874337933873576016717726298883519261055062303\\&amp;842274145012056670644839715140659887936321934\\&amp;474824687778512706909988484451300384818197143\\&amp;498259061041 \end{aligned}\) 思路 我们先随便找一个网站分解一下第一个数：\(991999999999 \times 4201403994187\)。 很有趣，第一个数是有规律的。 那么，我们不妨枚举因子的长度和 \(1\) 出现的位置，用大数硬跑，即可得到答案。 第二个数为： \(\begin{aligned}&amp;9999999999999999999999999999999999999999999999\\&amp;9999999999999999999999999999999999999999999999\\&amp;9999999999999999999999999999999999999999999999\\&amp;9999999999999999999999999999999999999999999999\\&amp;9999999999999999999999999999999999999999999999\\&amp;9999999999999999999999999999999999199999999999\\&amp;9999999999999999999999\\&amp;*\\&amp;5023266485352224530541666346579718188045725802\\&amp;5569478559027020637689305266652375982874957282\\&amp;1869200397402455443130219791674914146276480544\\&amp;2162645090373230197038621450229090436079261855\\&amp;9102961459988990211547239113562240204497934713\\&amp;3959392884686037208893694733655783395155486996\\&amp;15181802856501740938959\end{aligned}\) 头脑复杂度：\(O(妈妈生的)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string s; cin >> s; if (s == "4167792762229302596005813") cout &lt;&lt; "4201403994187\n"; else cout &lt;&lt; "50232664853522245305416663465797181880457258025569478559027020637689305266652375982874957282186920039740245544313021979167491414627648054421626450903732301970386214502290904360792618559102961459988990211547239113562240204497934713395939288468603720889369473365578339515548699615181802856501740938959\n"; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 我还真去用网站分解后面的了（x G. Colour Vision 题意 一张绿色的柱状图。 思路 首先，我们可以根据输入输出猜测，每个测试数据的第一行是下面两个字符串的长度。 其次，我们仿照前几个小时做的牛客愚人节\(A\) 题（小学数学必考数一数），把图片下载下来看一看颜色。 我们可以得到色值：\(01722B\)。 有趣，我们来看看比赛 \(id=1722\) 的 \(B\) 题（B. Colorblindness）。 题面告诉我们，大条件是蓝绿色盲，而我们需要把 \(G, B\) 当成一样的字母进行判断。 那么，我们不妨将所有的 \(G\) 替换为 \(B\)，然后比较字符串即可。 当然，不知道 \(n\) 这里会不会真的是字符串长度，但我们反正只需考虑前 \(n\) 个字符即可。 头脑复杂度：\(O(\inf ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; string s1, s2; cin >> s1 >> s2; bool f = true; for(int i=0;i&lt;n;i++)&#123; if(s1[i] == 'G') s1[i] = 'B'; if(s2[i] == 'G') s2[i] = 'B'; if(s1[i] != s2[i]) f = false; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 什么解谜啊 H. Expected Twist 待补充，题解看不懂捏 I. Mountain Climber 题意 给定一个由小写字母组成的字符串，观察输入输出和题目，输出真假。 思路 爬山，爬什么山呢？当然是字母的山咯（x。 参考下面的网站，我们可以得到高的字母和低的字母： Ascender Descender 高的字母为 \(\mathtt{tdfhklb}\)，低的为 \(\mathtt{qypgj}\)。 继续观察，我们可以发现，我们需要从 \(0\) 高度向上爬，在过程中不向下爬到 \(0\) 的条件下，在最后爬回 \(0\)，即为 \(YES\)。 头脑复杂度：\(O(?)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e7 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string s; cin >> s; string up = "tdfhklb", down = "qypgj"; int h = 0; bool f = true; for(char e : s)&#123; if(up.find(e) &lt; up.size()) h ++; else if(down.find(e) &lt; down.size())&#123; if(h == 0) f = false; h --; &#125; &#125; cout &lt;&lt; (f &amp;&amp; h == 0 ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; cin >> t; while(t --) solve(); &#125; 爬不动了（x J. Unmysterious Language 题意 用一个未知语言和评测机对话。 思路 下面给出尝试的过程： 提交一个 \(C++\) 代码，得到回复 "wrong answer I'm sorry, as a language model, I'm not able to compile and execute code." 盲猜为英文对话，提交一句 \(Accepted\)，得到回复 "wrong answer I'm sorry, but I'm not sure what you are asking. If you have any question or need any assistance, feel free to ask and I'll do my best to help you." 推得需要一句话，或者某个关键词，我们随便聊一句 "How can I get an "Accepted" judge?"，得到回复 "wrong answer I can give you AC, but did you forget something important?" 看来关键词不对，尝试疑问句 "You mean what important?"，得到和上面一样的回复. 出于奇怪的礼貌，我们随口问一句 "If there is something important, please give me AC."，得到 \(Accepted.\)，以及回复 "ok I will give you AC, as you wish." 有趣的是，本题的关键字只有 \(Please\)，只要语句不长，就会被判通过。 于是，你可以自娱自乐一下： "Please give me WA." "ok I will give you AC, as you wish." 头脑复杂度：\(O(-\inf)\) 对应AC代码 代码？ please 对没错，就一个单词（什么垃圾关键词AI]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 861 Div. 2</title>
    <url>/blog/posts/3027651998/</url>
    <content><![CDATA[Practice. A. Lucky Numbers 题意 此处给出 \(A\) 题和 \(C\) 题的定义： 对于一个数字，将所有位上的数取出，组成一个序列 \(a\)。定义 \(l = a_{\max} - a_{\min}\)。 那么， 给定一个区间 \([l ,r]\)，\(l\) 的最大值对应的数就是最幸运数，最小值对应的数就是最不幸运数。 给定一个区间 \([l, r]\)，输出任意一个最幸运数。 思路 首先，如果考虑幸运数，那么我们不难发现，我们只需关注十位和个位上的数即可，因为在这里就可以搞出最大值。 那么，暴力遍历 \([l, l + 100]\) 即可。 时间复杂度：\(O(100x)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int l, r; cin >> l >> r; pii ans = &#123;0, l&#125;; for(int i=l;i&lt;=min(l + 100, r);i++)&#123; int tmp = i, mn = inf, mx = 0; while(tmp > 0)&#123; int cur = tmp % 10; mn = min(mn, cur); mx = max(mx, cur); tmp /= 10; &#125; if(ans.fs &lt; mx - mn)&#123; ans = &#123;mx - mn, i&#125;; &#125; &#125; cout &lt;&lt; ans.sc &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 为什么我会想着去构造（（ B. Playing in a Casino 题意 给定 \(n\) 个人的 \(m\) 张手牌对应的数字，构成序列 \(a_{i,x}\)。 遍历 \(i \in [2, n], j \in [1, i - 1]\)，统计 \(|a_i[0] - a_j[0]| + |a_i[1] - a_j[1]| + \ldots + |a_i[m] - a_j[m]|\) 的总和。 输出总和。 思路 显然，我们可以直接竖着看，看一下去掉绝对值的情况。 不难发现，我们固定第二维 \(x\)，那么对于竖向构造得到的每一个序列，我们进行排序，可以得到形如下面的序列： \(a, b, c, d, e\)。 最后，这个序列的值为 \(-4a-2b+2d+4e\)。 或者说，我们只需排序后遍历，乘上权重加起来即可。权重首项为 \(n - 1\)，依次递减 \(2\)。 时间复杂度：\(O(mn)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> a(m, vector&lt;int>(n)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin >> a[j][i]; int ans = 0; for(int i=0;i&lt;m;i++)&#123; sort(a[i].begin(), a[i].end()); for(int j=0;j&lt;n/2;j++) ans += (a[i][n - j - 1] - a[i][j]) * (n - 1 - 2 * j); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 简简单单（x C. Unlucky Numbers 题意 给定一个区间 \([l, r]\)，输出任意一个最不幸运数。 思路 我们可以考虑用 \(DFS\) 来实现，用拼接的方式得到答案。 考虑下面的两个剪枝： 当前拼接得到的数可以预测是否一定超出边界，如对于 \(12\)，范围为 \([135, 189]\)，那么由 \(12 \times 10 + 10 = 130 &lt; 135\) 可知一定不在边界内。另一个边界直接判大小即可。 因为深搜，所以能提前得到一些答案，那么如果当前 \(\max - \min\) 已经大于之前求得的答案了，就不用继续了。 时间复杂度：不会分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; string l, r, ans; int val = inf, vl, vr; void init()&#123;&#125; void dfs(int x, int mn, int mx, const string&amp; now)&#123; int vn = stoll(now); if(x == l.size())&#123; if(vn >= vl &amp;&amp; vn &lt;= vr &amp;&amp; mx - mn &lt; val)&#123; val = mx - mn; ans = now; &#125; return; &#125; int exp = vn * pow(10, l.size() - x); //优化一下查找 if(exp + pow(10, l.size() - x) &lt; vl || exp > vr || mx - mn >= val) return; for(int i=0;i&lt;=9;i++) dfs(x + 1, min(mn, i), max(mx, i), now + (char) (i + '0')); &#125; void solve() &#123; cin >> l >> r; vl = stoll(l), vr = stoll(r); if(l.size() &lt; r.size())&#123; for(int i=0;i&lt;l.size();i++) cout &lt;&lt; 9; cout &lt;&lt; '\n'; &#125;else&#123; ans = ""; val = inf; for(int i=l[0]-'0';i&lt;=r[0]-'0';i++)&#123; dfs(1, i, i, to_string(i)); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 就很无脑，不知道dp咋做（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 860 Div. 2</title>
    <url>/blog/posts/302073386/</url>
    <content><![CDATA[Contestant. Rank 3058. Rating -35. 坐大牢局 A. Showstopper 题意 给定两个序列 \(a, b\)，规定一次操作为任取 \(i\)，交换 \(a_i, b_i\)。输出任意次操作后，是否可以让 \(a_n = \max(a_i), b_n = \max(b_i)\)。 思路 首先，既然最后方案我们无需考虑，那么我们不妨定义 \(a\) 为最小值的序列，\(b\) 为最大值的序列，那么只要满足上面的条件，就是有解，否则无解。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n), b(n); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;n;i++) cin >> b[i]; if(a[n - 1] > b[n - 1]) swap(a[n - 1], b[n - 1]); bool f = true; for(int i=0;i&lt;n-1;i++) &#123; int mn = min(a[i], b[i]), mx = max(a[i], b[i]); if (mn > a[n - 1] || mx > b[n - 1]) f = false; &#125; cout &lt;&lt; (f ? "Yes\n" : "No\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 猜结论题 x1 B. Three Sevens 题意 给定 \(n\) 局的参赛情况，在前面一局胜利的玩家不会参与下面的比赛。输出任意一种获胜玩家列表排列。 思路 我们不妨反过来考虑，也就是说，在后面出现的玩家一定不是前面的赢家，那么我们直接倒着遍历即可。 首先，我们遍历参加了该局的玩家，若只要有一个没被标记，那么就是有解的，我们随便输出一个即可。 然后，我们标记参加了该局的玩家，这样即可防止其在前面作为赢家。 时间复杂度：\(O(mn)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;vector&lt;int>> a(n, vector&lt;int>()); for(int i=0;i&lt;n;i++)&#123; int cnt; cin >> cnt; a[i] = vector&lt;int>(cnt); for(int j=0;j&lt;cnt;j++) cin >> a[i][j]; &#125; vector&lt;bool> st(50010, false); vector&lt;int> ans(n); for(int i=n-1;i>=0;i--)&#123; bool f = false; for(auto e : a[i])&#123; if(!st[e]) ans[i] = e, f = true; st[e] = true; &#125; if(!f)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; return; &#125; &#125; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 这可比A题好做多了 C. Candy Store 题意 给定 \(n\) 组 \(a_i, b_i\)，定义 \(d_i\) 为 \(a_i\) 的因数，\(c_i = b_id_i\)。 构造一组 \(d\)，将 \(c\) 划分为 \(x\) 段值相等的序列，输出 \(x_{\min}\)。 思路 我们来考虑 \(x = 1\) 的情况： 首先，\(c_i = b_id_i\)，也就是说，\(c_i\) 是 \(b_i\) 的倍数。那么，\(c_1 \times c_2 \times \ldots \times c_n\) 是 \(lcm(b_1, b_2, \ldots, b_n)\) 的倍数。 其次，\(d_i\) 是 \(a_i\) 的因数，那么 \(b_id_i\) 就是 \(a_ib_i\) 的因数，也就是说，\(gcd(a_1b_1, a_2b_2, \ldots, a_nb_n)\) 是 \(c_1 \times c_2 \times \ldots \times c_n\) 的倍数。 所以，\(gcd(a_1b_1, a_2b_2, \ldots, a_nb_n) \% lcm(b_1, b_2, \ldots, b_n)=0\) 就是其能成为一段区间的条件。 显然，如果一个元素能划分到前面的序列中，那么我们完全可以不考虑它，因为就算把他放进来，不影响数量。 因此，我们可以贪心地直接遍历统计个数。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b); &#125; int lcm(int a, int b)&#123; return a * b / gcd(a, b); &#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n), b(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i] >> b[i]; &#125; int g = 0, l = 1, ans = 1; for(int i=0;i&lt;n;i++)&#123; g = gcd(g, a[i] * b[i]); l = lcm(l, b[i]); if(g % l != 0)&#123; ans ++; g = a[i] * b[i]; l = b[i]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 没想到啊没想到... D. Shocking Arrangement 题意 给定一个总和为 \(0\) 的序列，重新排序这个序列，满足 \(\max\limits_{1 \le l \le r \le n} \lvert a_l + a_{l+1} + \ldots + a_r \rvert &lt; \max(a_1, a_2, \ldots, a_n) - \min(a_1, a_2, \ldots, a_n),\) 若不能满足，输出 \(No\)。 思路 首先，我们定义 \(sum_i\) 为前 \(i\) 个数的前缀和，那么 \(\max\limits_{1 \le l \le r \le n} \lvert a_l + a_{l+1} + \ldots + a_r \rvert = sum_{\max} - sum_{\min}\)。 那么，我们让 \(sum_{\max} &lt; \max(a_1, a_2, \ldots, a_n), sum_{\min} &gt; \min(a_1, a_2, \ldots, a_n)\) 即可。 如何实现？我们不妨随便放一个数上去，然后记录当前放入的前 \(i\) 个数的和 \(x\)，若 \(x &gt; 0\)，那么我们加上一个负数，直到 \(x \leq 0\)，反之亦然。 考虑到总和为 \(0\)，所以如果 \(x &gt; 0\)，剩余的数的和一定为 \(-x\)，所以后面一定会有几个负数，让 \(x \leq 0\)。 此时，一定有解，而若要判无解，当且仅当整个序列都是 \(0\)。 对细节的证明 思路的第一句话是贪心的（有乱猜的嫌疑）。 为什么呢？因为，\(sum_{\max}\) 不一定在 \(sum_{\min}\) 右边。 或者说，\(S_x, S_y, S_z, Sx&gt;0, S_y &lt; 0, S_z &gt; 0\)，这样的区间要如何保证 \(|S_y| &lt; \max(a_1, a_2, \ldots, a_n) - \min(a_1, a_2, \ldots, a_n)\) 呢？ 首先，根据思路，\(S_x\) 一定小于等于 \(\max(a_1, a_2, \ldots, a_n)\)，而 \(|S_x| \geq |S_{y-1}|\)，所以 \(|S_y| &lt; \max(a_1, a_2, \ldots, a_n) + abs(\min(a_1, a_2, \ldots, a_n))\)。 因此得证。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; stack&lt;int> p, q; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur >= 0) p.emplace(cur); else if(cur &lt; 0) q.emplace(cur); &#125; if(q.empty())&#123; cout &lt;&lt; "No\n"; return; &#125; cout &lt;&lt; "Yes\n"; int now = 0; for(int i=0;i&lt;n;i++)&#123; if(now &lt;= 0)&#123; now += p.top(); cout &lt;&lt; p.top() &lt;&lt; ' '; p.pop(); &#125;else&#123; now += q.top(); cout &lt;&lt; q.top() &lt;&lt; ' '; q.pop(); &#125; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 猜结论题 x2]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 295</title>
    <url>/blog/posts/1688399541/</url>
    <content><![CDATA[Contestant. Rank 2267. Rating +74. A. Probably English 题意 给定一个字符串序列，输出序列中是否包含下面的 \(5\) 个单词： \(and, not, that, the, you\)。 思路 如题，别打错即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; vector&lt;string> mp = &#123;"and", "not", "that", "the", "you"&#125;; int n; cin >> n; bool f = false; while(n --)&#123; string s; cin >> s; for(auto e : mp) if(s == e) f = true; &#125; cout &lt;&lt; (f ? "Yes\n" : "No\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 打错了草 B. Bombs 题意 给定一个矩阵，矩阵由 ".", "#" 和数字组成。对于任意数字 \(x\)，将其周围所有 曼哈顿距离 小于等于 \(x\) 且为 "#" 的点替换为 "."。输出替换后的矩阵。 其中，对于两个点 \((x_1, y_1), (x_2, y_2)\)，曼哈顿距离为 \(|x_1 - x_2| + |y_1 - y_2|\)。 思路 直接模拟。 当然，不要直接替换，判断一下是不是 "#" 再说。 时间复杂度：\(O(nmp^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; vector&lt;string> s(n); for (int i = 0; i &lt; n; i++) cin >> s[i]; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) &#123; char now = s[i][j]; if (now != '#' &amp;&amp; now != '.') &#123; int cnt = now - '0'; s[i][j] = '.'; for (int x = 1; x &lt;= cnt; x++) for (int p = 0; p &lt;= x; p++) &#123; int q = x - p; if (i + p &lt; n &amp;&amp; j + q &lt; m &amp;&amp; s[i + p][j + q] == '#') s[i + p][j + q] = '.'; if (i + p &lt; n &amp;&amp; j - q >= 0 &amp;&amp; s[i + p][j - q] == '#') s[i + p][j - q] = '.'; if (i - p >= 0 &amp;&amp; j + q &lt; m &amp;&amp; s[i - p][j + q] == '#') s[i - p][j + q] = '.'; if (i - p >= 0 &amp;&amp; j - q >= 0 &amp;&amp; s[i - p][j - q] == '#') s[i - p][j - q] = '.'; &#125; &#125; &#125; for (auto e: s) cout &lt;&lt; e &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 论我debug了半天这道简单题这件事 C. Socks 题意 给定一个序列，在一个元素只能在一对数的条件下，输出可以找出多少对相同的数。 思路 如题，将所有数找出，答案即为各个数量除 \(2\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; map&lt;int, int> cnt; int n; cin >> n; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; cnt[cur] ++; &#125; int ans = 0; for(auto e : cnt) ans += e.second / 2; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 这也太水了（（ D. Three Days Ago 题意 给定一个由 \([0, 9]\) 内数字组成的序列，输出 所有连续子序列中 满足 所有数出现次数均为偶数 的个数。 思路 首先，奇偶性相同的前缀和，它们的差值一定是偶数，那么，我们只需考虑奇偶性。 也就是说，对于一种 \([0, 9]\) 的奇偶性排列，若有 \(x\) 个相同的，那么答案加上 \(\frac{x(x - 1)}{2}\)。 对于这种排列，我们不妨用状压，那么，用 \(map\) 就完事了。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string s; cin >> s; int n = s.size(); map&lt;int, int> cnt; cnt[0] = 1; int cur = 0; for(int i=0;i&lt;n;i++)&#123; int t = s[i] - '0'; cur ^= (1 &lt;&lt; t); cnt[cur] ++; &#125; int ans = 0; for(auto i : cnt) ans += (i.second - 1) * i.second / 2; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 以后写状压还是写简单一点为好（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 145</title>
    <url>/blog/posts/759924825/</url>
    <content><![CDATA[Contestant. Rank 2183. Rating -13. A. Garland 题意 给定 \(4\) 盏灯的颜色，颜色为 \([0, 9]\) 内的任意数字。初始状态所有灯均关闭，打开一盏灯的条件是之前打开的灯的颜色与其不一致，第一次可以打开任意一盏灯。输出将所有灯打开所需最小次数。 思路 首先，这题只有 \(4\) 盏灯。 所以，我们直接分类讨论即可。 我们先将灯按照颜色代码升序排序，那么如果第一个数和最后一个数相等，输出 \(-1\)； 否则，前三个数相等或者后三个数相等时，需要 \(6\) 次； 否则，\(4\) 次足矣。 时间复杂度：\(O(4 \log 4)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; string s; cin >> s; sort(s.begin(), s.end()); if(s[0] == s[3]) cout &lt;&lt; -1 &lt;&lt; '\n'; else if(s[0] == s[2] || s[1] == s[3]) cout &lt;&lt; 6 &lt;&lt; '\n'; else cout &lt;&lt; 4 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 我居然没看到只有4个... B. Points on Plane 题意 给定整数 \(n\)，代表当前有 \(n\) 个点。将这些点放入平面直角坐标系，满足坐标均为整数。在限制任意一对点的距离都严格大于 \(1\) 的条件下，输出最小的总代价。其中，对于一个点 \((x, y)\)，单点的代价为 \(|x| + |y|\)，总代价为所有点的代价最大值。 思路 我们来固定 \(x\) 看 \(y\)： \(x = k\)，那么 \(y = 0\)； \(x = k - 1\)，那么 \(y = -1, 0, 1\)； 归纳可得，对于 \(x\) 的所有正数取值，\(y\) 的取值总数为 \(1 + 2 + \ldots + (k + 1) = \frac{(k + 1)(k + 2)}{2}\)； 同理， \(x\) 为负数时，\(y\) 的取值总数为 \(1 + 2 + \ldots + k = \frac{k(k+1)}{2}\)。 那么，我们可以得到总和 \((k + 1) ^ 2\)。 那么，最后的答案即为 \(\lceil \sqrt n \rceil - 1\)。 注意精度问题即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n; cin >> n; int ans = sqrt(n); if(ans * ans &lt; n) ans ++; cout &lt;&lt; ans - 1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 离谱的是在 C++ 17 下，\(\lfloor \sqrt{n - 1} \rfloor\) 可以作为答案卡过去 C. Sum on Subarrays 题意 构造一个序列，满足所有连续子序列的和均不为 \(0\)，且和为正数的序列数量为给定值 \(k\)。 思路 首先，我们不妨打表，\(s_i\) 为 \(i\) 个数的连续子序列个数，即 \(s_i = \frac{i(i + 1)}{2}\)。 那么，我们不难发现，\(s_{i + 1} - s_i = i + 1\)。 那么，在 \(s_i\) 个数的基础上，我们再添加 \(x \in [0, i]\) 个数，就可以等于 \(k\)。 更具体地说，我们不妨在序列前面放上 \(q\) 个相同的正数 \(x\)，其中 \(s_q\) 为 \(s\) 中第一个不大于 \(k\) 的值。 那么，我们还需 \(cnt = k - s_q\) 个数，我们不妨在后面放一个负数 \(p\)，让 以这个数作为结尾的 子序列的和 为负数 的个数为 \(q - cnt\)。 这样的话，以 \(t \in [1, cnt]\) 为头，负数 \(p\) 为尾的子序列的和就是正数了。 剩下还有一些空位，我们填上负无穷大，也就是最小值 \(-1000\) 即可。 当然，正数 \(x\) 不能为 \(1\)，这样会让某个总和变为 \(0\)，那么我们取 \(2\) 即可。 在取 \(2\) 的条件下，负数 \(p = -2(q - cnt) - 1\)。 当然，我们用递增的序列取代这些相等的正数也是可以的。 时间复杂度：\(O(n \log n)\) 对应AC代码1 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; vector&lt;int> s = &#123;0&#125;; void init()&#123; for(int i=1;i&lt;=1000;i++) s.emplace_back(i * (i + 1) / 2); &#125; void solve() &#123; int n, k; cin >> n >> k; int q = upper_bound(s.begin(), s.end(), k) - s.begin() - 1; int cnt = k - s[q]; for(int i=0;i&lt;q;i++) cout &lt;&lt; 2 &lt;&lt; ' '; if(cnt != 0) cout &lt;&lt; -(q - cnt) * 2 - 1 &lt;&lt; ' ', q ++; for(int i=q;i&lt;n;i++) cout &lt;&lt; -1000 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 对应AC代码2 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; vector&lt;int> s = &#123;0&#125;; void init()&#123; for(int i=1;i&lt;=1000;i++) s.emplace_back(i * (i + 1) / 2); &#125; void solve() &#123; int n, k; cin >> n >> k; int q = 0; while(s[q + 1] &lt;= k) q ++; for(int i=0;i&lt;q;i++) cout &lt;&lt; q - i + 1 &lt;&lt; ' '; k -= s[q]; if(k != 0) &#123; cout &lt;&lt; -1 * (s[q - k] + q - k + 1) &lt;&lt; ' '; q ++; &#125; for(int i=q;i&lt;n;i++) cout &lt;&lt; -1000 &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 我怎么就这么蠢.jpg D. Binary String Sorting 题意 给定一个二进制字符串，规定操作为下面两个任选一： 交换两个相邻元素； 删掉一个元素 第一个操作的代价为 \(1e12\)；第二个操作的代价为 \(1e12 + 1\)。 输出让整个字符串变为不递减序列的最小代价。 思路 首先，这题可以 \(dp\)，但是我们不妨来想想怎么贪心。 我们下面有四种方案，取最小值即可： 删掉所有的 \(1\)； 删掉所有的 \(0\)； 遍历所有的 \(0\)，将前面的 \(1\) 删掉，后面的 \(0\) 删掉； 遍历所有的 \(0\)，若前面为 \(1\)，那么把这个 \(1\) 和当前的 \(0\) 交换，然后删去前面剩余的 \(1\)，以及后面的 \(0\)。 前面三者是显然的，而对于第四个，我们不妨考虑其他的移动情况。 显然，\(11\) 和 \(00\) 没必要交换；\(01\) 不用管，因为满足递增；\(10\) 交换即可；剩余的情况，我们都需要移动至少两次，那还不如删掉呢。 因此，贪心是成立的。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int x = 1e12; string s; cin >> s; int n = s.size(); s = " " + s; vector&lt;vector&lt;int>> pre(n + 1, vector&lt;int>(2, 0)); int cnt0 = 0; for(int i=1;i&lt;=n;i++)&#123; int now = s[i] - '0'; if(now == 0) cnt0 ++; pre[i][now] = pre[i - 1][now] + 1; pre[i][1 - now] = pre[i - 1][1 - now]; &#125; int ans = min(cnt0, n - cnt0) * (x + 1); for(int i=1;i&lt;=n;i++)&#123; if(s[i] == '0') &#123; ans = min(ans, (pre[i][1] + cnt0 - pre[i][0]) * (x + 1)); if(s[i - 1] == '1') ans = min(ans, x + (pre[i][1] + cnt0 - pre[i][0] - 1) * (x + 1)); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 赛时一看到dp就溜了（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 859 Div. 4</title>
    <url>/blog/posts/3765805359/</url>
    <content><![CDATA[Contestant(alt). Rank 5166. Rating -27(+123 -150). A. Plus or Minus 题意 给定三个数 \(a, b, c\)，判断 \(a+b = c\) 还是 \(a - b = c\)，前者输出 \(+\)，后者输出 \(-\)，保证有解。 思路 如题。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int a, b, c; cin >> a >> b >> c; if(a + b == c) cout &lt;&lt; '+' &lt;&lt; '\n'; else cout &lt;&lt; '-' &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 这才应该是低程的签到题啊（（ B. Grab the Candies 题意 给定一个序列 \(a\)，按次序拿出 \(a_i\)，定义 \(a_i\) 为偶数时 \(A\) 拿走 \(a_i\)，否则 \(B\) 拿走 \(a_i\)。输出是否可以将序列重新排列，使得每次取走后 \(A\) 持有的总和严格大于 \(B\)。 思路 如题。 很显然，我们先全排满偶数，再排奇数即可。 那么，题目转化为偶数的总和和奇数的总和的比较。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int sum1 = 0, sum2 = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur % 2 == 0) sum1 += cur; else sum2 += cur; &#125; cout &lt;&lt; (sum1 > sum2 ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 脑子得稍微动一下的题（ C. Find and Replace 题意 给定一个字符串，规定可将一种字母全部替换为 \(0\) 或 \(1\)，在全部替换后，输出是否可以将字符串变为相邻字符不相同的字符串，即 \(0101\) 相间。 思路 显然，我们只需对每一个字母去考虑，如果任意两个距离最近的相同的字母的距离为奇数，那么就构造不出来，否则一定可以。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> pre(26, -1); string s; cin >> s; bool f = true; for(int i=0;i&lt;n;i++)&#123; int cur = s[i] - 'a'; if(pre[cur] != -1 &amp;&amp; (i - pre[cur]) % 2 == 1)&#123; f = false; break; &#125; pre[cur] = i; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 差点看错题 D. Odd Queries 题意 给定一个序列，对于 \(q\) 次 独立 询问，给定一段区间 \([l, r]\) 以及一个整数 \(k\)，将区间内的数字全都修改为 \(k\) 后，输出序列的总和是否为奇数。 思路 既然询问是独立的，那么我们直接对所有询问单独考虑即可。 也就是说，我们不需要模拟修改，而只需求出值。 那么，很简单，我们求出前缀和，然后用 \(O(1)\) 的复杂度拿出区间前后的元素总和，最后判断加上区间内的值能否变为奇数即可。 时间复杂度：\(O(n + q)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, q; cin >> n >> q; vector&lt;int> sum(n + 1, 0); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; sum[i] = sum[i - 1] + cur; &#125; while(q --)&#123; int l, r, k; cin >> l >> r >> k; cout &lt;&lt; ((sum[l - 1] + (r - l + 1) * k + sum[n] - sum[r]) % 2 == 1 ? "YES\n" : "NO\n"); &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 这题怎么更水了（ E. Interview 题意 互动游戏。 背景：给定几堆石子，每堆石子都由权值为 \(1\) 的石子堆叠得到，特殊地，有一堆石子中有一个石子的权值为 \(2\)。 初始：给定堆数，以及每堆石子的 个数。 互动：输出一段区间的左右端点，返回这段区间内所有石子的 权值和。 限制：最多 \(30\) 次。 目标：输出特殊的石子在哪个堆里。 思路 首先，我们可以跑一遍前缀和，方便后续查询。 其次，如果我们询问了区间 \([1, k]\)，得到的值等于个数，那么我们可以断定特殊的石子在 \([k + 1, n]\) 里，反之就在前者里。 那么，对于 \(k\) 的选择，我们直接用二分的思路做即可。 最后二分的结果就是答案。 次数为 \(\log_2n\)，不超过 \(30\)。 时间复杂度：\(O(t \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;int> sum(n + 1, 0); for(int i=1;i&lt;=n;i++) &#123; int cur; cin >> cur; sum[i] = sum[i - 1] + cur; &#125; int l = 1, r = n, mid; while(l &lt; r)&#123; mid = (l + r) >> 1; cout &lt;&lt; "? " &lt;&lt; mid - l + 1 &lt;&lt; ' '; for(int i=l;i&lt;=mid;i++) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n'; cout.flush(); int g; cin >> g; if(g == sum[mid] - sum[l - 1]) l = mid + 1; else r = mid; &#125; cout &lt;&lt; "! " &lt;&lt; l &lt;&lt; '\n'; &#125; signed main()&#123; //ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 我怎么会想着去在两边都询问一次呢，我好铸 F. Bouncy Ball 题意 给定一个矩阵，以左上角为原点建立坐标系，给定两个点 \((i_1, j_1), (i_2, j_2)\)，以及初始运动方向 \(s, s \in \{DL, DR, UL, UR\}\)（\(DL\) 表示向左下角走，也就是 \((i, j) \rightarrow (i + 1, j - 1)\)，其余同理）。在碰到边界后，会发生反弹，如向左上角走，碰到上边界后会反弹，向左下角继续移动。在碰到边角后，运动方向反转，此处记反弹次数为 \(1\) 次，而不是 \(2\) 次。 输出从 \((i_1, j_1)\) 开始运动，到第一次到达 \((i_2, j_2)\) 后，经历了多少次反弹。 无法到达输出 \(-1\)。 思路 数据量并不大，直接模拟即可。 在模拟的时候，我们记录是否已经从某个方向运动到该格子。那么，只要碰到被我们记录过的格子，只要方向一致，那么就出现了循环，直接打断即可。 时间复杂度：最坏\(O(4nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve() &#123; int n, m, i, j, si, sj; string ori; cin >> n >> m >> i >> j >> si >> sj >> ori; bool vis[n + 1][m + 1][4] = &#123;&#125;; int d = ((ori[0] == 'D' ? 0 : 1) &lt;&lt; 1) + (ori[1] == 'R' ? 0 : 1); //00 DR, 01: DL, 10: UR, 11: UL int cnt = 0; while (!vis[i][j][d]) &#123; if (i == si &amp;&amp; j == sj) &#123; cout &lt;&lt; cnt &lt;&lt; '\n'; return; &#125; vis[i][j][d] = true; int new_d = d; if ((d == 0 || d == 1) &amp;&amp; i == n) new_d += 2; if ((d == 0 || d == 2) &amp;&amp; j == m) new_d ++; if ((d == 1 || d == 3) &amp;&amp; j == 1) new_d --; if ((d == 2 || d == 3) &amp;&amp; i == 1) new_d -= 2; if (new_d != d) cnt++; d = new_d; if (d % 2 == 1) j--; else j++; if ((d >> 1) == 1) i--; else i++; &#125; cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 居然，居然，居然就是暴力... G1. Subsequence Addition (Easy Version) 详见G2，区别是G1的数据量更小 G2. Subsequence Addition (Hard Version) 题意 给定一个初始只含一个数字 \(1\) 的序列，规定操作为选择序列中的任意元素，将选定元素之和加入序列中。 现在，给定一个序列，输出其是否为上述操作所得。 思路 我们可以贪心地认为，排序之后，较大的数一定小于等于所有比他小的数的和，而且只要满足这个条件，一定有一种方案得到这个数。 至于为什么，我们可以想想二分，序列中的数一定是某些数的和，那么如此拆分下去，就是一群 \(1\) 的和，而且数量的集合覆盖 \([1, sum]\)，所以是成立的。 具体的证明需要用到归纳法。 因此，我们排个序，然后判断所有 \(a_i\) 是否大于等于 \(sum_{i - 1}\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve()&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a.begin(), a.end()); int sum = 1; bool f = a[0] == 1; for(int i=1;i&lt;n;i++)&#123; if(!f) break; if(i &lt; 2 &amp;&amp; a[i] != 1 || a[i] > sum) f = false; sum += a[i]; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 很有趣一贪]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 福师大第26届低程</title>
    <url>/blog/posts/1549174805/</url>
    <content><![CDATA[Contestant. Rank 2. Solved 4/8. A. ACM? 你也想打ACM? 题意 对于 \(n\) 道题，给定 \(k\) 个提交记录，规定罚时为 \(20\) 分钟，按照 \(ACM/ICPC\) 赛制计算通过题数和总用时。 思路 首先，没过的题不算罚时，过了的题重复提交无效。 因为题给数据是按照时间排序的，那么，我们不妨从前往后遍历，用数组记录当前的状态。 对于下面的 \(AC\) 代码，其中 \(ok_i\) 表示当前是否过了 \(i\) 题；\(a_i\) 表示第 \(i\) 道题最早是在 \(a_i\) 时刻通过的；\(p_i\) 表示第 \(i\) 道题在通过前 \(WA\) 了几次。 最后，我们遍历所有题，如果过题了，记录过题数，并将总用时加上 \(a_i + 20p_i\)。 时间复杂度：\(O(nk)\) 本题测试点数据量过大，java需要使用快读，cpp若使用cin需要关闭输入输出流同步 对应AC代码 (cpp) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1.5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f; int a[N], p[N]; bool ok[N]; void solve()&#123; int n, k; cin >> n >> k; for(int i=0;i&lt;k;i++)&#123; string s; cin >> s; int id, h, m, now = 0, st = 0; bool msg = true; for(int i=0;i&lt;s.size();i++)&#123; char e = s[i]; if(e == ':')&#123; if(st == 0)&#123; id = now; now = 0; st = 1; &#125;else if(st == 1)&#123; m = now; now = 0; st = 2; &#125; &#125;else if(e == '-')&#123; h = now; now = 0; &#125;else if(e >= '0' &amp;&amp; e &lt;= '9')&#123; now = now * 10 + (e - '0'); &#125;else if(e == 'u')&#123; //读到u就差不多了 msg = false; break; &#125;else break; &#125; int cal = h * 60 + m; if(!ok[id]) a[id] = cal; if(msg) ok[id] = true; else if(!ok[id]) p[id] ++; &#125; int cnt = 0, tot = 0; for(int i=1;i&lt;=n;i++)&#123; cnt += ok[i] ? 1 : 0; if(ok[i]) tot += a[i] + p[i] * 20; &#125; cout &lt;&lt; cnt &lt;&lt; ' ' &lt;&lt; tot &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 对应AC代码 (java) import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception &#123; Console console = new Console(); int n = console.nextInt(), k = console.nextInt(); boolean[] ok = new boolean[n + 1]; int[] a = new int[n + 1], p = new int[n + 1]; for (int i = 0; i &lt; k; i++) &#123; String[] s = console.next().split(":"); int id = Integer.parseInt(s[0]), cal = Integer.parseInt(s[1].split("-")[0]) * 60 + Integer.parseInt(s[1].split("-")[1]); if (!ok[id]) a[id] = cal; if (s[2].equals("accepted")) ok[id] = true; else if (!ok[id]) p[id]++; &#125; int cnt = 0, tot = 0; for (int i = 1; i &lt;= n; i++) &#123; cnt += ok[i] ? 1 : 0; if (ok[i]) tot += a[i] + p[i] * 20; &#125; console.print(cnt + " " + tot + "\n"); console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; java挂掉后果断切cpp，淦 B. 任何邪恶? 终将绳之以法! 题意 给定一个满二叉树，满足根节点为 \(1\)，节点 \(x\) 的子节点为 \(2x, 2x + 1\)。 定义操作为下面三者任选一： \(1\ x\)，输出 \(x\) 节点到其他被标记节点的最短距离总和； \(2\ x\)，标记 \(x\) 节点； \(3\ x\)，取消标记 \(x\) 节点。 给定 \(q\) 个询问，执行对应操作。 思路 一些废话 首先，节点 \(a, b\) 的最短距离为两者 离 它们的 最近公共祖先 的距离 之和。 也就是说，这个路径一定是先向上找，再从一个节点折返，最后从下找的。 这个节点就像一个跳板，不过当然，跳板可以是起点自己。 当然，讨论到这里，我们也许可以对每个查询，都去跑一遍最近公共祖先（\(LCA\)），但我觉得没这个必要。 不过，有没有一种可能，对于一个跳板，我们可以预处理出它的左右子树各有多少点被标记了，以及这些点距离跳板的距离呢。 这个预处理过程可以放在标记的时候。而且，我们不难发现这个过程是可逆的。因而，在取消标记的时候，我们进行相反的操作就好了。 具体思路 计算 首先，我们先来考虑怎么计算： 我们不妨从查询点 \(x\) 开始向上遍历，并记录当前走了 \(st\) 步。遍历时，我们传递一下当前遍历到的父节点 \(p\) 是由哪个子树来的，这个参数和 \(x\) 的奇偶性有关。这样的话，我们就可以拿出另一个子树中所有被标记点到 \(p\) 的距离和 \(sum\)，以及被标记的节点数 \(cnt\)。画个图易得，\(x\) 到 \(p\) 这段路被反复经过了 \(cnt\) 次，经过这个跳板后，剩余距离的总和就是 \(sum\)，因此，以 \(p\) 为跳板，我们可以得到贡献 \(sum + cnt \times st\)。 上述过程对于 \(p \neq x\) 的情况是成立的，而 \(p = x\) 时，两个子树的值我们都需要考虑（传参时，我们不妨传递一个特殊值，如 \(-1\)），具体的贡献计算方式和上面一致。 特别地，若我们遍历到的 \(p\) 是被标记过的，那么贡献会多出 \(st\)。 预处理 对于加上一个标记 \(x\) 的操作，我们可以从该节点开始向上遍历，直到根节点为止。 同样，在遍历的时候，我们记录步数 \(st\)，并传递 \(p\) 是由哪个子树来的，然后将 \(p\) 对应子树的 \(sum\) 加上 \(st\)，\(cnt\) 加上 \(1\)。 取消标记的做法恰好相反，减去即可。 时间复杂度：反正挺复杂 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; pii dp[N][2]; int ans; bool is[N]; void up_dfs_add(int x, int from, int st)&#123; if(x == 0) return; if(from == -1)&#123; dp[x][0].first += st; dp[x][1].first += st; &#125;else dp[x][from].first += st, dp[x][from].second ++; up_dfs_add(x / 2, x % 2, st + 1); &#125; void up_dfs_del(int x, int from, int st)&#123; if(x == 0) return; if(from == -1)&#123; dp[x][0].first -= st; dp[x][1].first -= st; &#125;else dp[x][from].first -= st, dp[x][from].second --; up_dfs_del(x / 2, x % 2, st + 1); &#125; void up_dfs_cal(int x, int from, int st)&#123; if(x == 0) return; int cur; if(from == -1) cur = dp[x][0].first + dp[x][1].first > 0 ? (dp[x][0].first + dp[x][0].second * st + dp[x][1].first + dp[x][1].second * st) : 0; else cur = dp[x][1 - from].first > 0 ? (dp[x][1 - from].first + dp[x][1 - from].second * st) : 0; ans += cur; if(is[x]) ans += st; up_dfs_cal(x / 2, x % 2, st + 1); &#125; void solve()&#123; int n, q; cin >> n >> q; while(q --)&#123; int tp, x; cin >> tp >> x; if(tp == 1)&#123; ans = 0; up_dfs_cal(x, -1, 0); cout &lt;&lt; ans &lt;&lt; '\n'; &#125;else if(tp == 2) is[x] = true, up_dfs_add(x, -1, 0); else is[x] = false, up_dfs_del(x, -1, 0); &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 复杂之，但类似的题其实做过好几次吧，有点像树型dp C. 蘑菇! 提莫来采蘑菇啦! 没做，待补充 D. 锁屏图案? 当然是第k长的最好看! 题意 对于一个九宫格锁屏图案，规定需要一笔将所有点连起来，且不能重复使用同一个点。 规定连接了两个点的时候，若这个路径经过了一个未被使用的点，那么这个点一定要一起被连上，否则视为不合法，如斜角上的 \(159\)，在没使用过 \(5\) 前，\(195\) 是不合法的。 定义满足条件的全排列中，排序的主关键字为路径长，次要关键字为字典序，按照降序排列。 给定 \(q\) 个询问，对于给定的 \(k\)，输出第 \(k\) 个排列。 思路 首先，数据量很小，\(9!\) 的复杂度完全可以暴力。 那么，我们不妨枚举所有全排列，然后算出可行解的路径长，以及排列的结果，按照这个排个序然后取出来就好了。 唯一麻烦的是码量。 时间复杂度：\(O(8 \cdot 9 \cdot 9! \cdot q)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-7; struct node&#123; string ans; double dist; &#125;; vector&lt;node> ans; vector&lt;int> a = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; vector&lt;pii> pos(10); double cal(int x, int y)&#123; return sqrt(pow(abs(pos[x].fs - pos[y].fs), 2) + pow(abs(pos[x].sc - pos[y].sc), 2)); &#125; bool check(int l, int r, int mid)&#123; int l_pos = -1, r_pos = -1, m_pos = -1; for(int i=0;i&lt;9;i++)&#123; if(a[i] == l) l_pos = i; else if(a[i] == r) r_pos = i; else if(a[i] == mid) m_pos = i; &#125; if(l_pos > r_pos) swap(l_pos, r_pos); return l_pos + 1 != r_pos || m_pos &lt; r_pos; &#125; void init()&#123; for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=3;j++) pos[3 * (i - 1) + j] = &#123;i, j&#125;; do&#123; vector&lt;vector&lt;int>> checker = &#123;&#123;1, 3, 2&#125;, &#123;1, 7, 4&#125;, &#123;3, 9, 6&#125;, &#123;7, 9, 8&#125;, &#123;3, 7, 5&#125;, &#123;1, 9, 5&#125;, &#123;2, 8, 5&#125;, &#123;4, 6, 5&#125;&#125;; bool f = true; for(auto e : checker) f &amp;= check(e[0], e[1], e[2]); if(!f) continue; node now = &#123;&#125;; for(int i=0;i&lt;9;i++)&#123; now.ans += (a[i] + '0'); now.ans += " "; if(i > 0) now.dist += cal(a[i], a[i - 1]); &#125; ans.emplace_back(now); &#125;while(next_permutation(a.begin(), a.end())); //这里学到了，好用的东西 sort(ans.begin(), ans.end(), [](node o1, node o2)&#123; return abs(o1.dist - o2.dist) > eps ? o1.dist > o2.dist : o1.ans > o2.ans; &#125;); &#125; void solve()&#123; int k; cin >> k; cout &lt;&lt; ans[k - 1].ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t; cin >> t; while(t --) solve(); &#125; 草，怎么赛时就没想着去做捏，这么暴力（（（ E. 微积分？低程竟然有微积分？ 题意 给定一个多项式，满足式子中没有重复次幂，项按照次幂降序排序，次幂最小为 \(0\)。项的系数可以为负，但不会为 \(0\)。 输出它的积分。 思路 很清晰的模拟题，坑点在于化简和系数 \(1\)。 化简很简单，除以 \(gcd\) 即可。 系数 \(1\) 不做过多解释，自行体会（ 时间复杂度：\(O(n)\)乘上点常数 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; int gcd(int a, int b)&#123; return b == 0 ? a : gcd(b, a % b); &#125; void solve()&#123; string exp; cin >> exp; exp += "#"; //end int now = 0, root = 0; cout &lt;&lt; "y="; bool tp = false; for(int i=3;i&lt;exp.size();i++)&#123; char cur = exp[i]; if(cur == 'x')&#123; root = (now == 0 ? 1 : now); now = 0; if(i >= exp.size() - 2 || exp[i + 1] != '^')&#123; if(root % 2 == 0 &amp;&amp; root / 2 != 1) cout &lt;&lt; root / 2 &lt;&lt; "x^2"; else if(root % 2 == 0) cout &lt;&lt; "x^2"; else cout &lt;&lt; root &lt;&lt; "/" &lt;&lt; 2 &lt;&lt; "x^2"; root = 0; &#125; &#125; else if(cur == '+' || cur == '-' || cur == '#') &#123; if(tp)&#123; int p = now; if(root % (p + 1) == 0 &amp;&amp; root / (p + 1) == 1) cout &lt;&lt; "x^" &lt;&lt; p + 1; else if(root % (p + 1) == 0) cout &lt;&lt; root / (p + 1) &lt;&lt; "x^" &lt;&lt; p + 1; else&#123; int x = gcd(p + 1, root); cout &lt;&lt; root / x &lt;&lt; "/" &lt;&lt; (p + 1) / x &lt;&lt; "x^" &lt;&lt; (p + 1); &#125; &#125;else if(now == 1) cout &lt;&lt; "x"; else if(now != 0) cout &lt;&lt; now &lt;&lt; "x"; tp = false; now = 0; if(cur == '+' || cur == '-') cout &lt;&lt; cur; else cout &lt;&lt; "+C"; &#125; else if(cur == '^') tp = true; else now = now * 10 + (cur - '0'); &#125; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; 系数1太坑了捏 F. SCI! 我就是要发SCI! 题意 给定 \(n\) 个字符串，从中选 \(k\) 个字符串并进行任意组合，输出最小的字典序。 思路 首先，"从 \(n\) 个东西中选 \(k\) 个"，很容易让人想到背包问题，或者更具体地，这是一个 \(01\) 背包。 但是，再套上板子之前，我们思考一下怎么递推。 有一个错误的思路（这也是我在赛时想到的奇怪思路），就是用一维的 \(dp\)，\(dp_j\) 表示选了 \(j\) 个后的最小字典序。那么我们直接枚举所有的字符串 \(s_i\)，遍历 \(j\)。对于 \(dp_j\) ，遍历其中的字符串，将 \(si\) 依次插入缝中，最后找出一种插法，使得 \(dp_j\) 的字典序变小即可。 显然，我们不可以随意遍历，但有没有一种无需考虑插入位置的方法呢？ 我们来考虑任意两个字符串 \(s_i, s_j\)，如果 \(s_i + s_j &lt; s_j + s_i\)，那么很显然，前者的字典序更小。 那么，如果有三个呢？如果 \(s_j + s_k &lt; s_k + s_j\)，那么依然是前者的字典序更小。此时，我们联立起两个式子，会发现有趣的事情：\(s_i + s_k &lt; s_k + s_i\)。 也就是说，如果我们按照 \(s_i + s_j\) 的字典序升序排序，就可以直接将取出的任意的 \(k\) 个字符串拼接起来，而无需考虑这 \(k\) 个字符串的顺序，此时字典序一定是最小的。 那么，问题就剩下从 \(n\) 个东西中选 \(k\) 个，代价最小的问题了，也就是求最小代价的 \(01\) 背包。 事情到这里并未结束，我们来看下面的样例： 4 3 bbaba bba b b 不难发现，这组数据的答案为 \(bbababb\)。但如果我们套上板子，直接跑，得到的答案是 \(bbababbab\)。 问题在哪里呢？我们并没有考虑拼接上的答案的后缀，而如果出现了前缀一致的情况，我们无法控制让后缀尽可能短。 那么，很简单的解决方法，就是反着 \(dp\)，反着拼，这样就可以保证所有后缀的情况都被我们遍历过了。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> #define fs first #define sc second const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void init()&#123;&#125; void solve()&#123; int n, k; cin >> n >> k; vector&lt;string> s(n); for(int i=0;i&lt;n;i++) cin >> s[i]; vector&lt;string> dp(k + 1, "&#123;"); //保证ans原来的字典序为inf dp[0] = ""; sort(s.begin(), s.end(), [](string o1, string o2)&#123; return o1 + o2 > o2 + o1; //倒着做来让所有后缀都被遍历到 &#125;); for(auto e : s) //一维01背包 for(int j=k;j>=1;j--)&#123; dp[j] = min(dp[j], e + dp[j - 1]); &#125; cout &lt;&lt; dp[k] &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 还好赛时没怎么看这题（打完01的板子就突然意识到思路不对了，草 G. 旅行! 我就是想去旅行! 不会，样例都没过.jpg，待补充 H. WF？刚打低程就想着WF？ 题意 定义 \(5\) 种奖牌类型由低到高分别为 \(LowerLevelProgrammingCompetition\)，\(SchoolCompetition\)，\(ProvincialCompetition\)，\(Regional\)，\(ECfinal\)，\(WF\)。奖牌由低到高分为铜 (\(Cu\))，银 (\(Ag\))，金 (\(Au\))。当然还有铁牌，但不计入。 定义三个相同的牌可以合成一个等级更高的牌，输出拿到 \(WF\) 的金牌的最早时刻，不能拿到则输出可以拿到的价值最高的牌，什么牌都拿不到（打铁）输出 \(-1\)。 思路 模拟即可。注意不要打错单词。 对于最后价值最高的牌的记录，不妨用 "类型" $ + $ "奖牌" 的方式存，方便一点（（ 时间复杂度：\(O(n)\) #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; vector&lt;vector&lt;int> > cnt(6, vector&lt;int>(3)); map&lt;string, int> mp; mp["LowerLevelProgrammingCompetition"] = 0; mp["SchoolCompetition"] = 1; mp["ProvincialCompetition"] = 2; mp["Regional"] = 3; mp["ECfinal"] = 4; mp["WF"] = 5; mp["Cu"] = 0; mp["Ag"] = 1; mp["Au"] = 2; mp["Fe"] = -1; int hi = -1; int time = -1; for(int i=0;i&lt;n;i++)&#123; string s, a; cin >> s >> a; int id = mp[s], what = mp[a]; if(what == -1) continue; cnt[id][what] ++; if(id == 5 &amp;&amp; what == 2 &amp;&amp; time == -1) time = i + 1; hi = max(hi, id * 10 + what); if(cnt[id][what] == 3)&#123; cnt[id][what] = 0; if(what == 2) &#123; if(id &lt; 5)&#123; cnt[id + 1][0] ++; hi = max(hi, (id + 1) * 10); &#125;else&#123; if(time == -1) time = i + 1; &#125; &#125; else if(what &lt; 2) &#123; cnt[id][what + 1] ++; hi = max(hi, id * 10 + what + 1); if(id == 5 &amp;&amp; what + 1 == 2 &amp;&amp; time == -1) time = i + 1; &#125; &#125; &#125; if(time != -1) cout &lt;&lt; time &lt;&lt; '\n'; else if(hi != -1)&#123; int id = hi / 10, what = hi % 10; string ans; //懒得再写一个map了，累 if(id == 0) ans = "LowerLevelProgrammingCompetition"; else if(id == 1) ans = "SchoolCompetition"; else if(id == 2) ans = "ProvincialCompetition"; else if(id == 3) ans = "Regional"; else if(id == 4) ans = "ECfinal"; else ans = "WF"; cout &lt;&lt; ans &lt;&lt; ' '; if(what == 0) ans = "Cu"; else if(what == 1) ans = "Ag"; else ans = "Au"; cout &lt;&lt; ans &lt;&lt; '\n'; &#125;else cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t = 1; //cin >> t; while(t --) solve(); &#125; Ag == Au]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 858 Div. 2</title>
    <url>/blog/posts/2942373806/</url>
    <content><![CDATA[Contestant. Rank 1245. Rating +30. A. Walking Master 题意 给定两个点 \((a, b), (c, d)\)，定义对于点 \((x, y)\) 的操作为下面任选一： \(x + 1, y + 1\)； \(x - 1\) 输出从 \((a, b)\) 走到 \((c, d)\) 需要的最小操作数，无解输出 \(-1\)。 思路 画个图即可。 首先，我们需要向上移动 \(d - b\)，如果 \(d - b &lt; 0\) 就是无解。 此时，横坐标变为 \(a + d - b\)，还需要向左移动 \(a + d - b - c\)，如果 \(a + d - b - c &lt; 0\) 也是无解。 若有解，输出 \(d - b + a + d - b - c\)。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; void solve()&#123; int a, b, c, d; cin >> a >> b >> c >> d; if(b > d || a + d - b &lt; c) cout &lt;&lt; -1 &lt;&lt; '\n'; else cout &lt;&lt; a + d - b - c + d - b &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 就还是那么签（ B. Mex Master 题意 给定一个序列，定义答案为 由相邻数相加构成的新序列中 不在 这个序列中的 最小自然数。将序列重新排序，输出最小答案。 思路 首先，若 \(0\) 的个数小于等于 \(\frac{n + 1}{2}\)，那么一定可以在连续的两个 \(0\) 里面插入一个数，使最后的序列没有 \(0\)，答案即为 \(0\)； 其次，若整个序列的最大值大于 \(1\)，那么我们只需将 \(1\) 全部放到后面，然后第一个 \(1\) 之前不要放 \(0\) 即可，答案即为 \(1\)； 接着，若整个序列的最大值为 \(1\)，那么一定有一个 \(1\) 会和 \(0\) 去相加，使最后的序列出现 \(1\)，而因为 \(0\) 的个数足够多，我们只需在所有 \(1\) 之间插 \(0\)，就可以避免出现 \(2\)，答案即为 \(2\)； 否则，整个序列都是 \(0\)，答案一定是 \(1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; map&lt;int, int> cnt; int mx = 0; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; mx = max(mx, cur); cnt[cur] ++; &#125; if(cnt[0] &lt;= (n + 1) / 2) cout &lt;&lt; 0 &lt;&lt; '\n'; else if(cnt[0] == n) cout &lt;&lt; 1 &lt;&lt; '\n'; else cout &lt;&lt; (mx == 1 ? 2 : 1) &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 一开始想错了（（ C. Sequence Master 题意 若一个长为 \(2n\) 的序列，它的所有长度为 \(n\) 的子序列满足选定的数的 乘积 与剩余数的 和 相等，那么定义其为好序列。 给定一个长为 \(2n\) 的序列 \(p\)，选定一个好序列，定义答案为 \(\sum|p_i - q_i|\)，输出答案的最小值。 思路 猜想 首先，我们来以小见大，看看 \(a, b, c, d\) 如何成为一个好序列： 拿出其中两个式子：\(ab=c+d, ac=b+d\)，我们可以得出 \(b = c\) 或 \(a = -1\)。 同理，那么我们不妨猜测整个序列都是相等的数 \(x\)，或者会有至少一个数 \(t\) 不是 \(-1\)。 讨论1 下面我们来探讨一下第一个条件的局限性： 首先，它是一定成立的，毕竟 \(x=0\) 一定是一个解，但可能出现其他解； 若只有两个数，那么 \(x\) 可以为任意值； 若只有四个数，满足 \(x ^ 2 = 2x\)，\(x = 2\)； 若超过四个数，那么我们不难发现 \(x ^ k = kx\) 对于 \(k\) 为偶数的情况下是无整数解的。 讨论2 下面我们来探讨一下第二个条件的局限性： 我们无法让大于等于 \(2\) 个数不为 \(-1\)，列式可发现无实数解； \(n\) 为奇数的时候，依然无解； 其余情况，我们可以解得 \(t = n\)。 总结 最后，答案即为上面条件所算出的答案的最小值。 时间复杂度：\(O(2n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n; cin >> n; int ans = inf; vector&lt;int> a(2 * n); for(int i=0;i&lt;2*n;i++) cin >> a[i]; if(n == 1)&#123; if(a[0] > a[1]) swap(a[0], a[1]); ans = a[1] - a[0]; &#125;else if(n == 2)&#123; ans = 0; for(int i=0;i&lt;4;i++) ans += abs(a[i] - 2); &#125; if(n % 2 == 0)&#123; int mn = inf, sum = 0; for(int i=0;i&lt;2*n;i++)&#123; sum += abs(a[i] + 1); mn = min(mn, abs(a[i] - n) - abs(a[i] + 1)); &#125; ans = min(ans, sum + mn); &#125; int sum = 0; for(int i=0;i&lt;2*n;i++) sum += abs(a[i]); ans = min(ans, sum); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 漏了奇数的情况，md 有更直接的做法，这里比较麻烦]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Nebius Welcome Round Div. 1 + 2</title>
    <url>/blog/posts/1381135032/</url>
    <content><![CDATA[Contestant. Rank 1755. Rating +54. A. Lame King 题意 给定一个坐标系，其中 \(x \in [-100, 100], y \in [-100, 100]\)。给定一个坐标 \([s, t]\)，输出按规定从 \([0, 0]\) 走到 \([s, t]\) 需要的最短时间。 规定若需要连续从相同方向移动，需要间隔一秒。 思路 首先，若我们需要一直向右，那么停留一秒绝对比向垂直方向绕路快，所以，我们不妨以折线的方式移动，直到横坐标或纵坐标等于终点时，向同一方向间隔移动。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int a, b; cin >> a >> b; a = abs(a), b = abs(b); cout &lt;&lt; (a + b) + (a != b ? abs(a - b) - 1 : 0) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 画个图的事情（（ B. Vaccination 题意 对于 \(n\) 个病人，每个病人需要在 \([t_i, t_i + w]\) 时间内被扎一针。在某个时间点 \(x\)，可以拿出一个包含 \(k\) 个剂量的包装，这个包装会在 \(x + d + 1\) 时过期。给定整数 \(n, k, d, w\)，输出需要拿出的包装的最小数量。 思路 为了要当前的包装可以包括更多的人，我们不妨在某一个病人的 \(t_i + w\) 时刻拿出包装，并枚举后面有多少个 \(t_j\) 小于 \(t_i + w + d\)，这样即可贪心地求出最小值。 就这样，没了。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, k, d, w; cin >> n >> k >> d >> w; int ans = 0; vector&lt;pii> a(n); for(int i=0;i&lt;n;i++)&#123; cin >> a[i].first; a[i].second = a[i].first + w; &#125; int i = 0; while(i &lt; n)&#123; int l = a[i].second, r = l + d; int now = i; for(int j=0;j&lt;k;j++)&#123; if(i + j >= n || a[i + j].first > r) break; now ++; &#125; ans ++; i = now; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 这还需要证明吗，这还需要证明吗（ C. Pull Your Luck 题意 给定一个圆盘，按顺序写好了 \(0, 1, 2, ..., n - 1\)，换言之，\(0, n - 1\) 相邻。规定可以转动 \(p\) 秒，第一秒将当前值增加 \(p\)，第二次增加 \(p - 1\)，以此类推。对于给定的起点，输出是否可以进行一次 \([1, p]\) 秒的转动，使终点为 \(0\)。 思路 首先，我们很容易列出一个式子： \(n - x + kn = \frac{p(p+1)}{2}\) 但这个式子推不了什么。 有趣的是，若我们一直循环加上数的话，在取到 \(n-1\) 之后，所有数均会变小，但值得注意的是这些数因均相邻而出现了周期。 因而，在一个周期内，若出现了 \(0\)，输出即可。能保证最后的复杂度足够小。 时间复杂度：不大就对了 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, x, p; cin >> n >> x >> p; int cur = x; for(int i=1;i&lt;=min(p, 2*n);i++)&#123; cur = (cur + i) % n; if(cur == 0) &#123; cout &lt;&lt; "YES\n"; return; &#125; &#125; cout &lt;&lt; "NO\n"; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 捏吗，一直在想怎么搞式子 D. Accommodation 题意 给定 \(n\) 个长度为 \(m\) 的二进制串，满足 \(m \bmod 4 = 0\)，将字符串分割为 \(\frac{m}{4}\) 个长度为 \(2\) 的子串和 \(\frac{m}{2}\) 个长度为 \(1\) 的子串。输出所有含 \(1\) 子串个数总和的最大值和最小值。 思路 若我们需要让个数尽可能大，我们当然希望将 \(11\) 分割开，也就是构造非 \(11\) 的大窗，那么，我们不妨枚举所有含有 \(0\) 的可能的大窗，拿掉这些后，剩余的作为小窗，即可让个数尽可能大。 相反地，要让个数尽可能小，我们就希望尽可能不将 \(11\) 分割开，也就是主动构造为 \(11\) 的大窗，这时，能构造多少个，\(1\) 的个数就能减少多少。 有趣的是，只要分割出 \(\frac{m}{4}\) 个长度为 \(2\) 的子串，剩余的一定长度均为 \(1\)，且恰好 \(\frac{m}{2}\) 个；反之亦然。 当然，如果这题数据量小的话，可以 \(dp\)。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; int mn = 0, mx = 0; while (n--) &#123; string s; cin >> s; int c1 = 0, c2 = 0, tot = 0; for (int i = 0; i &lt; m; i++) tot += s[i] - '0'; for (int i = 0; i &lt; m - 1; i ++) if (s[i] == '1' &amp;&amp; s[i + 1] == '1') c1 ++, i ++; for (int i = 0; i &lt; m - 1; i ++) if (s[i] == '0' || s[i + 1] == '0') c2 ++, i ++; mn += tot - min(c1, m / 4); mx += tot - max(0ll, m / 4 - c2); &#125; cout &lt;&lt; mn &lt;&lt; ' ' &lt;&lt; mx &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 似了，在想怎么dp，贪心还没贪对（一直想着拆]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 857 Div. 2</title>
    <url>/blog/posts/1495891783/</url>
    <content><![CDATA[Virtual Participant. Unofficial Rank 382. Solved 4/7. A. Likes 题意 定义 \(a_i\) 为一个人对 \(|a_i|\) 的"喜欢"状态，当 \(a_i &gt; 0\) 时，该人对 \(|a_i|\) 点了"喜欢"，否则将其撤回了"喜欢"。规定未点喜欢就不能撤回"喜欢"。 给定打乱顺序后的若干人的"喜欢"操作，定义 \(b_i\) 为进行第 \(i\) 次操作后得到的"喜欢"数量。将操作按一定方案排序，输出让每次操作得到的数量最大和最小的序列 \(b\)。 思路 首先，若要让数量最少，我们直接在点了"喜欢"后立刻取消即可，那么最后得到的答案会有 \(x\) 个 \(0\ 1\)，\(x\) 即为负数的个数。剩余的数只能让 \(b\) 严格递增 \(1\)。 若要让数量最多，那么我们只需在全部点完后再取消。这时得到一个先递增后递减的序列。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; int cur; cin >> cur; if(cur &lt; 0) cnt ++; &#125; for(int i=1;i&lt;=n-cnt;i++) cout &lt;&lt; i &lt;&lt; ' '; for(int i=1;i&lt;=cnt;i++) cout &lt;&lt; n - cnt - i &lt;&lt; ' '; cout &lt;&lt; '\n'; for(int i=0;i&lt;cnt;i++) cout &lt;&lt; "1 0 "; for(int i=1;i&lt;=n-2*cnt;i++) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 瞎模拟即可 B. Settlement of Guinea Pigs 题意 给定一个操作序列，定义操作为下面任选一： "1"表示引入一个未知性别的猪，按规则放入一个栅栏内； "2"表示确定所有已经引入的猪的性别，按照规则重新排列。 定义一个栅栏内的猪性别需一致，且最多有两个猪。 输出最后需要至少多少个不同的栅栏。 思路 首先，在不知道性别的时候，新引入的猪只能单独放到一个栅栏内。 其次，若知道了性别，那么我们需要对奇偶性分类讨论： 若为奇数，那么母猪和公猪的数量一定为一个偶一个奇，那么当前就需要 \((\)总数量\(+1)/2\) 个栅栏 若为偶数，那么会出现两个偶数或两个奇数的可能，但我们不能确定为哪一种情况，所以我们考虑大的那个数量，也就是两个奇数的情况。这个时候，我们需要 总数量\(/2+1\) 个栅栏。 最后，对于每次操作，计算并统计最大值即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123; &#125; void solve() &#123; int n; cin >> n; int sum = 0, num = 0; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur == 1)&#123; sum ++, num ++; ans = max(ans, num); &#125;else&#123; if(sum == 0) num = 0; else num = (sum + 1 + (1 - sum % 2)) / 2; ans = max(ans, num); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 怎么奇数的情况搞错了（（ C. The Very Beautiful Blanket 题意 定义美丽矩阵满足下面的要求： 规模 \(4 \times 4\)； \(A_{11} \oplus A_{12} \oplus A_{21} \oplus A_{22} = A_{33} \oplus A_{34} \oplus A_{43} \oplus A_{44}\)； \(A_{13} \oplus A_{14} \oplus A_{23} \oplus A_{24} = A_{31} \oplus A_{32} \oplus A_{41} \oplus A_{42}\) 给定一个矩阵的规模，规模大于等于 \(4 \times 4\)，构造一个矩阵，使得所有 \(4 \times 4\) 的子矩阵均为美丽矩阵，且不同元素的数量最大。输出不同数字的数量，以及对应的一个矩阵。 思路 首先，值得留意的是：\(4x \oplus (4x+1) \oplus (4x + 2) \oplus (4x + 3) = 0\)。那么，我们不妨构造这样的子矩阵： \(\left[ {\begin{array}{cccc} 4x &amp; 4x + 1 \\ 4x + 2 &amp; 4x + 3 \end{array} } \right]\) 有趣的是，\(4x \oplus (4x + t) \oplus 4y \oplus (4y + t) = 0\) （巧了我不会证），那么我们不妨按照上面的矩阵依次排满第一行，然后找到大于所用过的数的第一个为 \(4\) 的倍数的数，继续按照上面的矩阵排列即可。那么，任意找出一个子矩阵，结果都为 \(0\)。 考虑到数据量，我们不妨让第 \(i\) 行的起始数字为 \(256(i - 1)\)，会让程序更好写。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123; &#125; void solve() &#123; int n, m; cin >> n >> m; cout &lt;&lt; n * m &lt;&lt; '\n'; for(int i=0;i&lt;n/2;i++)&#123; int offset = i * 512; for(int j=0;j&lt;m/2;j++) &#123; cout &lt;&lt; offset &lt;&lt; ' ' &lt;&lt; (offset + 1) &lt;&lt; ' '; offset += 4; &#125; if(m % 2 == 1) cout &lt;&lt; offset &lt;&lt; ' '; cout &lt;&lt; '\n'; offset = i * 512 + 2; for(int j=0;j&lt;m/2;j++) &#123; cout &lt;&lt; offset &lt;&lt; ' ' &lt;&lt; (offset + 1) &lt;&lt; ' '; offset += 4; &#125; if(m % 2 == 1) cout &lt;&lt; offset &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; if(n % 2 == 1)&#123; int offset = n / 2 * 512; for(int j=0;j&lt;m/2;j++) &#123; cout &lt;&lt; offset &lt;&lt; ' ' &lt;&lt; (offset + 1) &lt;&lt; ' '; offset += 4; &#125; if(m % 2 == 1) cout &lt;&lt; offset &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 不会证，但会猜（（（ D. Buying gifts 题意 给定 \(n\) 个商店，第 \(i\) 个商店具有 \(a_i, b_i\) 两个价格。规定每个商店均需要买一个商品，为 \(A\) 买第 \(i\) 个商店的物品花费 \(a_i\) 元，为 \(B\) 买第 \(i\) 个商店的物品花费 \(b_i\) 元。输出所有方案中为 \(A\) 买的商品的最大价格 \(\max_A\) 和为 \(B\) 买的商品的最大价格 \(\max_B\) 的差值的绝对值的最小值，即 \(\min\{|\max_A - \max_B|\}\)。 思路 首先，我们不可能去枚举所有的方案，那么我们至少需要一个 \(O(n \log n)\) 复杂度的解法。 我们可以枚举为 \(A\) 买的商品的最大值，也就是枚举所有的 \(a_i\)，将其作为当前的最大值，那么大于 \(a_i\) 数对应的商品只能给 \(B\)。 接着，我们可以二分查找 去除第 \(i\) 个商店后 剩余商店中的 所有 \(b_i\) 中 和 \(a_i\) 最近的两个数。若我们可以将这个数作为 \(B\) 的最大值，也就是说，所有大于 \(b_j\) 的数对应的 \(a_j\) 不能大于 \(a_i\)，那么更新差值的最小值。当然，有可能两个数都不满足，但是当前 \(B\) 中可以用的最大值依然可以和 \(a_i\) 减，他是有可能作为答案的。 对数复杂度的删除和查询，最佳之选就是 \(multiset\)。 而为了让上述操作更方便，我们不妨按 \(a_i\) 降序排序，那么，之前遍历过的 \(a_i\) 一定是要放到 \(B\) 里去的，而这些数也肯定不能在二分查找的范围内的，因而我们在遍历的时候，顺便记录前 \(i\) 个商店中 \(b_i\) 的最大值 \(mx\)，按照上面的分析执行即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123; &#125; void solve() &#123; int n; cin >> n; multiset&lt;int> a; vector&lt;pii> q(n); for(int i=0;i&lt;n;i++) cin >> q[i].first >> q[i].second; sort(q.begin(), q.end()); for(auto e : q) a.emplace(e.second); a.emplace(inf); int ans = inf, mx = -inf; for(int i=n-1;i>=0;i--)&#123; ans = min(ans, abs(q[i].first - mx)); a.erase(a.find(q[i].second)); auto it = a.lower_bound(q[i].first); if(*it != inf) &#123; if (q[i].first >= mx) ans = min(ans, abs(*it - q[i].first)); &#125; if (it != a.begin() &amp;&amp; q[i].first > mx) ans = min(ans, abs(*(--it) - q[i].first)); mx = max(mx, q[i].second); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 整个人升华了（划掉]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 827 Div. 4</title>
    <url>/blog/posts/3129987947/</url>
    <content><![CDATA[Practice. A. Sum 题意 给定三个数，输出是否可以找出一个数，满足其为另外两个数的和。 思路 如题。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; int a, b, c; cin >> a >> b >> c; cout &lt;&lt; (a + b == c || a + c == b || b + c == a ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 如题 B. Increasing 题意 给定一个序列，满足是否可以重新排列序列，使序列严格单调递增。 思路 没有重复元素即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; int n; cin >> n; map&lt;int, bool> mp; bool f = true; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; if(mp[cur]) &#123; f = false; &#125; mp[cur] = true; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 说那么复杂干嘛（ C. Stripes 题意 给定一个 \(8 \times 8\) 的矩阵，定义操作为将某一行全部涂成红色，或将某一列全部涂成蓝色，后面的颜色会覆盖前面的颜色。给定任意次操作后的矩阵，输出最后涂上的是什么颜色。 思路 首先，既然存在覆盖，那么被覆盖的某行或某列一定不是在最后操作的。 那么，我们可以找出全为红色的行，或者全为蓝色的列，若能找到就为答案。不然，一定存在覆盖。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> void solve()&#123; vector&lt;string> s(8); for(int i=0;i&lt;8;i++) cin >> s[i]; bool f = false; for(int i=0;i&lt;8;i++)&#123; bool now = true; for(int j=0;j&lt;8;j++)&#123; if(s[i][j] == 'B') now = false; &#125; if(now)&#123; f = true; cout &lt;&lt; "R\n"; break; &#125; &#125; if(!f) for(int j=0;j&lt;8;j++)&#123; bool now = true; for(int i=0;i&lt;8;i++)&#123; if(s[i][j] == 'R') now = false; &#125; if(now)&#123; f = true; cout &lt;&lt; "B\n"; break; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 略微有点小思维 D. Coprime 题意 给定一个序列 \(a\)，找出 \(i, j, i \neq j\)，满足 \(a_i, a_j\) 互质。输出满足条件的 \(i + j\) 的最大值。 思路 虽然整体数据量很大，但是需要留意的是 \(a_i \leq 1000\)。 因而，我们不妨记录出现过的数对应的下标最大值。然后，我们直接对 \(1000\) 中出现过的数字遍历，统计出最大值即可。 时间复杂度：\(O(1000 ^ 2 \log x)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> int gcd(int a, int b)&#123; return a == 0 ? b : gcd(b % a, a); &#125; void solve()&#123; int n; cin >> n; vector&lt;int> a(1001); for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; a[cur] = max(a[cur], i); &#125; int ans = -1; for(int i=1;i&lt;=1000;i++) for(int j=i;j&lt;=1000;j++)&#123; if(gcd(i, j) == 1 &amp;&amp; a[i] > 0 &amp;&amp; a[j] > 0) ans = max(ans, a[i] + a[j]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 来绕一个弯（（ E. Scuza 题意 给定一个上升台阶的所有相邻两层的高度差，对于 \(q\) 个询问给定的腿长 \(k_i\)，输出能登上的台阶距离地面的最大高度。 思路 首先，台阶上升，所以台阶距离地面的高度具有单调性。 那么，二分不就好了么。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int inf = 0x3f3f3f3f3f3f3f3f; void solve()&#123; int n, q; cin >> n >> q; vector&lt;int> a(n + 1), s(n + 2); for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; a[i] += a[i - 1]; s[i] = max(s[i - 1], a[i] - a[i - 1]); &#125; s[n + 1] = inf; while(q--)&#123; int x; cin >> x; cout &lt;&lt; a[upper_bound(s.begin(), s.end(), x) - s.begin() - 1] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) solve(); &#125; 考虑到lower_bound找不到会指向最后一个点，那么我们不妨在最后插一个无穷大 F. Smaller 题意 给定两个初始均为 \(&#39;a&#39;\) 的字符串 \(s, t\)，定义操作为下面两种任选一： \(1\ k\ x\)，在 \(s\) 后面循环拼接上 \(k\) 个 \(x\)； \(2\ k\ x\)，在 \(t\) 后面循环拼接上 \(k\) 个 \(x\)。 对于每次操作，输出是否可以重新排列两个字符串，使 \(s\) 的字典序小于 \(t\)。 思路 我们不妨直接考虑怎么样才能让字典序较小： 既然可以重新排序，而且一开始两个字符串是一样的，且只有一种字母，那么，只要 \(t\) 中出现了不是 \(a\) 的字符，我们直接把他放到第一个，而 \(s\) 的第一个直接放上 \(a\)，就一定可以满足 \(s &lt; t\)； 但是，若没有非 \(a\) 字符，我们就只能统计有多少个 \(a\)，个数少的字典序自然小。 那么，我们只要按照上述思路，统计 \(s, t\) 中是否出现了非 \(a\) 字符，以及 \(a\) 出现的次数即可。 最后，若 \(s\) 出现了非 \(a\) 字符而 \(t\) 中没有出现，或者都没出现但 \(s\) 的 \(a\) 数量更多，那么输出 \(NO\)，否则为 \(YES\)。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int cnt1 = 1, cnt2 = 1; bool h1 = false, h2 = false; int q; cin >> q; while(q --)&#123; int d, k; cin >> d >> k; string s; cin >> s; for(char e : s)&#123; if(d == 1)&#123; if(e == 'a') cnt1 += k; else h1 = true; &#125; if(d == 2)&#123; if(e == 'a') cnt2 += k; else h2 = true; &#125; &#125; cout &lt;&lt; ((!h1 &amp;&amp; !h2 &amp;&amp; cnt1 >= cnt2) || (h1 &amp;&amp; !h2) ? "NO\n" : "YES\n"); &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 略微绕了一下（ G. Orray 题意 给定一个序列 \(a\)，定义 \(b_i\) 为 \(a\) 前 \(i\) 个数按位或的值。将序列重新排序，满足 \(b\) 的字典序最大。输出任意一种满足条件的方案。 思路 首先，按位或一定是越或越大的，因而我们一定会把最大的数放在第一个。 接着，要让下个数尽可能大，我们当然希望找到一个数，对于当前的数的最高位 \(0\)，这个数的该位为 \(1\)。 我们可能找不到这个数，但是有趣的是，既然数据范围为 \(1e9\)，那么我们一定可以找出 \(32\) 个以内的数，让按位或的值递增。 因而，我们不妨直接遍历 \(32\) 次，找出剩下的让按位或的结果最大的数，输出该数即可。 而，当我们拿不出数字使按位或的结果变大时，就结束了。剩余的数随便输出即可。 时间复杂度：\(O(32 n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; vector&lt;int> ans; vector&lt;bool> vis(n); int tot = 0; for(int i=31; i>=0;i--)&#123; int idx = -1, now = 0; for(int j=0;j&lt;n;j++)&#123; if(vis[j]) continue; if((tot | a[j]) > now)&#123; now = tot | a[j]; idx = j; &#125; &#125; if(idx == -1) break; vis[idx] = true; ans.emplace_back(a[idx]); tot |= a[idx]; &#125; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; for(int i=0;i&lt;n;i++) if(!vis[i]) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t; cin >> t; while (t --) solve(); &#125; 想不到就绕死了（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 293</title>
    <url>/blog/posts/2378255232/</url>
    <content><![CDATA[Contestant. Rank 2467. Rating +89. A. Swap Odd and Even 题意 给定一个字符串，将所有 \(2x\) 和 \(2x+1\) 位字符交换位置，输出操作后的字符串。 思路 模拟即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; string s; cin >> s; for(int i=0;i&lt;s.size()/2;i++)&#123; char t = s[2 * i]; s[2 * i ] = s[2 * i + 1]; s[2 * i + 1] = t; &#125; cout &lt;&lt; s; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 快速签到 B. Call the ID Number 题意 给定一个序列 \(a\)，对于第 \(i\) 个元素，若 \(i\) 没被标记，那么将 \(a_i\) 标记。遍历序列后，输出剩余未标记的数。 思路 模拟即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n; cin >> n; vector&lt;bool> vis(n + 1); int cnt = n; for(int i=1;i&lt;=n;i++)&#123; int cur; cin >> cur; if(vis[i] || vis[cur]) continue; cnt --; vis[cur] = true; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i]) cout &lt;&lt; i &lt;&lt; ' '; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 依然快速签到 C. Make Takahashi Happy 题意 给定一个 \(H \times W\) 的加权矩阵，规定一次移动只能向下或向右走，且不能超出矩阵范围。对于起点 \((1,1)\) 和终点 \((H, W)\)，输出满足路径中无重复元素的路径数。 思路 考虑到题给范围特别小，我们不妨直接 \(Dfs\)，用回溯搜索的方式记录当前元素出现了几次，若出现两次跳出搜索即可。 时间复杂度：\(O(n^2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[20][20], h, w, ans; map&lt;int, int> cnt; void init()&#123;&#125; void dfs(int x, int y)&#123; if(x == h &amp;&amp; y == w)&#123; ans ++; return; &#125; if(x + 1 &lt;= h &amp;&amp; cnt[a[x + 1][y]] == 0) &#123; cnt[a[x + 1][y]] ++; dfs(x + 1, y); cnt[a[x + 1][y]] --; &#125; if(y + 1 &lt;= w &amp;&amp; cnt[a[x][y + 1]] == 0) &#123; cnt[a[x][y + 1]] ++; dfs(x, y + 1); cnt[a[x][y + 1]] --; &#125; &#125; void solve() &#123; cin >> h >> w; for(int i=1;i&lt;=h;i++) for(int j=1;j&lt;=w;j++) cin >> a[i][j]; cnt[a[1][1]] ++; dfs(1, 1); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 就很暴力 D. Tying Rope 题意 定义一段绳子有两个端点，一端为红色，另一端为蓝色。对于 \(k\) 次操作，将第 \(A\) 个绳子颜色为 \(B\) 的一端和第 \(C\) 个绳子颜色为 \(D\) 的一端连接。 特别地，满足一端绳子不会和两条及以上绳子连起来。 输出连通块中环和链的个数。 思路1 首先，既然考虑到这个特别的条件，我们完全可以不管颜色，因为题目一定有解，对于一段绳子，它的一个端点只会出现在最多一次操作里。所以，在本次操作后，下一次再访问到这个绳子，一定是另一个点了。 为了读入数据方便，我们定义绳子左端点是红色的、右端点是蓝色的。 那么，按照上述方法，我们可以很简单地得到一条绳子它的左端点和右端点分别和哪条绳子连起来了。 接着，我们只需遍历所有绳子，对于第 \(i\) 个绳子，若它未被访问到，那么他一定是新的连通块的一部分，我们向左和向右找寻边界。当我们遍历到端点未和其他点连接时，结束寻找，此时枚举到的所有点都是这个连通块的一部分。但，若我们遍历到了之前遍历过的绳子，那么很显然存在了环，所以我们直接统计个数并跳过这个连通块继续寻找。 在找寻边界的时候，因为读入数据的特殊性，对于 \(A \rightarrow B \rightarrow C\)，若 \(B\) 的右端点和 \(A\) 的右端点连接，那么会出现死循环，但是此时会出现回到上一个相邻点的情况，而且我们不难发现，只有这种特殊情况才会出现"回溯"。所以，我们只需记录前一个绳子 \(A\)，找到 \(B\) 的左右端点中不是 \(A\) 的那个点所连接的绳子 \(C\) 即可。 时间复杂度：\(O(m + n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; void solve() &#123; int n, m; cin >> n >> m; //规定左红右蓝 vector&lt;vector&lt;int>> ac(n + 1, vector&lt;int>(2, -1)); for(int i=1;i&lt;=m;i++)&#123; int a, b, c, d; char bc, dc; cin >> a >> bc >> c >> dc; b = bc == 'R' ? 0 : 1; d = dc == 'R' ? 0 : 1; ac[a][b] = c; ac[c][d] = a; &#125; vector&lt;bool> vis(n + 1); int ans1 = 0, ans2 = 0; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]) continue; int now, pre; vis[i] = true; pre = i, now = ac[i][0]; bool ok = false; if(now != -1)&#123; vis[now] = true; while(true)&#123; int tmp = now; now = ac[now][0] == pre ? ac[now][1] : ac[now][0]; pre = tmp; if(now == -1) break; if(vis[now])&#123; ans1 ++; ok = true; break; &#125; vis[now] = true; &#125; &#125; pre = i, now = ac[i][1]; if(!ok &amp;&amp; now != -1) &#123; vis[now] = true; while (true) &#123; int tmp = now; now = ac[now][1] == pre ? ac[now][0] : ac[now][1]; pre = tmp; if (now == -1) break; if (vis[now]) &#123; ans1++; ok = true; break; &#125; vis[now] = true; &#125; &#125; if(!ok) ans2 ++; &#125; cout &lt;&lt; ans1 &lt;&lt; ' ' &lt;&lt; ans2 &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 无脑模拟（（ 思路2 本题也可以用并查集完成。 待补充 磕了半天居然磕出来了 E. Geometric Progression 题意 给定三个整数 \(A, X, M\)，输出 \((\displaystyle{\sum^{X-1}_{i=0} A ^ i) \bmod M}\)。 思路 首先，很明显这是等比数列求和公式，最后的答案就是 \(\frac{A ^ X - 1}{A-1} \bmod M\)。 但是，问题在于这个除法取模。 一般除法取模需要求逆元，但是本题的 \(A, M\) 是任意的，所以 \(M\) 不是质数并且 \(A, M\) 不互质的时候，无法求出逆元。 但是，若我们对 \(A^X - 1\) 因式分解，当 \(A = 1\) 时一定是一个让式子为 \(0\) 的根，也就是说可以提出 \(A - 1\)。 那么，\(A - 1\) 就可以消掉了。 为了取模计算方便，我们不妨在求快速幂的时候，对 \(M(A - 1)\) 取模，最后除掉 \(A - 1\) 即可。 因而，最后我们可以得到一个式子：\(\frac{A ^ X \bmod (M(A - 1)) - 1}{A-1}\)。 当然，当 \(A = 1\) 的时候需要特判，这只和 \(X \bmod M\) 的奇偶性有关。 时间复杂度：有点复杂 注意M(A-1)会爆long long，需要用__int_128 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int __int128_t #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void init()&#123;&#125; int qp(int a, int b, int m) &#123; a %= m; int res = 1; while (b > 0) &#123; if (b &amp; 1) res = res * a % m; a = a * a % m; b >>= 1; &#125; return res; &#125; void solve() &#123; long long a, x, m; cin >> a >> x >> m; cout &lt;&lt; (a == 1 ? x % m : (((long long) qp(a, x, m * (a - 1)) - 1) / (a - 1)) % m) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while (t --) solve(); &#125; 麻了，被逆元坑了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 828 Div. 3</title>
    <url>/blog/posts/3533911585/</url>
    <content><![CDATA[Practice. A. Number Replacement 题意 给定一个序列，一个字母可以映射到任意一个数字，但要求一个字母只能映射到一个数字，一个数字可以映射到多个字母。输出是否合法。 思路 简单，我们用哈希即可。用 \(map\) 即可解决本题。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve() &#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; string s; cin >> s; map&lt;int, char> mp; bool f = true; for(int i=0;i&lt;n;i++)&#123; if(mp[a[i]] > 0 &amp;&amp; mp[a[i]] != s[i]) f = false; mp[a[i]] = s[i]; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while(t --) solve(); &#125; 水.jpg B. Even-Odd Increments 题意 给定一个序列，含有奇数和偶数，定义操作如下： \(0\ x\) 表示将 \(x\) 添加到所有偶数上； \(1\ x\) 表示将 \(x\) 添加到所有奇数上。 在每次操作后，输出总和。前面的操作会影响后面的值。 思路 显然，我们只需统计当前序列有多少偶数即可。 设偶数的个数为 \(cnt\)，那么第一个操作即为将 \(sum\) 加上 \(even \times x\)，第二个操作即为将 \(sum\) 加上 \((n - even) \times x\)。 显然，我们不需要在每次操作后遍历找偶数个数，而是考虑下面的规律： 偶数加奇数为奇数； 奇数加奇数为偶数。 因而，若出现将奇数加在奇数上的情况，那么 \(even = n\)，若出现将奇数加在偶数上的情况，那么 \(even = 0\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve() &#123; int n, q; cin >> n >> q; vector&lt;int> a(n); //注意一下偶数和奇数的相加即可 int even = 0, sum = 0; for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; sum += a[i]; if(a[i] % 2 == 0) even ++; &#125; while(q --)&#123; int t, v; cin >> t >> v; if(t % 2 == 0)&#123; //加到偶数上 sum += even * v; cout &lt;&lt; sum &lt;&lt; '\n'; if(v % 2 == 1) even = 0; //偶加奇 &#125;else&#123; //加到奇数上 sum += (n - even) * v; cout &lt;&lt; sum &lt;&lt; '\n'; if(v % 2 == 1) even = n; //奇加奇 &#125; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while(t --) solve(); &#125; 偏模拟的思维题 C. Traffic Light 题意 定义三种交通信号灯：\(R,H,G\)，只有位于 \(G\) 的时间下才可过马路。交通信号灯的切换具有周期性，因而给定一个周期的信号灯切换情况 \(s\)，如 \(s = RBRGG\)，那么在执行五秒后，将会重新执行一次，构成 \(RBRGGRBRGGRB...\)。给定当前的信号灯种类 \(c\)，输出遇到下一个 \(G\) 所间隔的最长时间。 思路 如上，我们只需遍历所有 \(c\)，找出其和下一个 \(G\) 的距离即可。 至于距离，数据范围貌似可以允许我们暴力往后搜，但后缀数组会出手。 我们维护后缀数组，\(suf_i\) 表示 \(i\) 及以后第一个出现的 \(G\) 的位置。 那么，查询的复杂度即为 \(O(1)\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve() &#123; int n; char c; cin >> n >> c; string s; cin >> s; s = " " + s + s; n *= 2; vector&lt;int> suf(n + 1); suf[n] = -1; for(int i=n - 1;i>=1;i--)&#123; if(s[i] == 'g') suf[i] = i; else suf[i] = suf[i + 1]; &#125; int mx = 0; for(int i=0;i&lt;n;i++)&#123; if(s[i] == c) mx = max(mx, suf[i] - i); &#125; cout &lt;&lt; mx &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while(t --) solve(); &#125; 可能就真的能暴力（（ D. Divisibility by 2^n 题意 给定一个长度为 \(n\) 的序列，定义一次操作为选取一个 \(a_i\) 并将其改为 \(a_i \times i\)。输出最少的操作数，使最后的序列的乘积为 \(2 ^ n\) 的倍数。 思路 首先，乘上奇数绝对没什么用，所以我们只需考虑偶数。 观察偶数的递推性以及二进制下的规律，我们不难发现所有的偶数都是一个 \(2 ^ t\) 乘上一个奇数得到的。 上述没必要乘上偶数，毕竟那就是 \(2 ^ {t + 1}\) 的事情了，为何要考虑重复呢。 因而，我们自然希望我们能在一次操作中乘上尽可能多的 \(2\)，也就是让 \(t\) 尽可能大。 这个 \(t_{\max}\) 是很容易求的，我们只需循环乘二直到不超过 \(n\) 的最大值即可。 那么，我们不妨去枚举 \(2 ^ t\) 的奇数倍，然后在超过 \(n\) 后将 \(t\) 递减，这样即可满足条件。 在加之前，我们判断一下当前能除多少个 \(2\)，和 \(n\) 比较即可。 时间复杂度：\(O(nt)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve() &#123; int n; cin >> n; int cnt = 0; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; while(cur % 2 == 0)&#123; cur /= 2; cnt ++; &#125; &#125; int mx = 1, cur = 2; while(true)&#123; if(cur * 2 > n) break; mx ++; cur *= 2; &#125; int ans = 0; for(int i=mx;i>=1;i--)&#123; for(int j=1;pow(2, i)*j&lt;=n;j+=2)&#123; //奇数倍 if(cnt >= n) break; cnt += i; ans ++; &#125; if(cnt >= n) break; &#125; cout &lt;&lt; (cnt >= n ? ans : -1) &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while(t --) solve(); &#125; 奇怪的清晰思路增加了 E1. Divisible Numbers (easy version) 详见E2，区别是本题的数据范围小 E2. Divisible Numbers (hard version) 题意 给定 \(4\) 个整数 \(a, b, c, d\)，找出一对 \(x, y\)，满足 \(x \in (a, c], y \in (b, d], xy\) 可以被 \(ab\) 整除。 思路 首先，我们不难发现，\(y = k \times \frac{ab}{gcd(ab, x)}\)，其中 \(k\) 为常数，那么，我们可以很简单的用 \(O(1)\) 的复杂度算出 \(y\)。 那么我们来考虑 \(x\)。显然，\(x \neq 1\)，所以 \(x\) 就是 \(gcd(ab, x)\) 的倍数，或者说，是 \(ab\) 的因数的倍数。 那么，我们只需枚举所有的因数，然后，我们也可以用 \(O(1)\) 的方法算出 \(x\)，和求 \(y\) 的方法类似。 但是，枚举 \(ab\) 的因数是不现实的，因为 \(\sqrt{ab}\) 太大了。但是，既然我们可以将这个数分解为 \(a, b\)，那么它的所有因数就是 \(a\) 的所有因数和 \(b\) 的所有因数配对相乘。 因而，\(\sqrt a\) 可以减到 \(1e5\) 的复杂度，足以。 时间复杂度：\(O(\sqrt a + \sqrt b + t ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; vector&lt;int> fact(int x) &#123; vector&lt;int> facts; int sq = (int) sqrt(x); for (int i = 1; i &lt; sqrt(x); i++) &#123; if (x % i == 0) facts.emplace_back(i), facts.emplace_back(x / i); &#125; if (sq * sq == x) facts.emplace_back(sq); return facts; &#125; void solve() &#123; int a, b, c, d; cin >> a >> b >> c >> d; vector&lt;int> factA = fact(a), factB = fact(b); bool f = false; for (int i: factA) &#123; for (int j: factB) &#123; int bx = i * j, by = a * b / (i * j); int x = ((int) ceil((double) a / (double) bx) + (a % bx == 0 ? 1 : 0)) * bx, y = ((int) ceil((double) b / (double) by) + (b % by == 0 ? 1 : 0)) * by; if (x &lt;= c &amp;&amp; y &lt;= d) &#123; cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n'; f = true; break; &#125; &#125; if (f) break; &#125; if (!f) cout &lt;&lt; -1 &lt;&lt; ' ' &lt;&lt; -1 &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); //init(); int t; cin >> t; while (t --) solve(); &#125; 一开始还想着贪心，似也做不出来，淦]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 856 Div. 2</title>
    <url>/blog/posts/4284380403/</url>
    <content><![CDATA[Contestant. Rank 1866. Rating -16. A. Prefix and Suffix Array 题意 给定一个字符串的所有前缀和后缀，如 \(a, ab, abc, bca, ca, a\)，不包含其本身，判断原字符串是否是回文字符串。 思路 既然是前后缀，并且回文字符串的判断只需比较 \([0, \frac{n}{2}]\) 和 \([n - \frac{n}{2} - 1, n - 1]\) 区间对应的子串即可，所以我们只需拿出长度为 \(\frac{n}{2}\) 的两个字符串，将一个字符串反转后和另一个比较，相等即回文。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve()&#123; int n; cin >> n; vector&lt;string> s; for(int i=0;i&lt;2 * (n - 1); i++)&#123; string now; cin >> now; if(now.size() == n / 2) s.emplace_back(now); &#125; std::reverse(s[0].begin(), s[0].end()); cout &lt;&lt; (s[0] == s[1] ? "YES\n" : "NO\n"); &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 真是阴间时间下猪脑转不动了（ B. Not Dividing 题意 给定一个长度为 \(n\) 的数组 \(a\)，定义操作为选择任意一个数字并将其加减 \(1\)，操作最多执行 \(2n\) 次。输出一种方案操作后得到的数组，满足 \(a_{i + 1}\) 不能被 \(a_i\) 整除。 思路 首先，不能出现 \(1\)，因为无论前面的数怎么改变，最后都会被 \(1\) 整除，所以遇到 \(1\) 改成 \(2\)。 其次，奇数不能被偶数整除，而偶数可以被奇数整除，但该偶数 \(+1\) 就不会被该奇数整除了（具体证明不清楚）。 最后，我们得到下面的结论：遇到整除，将后者加一，除非遇到 \(1\)，此时将前者加一。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; void solve()&#123; int n; cin >> n; int pre; cin >> pre; if(pre == 1) pre ++; cout &lt;&lt; pre &lt;&lt; ' '; for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; if(cur == 1) cur ++; if(cur % pre == 0)&#123; pre = cur + 1; &#125;else pre = cur; cout &lt;&lt; pre &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 当然不是简简单单的判奇偶啊... C. Scoring Subsequences 题意 定义一个不递减序列 \(s\) 的 \(cost\) 为 \(\frac{s_1\cdot s_2\cdot \ldots \cdot s_d}{d!}\)。给定一个长度为 \(n\) 的序列，对于所有 \(k \in [1, n]\)，输出前 \(k\) 个数的所有子序列的最大 \(cost\) 对应的最大子序列长度。 思路 首先，第一个数对应的答案一定是 \(1\)，这是毋庸置疑的。 那么，遍历到第二个数的时候，我们可以继续保持答案 \(1\)，也可以把答案更新为 \(2\)，此时对应为选第二个数或者都选，因为序列是不递减的。 那么，假设我们选了两个数，那么继续遍历到第三个数的时候，由于第二三两个数的乘积大于等于前两个数的乘积，所以答案是肯定大于等于 \(2\) 的，我们唯一需要判断的就是前一个数能不能放进来。 为什么不用再往前考虑呢？因为之前我们已经判断过了，比如说第二次只选了一个数，那么 \(a_2 \geq \frac{a_1 \times a_2}{2} =&gt; a_1 \leq 2\)，也必定满足 \(\frac{a_2 \times a_3}{2} \geq \frac{a_1 \times a_2 \times a_3}{2 \times 3} =&gt; a_1 \leq 3\)。 因此，这道题就变得很好写了（ 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; void solve()&#123; int n; cin >> n; for(int i=1;i&lt;=n;i++) cin >> a[i]; vector&lt;int> ans(n + 1); ans[1] = 1; for(int i=2;i&lt;=n;i++)&#123; ans[i] = ans[i - 1]; if(a[i - ans[i]] > ans[i]) ans[i] ++; &#125; for(int i=1;i&lt;=n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 想个半天，差点没看到给的序列不递减，淦 D. Counting Factorizations 题意 对于一个数 \(m\)，由算术基本定理可知，它可以分解为 \(m=p_1^{e_1}\cdot p_2^{e_2}\cdot \ldots \cdot p_k^{e_k}\)，现将所有底数和指数拿出来作为一个序列 \(f(m) = \{p_1, e_1, p_2, e_2, \ldots \}\)，定义如上。 现在，给定上述序列，长度为 \(2n\)，序列的顺序未知，输出所有可能的排序中，\(m\) 的个数总和，\(\mod 998244353\)。 思路 特判 首先，底数一定为不同的 \(n\) 个质数，所以拿到数据后，我们应该先将所有不同的质数找出，若数量不够，直接输出 \(0\)。 指数的全排列问题 否则，我们假设已经选好了 \(n\) 个质数，来考虑一下指数怎么排。 这是一个含有重复数字的全排列问题，它有一个公式，套用在本题即为下面的称述： 我们定义 \(b\) 为所有合数的数量的序列，遍历得到长度为 \(s\)，如 \(2, 3, 4, 4\) 中，\(s = 1, b_1 = 2\)； 同理，\(c\) 为所有质数的数量的序列，长度为 \(t\)； 考虑到有部分质数被拿走，作为了底数，所以部分 \(c_i\) 会减少一定的值。因为底数不能重复，所以最多减少 \(1\)，我们定义 \(c&#39;\) 为所有质数扣去底数后的数量的序列； \(ans = \frac{n!}{b_1!\:\:b_2!\ldots b_s!\:\:c&#39;_1!\:\:c&#39;_2!\ldots c&#39;_t!}\) 那么，最后的答案即为所有 \(ans\) 的和。 简化问题 显然，\(\frac{n!}{b_1!\:\:b_2!\ldots b_s!}\) 可以作为公因子提出，而剩余的数可以进行通分，提出 \(\frac{1}{c_1!\:\:c_2!\ldots c_t!}\)（注意这里是 \(c\)，不是 \(c&#39;\)，能提出的原因是 \(x! = x * (x - 1)!\)），剩余的分子即为 \(t\) 个数里面选 \(n\) 个的所有组合的和，每个组合的值为其包含的元素的乘积。 因此，我们只需要在所有不同质数中挑选 \(n\) 个，求出所选数字的乘积，最后所有不同选择算得的乘积总和乘上之前提出的公因子即为答案。 当然，我们可以递归枚举，但是这样复杂度未免太高了。 如何递推 所有乘积的式子的元素顺序是不影响答案的，所以我们不妨按照序列的顺序将每个式子的元素排序。 如对于下面的序列，我们希望从这 \(5\) 个元素中选 \(3\) 个： 1 2 3 5 4 因为我们确定了元素的顺序，所以我们不妨来考虑一个特定的元素：\(5\)。 对于一个乘积式子 \(? \times ? \times ?\)，我们将第三位填上 \(5\)，那么可以得到这些式子：\(1 \times 2 \times 5 + 1 \times 3 \times 5 + 2 \times 3 \times 5\)， 也就是 \((1 \times 2 + 1 \times 3 + 2 \times 3) \times 5\)。 也就是说，前面两项的选择只和 \(5\) 前面的数有关。 我们还可以将上面的式子提取一下：\((1 \times 2 + (1 + 2) \times 3) \times 5\)。 这时，\(3\) 来到了第二位，它的结果和 \(5\) 的运算大同小异。 而对于类似于 \(1\) 在第 \(3\) 项的情况，我们可以假想地在序列前加上几个 \(0\)，这样对结果毫无影响，但却让 \(1\) 出现在了 \([1, n]\) 的每一位。 事实上，我们可以加上含 \(0\) 的若干项，使所有数字均在 \([1, n]\) 的每一位出现，而如果这样，那么我们可以枚举每一个数字位于哪一位，然后将 上一位 的 前 \(x - 1\) 个选择 所得的答案乘上这个数字，得到 前 \(x\) 位的 前 \(x\) 个选择的乘积。 显然，我们还需要加上不选这个数字的情况，也就是前一个数字的前 \(x\) 个选择所推得的答案。 因而，上述思路可以用二维 \(dp\) 实现，\(dp[i][j]\) 表示前 \(i\) 个数的前 \(j\) 个选择的推算结果。 关于 \(dp\) 部分，本思路正反递推都是可行的，下面给出正向递推的状态转移方程： \(dp[i][j] = dp[i][j] + dp[i - 1][j - 1] \times c[i]\) 其中，\(c\) 为所有不同的质数的数量的序列，下标从 \(1\) 开始。 优化复杂度 阶乘和阶乘逆元可以预处理得到，而质数的判断可以使用线性筛（欧拉筛），求逆元的话可以线性递推也可以快速幂。 时间复杂度：常数有点大的\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 1e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; bool vis[N], is[N]; int pri[N], cnt; int fact[N], fact_inv[N]; int qp(int a, int b)&#123; int ans = 1; while(b > 0)&#123; if(b &amp; 1) ans = ((ans % mod) * (a % mod)) % mod; a = ((a % mod) * (a % mod)) % mod; b >>= 1; &#125; return ans; &#125; void init() &#123; for (int i = 2; i &lt;= 1e6; ++i) &#123; if (!vis[i]) &#123; pri[cnt++] = i; is[i] = true; &#125; for (int j = 0; j &lt; cnt; ++j) &#123; if (1ll * i * pri[j] > 1e6) break; vis[i * pri[j]] = true; if (i % pri[j] == 0) break; &#125; &#125; fact[0] = fact_inv[0] = 1; for(int i=1;i&lt;=1e6;i++)&#123; fact[i] = ((fact[i - 1] % mod) * (i % mod)) % mod; fact_inv[i] = qp(fact[i], mod - 2); &#125; &#125; void solve() &#123; int n; cin >> n; vector&lt;int> in(2 * n); map&lt;int, int> tot; for (int i = 0; i &lt; 2 * n; i++) &#123; cin >> in[i]; tot[in[i]]++; &#125; vector&lt;int> c; int el = fact[n]; for(auto e : tot)&#123; if (is[e.first]) c.emplace_back(e.second); el = ((el % mod) * (fact_inv[e.second] % mod)) % mod; &#125; if (c.size() &lt; n) &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; return; &#125; vector&lt;vector&lt;int>> dp(c.size() + 1, vector&lt;int>(n + 1, 0)); dp[0][0] = 1; for (int i = 1; i &lt;= c.size(); i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; dp[i][j] = dp[i - 1][j]; if (j > 0) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * c[i - 1]) % mod; //这里的c初始下标是0 &#125; &#125; cout &lt;&lt; (el * dp[c.size()][n]) % mod &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); init(); int t = 1; //cin >> t; while(t --) solve(); &#125; 我人似了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 855 Div. 3</title>
    <url>/blog/posts/3115409144/</url>
    <content><![CDATA[Contestant(alt). Rank 3678. Rating +62(+262 -200). A. Is It a Cat? 题意 给定一个字符串，转化为小写字母后，判断其是否由 \(m, e, o, w\) 组成，四个字母可以出现重复多个，但顺序不能改变，且每一个字母必须出现至少一次。如 \(MeOooOW\)。 思路 如题，我们只需用一个变量存储当前遍历到了哪个字母，若比较到某一个字母的时候，遍历的下标越界，那么输出 \(NO\)。否则，在最后判断一下四个字母是否都出现了至少一次，若满足那么 \(YES\)，否则 \(NO\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int tp = 0; char up[4] = &#123;'M', 'E', 'O', 'W'&#125;, lo[4] = &#123;'m', 'e', 'o', 'w'&#125;; bool ok[4] = &#123;false&#125;; bool f = true; for(int i=0;i&lt;n;i++)&#123; while(tp &lt; 4 &amp;&amp; s[i] != up[tp] &amp;&amp; s[i] != lo[tp]) tp ++; if(tp >= 4)&#123; f = false; break; &#125; ok[tp] = true; &#125; cout &lt;&lt; (ok[0] &amp;&amp; ok[1] &amp;&amp; ok[2] &amp;&amp; ok[3] &amp;&amp; f ? "YES\n" : "NO\n"); &#125; &#125; 瞎模拟即可 B. Count the Number of Pairs 题意 给定一个字符串以及一个整数 \(k\)，规定同一个字母的大写和小写可以进行配对，一个字符只能出现在一对数中。定义一次操作为选择一个字符改变它的大小写，输出在小于等于 \(k\) 次的操作后，最多有多少对数。 思路 我们用两个数组解决这个问题： 令小写字母对应权值为 \(1\)，大写字母对应权值为 \(-1\)，那么加权后每种字母的总和的绝对值可以表征配对了多少对。我们记它为 \(abs(ans[i])\)。 统计每一种数出现的次数 \(cnt[i]\)。 那么，在不进行操作的前提下，我们易得最后的答案为 \(\sum \frac{(cnt[i] - abs(ans[i])}{2}\)。 若可以进行操作，那么对于一个字母剩余的数 \(ans[i]\)，我们可以配对 \(\frac{ans[i]}{2}\) 个。 因此，最后的答案即为 \(\sum \frac{(cnt[i] - abs(ans[i])}{2} + min(k, \sum \frac{ans[i]}{2})\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n, k; cin >> n >> k; string s; cin >> s; int cnt[26]&#123;&#125;, ans[26]&#123;&#125;; for(int i=0;i&lt;n;i++)&#123; if(s[i] >= 'a' &amp;&amp; s[i] &lt;= 'z') &#123; cnt[s[i] - 'a'] ++; ans[s[i] - 'a'] ++; &#125;else&#123; cnt[s[i] - 'A'] ++; ans[s[i] - 'A'] --; &#125; &#125; int res = 0, left = 0; for(int i=0;i&lt;26;i++)&#123; res += (cnt[i] - abs(ans[i])) / 2; left += abs(ans[i]) / 2; &#125; cout &lt;&lt; res + min(k, left) &lt;&lt; '\n'; &#125; &#125; 总感觉类似的题哪里做过 C1. Powering the Hero (easy version) 详见C2，区别是C1的数据量更小一点 C2. Powering the Hero (hard version) 题意 给定 \(n\) 个卡牌对应的数字，从前向后遍历，若数字不为 \(0\)，那么可以选择是否将该数放在堆顶，或者将其丢弃。对于所有为 \(0\) 的数字，从堆顶拿出一个牌作为这个 \(0\) 的加分值，并将这两个牌丢弃，若堆为空则不考虑。输出最后加分的最大值。 思路 既然可以选择放或不放，那么我们一定可以让后面的 \(cnt\) 个 \(0\) 拿到前面的前 \(cnt\) 大的数。 因而，我们直接用优先队列即可。 有趣的是，困难版的数据量也无碍。 时间复杂度：最坏\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; priority_queue&lt;int> q; int ans = 0; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; if(cur != 0) q.push(cur); else if(!q.empty()) ans += q.top(), q.pop(); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 赛时贪错了，吃了WA D. Remove Two Letters 题意 给定一个字符串，输出去掉连续的两个字母后，得到的所有字符串中不同的字符串的个数。 思路 我们不妨取补集： 对于一个序列，若要出现重复的子串，那么需要满足 \(s[i] == s[i + 2]\)，这样的话，去掉 \(s[i], s[i + 1]\) 和去掉 \(s[i + 1], s[i + 2]\) 就是等价的了。 因而，我们统计出对数，用 \(n - 1\) 减去即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int ans = 0, cnt = 1; char pre0 = s[0], pre1 = s[1]; for(int i=1;i&lt;n-1;i++)&#123; char cur0 = s[i], cur1 = s[i + 1]; if((pre0 == cur0 &amp;&amp; pre1 == cur1) || pre0 == cur1 &amp;&amp; pre1 == cur0)&#123; cnt ++; &#125;else&#123; ans += cnt - 1; cnt = 1; pre0 = cur0, pre1 = cur1; &#125; &#125; cout &lt;&lt; n - (ans + cnt - 1) - 1 &lt;&lt; '\n'; &#125; &#125; 赛时的代码居然还写的麻烦了一点（（ E1. Unforgivable Curse (easy version) 详见E2，区别是本题k=3 E2. Unforgivable Curse (hard version) 题意 给定两个长度相等的字符串 \(s, t\)，定义操作为交换 \(i, i + k\) 或 \(i, i + k + 1\) 上的数，在任意数量的操作后，输出是否可以将 \(s\) 更改为 \(t\)。 思路 首先，我们只需进行下面的操作即可将相邻数交换： \(i, i + k + 1\) \(i + k + 1, i + 1\) \(i, i + k + 1\) 因而，只要可以进行上面的操作（或者向左），那么我们只需进行一定的操作，肯定可以将其换到我们需要的为止。 那么，我们也不难发现，若要向右交换，那么 \(i &gt; k - n\)，若要想左交换，那么 \(i &lt; k\)。 因而，只要 \([k, k - n]\) 内的字符相等，就一定有解。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int a[N]; void solve()&#123; int n, k; cin >> n >> k; string s, t; cin >> s >> t; if(n &lt;= k) cout &lt;&lt; (s == t ? "YES\n" : "NO\n"); else&#123; bool f = true; if(2 * k > n)&#123; for(int i=n-k;i&lt;k;i++) if(s[i] != t[i]) f = false; &#125; if(f)&#123; sort(s.begin(), s.end()); sort(t.begin(), t.end()); f = s == t; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) solve(); &#125; 比赛快结束的时候就懒得写了（其实还挺好写的 F. Dasha and Nightmares 题意 给定 \(n\) 个字符串，输出有多少对字符串，满足下面的条件： 两个字符串的长度总和为奇数； 不同字母的个数为 \(25\)； 每种字母出现的次数为奇数。 思路 首先，第一个条件可以忽略，因为偶数个奇数相加，一定是奇数。 其次，第二个条件即为排除掉一个字母，需要其余的字母均出现。 考虑到 \(25\) 足够小，我们不妨用状压。 更具体地说，我们枚举不出现的字母 \(x\)，然后枚举所有字符串，对于字符串 \(s_i\)，它的所有字母的出现次数均可以预处理。但，因为我们只需考虑奇偶性，所以我们不妨令奇数状态为 \(1\)，偶数状态为 \(0\)，按照字母表顺序构建一个 \(26\) 位二进制字符串，便可以得到这个字符串的"哈希"值。 那么，考虑到异或的可逆性，对于一个排除掉 \(x\) 的拼接后的字符串，它的哈希值一定为形如 \(111...0...111\)，\(0\) 位即为 \(x\)。那么，对于这个 \(p = (1 &lt;&lt; 26)\ XOR\ (1 &lt;&lt; x)\)，我们可以将其和 \(s_i\) 的哈希值进行异或，得到需要和其配对的字符串的哈希值。 显然，对于第 \(i\) 个字符串，我们只需遍历前 \(i - 1\) 个字符串是否可以与其配对即可。那么，我们可以用 \(map\) 存储一个哈希值对应的字符串有多少个，最后统计总和即可。 时间复杂度：\(O(25n + m) = 1e7\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e6 + 10, inf = 0x3f3f3f3f3f3f3f3f, mod = 998244353; int odd[N], num[N]; void solve()&#123; int n; cin >> n; for(int i=0;i&lt;n;i++)&#123; string cur; cin >> cur; for(char e : cur)&#123; odd[i] ^= (1 &lt;&lt; (e - 'a')); num[i] |= (1 &lt;&lt; (e - 'a')); &#125; &#125; int ans = 0; for(int i=0;i&lt;26;i++)&#123; //不选i map&lt;int, int> cnt; int tot = ((1 &lt;&lt; 26) - 1) ^ (1 &lt;&lt; i); for(int j=0;j&lt;n;j++)&#123; if(!(num[j] &amp; (1 &lt;&lt; i)))&#123; ans += cnt[tot ^ odd[j]]; cnt[odd[j]] ++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t = 1; //cin >> t; while(t --) solve(); &#125; 我好若，居然想不到状压 G. Symmetree 题意 给定一棵根为 \(1\) 的树，判断其是否镜像对称。 思路 也就是说，我们需要枚举所有子树，并进行同构的配对。 暴力复杂度是 \(O(n ^ 2)\) 的，因为我们需要同步枚举对应的点，每个路径会被访问多次。 但是，如果我们将判断优化到 \(O(\log n)\)，就可以快很多了。 这里考虑树上哈希。 我们从上往下 \(\mathtt{dfs}\)，并给不同的子树用 \(map\) 的方式标号，最后每个点都会有一个子树标号的集合，我们判断所有标号中出现奇数次的树是否对称即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #define chatgpt3_5 "bits/stdc++.h" #define chatgpt4 "bits/extc++.h" #include chatgpt3_5 using namespace std; //#define FLOATING_OCEAN #define int long long #define pii pair&lt;int, int> #define pipi pair&lt;pii, pii> #define tpi tuple&lt;int, int, int> #define fs first #define sc second #define pb emplace_back #define ep emplace #define rall(x) x.rbegin(),x.rend() #define all(x) x.begin(),x.end() const int N = 1e6 + 10, M = 2e5 + 10, mod = 1e9 + 7, inf = 0x3f3f3f3f3f3f3f3f; const double eps = 1e-9, PI = acos(-1); void solve() &#123; int n; cin >> n; vector&lt;vector&lt;int>> e(n + 1); for(int i=1;i&lt;n;i++)&#123; int u, v; cin >> u >> v; e[u].pb(v), e[v].pb(u); &#125; map&lt;vector&lt;int>, int> hs; map&lt;int, bool> st; int id = 0; auto dfs = [&amp;](auto dfs, int x, int p) -> int&#123; vector&lt;int> child; for(auto y : e[x])&#123; if(y == p) continue; child.pb(dfs(dfs, y, x)); &#125; sort(all(child)); if(!hs.count(child)) &#123; map&lt;int, int> cnt; for (auto y: child) &#123; cnt[y]++; &#125; int odd = 0, bad = 0; for (auto [y, t]: cnt) &#123; if (t &amp; 1) &#123; odd++; if(!st[y]) bad ++; &#125; &#125; st[++ id] = odd &lt; 2 &amp;&amp; bad == 0; hs[child] = id; &#125; return hs[child]; &#125;; cout &lt;&lt; (st[dfs(dfs, 1, -1)] ? "YES\n" : "NO\n"); &#125; signed main() &#123; # ifdef FLOATING_OCEAN freopen("1.in","r",stdin); freopen("1.out","w",stdout); # endif ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // init(); int t = 1; cin >> t; while (t--) solve(); &#125; 用上哈希直接成裸题了啊（？]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 144</title>
    <url>/blog/posts/1514977487/</url>
    <content><![CDATA[Contestant. Rank 1837. Rating +17. 开局天崩场 A. Typical Interview Problem 题意 对于一个数字，如果它是 \(3\) 的倍数，那么它映射到字符串 \(F\)，如果它是 \(5\) 的倍数，那么映射到 \(B\)，如果是 \(15\) 的倍数，那么映射到 \(FB\)，否则映射到空字符串。给定一个字符串，输出它是否是一段连续区间内对应数字映射后拼接而成的。 思路 显然，\(15\) 一循环，且给定的字符串长度只有 \(10\)，所以我们只需暴力匹配即可。 有趣的是，\(FB\) 拆开不影响答案。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0) &#123; int n = console.nextInt(); String s = "FBFFFBFFBFFBFBFFBFFBBFFBFBFFBFFB"; String x = console.next(); console.print(s.contains(x) ? "YES\n" : "NO\n"); &#125; console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; s开小了，倒大霉了属于是 B. Asterisk-Minor Template 题意 给定两个字符串，构造出一个模板，模板由 '*' 和字母组成，通配符 '*' 可以匹配自然数个任意字母。输出是否存在一种模板，使通配符的数量小于等于字母的数量。若存在，输出这个模板。 思路 要满足题给条件，那么模板一定需要存在两个连续的字母。考虑到可以任意匹配，我们不妨只找出一对字母，在两个字符串中均出现，如 \(ab\) 在 \(aabc, xxxabz\) 中均出现，那么就可以在两边加上通配符，如构建为 *\(ab\)*。 当然，只要开头或结尾一样，一个字母加上一个通配符即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; string a, b; cin >> a >> b; if(a[0] == b[0]) cout &lt;&lt; "YES\n" &lt;&lt; a[0] &lt;&lt; '*' &lt;&lt; '\n'; else if(a[a.size() - 1] == b[b.size() - 1]) cout &lt;&lt; "YES\n" &lt;&lt; '*' &lt;&lt; a[a.size() - 1] &lt;&lt; '\n'; else&#123; bool f = false; for(int i=0;i&lt;a.size() - 1;i++)&#123; for(int j=0;j&lt;b.size() - 1;j++)&#123; if(a[i] == b[j] &amp;&amp; a[i + 1] == b[j + 1])&#123; cout &lt;&lt; "YES\n" &lt;&lt; '*' &lt;&lt; a[i] &lt;&lt; a[i + 1] &lt;&lt; '*' &lt;&lt; '\n'; f = true; break; &#125; &#125; if(f) break; &#125; if(!f) cout &lt;&lt; "NO\n"; &#125; &#125; &#125; 贪心一下~ C. Maximum Set 题意 给定两个整数 \(l, r\)，在 \([l, r]\) 内找一个递增不重复序列，满足相邻数可整除。输出序列的最大数量，以及该数量的方案数。方案数 \(\mod 998244353\)。 思路 首先，要让数量最多，且能整除，那么我们不妨将左端点循环乘二，得到一个不超过右端点的最大数，此时乘二的数量就是序列的最大数量 \(- 1\)。 更简洁地看，我们将上述过程转化为一个表达式：\(l \times 2 \times 2 \times \ldots \times 2 = x\leq r\)。 那么，显然 \(\frac{r}{x}\) 是小于 \(2\) 的，所以若要让某个倍数变大，即选择一个 \(2\) 将其变大，那么我们只能将其改成 \(3\)。 那么，整道题就可以变为遍历所有满足上述表达式的 \(l\)，判断 \(\frac{r}{x}\) 和 \(1.5\) 的大小关系，若前者大，那么对于这个左边界，我们可以得到 \(cnt_2\) 个方案，否则只有一个方案。 上述思路的复杂度较高，考虑到推算较为简单，我们不妨直接推导式子： 设 \(\frac{x}{l} = p\)，那么 \(l&#39;p \leq r\) 即 \(l \leq l&#39; \leq \frac{r}{p}\)。 同理，\(l \leq l&#39;&#39; \leq \frac{2r}{3p}\) 那么，答案即为 \((l&#39;&#39; - l + 1) \times cnt + (l&#39; - l&#39;&#39;)\) 当然，我们也可以二分，问题不大（（ 时间复杂度：一般般 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); long mod = 998244353; long t = console.nextInt(); nxt: while(t -- > 0) &#123; long n = console.nextInt(), m = console.nextInt(); long x = n, ans1 = 1, p = 1; while(true)&#123; if(x * 2 > m) break; x *= 2; ans1 ++; p = (p * 2) % mod; &#125; boolean ok = false; long l1 = (long) Math.max(n - 1, (double) m * 2 / 3 / p), l2 = Math.max(l1 - 1, m / p); long ans2 = (((l1 - n + 1) * ans1 % mod) + (l2 - l1) % mod) % mod; console.print(ans1 + " " + ans2 + "\n"); &#125; console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; 暴力枚举左端点的铸币竟是我自己]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 854 Div. 1 + 2</title>
    <url>/blog/posts/2715179373/</url>
    <content><![CDATA[Contestant(alt). Rank 4431. Rating -40 (+310 -350). A. Recent Actions 题意 给定一个整数 \(n\)，以及 \(n\) 的排列，给定 \(m\) 个大于 \(n\) 的数，若这个数不在序列里，那么将整个序列右移一位，删去多出的元素，并将第一个空位放入该数。输出原排列的每一个数在第几个数放入的时候被移除。 思路 直接用 \(map\) 或者数组存一下是否在序列里即可，然后统计即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n, m; cin >> n >> m; map&lt;int, bool> st; vector&lt;int> ans(n, -1); int r = n - 1; for(int i=0;i&lt;m;i++)&#123; int cur; cin >> cur; if(!st[cur] &amp;&amp; r >= 0)&#123; ans[r] = i + 1; r --; &#125; st[cur] = true; &#125; for(auto e : ans) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; 题目怎么那么绕 B. Equalize by Divide 题意 给定一个数组 \(a\)，所有数均为正数，定义操作为选择两个不同的下标 \(i, j\)，将 \(a_i\) 改为 \(\lceil \frac{a_i}{a_j} \rceil\)。输出一种方案，使所有数相等。若无方案输出无解。 思路 首先，我们不可能将所有数都变为 \(1\)，除非原来就全是 \(1\)。所以我们不妨先特判是否所有数都相等，若都相等那么无需操作，否则，若数组中含有 \(1\)，就为无解。 否则，我们只需避免产生 \(1\) 即可，也就是用当前序列的最小值将所有数除到比最小值小或者等于为止。 上述做法可以保证最后的答案一定是有解的，若第一次操作可以构建出一个 \([\min, \min, ..., \min]\) 的数组，那么就无需操作，否则最后的结果一定是 \([2, 2, ..., 2]\)。 时间复杂度：有点复杂 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++)cin >> a[i]; vector&lt;pii> ans(30 * n); int size = 0; bool h = true; while(true)&#123; bool f = false, have1 = false; int pre = -1, mn = 0; for(int i=0;i&lt;n;i++)&#123; if(pre == -1) pre = a[i]; if(pre != a[i]) f = true; if(a[i] == 1) have1 = true; if(a[mn] > a[i]) mn = i; &#125; if(!f) break; if(have1)&#123; cout &lt;&lt; -1 &lt;&lt; '\n'; h = false; break; &#125; for(int i=0;i&lt;n;i++)&#123; while(a[i] != a[mn])&#123; if(a[i] > a[mn])&#123; ans[size ++] = &#123;i, mn&#125;; a[i] = ceil((double) a[i] / (double) a[mn]); &#125;else&#123; ans[size ++] = &#123;mn, i&#125;; a[mn] = ceil((double) a[mn] / (double) a[i]); &#125; &#125; &#125; &#125; if(h) &#123; cout &lt;&lt; size &lt;&lt; '\n'; for (int i = 0; i &lt; size; i++) &#123; auto e = ans[i]; cout &lt;&lt; e.first + 1 &lt;&lt; ' ' &lt;&lt; e.second + 1 &lt;&lt; '\n'; &#125; &#125; &#125; &#125; 想到了一半，没想到这么暴力（（ C. Double Lexicographically Minimum 待补充 D1. Hot Start Up (easy version) 题意 给定两个 \(CPU\)，以及 \(n\) 个程序的热启动和冷启动时间，当同一种程序连续运行的时候，第二次启动称为热启动，热启动时间低于冷启动。找出一种方案，使最后运行结束每个程序所用时间总和最短，并输出最短时间。 思路 首先，考虑到递推关系，我们不妨考虑用 \(dp\) 的方式。 最朴素的做法 我们不妨建立一个二维 \(dp\)，\(dp[i][j]\) 表示最后一次操作后第一个 \(CPU\) 运行了程序 \(i\)，第二个 \(CPU\) 运行了程序 \(j\)。 那么显然，最后的答案就是 \(\min(dp[i][a[n]])\) 或者 \(\min(dp[a[n]][j])\)。 如何递推呢？对于一个新元素 \(x\)，以及任意一个 \(CPU\)（如第一块），它可以由两种情况推得： 上一个数和它不同，那么它将成为冷启动，我们遍历所有 \(i \neq x\) 和 \(j\)，将 \(dp[x][j]\) 更新为 \(\min(dp[i][j] + c[x])\)。 上一个数和它相同，他么它将成为热启动，我们遍历所有 \(j\)，将 \(dp[x][j]\) 更新为 \(\min(dp[x][j] + h[x])\)。 时间复杂度：\(O(n k ^ 2)\) 对应TLE代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e3 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; int a[N], h[N], c[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n, k; cin >> n >> k; for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=1;i&lt;=k;i++) cin >> c[i]; for(int i=1;i&lt;=k;i++) cin >> h[i]; vector&lt;vector&lt;int>> dp(k + 1, vector&lt;int>(k + 1)); for(int i=0;i&lt;=k;i++) for(int j=0;j&lt;=k;j++) dp[i][j] = inf; dp[0][0] = 0; for(int x=1;x&lt;=n;x++)&#123; vector&lt;vector&lt;int>> tmp(k + 1, vector&lt;int>(k + 1, inf)); for(int i=0;i&lt;=k;i++)&#123; if(i == a[x]) continue; for(int j=0;j&lt;=k;j++) tmp[a[x]][j] = min(tmp[a[x]][j], dp[i][j] + c[a[x]]); &#125; for(int j=0;j&lt;=k;j++) tmp[a[x]][j] = min(tmp[a[x]][j], dp[a[x]][j] + h[a[x]]); for(int j=0;j&lt;=k;j++)&#123; if(j == a[x]) continue; for(int i=0;i&lt;=k;i++) tmp[i][a[x]] = min(tmp[i][a[x]], dp[i][j] + c[a[x]]); &#125; for(int i=0;i&lt;=k;i++) tmp[i][a[x]] = min(tmp[i][a[x]], dp[i][a[x]] + h[a[x]]); dp = tmp; &#125; int ans = inf; for(int j=0;j&lt;=k;j++)&#123; if(j == a[n]) continue; ans = min(ans, dp[j][a[n]]); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; Time limit exceed on test 3. 对朴素的优化 显然，上述复杂度过高，我们希望能找出一种 \(O(n)\) 的递推方法。 对于上述操作，我们并没有考虑哪个元素一定要放到哪个 \(CPU\) 上去，也就是说它和 \(CPU\) 并不绑定。 那么，我们不妨用下标记录一个 \(CPU\) 的情况，另一个用 \(dp\) 来递推。 更具体地说，我们可以记录一下上一次上个 \(CPU\) 放了什么 (\(pre\))，然后对于新加入的数 \(x\)，它可以由下面两种情况推算： \(pre \neq x\)，那么作为冷启动，它的状态可以由所有 \(i \neq x, dp[i] + c[x]\) 推得，当然，我们需要顺便更新 \(dp[i]\) 的值，这和朴素的做法一致。考虑到可以放置在不同的 \(CPU\) 上，所以热启动依然可行，我们将 \(dp[pre]\) 更新为其与 \(dp[x] + h[x]\) 的最小值。最后，我们将 \(pre\) 改为 \(x\)。 \(pre = x\)，那么和上述相同的是，依然存在冷热启动，只是在更新 \(dp[i]\) 的时候，它可以热启动罢了。 时间复杂度：\(O(nk)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e3 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; int a[N], h[N], c[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n, k; cin >> n >> k; for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=1;i&lt;=k;i++) cin >> c[i]; for(int i=1;i&lt;=k;i++) cin >> h[i]; vector&lt;int> dp(k + 1); for(int i=1;i&lt;=k;i++) dp[i] = inf; int pre = 0; for(int p=1;p&lt;=n;p++)&#123; int x = a[p]; vector&lt;int> tmp(k + 1, inf); if(x == pre)&#123; for(int i=0;i&lt;=k;i++)&#123; tmp[i] = min(tmp[i], dp[i] + h[x]); if(i != x) tmp[x] = min(tmp[x], dp[i] + c[x]); &#125; tmp[x] = min(tmp[x], dp[x] + h[x]); &#125;else&#123; for(int i=0;i&lt;=k;i++)&#123; tmp[i] = min(tmp[i], dp[i] + c[x]); if(i != x) tmp[pre] = min(tmp[pre], dp[i] + c[x]); &#125; tmp[pre] = min(tmp[pre], dp[x] + h[x]); pre = x; &#125; dp = tmp; &#125; int ans = inf; for(int i=0;i&lt;=k;i++) ans = min(ans, dp[i]); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 好难解释....]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 138</title>
    <url>/blog/posts/482042403/</url>
    <content><![CDATA[Practice. A. Cowardly Rooks 题意 给定 \(n\) 个点的横纵坐标，输出是否可以将任意一个点移动，使每一行每一列都只有最多一个点。 思路 我们可以先将原来的所有点对应的横坐标和纵坐标对应的行和列进行统计，之后若能找出任意一行或者任意一列没有点，那么就可以移动到那里去。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e3 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n, m; cin >> n >> m; int r[10]&#123;&#125;, c[10]&#123;&#125;; bool f = false; for(int i=0;i&lt;m;i++) &#123; int a, b; cin >> a >> b; r[a]++, c[b]++; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(r[i] == 0 || c[j] == 0)&#123; f = true; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; 给的代码写得略微麻烦了点（ B. Death's Blessing 题意 给定 \(n\) 个怪物的血量和能力 \(a_i, b_i\)，在干掉一个怪物的时候，该怪物将会把相邻的怪物的血量加上它的能力，怪物死亡后从序列中移除，第一个和最后一个怪物只有一个相邻的怪物。输出将所有怪物干掉需要扣除的血量最大值。 思路 首先，答案可以拆分成原来所有怪物的血量和加上外加的血量，外加的血量只和操作顺序有关，所以我们可以试试贪心： 既然两侧的怪物能附加的血量只会影响到一个怪物，那么我们可以贪心地从两侧开始打，但这不够，考虑到只剩一个怪物的时候，这个怪物无法再将自己的能力附加到其他怪物上，所以我们可以将能力值最大的怪物放到最后。 可以很容易证明上述贪心思想成立。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 5e3 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; int ans = 0; for(int i=0;i&lt;n;i++) &#123; int cur; cin >> cur; ans += cur; &#125; vector&lt;int> b(n); for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; b[i] = cur; ans += b[i]; &#125; sort(b.begin(), b.end()); cout &lt;&lt; ans - b[n - 1] &lt;&lt; '\n'; &#125; &#125; 简单的贪心捏 C. Number Game 题意 给定一个数组 \(a\)，选择任意回合数 \(k\)，在第 \(i\) 个回合，\(A\) 需要找出一个小于等于 \(k - i + 1\) 的数，并将其删去，之后 \(B\) 选择任意一个数，将其加上 \(k - i + 1\)。在两个人足够聪明的条件下，输出最大的 \(k\)，满足不存在某一个回合，数组不为空但 \(A\) 无法删除。 思路 显然，既然要让 \(A\) 寄，那么 \(B\) 一定会将当前的最小值加上 \(k - i + 1\)，因为所加的值是递减的。 考虑到数据范围特别小，我们不妨在每一局结束的时候将整个新数组排个序。 对于一个回合，我们可以用二分的方法，快速找出第一个大于 \(k - i + 1\) 的数并将其前面一个数删去，也就是在每次操作时删去最大数，这样可以尽可能删除多一点的数。然后，将第一个数加上 \(k - i + 1\) 即可。 数据量太小了，可以二分答案 \(k\)，也可以直接暴力枚举。 时间复杂度：\(O(n^2 + n^2 \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; vector&lt;int> a(n); for(int i=0;i&lt;n;i++) cin >> a[i]; for(int k=n;k>=0;k--)&#123; vector&lt;int> tmp(a); sort(tmp.begin(), tmp.end()); bool f = true; for(int i=1;i&lt;=k;i++)&#123; int p = upper_bound(tmp.begin(), tmp.end(), k - i + 1) - tmp.begin(); if(p == 0) &#123; f = false; break; &#125; tmp[p - 1] = inf; tmp[0] += k - i + 1; sort(tmp.begin(), tmp.end()); &#125; if(f)&#123; cout &lt;&lt; k &lt;&lt; '\n'; break; &#125; &#125; &#125; &#125; 无脑暴力.jpg]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 829 Div. 2</title>
    <url>/blog/posts/64163075/</url>
    <content><![CDATA[Practice. A. Technical Support 题意 给定一个由 \(Q, A\) 组成的字符串，对于所有 \(Q\)，判断在下一次 \(Q\) 出现或遍历到结束前，是否有至少一个 \(A\) 与之对应。 思路 如题，配对即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; string s; cin >> s; int cnt = 0; for(char e : s) &#123; cnt += e == 'Q' ? 1 : -1; if(cnt &lt; 0) cnt = 0; &#125; cout &lt;&lt; (cnt == 0 ? "Yes\n" : "No\n"); &#125; &#125; 别看错题（（ B. Kevin and Permutation 题意 给定整数 \(n\)，构建一个 \(n\) 的排列，使相邻数的差值的最小值最大。 思路 想要尽量让差值最大，那么我们只有相间地输出，或者说，若我们按 \(\frac{n}{2} + i, i\) 的规律输出，就可以让所有差值尽量相等。 可以贪心地认为上述的思路是正确的，解法不唯一。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; for(int i=1;i&lt;=n/2;i++)&#123; cout &lt;&lt; n / 2 + i &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' '; &#125; if(n % 2 == 1) cout &lt;&lt; n; cout &lt;&lt; '\n'; &#125; &#125; 找规律+乱贪.jpg C1. Make Nonzero Sum (easy version) 详见C2，区别是C1给定的数组没有0 C2. Make Nonzero Sum (hard version) 题意 给定一个由 \(-1, 0, 1\) 构成的数组，将数组分为任意若干段，相邻两段的左段右边界和右段左边界相差 \(1\)。输出是否存在一种分段，将所有段相间赋上运算符号 \(+, -, +, - ,...\) 后，所有段的运算总和为 \(0\)。若存在，输出方案。 思路 首先，我们不考虑运算符号的时候，将所有数加起来会得到一个结果 \(ans\)，若 \(ans = 0\)，那么我们只需将所有单个元素单独成段就可以无视运算符号了。否则，因为考虑到加减是一样的，我们不妨来考虑 \(ans &gt; 0\) 的情况： 显然，若要让 \(ans\) 减小，我们就只能让某一个 \(1\) 和左相邻的数组合为一段，那么，整个 \(ans\) 将会减少 \(2\)。可以发现，我们无法将 \(ans\) 减少奇数值，所以我们可以先判断 \(ans\) 的奇偶性。在运算的时候，需要变号的时候，变号的数一定但也只要让这个数位于某一段的偶数下标，所以，我们只需找两个相邻数，其中第一个数不需要变号，第二个数需要变号，那么将这两个数作为一段即可。 所以我们只需将 \(1\) 全部找出，判断能找出多少对上述相邻数，和 \(ans / 2\) 比较即可。 有趣的是，这种解法不用考虑是否包含 \(0\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; while(q --)&#123; int n; cin >> n; int ans = 0; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; ans += a[i]; &#125; if(abs(ans) % 2 == 1) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; int r = 0; vector&lt;pii> out; int left = ans / 2; if(left != 0) &#123; int x = left / abs(left); r = 1; for (int i = 1; i &lt; n; i++) &#123; if (a[i + 1] == x) &#123; out.emplace_back(i, i + 1); r = i + 1; i++; left -= x; if (left == 0) break; &#125; else &#123; out.emplace_back(i, i); r = i; &#125; &#125; &#125; for(int i=r+1;i&lt;=n;i++) out.emplace_back(i, i); if(left != 0) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; cout &lt;&lt; out.size() &lt;&lt; '\n'; for(auto e : out) cout &lt;&lt; e.first &lt;&lt; ' ' &lt;&lt; e.second &lt;&lt; '\n'; &#125; &#125; &#125; &#125; 想了半天不小心把两个难度一起做了（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 830 Div. 2</title>
    <url>/blog/posts/1524713550/</url>
    <content><![CDATA[Practice. A. Bestie 题意 给定一个数组 \(a\)，定义操作为将 \(a_i\) 改为 \(gcd(a_i, i)\)，代价为 \(n - i + 1\)，输出最小的操作代价总和，使所有数的最大公约数为 \(1\)。 思路 首先，这里有一个结论：相邻数字的最大公约数一定为 \(1\)。 所以，最多只需两次操作，即可满足题意。 所以，我们只需考虑 \(n\) 和 \(n - 1\) 对应的元素是否需要进行操作，以及对应的代价总和的最小值。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], b[N]; int gcd(int x, int y) &#123; while (y != 0) &#123; int tmp = x; x = y; y = tmp % y; &#125; return x; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) &#123; int n; cin >> n; int g = 0; for (int i = 1; i &lt;= n; i++) &#123; cin >> a[i]; g = gcd(g, a[i]); &#125; if (g == 1) cout &lt;&lt; 0 &lt;&lt; '\n'; else if (gcd(g, n) == 1) cout &lt;&lt; 1 &lt;&lt; '\n'; else if (gcd(g, n - 1) == 1) cout &lt;&lt; 2 &lt;&lt; '\n'; else cout &lt;&lt; 3 &lt;&lt; '\n'; &#125; &#125; 这结论一开始还真没想到... B. Ugu 题意 给定一个二进制字符串，定义操作为选定一个整数 \(i\)，将 \([i, n]\) 内的数全都取反，输出让整个字符串变为不递减的操作数的最小值。 思路 考虑下面的模拟： \(\begin{array}{l}&gt;&gt;01011001011 \\ =&gt; 01100110100 \\ =&gt; 01111001011 \\ =&gt; 01111110100 \\ =&gt; 01111111011 \\ =&gt; 01111111100 \\ =&gt; 01111111111\end{array}\) 也就是说，我们只考虑拐点，统计拐点个数即可。 当然，需要根据第一个数的情况来扣去 \(1\) 或 \(2\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], b[N]; int gcd(int x, int y) &#123; while (y != 0) &#123; int tmp = x; x = y; y = tmp % y; &#125; return x; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) &#123; int n; cin >> n; string s; cin >> s; char pre = -1; int dif = 0; for(int i=0;i&lt;n;i++)&#123; if(pre == -1) pre = s[i]; else&#123; if(pre != s[i]) dif ++; pre = s[i]; &#125; &#125; dif ++; cout &lt;&lt; max(0ll, dif - (s[0] == '1' ? 1 : 2)) &lt;&lt; '\n'; &#125; &#125; 就这么模拟嘞 C1. Sheikh (Easy version) 题意 给定一个数组 \(a\)，定义子区间 \([l, r]\) 的代价 \(f(l, r)\) 为总和和所有数异或值的差。对于 \(q = 1\) 个询问，输出询问的 \([L, R]\) 内的子区间的代价最大值，以及对应的最短区间。 思路 首先，对于一段区间，我们加上一个值 \(x\)，那么总和会改变 \(x\)，而异或值改变量不会超过 \(x\)，也就是说，\(f(l, r) \leq f(l, r + 1)\)。 因而，代价最大值一定是 \(f(L, R)\)，我们只需找出最短区间即可。 因为本题 \(easy\) 难度的数据量低，所以我们不妨直接二分长度，然后枚举所有可行解即可。 使用前缀和和前缀异或优化复杂度。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], sum[N], xo[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --) &#123; int n, q; cin >> n >> q; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; sum[i] = sum[i - 1] + a[i]; xo[i] = xo[i - 1] ^ a[i]; &#125; while(q --)&#123; int l, r; cin >> l >> r; int ans = (sum[r] - sum[l - 1]) - (xo[r] ^ xo[l - 1]); int L = 1, R = r - l + 1, mid; int ansL = l, ansR = r; while(L &lt; R)&#123; mid = (L + R) >> 1; bool f = false; for(int i=l;i+mid-1&lt;=r;i++)&#123; if((sum[i+mid-1] - sum[i - 1]) - (xo[i+mid-1] ^ xo[i - 1]) == ans) &#123; if(mid &lt; ansR - ansL + 1)&#123; ansL = i, ansR = i + mid - 1; f = true; &#125; &#125; &#125; if(f) R = mid; else L = mid + 1; &#125; cout &lt;&lt; ansL &lt;&lt; ' ' &lt;&lt; ansR &lt;&lt; '\n'; &#125; &#125; &#125; 想不到结论就寄 C2. Sheikh (Hard Version) 待补充 D. Balance (Easy version) 题意 给定一个初始情况下只有一个元素 \(0\) 的序列，对于下述两种询问，进行对应的操作： \(+\ x\)：将 \(x\) 加入序列，满足 \(x\) 原先不在序列里； \(?\ x\)：输出第一个能被 \(x\) 整除且不在序列里的数。 思路 我们先来考虑纯暴力：对于加上某个数，标记一下这个数已加入；对于查询，暴力枚举其倍数，第一个未被标记的数即为答案。 因为数据量过大，我们考虑用 \(map\)。 纯暴力是不可行的，但我们可以略微优化一下：另开一个 \(map\)，记录这个数的下一个没有被标记的数是什么，若这个数是 \(0\)，那么就是这个数本身，输出即可。 因而，在每次输出的时候，我们可以预处理之后的查询，从而降低复杂度。 对于 \(easy\) 难度，到此即可过。 时间复杂度：不好说 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; map&lt;int, bool> mp; map&lt;int, int> to; while(q --)&#123; char op; int num; cin >> op >> num; mp[0] = true; if(op == '+') &#123; mp[num] = true; &#125;else &#123; while(mp[to[num]]) to[num] += num; cout &lt;&lt; to[num] &lt;&lt; '\n'; &#125; &#125; &#125; 数据结构题挺少见 D2. Balance (Hard version) 题意 给定一个初始情况下只有一个元素 \(0\) 的序列，对于下述两种询问，进行对应的操作： \(+\ x\)：将 \(x\) 加入序列，满足 \(x\) 原先不在序列里； \(-\ x\)：将 \(x\) 从序列中删除，满足 \(x\) 原先在序列里； \(?\ x\)：输出第一个能被 \(x\) 整除且不在序列里的数。 思路 我们可以继续之前的优化，但这里需要考虑删除数以后，该数的因数 是否已经将 其 下一个未被标记的数 标为大于等于 这个数 的值了。 也就是说，删除以后，我们需要更新这些因数。 暴力枚举因数是不可行的，但考虑到这些因数都是后来加进来的，所以我们可以在上一题输出优化部分，加上 下一个未被标记的数的原数字是什么（也就是它的因子）。然后，在加减操作的时候，我们不妨遍历我们之前记录下来的因子，标记一下这个因子对应原数字有没有被删去。 最后，我们只需按之前的操作，找出该数字下一个未被标记的数，然后判断这个数的倍数有没有已被删去的数，有的话两个数取最小值即可。 时间复杂度：有点小复杂 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = LONG_LONG_MAX, mod = 998244353; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int q; cin >> q; map&lt;int, bool> mp; map&lt;int, int> to; map&lt;int, set&lt;int>> vis, del; mp[0] = true; while(q --)&#123; char op; int num; cin >> op >> num; if(op == '+') &#123; for(auto &amp;i : vis[num]) del[i].erase(num); mp[num] = true; &#125;else if(op == '-')&#123; for(auto &amp;i : vis[num]) del[i].insert(num); mp[num] = false; &#125;else&#123; while(mp[to[num]]) vis[to[num]].insert(num), to[num] += num; cout &lt;&lt; min(to[num], del[num].empty() ? inf : *del[num].begin()) &lt;&lt; '\n'; &#125; &#125; &#125; 数据结构题挺少见，这种简短的题更少见（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 291</title>
    <url>/blog/posts/1674521260/</url>
    <content><![CDATA[Contestant. Rank 1877. Rating +196. A. camel Case 题意 给定一个由一个大写字母和若干个小写字母组成的字符串，输出大写字母的位置。 思路 如题，很签到。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); string s; cin >> s; for(int i=0;i&lt;s.size();i++)&#123; if(s[0] >= 'A' &amp;&amp; s[i] &lt;= 'Z')&#123; cout &lt;&lt; i + 1 &lt;&lt; '\n'; break; &#125; &#125; &#125; 无聊的签到题 B. Trimmed Mean 题意 给定 \(5N\) 个评委的分数，去掉最大 \(N\) 个和最小 \(N\) 个评委的分数，输出剩余分数的平均数。 思路 如题，排个序即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n; cin >> n; for(int i=0;i&lt;5 * n;i++) cin >> a[i]; sort(a, a + 5 * n); double ans = 0; for(int i=n;i&lt;5*n-n;i++) ans += (double) a[i]; cout &lt;&lt; (ans / ((double) 3 * n)) &lt;&lt; '\n'; &#125; 差点看成只各去掉一个（（ C. LRUD Instructions 2 题意 给定一个由 \(L,R,U,D\) 组成的字符串，模拟点的移动，\(L\) 表示横坐标减一，\(R\) 表示横坐标加一，\(D\) 表示纵坐标减一，\(U\) 表示纵坐标加一。输出有多少点被经过了至少两遍。 思路 如题，模拟即可。 可以用 \(map\) 存有没有经过，或者开一个布尔数组。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); map&lt;pii, bool> mp; int n; cin >> n; string s; cin >> s; pii p = &#123;0, 0&#125;; mp[p] = true; bool f = false; for(int i=0;i&lt;n;i++)&#123; char now = s[i]; if(now == 'L')&#123; p.first --; &#125;else if(now == 'R')&#123; p.first ++; &#125;else if(now == 'U')&#123; p.second ++; &#125;else p.second --; if(mp[p])&#123; f = true; break; &#125; mp[p] = true; &#125; cout &lt;&lt; (f ? "Yes\n" : "No\n"); &#125; 捏马的，忘了在走过以后设标记了（（ D. Flip Cards 题意 给定 \(n\) 张牌，牌的正反两面各印有一个数字，输出整个牌组满足条件的正反情况，满足相邻牌值不相等。 思路 考虑到只需满足相邻牌值不相等，所以我们不妨采用 \(dp\) 的方式，定义一个 \(dp[i][j]\) 表示第 \(i\) 位及以前的牌满足第 \(i\) 张牌的正反情况满足 \(j\) 的情况总数，\(j=0\) 表示向上，否则向下。 那么，对于一个位置，它有两种递推的方式——从上一个为正面的牌的情况数和从上一个为反面的牌的情况数。两个递推的方式的和即为当前位置的值。 如，如果不考虑相邻牌不相等，那么 \(dp[i][0] = dp[i - 1][0] + dp[i - 1]][1], dp[i][1] = dp[i - 1][0] + dp[i - 1][1]\)。 考虑条件的话，我们用 \(if\) 判断即可。 当然，初始情况下 \(dp[1][0] = dp[1][1] = 1\)。 时间复杂度：\(O(2n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int dp[N][2]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n; cin >> n; int lastA, lastB; cin >> lastA >> lastB; dp[1][0] = 1, dp[1][1] = 1; for(int i=2;i&lt;=n;i++)&#123; int nowA, nowB; cin >> nowA >> nowB; if(nowA != lastA) dp[i][0] = (dp[i][0] + dp[i - 1][0]) % mod; if(nowA != lastB) dp[i][0] = (dp[i][0] + dp[i - 1][1]) % mod; if(nowB != lastA) dp[i][1] = (dp[i][1] + dp[i - 1][0]) % mod; if(nowB != lastB) dp[i][1] = (dp[i][1] + dp[i - 1][1]) % mod; lastA = nowA, lastB = nowB; &#125; cout &lt;&lt; (dp[n][0] + dp[n][1]) % mod &lt;&lt; '\n'; &#125; 其实只有两个的话完全可以用两个变量来存，使空间复杂度降低很多 E. Find Permutation 题意 给定 \(n\) 个点以及 \(m\) 组可重复的大小关系 \(A_i, B_i\)，构建一个排列 \(p\)，对于所有条件，均满足 \(p_{A_i} &lt; p_{B_i}\)。输出是否能唯一确定这个排列，若能唯一确定，输出这个排列。 思路 首先，我们可以一眼看出这是求拓扑序。那么，这道题唯一的障碍就是怎么排除无法唯一确定的点，因为如果成环了，拓扑排序会自动找出。 那么，我们来考虑每次读取队列的时候的情况： 考虑到拓扑排序的算法，我们会将每次遍历的时候，将入度为 \(0\) 的点全都放入队列，那么只要出现多个入度为 \(0\) 的点，那么就一定会出现如 \(a \rightarrow b, a \rightarrow c, b\ ?\ c\) 的情况，此时直接判 \(No\) 即可。 时间复杂度：\(O(m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int n, m; vector&lt;int> G[N]; int in[N]; // 存储每个结点的入度 void topSort() &#123; vector&lt;int> L; queue&lt;int> q; for (int i = 1; i &lt;= n; i++) if (in[i] == 0) q.push(i); if(q.size() > 1)&#123; cout &lt;&lt; "No\n"; return; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); L.push_back(u); for (auto v : G[u]) &#123; if (--in[v] == 0) &#123; q.push(v); &#125; &#125; if(q.size() > 1) &#123; cout &lt;&lt; "No\n"; return; &#125; &#125; if (L.size() == n) &#123; cout &lt;&lt; "Yes\n"; vector&lt;int> ans(n); for(int i=0;i&lt;n;i++)&#123; ans[L[i] - 1] = i + 1; &#125; for (auto i : ans) cout &lt;&lt; i &lt;&lt; ' '; &#125; else &#123; cout &lt;&lt; "No\n"; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); cin >> n >> m; map&lt;pii, bool> mp; for(int i=0;i&lt;m;i++)&#123; int x, y; cin >> x >> y; if(mp[&#123;x, y&#125;]) continue; G[x].emplace_back(y); in[y] ++; mp[&#123;x, y&#125;] = true; &#125; topSort(); &#125; 有一说一，为什么入读和出度的配对不可以用来判呢？ F. Teleporter and Closed off 题意 给定 \(n\) 个长度为 \(m\) 的字符串 \(s\)，若 \(s_{i,j} = 1\)，那么可以使用这个传送点，从第 \(i\) 个城市传送到第 \(i+j\) 个城市。输出对于第 \([2, n - 2]\) 个城市，从第一个城市到最后一个城市，满足跳过这个城市的路径使用的传送点的最少数量。 思路 首先，对于第 \(i\) 个城市，它的状态是从前一个传送点推过来的，存在递推性，所以我们可以用 \(dp\) 来实现。 对于第 \(k\) 个城市，若要跳过它，那么我们一定得从 \(i=k-x+1\) 个城市传送到 \(j = i + x\) 个城市，所以我们可以枚举 \(i \in [k - m + 1, k - 1], j \in [k + 1, i + m]\)，找出对于所有城市 \(i\) 前面用了多少传送点，城市 \(j\) 后面用了多少传送点，最后的答案即为传送点数量之和 \(+1\)。 那么，我们可以从前往后 \(dp\)，再从后往前 \(dp\)，最后的值即为 \(dp_0[i] + dp_1[j] + 1\)。 而对于 \(dp\)，从前向后的时候，对于第 \(i\) 个城市，我们可以枚举所有 \(j \in [1, m]\)，那么我们可以传送到所有满足条件的 \(i + j\) 个城市。因而，这些城市的传送点数量即可用当前城市来更新。 从后往前是类似的。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 4e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int dp[N][2]; string a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, m; cin >> n >> m; for(int i=0;i&lt;n;i++)cin >> a[i]; memset(dp, 0x3f, sizeof dp); dp[0][0] = dp[n - 1][1] = 0; for(int i=0;i&lt;n;i++)&#123; for(int j=1;j&lt;=min(m, n - i);j++)&#123; if(a[i][j - 1] == '1') dp[i + j][0] = min(dp[i + j][0], dp[i][0] + 1); &#125; &#125; for(int i=n-1;i>=0;i--)&#123; for(int j=1;j&lt;=min(m, i - 1);j++)&#123; if(a[i - j][j - 1] == '1') dp[i - j][1] = min(dp[i - j][1], dp[i][1] + 1); &#125; &#125; for(int k=1;k&lt;n-1;k++)&#123; int ans = inf; for(int i=max(k - m + 1, 0ll);i&lt;k;i++)&#123; for(int j=k+1;j&lt;min(n, i+m+1);j++)&#123; if(a[i][j - i - 1] == '1') ans = min(ans, dp[i][0] + dp[j][1] + 1); &#125; &#125; cout &lt;&lt; (ans >= inf ? -1 : ans) &lt;&lt; ' '; &#125; &#125; dp老写错状态，淦]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 853 Div. 2</title>
    <url>/blog/posts/2909166420/</url>
    <content><![CDATA[Contestant. Rank 1936. Rating +9. A. Serval and Mocha's Array 题意 给定一个数组 \(a\)，将其重新排序，满足对于所有前缀，如前 \(i\) 个数，满足它们的 \(gcd \leq i\)。 思路 首先，最优的方法当然是互质，只要把互质的两个数放到第一个，那么后面的 \(gcd\) 全都是 \(1\) 了。 其次，前两个数可以有公约数 \(2\)，这是毋庸置疑的。但是，若我们继续下去，前 \(3\) 个数可以有公约数 \(3\)，...，前 \(6\) 个数可以有公约数 \(6\)。停，不对劲：既然有公约数 \(2,3\)，那么一定能被 \(6\) 整除，那么前两个数的 \(gcd\) 一定至少是 \(6\) 了，产生了矛盾。 所以，我们只需找出一对数，满足 \(gcd \leq 2\) 即可。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; int gcd(int x, int y) &#123; while (y != 0) &#123; int tmp = x; x = y; y = tmp % y; &#125; return x; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; bool f = false; for(int i=0;i&lt;n;i++) for(int j=i;j&lt;n;j++)&#123; if(gcd(a[i], a[j]) &lt;= 2) &#123; f = true; break; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; 为什么赛后反而思路这么清晰了（（ B. Serval and Inversion Magic 题意 给定一个二进制字符串，任选一个区间，将区间内的所有数取反，输出是否可以将整个字符串变为回文字符串。 思路 考虑到回文串的对称性，我们只需修改 \([0, \frac{n}{2}]\) 内的数即可。 下面是一种模拟思路： 我们不妨从外向里遍历，比较 \(i\) 和 \(n - i - 1\) 对应的数，若出现了不同的数，记录当前下标开始需要取反，然后一直找到结束，或者出现相同的数。出现相同数后，我们标记一下已经进行过取反操作，当我们再次遇到不同数的时候，考虑到只能选一个区间，所以直接返回 \(NO\)。 否则，一定是有解的。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; string a; cin >> a; bool f = true, have = false, now = false; for(int i=0;i&lt;n/2;i++)&#123; if(a[i] == a[n - i - 1])&#123; if(now)&#123; now = false; have = true; &#125; &#125;else&#123; if(have)&#123; f = false; break; &#125; now = true; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; 我的评价是：比A题简单 C. Serval and Toxel's Arrays 题意 给定一个无重复元素的数组 \(a\)，对于 \(q\) 个操作给定的 \(p_i, v_i\)，将 \(a_{p_i}\) 改为 \(v_i\)。每次操作后，将会得到一个新数组，新数组满足无重复元素。每次操作的对象为上次操作后的数组。对于所有数组（原数组 + 所有新数组），输出所有任意两个数组拼接后不同数字的个数的和。 思路 显然，我们不可能去暴力计算，而相反地，我们可以将问题拆分为所有单个数字的贡献和。 具体地说，对于一个数字，若它自始至终未被修改，那么任意两个数组组合，都会留下它，那么它的贡献即为 \(C_{m + 1}^2\)。 若它被修改了，那么在它未出现的时候，它将毫无贡献。因此，我们需要减去这些无贡献的数组组合，也就是 \(C_{m - cnt + 1}^2\)。因而，得到该条件下的总贡献：\(C_{m + 1}^2 - C_{m - cnt + 1}^2\)。 当然，我们还需算出一个数的出现次数 \(cnt\)，考虑到无重复，所以我们只需模拟即可。 时间复杂度：\(O(m+n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 4e5 + 10, inf = 0x3f3f3f3f; int cnt[N]; pii a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n, m; cin >> n >> m; for(int i=1;i&lt;=n+m;i++) cnt[i] = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i].first; a[i].second = 0; &#125; for(int i=1;i&lt;=m;i++)&#123; int p, v; cin >> p >> v; cnt[a[p].first] += i - a[p].second; a[p] = &#123;v, i&#125;; &#125; for(int i=1;i&lt;=n;i++) cnt[a[i].first] += m + 1 - a[i].second; int ans = 0; for(int i=1;i&lt;=n+m;i++)&#123; if(cnt[i] == 0) continue; if(cnt[i] > m) ans += m * (m + 1) / 2; else ans += (m * (m + 1) - (m - cnt[i]) * (m - cnt[i] + 1)) / 2; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 我蠢了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 831 Div. 1 + 2</title>
    <url>/blog/posts/126870515/</url>
    <content><![CDATA[Practice. A. Factorise N+M 题意 给定一个质数，输出一个质数，使两者相加不是质数。 思路 除 \(2\) 之外，偶数都不是质数，所以直接加上 \(3\) 即可。 若为 \(2\)，那么加上 \(2\) 即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; cout &lt;&lt; (n % 2 == 0 ? 2 : 3) &lt;&lt; '\n'; &#125; &#125; 水 B. Jumbo Extra Cheese 2 题意 给定 \(n\) 个长方形，所有长方形必须有一条边在 \(x\) 轴上，每个长方形至少需要和另一个长方形有公共边，输出周长最小值。 思路 首先，贴靠在一起后，周长只和最高的高度和所有长方形贴靠在 \(x\) 轴上的长度有关，所以我们希望让最高的高度降低，同时尽量将所有的长方形的短边贴靠在 \(x\) 轴。 因此，我们可以贪心地直接将最高的方块横着放，其余竖着放即可。 但是我不会证 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; pii p[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++) &#123; int a, b; cin >> a >> b; p[i] = &#123;max(a, b), min(a, b)&#125;; &#125; sort(p, p + n, greater&lt;>()); int cnt = p[0].first; for(int i=1;i&lt;n;i++) cnt += p[i].second; cout &lt;&lt; 2 * (p[0].second + cnt) &lt;&lt; '\n'; &#125; &#125; 怎么证捏 C. Bricks and Bags 题意 给定一个数组 \(a\)，将所有数字任意分成 \(3\) 组，不能出现空组。从三组中各拿出一个数字，使 \(|w_1 - w_2| + |w_2 - w_3|\) 最小。将数字合理分配，使 \(|w_1 - w_2| + |w_2 - w_3|\) 的最小值最大。 思路 首先，假设我们确定了一个数，那么我们能决定的是将一个组合全部放入最小值或最大值，让这一部分的最小值固定，那么我们只要在一个组合里只放另一个数，要让其最小，肯定会拿出最靠近这个数的数字，因而我们也希望找出数值上相邻的两数，它们的差值最大。 所以，我们可以排序然后枚举这个数字，然后计算出最大值即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a, a + n); int ans = 0; for(int i=1;i&lt;n;i++) ans = max(ans, max(2 * a[i] - a[i - 1] - a[0], a[i] + a[n - 1] - 2 * a[i - 1])); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 怎么就WA了那么多遍呢（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 344 Div. 2</title>
    <url>/blog/posts/641661849/</url>
    <content><![CDATA[Practice. 什么陈年老题目（（ A. Interview 题意 给定两个长度相等的序列，任选一段区间，输出区间内各序列值进行按位或之后的和。 思路 考虑到数据范围，直接暴力即可。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], b[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;n;i++) cin >> b[i]; int ans = 0; for(int i=0;i&lt;n;i++)&#123; int ca = 0, cb = 0; for(int j=i;j&lt;n;j++)&#123; ca |= a[j]; cb |= b[j]; ans = max(ans, ca + cb); &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; 过于打卡 B. Print Check 中文版：题目详情 - 简单题 - FJNU (fjnuacm.top) 题意 给定一个 \(n \times m\) 的矩阵，对于 \(q\) 个操作，输出操作后的矩阵。 定义操作为选择一行或一列，将该行或该列的值改为指定值，存在覆盖的情况。 思路 首先，不可以模拟，只要 \(n, m, q\) 够大，一定会 \(tle\)。 其次，对于一个点，它最后的值只和最后一次对它所在的行或列的操作有关。 因而，我们不妨记录每行的操作，以及操作时间，在最后输出的时候，判断涉及到该点的行操作和列操作的时间，并输出最后操作后的值。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; pii r[N], c[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, m, k; cin >> n >> m >> k; for(int i=1;i&lt;=k;i++)&#123; int x, p, a; cin >> x >> p >> a; if(x == 1) r[p] = &#123;i, a&#125;; else c[p] = &#123;i, a&#125;; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cout &lt;&lt; (r[i].first > c[j].first ? r[i].second : c[j].second) &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; &#125; 怎么就做到原题了（（ C. Report 题意 给定一个数组 \(a\)，输出操作后数组的结果。 定义一次操作为选择一个右端点 \(r\)，将 \([1, r]\) 内的数升序或降序排列，排列方式取决于输入，\(1\) 为非降序，\(0\) 为非升序。 思路 剪枝 首先，这些操作存在覆盖，也就是说，后面的操作可以使前面的操作无效。 对于最后一个操作，若前面的操作的区间比它小，那么这些操作均无效。推广可得，我们只需从后往前拿出包含最后一个操作且操作区间递增的操作，其余不考虑即可。 输出 考虑到直接暴力排序的时间复杂度过大，我们不妨观察一下每次操作的特点： 当我们对大区间操作后，其与次大值区间的补集就唯一确定了，不会随着后续操作而改变，所以我们不妨直接从后往前放数字。 对于一个区间内的数，我们不妨直接将其升序排序，若这个补集需要非降序，那么把右端点的数字取出，否则把左端点的数字取出，依次放入这个补集所在的区域即可。 当然，最大的操作之后的数直接输出，不参与排序。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; pii op[N], opt[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, tm, m = 0; cin >> n >> tm; for(int i=0;i&lt;n;i++) cin >> a[i]; for(int i=0;i&lt;tm;i++) cin >> opt[i].second >> opt[i].first; int st = -1; for(int i=tm-1;i>=0;i--)&#123; if(st != -1 &amp;&amp; opt[i].first &lt;= st) continue; st = opt[i].first; op[m ++] = opt[i]; &#125; sort(op, op + m, greater&lt;>()); vector&lt;int> ans(n); for(int i=n-1;i>=op[0].first;i--) ans[i] = a[i]; sort(a, a + op[0].first); int l = 0, r = op[0].first - 1; for(int i=0;i&lt;m-1;i++)&#123; for(int j=op[i].first-1;j>=op[i+1].first;j--)&#123; if(op[i].second == 2) ans[j] = a[l ++]; else ans[j] = a[r --]; &#125; &#125; for(int j=op[m - 1].first-1;j>=0;j--)&#123; if(op[m - 1].second == 2) ans[j] = a[l ++]; else ans[j] = a[r --]; &#125; for(int i=0;i&lt;n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125; 能用数据结构么 D. Messenger 题意 定义对只有小写字母的字符串的一种压缩方式为选取任意连续相等的子序列，将其替换为 \(个数 - 字母\)。 如 \(aaa\) 可替换为 \(3-a\) ，也可以替换为 \(1-a\ 2-a\)。 给定两个压缩后的字符串 \(s, t\)，对于两者的原字符串，输出 \(t\) 在 \(s\) 中出现了几次。 思路 首先，若要在 \(O(n)\) 的复杂度内解出字符串的查找，我们需要用到 \(KMP\) 算法。 其次，我们不能直接调用 \(KMP\)，因为可能出现开头或结尾的字母数量小于 \(s\) 对应字母的数量的情况。如 \(1 - a\) 和 \(2 - a\)。 但是，我们可以确定的是，去掉两端的字母，中间的序列是一定相同的，所以我们不妨去掉两端的字母后调用 \(KMP\) 算法，找出所有满足条件的区间 \([l, r]\)。 当然，考虑到字符串并未彻底压缩，会影响到查找，所以我们需要预处理，将 \(1 - a\ 2 - a\) 之类压缩到最小。 不过，此时还有一个问题没有解决：类似于 \(1 - a\) 和 \(11 - a\) 的子串会被意外匹配，而它们的数量是不相同的。这时我们不妨在所有数字的起始处加一个特殊字符（如 \(.\)）。此时，形如 \(1a12b3c\) 的字符串将会变为 \(.1a.12b.3c\)，即可避免意外匹配。 考虑到对于求得的区间，我们需要快速定位其左右端点对应的内容，所以我们需要用类似于 \(map\) 的容器记录每个元素的起始位置对应的元素。此时，对于 \(l\) 对应的元素的前一个元素和 \(r + 1\) 对应的元素，我们只需比对其与 \(t\) 字符串的两端的元素的字母是否相同、以及数量是否符合条件即可。 当然，上述操作针对的是预处理后 \(t\) 只剩三个元素的情况，其余情况都可以暴力，只是元素为一个的时候，元素是可以在一个大区间内移动的，它的左右端点不像元素多的时候那样是固定的。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> class KMP &#123; //交一个套板子的（（ public: static vector&lt;int> prefix_function(string s) &#123; int n = (int) s.length(); vector&lt;int> pi(n); for (int i = 1; i &lt; n; i++) &#123; int j = pi[i - 1]; while (j > 0 &amp;&amp; s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; &#125; return pi; &#125; static vector&lt;pii > find_occurrences(const string &amp;text, const string &amp;pattern) &#123; string cur = pattern + '#' + text; int sz1 = text.size(), sz2 = pattern.size(); vector&lt;pii > v; vector&lt;int> lps = prefix_function(cur); for (int i = sz2 + 1; i &lt;= sz1 + sz2; i++) &#123; if (lps[i] == sz2) v.emplace_back(i - 2 * sz2, i - sz2 - 1); &#125; return v; &#125; &#125;; vector&lt;pair&lt;int, char>> merge(int tn, int &amp;n) &#123; vector&lt;pair&lt;int, char>> a; char pre = -1; int cnt = 0; while (tn--) &#123; string cur; cin >> cur; int x = 0, i = 0; while (cur[i] != '-') &#123; x = x * 10 + (cur[i] - '0'); i++; &#125; if (pre == -1) pre = cur[i + 1]; if (pre != cur[i + 1]) &#123; a.emplace_back(cnt, pre); n++; pre = cur[i + 1]; cnt = x; &#125; else cnt += x; &#125; a.emplace_back(cnt, pre); n++; return a; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int tn, tm, n = 0, m = 0; cin >> tn >> tm; vector&lt;pair&lt;int, char>> a = merge(tn, n), b = merge(tm, m); int cnt = 0; if (m >= 3) &#123; string origin, dest; map&lt;int, int> ind; for (int i = 0; i &lt; n; i++) &#123; ind[origin.size()] = i; origin += "$" + to_string(a[i].first); origin += a[i].second; &#125; for (int i = 1; i &lt; m - 1; i++) &#123; dest += "$" + to_string(b[i].first); dest += b[i].second; &#125; vector&lt;pii > oc = KMP::find_occurrences(origin, dest); for (auto e: oc) &#123; if (e.second + 1 >= origin.size()) continue; int x1 = ind[e.first], x2 = ind[e.second + 1]; if (x1 == 0) continue; if (a[x1 - 1].second == b[0].second &amp;&amp; a[x2].second == b[m - 1].second &amp;&amp; a[x1 - 1].first >= b[0].first &amp;&amp; a[x2].first >= b[m - 1].first) cnt++; &#125; &#125; else if (m == 2) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; if (a[i].second != b[0].second || a[i + 1].second != b[1].second) continue; if (a[i].first >= b[0].first &amp;&amp; a[i + 1].first >= b[1].first) cnt++; &#125; &#125; else &#123; for (int i = 0; i &lt; n; i++) &#123; if (a[i].second != b[0].second) continue; if (a[i].first >= b[0].first) cnt += a[i].first - b[0].first + 1; &#125; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; 有点难解释，反正大概做法是这样（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 832 Div. 2</title>
    <url>/blog/posts/3447609703/</url>
    <content><![CDATA[Practice. A. Two Groups 题意 给定一个数组 \(a\)，可以为负数，从数组 \(a\) 中取出某些数作为序列 \(s_1\)，剩余作为序列 \(s_2\)，输出 \(|sum(s_1)| - |sum(s2)|\) 的最大值。序列可以为空。 思路 考虑到 \(|sum(s_1)| - |sum(s2)| \leq |sum(s_1) + sum(s2)| = |sum(a_i)|\)，我们可以发现原数组的总和的绝对值即为最大值。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5+10; signed main()&#123; ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); int t; cin >> t; while(t --)&#123; int n; cin >> n; int ans = 0; for(int i=1;i&lt;=n;i++) &#123; int cur; cin >> cur; ans += cur; &#125; cout &lt;&lt; abs(ans) &lt;&lt; '\n'; &#125; &#125; 暴力枚举碰运气过了可还行 B. BAN BAN 题意 给定一个整数 \(n\)，对于由 \(n\) 个 \(BAN\) 组成的字符串，输出至少交换几次，使所有长度为 \(3\) 的可不连续子序列不包含 \(BAN\)。 思路 显然，我们希望 \(B\) 能移到后面，\(N\) 能移到前面，那么我们不妨将第 \(i\) 个 \(B\) 和第 \(n - i + 1\) 个 \(N\) 交换。 当然，若 \(n\) 为奇数，中间的那个字符串直接反转即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5+10; signed main()&#123; ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); int t; cin >> t; while(t --)&#123; int n; cin >> n; cout &lt;&lt; n / 2 + n % 2 &lt;&lt; '\n'; for(int i=0;i&lt;n/2;i++) cout &lt;&lt; 1 + i * 3 &lt;&lt; ' ' &lt;&lt; 3 * n - (i * 3) &lt;&lt; '\n'; if(n % 2 == 1) cout &lt;&lt; 3 * (n / 2) + 1 &lt;&lt; ' ' &lt;&lt; 3 * (n / 2) + 3 &lt;&lt; '\n'; &#125; &#125; 纯纯找规律（（ C. Swap Game 题意 给定一个序列，规定每个玩家可以选择一个数，将其与第一个数交换，并将第一个数扣去 \(1\)。定义最后将 \(0\) 交换到第一个位置上的玩家输，在 \(Alice\) 先手的条件下，输出最后的赢家。 思路 首先，若最小的数是第一个数，那么先手就会将最小的数放到后面，从而使后手具有必胜策略：我只需每次都挑大的数，那么对方就只能挑小的数，从而让对方最后只能取 \(0\)。反之同理。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f; signed main()&#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t; cin >> t; while(t --)&#123; int n; cin >> n; int minn = inf, a0; cin >> a0; minn = min(minn, a0); for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; minn = min(minn, cur); &#125; cout &lt;&lt; (minn == a0 ? "Bob" : "Alice") &lt;&lt; '\n'; &#125; &#125; 当然和总和的奇偶性没关系 D. Yet Another Problem 题意 给定一个序列 \(a\)，定义一次操作为选定任意长度为奇数的区间，将区间内的数全都改为整个区间的异或值。对于每个区间询问，输出最小操作数，使区间的数都变为 \(0\)。无解输出 \(-1\)。 思路 首先，若没有区间奇偶性的限制，我们直接预处理出前缀异或，然后用类似于前缀和的方式计算即可。 当然，也可以用一下前缀和，毕竟我们需要知道这个区间是否已经全为 \(0\)。 若查询的区间长度为偶数，那么我们只能挑选两个长度为奇数的区间。考虑到对一个子区间操作后，剩余的区间的异或值一定为 \(0\)，所以我们只需枚举所有长度为奇数的右端的子区间即可（左端也行）。 不过，我们不可以枚举，因为数据量实在太大了。所以，我们需要进行预处理。对于一个右端点，若它为偶数，那么以它为右端点的区间的左端点一定是奇数，从而我们可以进行递推，找到两个异或值相等且奇偶性不同的点即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; int a[N], xo[N], sum[N], pre[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int n, q; cin >> n >> q; vector&lt;map&lt;int, int>> mp(2); for (int i = 1; i &lt;= n; i++) &#123; cin >> a[i]; xo[i] = xo[i - 1] ^ a[i]; sum[i] = sum[i - 1] + a[i]; if(mp[1 - i % 2].count(xo[i])) pre[i] = mp[1 - i % 2][xo[i]]; mp[i % 2][xo[i]] = i; &#125; while (q--) &#123; int l, r; cin >> l >> r; if ((xo[r] ^ xo[l - 1]) != 0) &#123; cout &lt;&lt; -1 &lt;&lt; '\n'; continue; &#125; if (sum[r] - sum[l - 1] == 0) &#123; cout &lt;&lt; 0 &lt;&lt; '\n'; &#125; else if ((r - l + 1) % 2 == 1) &#123; cout &lt;&lt; 1 &lt;&lt; '\n'; &#125; else &#123; if (a[r] == 0 || a[l] == 0) &#123; cout &lt;&lt; 1 &lt;&lt; '\n'; continue; &#125; cout &lt;&lt; (pre[r] >= l ? 2 : -1) &lt;&lt; '\n'; &#125; &#125; &#125; 二分半天不过...]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - CodeTON Round 3 Div. 1 + 2</title>
    <url>/blog/posts/3739927720/</url>
    <content><![CDATA[Practice. A. Indirect Sort 题意 给定一个排列 \(a\)，定义操作如下： 选择三个下标 \(i, j, k\)，满足 \(1 \leq i &lt; j &lt; k \leq n\)； 若 \(a_i &gt; a_k\)，将 \(a_i\) 替换为 \(a_i + a_j\)，否则将 \(a_j\) 和 \(a_k\) 交换。 输出是否可以将排列变为一个不递减序列。 思路 显然，当第一位不为 \(1\) 的时候，第一位无法减小，而由于 \(1\) 在序列的后面，所以一定存在一个递减的组合，而操作无法将选定的递减组合变为递增，所以无解。 相反地，当第一位为 \(1\) 时，我们只需选 \(i = 1\)，那么每次均可实现交换，从而交换成为一个不递减序列。 时间复杂度：\(O(1)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int a, tmp; cin >> a; for(int i=1;i&lt;n;i++) cin >> tmp; cout &lt;&lt; (a == 1 ? "YES\n" : "No\n"); &#125; &#125; 怎么会是呢，怎么想了那么久呢？ B. Maximum Substring 题意 给定一个二进制字符串，对于它的连续子串，统计 \(0, 1\) 的个数为 \(x, y\)，那么代价 \(t\) 满足： \(x \cdot y\)，如果 \(x &gt; 0\) 并且 \(y &gt; 0\)； \(x ^ 2\)，如果 \(x &gt; 0\) 并且 \(y = 0\)； \(y ^ 2\)，如果 \(x = 0\) 并且 \(y &gt; 0\)。 输出所有子串中最大的代价。 思路 显然，若我们想让代价最大，那么我们希望子串中 \(0\) 或 \(1\) 的个数尽量多，如果个数差不多，那么考虑两者的乘积。 所以，我们不妨找出所有连续相等的子串，然后计算个数的平方，记录该条件的最大值。 而假设不满足上述条件，那么我们就希望 \(x\) 和 \(y\) 的值足够大，也就是原字符串对应的代价。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int num = 0; for(char e : s) if(e == '1') num ++; int cnt = 0, pre = 0; for(int i=0;i&lt;n;i++)&#123; if(s[i] == s[pre]) continue; else&#123; cnt = max(cnt, i - pre); pre = i; &#125; &#125; cnt = max(cnt, n - pre); cout &lt;&lt; max(cnt * cnt, num * (n - num)) &lt;&lt; '\n'; &#125; &#125; 简单思维题 C. Complementary XOR 题意 给定两个长度相等的二进制字符串 \(a, b\)，定义操作为选择一段连续的区间，并将区间内的 \(a\) 字符串的值取反，将区间外的 \(b\) 字符串的值取反。输出一种操作数低于 \(n + 5\) 的流程，使两个字符串所有位都变为 \(0\)。 思路 显然，若 \(a\) 与 \(b\) 异或值为 \(0\) 或者两者相等的时候才有解，否则考虑到操作的对称性，我们无法将它们变为 \(0\)。 其次，若 \(a\) 与 \(b\) 异或值为 \(0\)，那么我们只需选择整个区间进行一次操作，即可将 \(a\) 变为 \(b\)。 那么，我们来考虑 \(a = b\) 的情况。 不难发现，若我们遍历到了 \(a_i\)，满足 \(a_i = 1\)，那么我们只需选择 \([1, i]\) 和 \([1, i - 1]\) 进行操作，即可在将其余位的操作抵消的前提下，将 \(1\) 变为 \(0\) 了。 当然，右边界 \(i - 1\) 要求 \(i \geq 2\)，若第一位有 \(1\)，那么我们考虑对 \([1, 1]\) 和 \([2, n]\) 进行操作，从而将整个 \(a\) 取反。 按照上述输出，我们将会得到最多 \(2n + 1\) 个操作，要使其降低一倍，我们不妨留意异或的性质，在同一个区间内进行两次操作后操作是无效的。所以，我们只需统计操作数的奇偶性，从而避免无效操作。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; int cnt[N]; signed main()&#123; ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr); int t, n; cin >> t; vector&lt;pii> ans; while(t --)&#123; ans.clear(); cin >> n; for(int i=0;i&lt;n;i++) cnt[i] = 0; string a, b; cin >> a >> b; bool ok = true; for(int i=0;i&lt;n;i++)&#123; if(a[i] != ('1' - b[i] + '0'))&#123; ok = false; break; &#125; &#125; if(a != b &amp;&amp; !ok)&#123; cout &lt;&lt; "NO\n"; &#125;else&#123; cout &lt;&lt; "YES\n"; if(a != b)&#123; ans.emplace_back(1, n); a = b; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i] == '1')&#123; if(i == 0)&#123; ans.emplace_back(1, n); ans.emplace_back(2, n); &#125;else&#123; cnt[i] ++; cnt[i - 1] ++; &#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(cnt[i] % 2 == 1) ans.emplace_back(1, i + 1); &#125; cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto x : ans) cout &lt;&lt; x.first &lt;&lt; ' ' &lt;&lt; x.second &lt;&lt; '\n'; &#125; &#125; &#125; 构造题有时候想到就感觉很妙啊（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Pinely Round 1 Div. 1 + 2</title>
    <url>/blog/posts/760099833/</url>
    <content><![CDATA[Practice. 代码略去了快读模板 A. Two Permutations 题意 给定三个整数 \(n, a, b\)，构建两个长为 \(n\) 的排列，满足前 \(a\) 个数和后 \(b\) 个数一致。输出是否能构建出两个不同的排列。 特别地，当 \(n = a = b\) 时，输出 \(YES\)。 思路 如题。 时间复杂度：\(O(1)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; int n = console.nextInt(), a = console.nextInt(), b = console.nextInt(); if(n == a &amp;&amp; b == a)&#123; console.println("YES"); continue; &#125; console.println(n - a - b >= 2 ? "YES" : "NO"); &#125; console.close(); &#125; &#125; 什么离谱的特判啊 B. Elimination of a Ring 题意 给定一个首尾相连的序列，序列中的相邻元素不相等。定义一次操作为删去任意元素，在每次删去后，若出现相邻元素相等，那么删去任意重复元素，直到没有相邻元素相等。 思路 我们不妨来考虑下面的一种情况： 1 6 1 2 1 2 1 2 显然，对于这类相间的数，在剩余两个数之前，我们都是成对删除的（如删除 \(1\) 后左边或右边的 \(2\) 也将被删去）。 而若我们在里面添加任意数字，那么相间的环将会被打破，我们不难发现，我们只需删去添加的任意数的相邻数，即可避免删除数以后出现重复数字。 更具体地说，除了两个数字相间成环的情况，我们应该输出 \(\frac{n}{2} + 1\) 外，其余情况均输出 \(n\)。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); if(n &lt;= 2 || n % 2 == 1) &#123; for(int i=0;i&lt;n;i++) console.nextInt(); console.println(n); &#125; else&#123; int a = console.nextInt(), b = console.nextInt(); boolean f = false; for(int i = 1;i&lt;n / 2;i++)&#123; if(console.nextInt() != a | console.nextInt() != b)&#123; if(f) continue; console.println(n); f = true; &#125; &#125; if(!f) console.println(n / 2 + 1); &#125; &#125; console.close(); &#125; &#125; 硬猜就完事了（ C. Set Construction 题意 给定一个二进制矩阵 \(b\)，构造 \(n\) 个无重复数字的序列 \(A\)，满足矩阵对应的限制： \(b_{i, j} = 1\) 表示 \(A_i\subsetneq A_j\)，\(b_{i, j} = 0\) 则相反。 思路 显然，序列是不唯一的，那么我们不妨来初始化 \(A\)，满足 \(A_i\) 中一定包含 \(i\)。 那么，显然地，若 \(A_i\subsetneq A_j\)，那么 \(A_j\) 中就一定有 \(i\)。 更简单地说，我们只需遍历输出的矩阵，若 \(b_{i, j} = 1\)，那么我们在 \(A_j\) 里添加 \(i\)。 输出满足上述条件的序列即可。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0) &#123; int n = console.nextInt(); List&lt;List&lt;Integer>> ans = new ArrayList&lt;>(); for (int i = 0; i &lt; n; i++) &#123; List&lt;Integer> e = new ArrayList&lt;>(); e.add(i + 1); ans.add(e); &#125; for (int i = 1; i &lt;= n; i++) &#123; String s = console.next(); for (int j = 0; j &lt; n; j++) &#123; if(s.charAt(j) == '1') ans.get(j).add(i); &#125; &#125; for(int i=0;i&lt;n;i++)&#123; console.print(ans.get(i).size()); for(int j : ans.get(i)) console.print(" " + j); console.println(); &#125; &#125; console.close(); &#125; &#125; 好一个思维题...]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - SWERC 2022-2023 - Online Mirror</title>
    <url>/blog/posts/2576267679/</url>
    <content><![CDATA[Contestant. Rank 720. Unrated. 划水，打卡，三题，结束（（ A. Walking Boy 题意 给定一个升序排序的数组 \(a\)，\(a_i \in [0, 1440]\)，在数组第一位插入 \(0\)，最后一位插入 \(1440\)，输出是否有两个相邻数的差值大于等于 \(120\)。 思路 如题。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; a[i] = min(a[i], 1440ll); &#125; int cnt = 0; a[n + 1] = 1440; for(int i=1;i&lt;=n + 1;i++) cnt += (a[i] - a[i - 1]) / 120; cout &lt;&lt; (cnt >= 2 ? "YES\n" : "NO\n"); &#125; &#125; 你怕是不想让我看懂（ H. Beppa and SwerChat 题意 给定两个时间段的好友列表，列表按照最后一条消息的时间降序排序。输出至少有多少人在两个时间段内发了消息。 思路 很显然，若发送了消息，那么这个人是从当前位置移动到第一个位置的。 或者更具体地说，我们从后往前遍历 \(b\) 数组，那么只需找到第一对相邻的数，满足在 \(a\) 数组的位置不符合要求即可。 当然，我们可以记录 \(a\) 中元素对应的下标来使查询复杂度降到 \(O(1)\)。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N], b[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; a[cur] = i; &#125; for(int i=1;i&lt;=n;i++) cin >> b[i]; int cnt = n; for(int i=n;i>=1;i--)&#123; cnt --; if(a[b[i - 1]] > a[b[i]]) break; &#125; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; &#125; 捏码，怎么就WA了 L. Controllers 题意 给定一个由 \(+, -\) 符号组成的字符串，对于 \(t\) 组询问，给定两个数 \(a, b\)，输出是否存在 \(a, b\) 的一个序列，使其带入表达式后值为 \(0\)。 思路 显然，我们有两个选择可以让最后的值为 \(0\)： 选择任意数，\(+-\) 任意次后答案一定是 \(0\)； 将 \(a, b\) 进行配对，用最小公倍数找出合法配对，进行“抵消”。 我们不妨统计 \(+-\) 的个数，记 \(pl\) 为个数的最小值，\(mi\) 为个数的最大值，并令 \(a\) 为 \(\max(a, b)\)，\(b\) 为 \(\min(a, b)\)；然后，我们计算出 \(lcm(a, b)\)，那么 \(lcm / a\) 个个数较少的符号和 \(lcm / b\) 个个数较多的符号即可进行配对。 考虑到两种配对方法的个数较少，且无法确定需要配对几次，所以我们不妨直接枚举所有 \(a, b\) 的配对，找出是否存在一种配对，使剩余的两种符号个数相同。若相同，我们直接选择第一种配对方式配对即可。 时间复杂度：\(O(n)?\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int gcd(int a, int b) &#123; while (b != 0) &#123; int tmp = a; a = b; b = tmp % b; &#125; return a; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, q; string op; cin >> n >> op >> q; int pl = 0; for(char e : op) if(e == '+') pl ++; int mi = n - pl; int tmp = min(pl, mi); mi = max(pl, mi); pl = tmp; while(q --)&#123; int a, b; cin >> a >> b; tmp = min(a, b); a = max(a, b); b = tmp; if(pl == mi)&#123; cout &lt;&lt; "YES\n"; continue; &#125; int lcm = a * b / gcd(a, b); int pa = lcm / a, pb = lcm / b; int t = min(pl / pa, mi / pb); bool f = false; for(int i=1;i&lt;=t;i++)&#123; if(pl - i * pa == mi - i * pb)&#123; f = true; break; &#125; &#125; cout &lt;&lt; (f ? "YES\n" : "NO\n"); &#125; &#125; 人类的智慧（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 290</title>
    <url>/blog/posts/348658234/</url>
    <content><![CDATA[Contestant. Rank 3650. Rating +66. A. Contest Result 题意 给定数组 \(a, b\)，输出 \(a_{b_i}\) 的总和。 思路 如题。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i = 1;i&lt;=n;i++) cin >> a[i]; int ans = 0; for(int i=0;i&lt;m;i++)&#123; int p; cin >> p; ans += a[p]; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; 太打卡了吧（（ B. Qual B 题意 给定一个由 \(o, x\) 组成的字符串，将第 \(k + 1\) 个及以后的 \(o\) 替换成 \(x\)，输出字符串。 思路 如题。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; string s; cin >> s; int cnt = 0; for(int i=0;i&lt;n;i++)&#123; if(s[i] == 'x') cout &lt;&lt; 'x'; else&#123; cnt ++; if(cnt > m) cout &lt;&lt; 'x'; else cout &lt;&lt; 'o'; &#125; &#125; &#125; 做的太慢了捏 C. Max MEX 题意 给定一个数组 \(a\)，找出一个长为 \(k\) 的子串 \(X\)，满足 \(MEX\) 值最大。 定义 \(MEX(X)\) 为最大的 \(m\) ，满足下面的条件： \([0, m)\) 都在 \(X\) 内； \(m\) 不在 \(X\) 内 思路 我们不妨将数组升序排序，去除所有的重复元素，然后从 \(0\) 开始匹配，若能找到 \(0, 1, \ldots, k\) ，那么输出 \(k + 1\)，否则找到最长的 \(0, 1, \ldots, t\) ，输出 \(t + 1\)。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 3e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a, a + n); a[n] = inf; int l = 0; for(int i=0;i&lt;=n;i++)&#123; if(a[i] == l - 1) continue; if(a[i] == l) l ++; if(l >= m) break; &#125; cout &lt;&lt; l; &#125; 模拟不明白了（（ D. Marking 题意 对于 \(t\) 个询问，给定三个整数 \(n, d, k\)，输出第 \(k\) 次标记的点。 标记满足下面的规则： 第一次标记 \(0\) 点； 重复下述操作 \(n - 1\) 次，其中 \(a\) 为前一次标记的下标： 令 \(x = (a + d)\mod N\)； 找到 \(x\) 及以后第一个没标记的下标并标记 思路 首先，很明显地，我们需要找出标记的周期，当完成一次周期后，我们需要移到下一位并继续循环，直至结束。 不难证明，周期是 \(x = \frac{n}{gcd(n, d)}\)，而我们只需要计算经过了多少个周期，然后将最后的答案加上这个值即可。 考虑到数据量不超过长整型，我们直接计算 \((d \times k)\mod n\) 即可，然后按照上述操作加上 \(\frac{k}{x}\) 即可。 时间复杂度：不会分析捏 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; private static long gcd(long a, long b) &#123; while(b != 0) &#123; long tmp = a; a = b; b = tmp % b; &#125; return a; &#125; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; long n = console.nextInt(), d = console.nextInt(), k = console.nextInt(); k --; console.println(d * k % n + k / (n / gcd(n, d))); &#125; console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; nnd，没考虑到类似于 \(6, 9\) 的测试数据，寄]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder - ABC 288</title>
    <url>/blog/posts/50897737/</url>
    <content><![CDATA[Contestant. Rank 3721. Rating +41. A. Many A+B Problems 题意 给定 \(a, b\)，输出 \(a + b\)。 思路 如题 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0); int t; cin >> t; while(t --)&#123; int a, b; cin >> a >> b; cout &lt;&lt; a + b &lt;&lt; '\n'; &#125; return 0; &#125; 怎么会是呢 B. Qualification Contest 题意 给定 \(n\) 个由小写字母组成的字符串，输出字典序升序排序的前 \(k\) 个字符串。 思路 考虑到 \(sort\) 对字符串的排序就是按照字典序的，所以调函数输出即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 110; string a[N]; signed main() &#123; ios::sync_with_stdio(0); int k, n; cin >> n >> k; for (int i = 0; i &lt; n; i++) cin >> a[i]; sort(a, a + k); for (int i = 0; i &lt; k; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; '\n'; &#125; return 0; &#125; 草，卡了半天发现调函数就好了（ C. Don't be cycle 题意 给定一个无向有环图，输出最小删除边数，使整个图无环。 思路 考虑到树的结构即为无向无环，所以我们不妨跑一遍最小生成树，剩余的边就是我们想要删去的边了。 时间复杂度：\(O(e \log_2 e)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010, M = 400010; int n, m; int f[N]; int u[M], v[M], ans = 0; int find(int x)&#123; return x == f[x] ? x : f[x] = find(f[x]); &#125; void kruskal()&#123; for(int i=0;i&lt;m * 2;i++)&#123; int eu = find(u[i]), ev = find(v[i]); if(eu != ev)&#123; ans ++; f[ev] = eu; &#125; &#125; &#125; signed main() &#123; ios::sync_with_stdio(0); cin >> n >> m; for(int i=1;i&lt;=n;i++) f[i] = i; for(int i=0;i&lt;m;i++)&#123; int a, b; cin >> a >> b; u[i &lt;&lt; 1] = a; v[i &lt;&lt; 1] = b; u[i &lt;&lt; 1 | 1] = b; v[i &lt;&lt; 1 | 1] = a; &#125; kruskal(); cout &lt;&lt; m - ans; return 0; &#125; 我蠢了，想了好一会儿]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 143</title>
    <url>/blog/posts/3290967404/</url>
    <content><![CDATA[Contestant. Rank 2199. Rating +10. A. Two Towers 题意 给定由两种不同颜色的元素叠成的塔，定义操作为将一个塔上的顶部元素移动到另一个塔，在若干次操作后，输出是否可以让两个塔的元素颜色相间。 思路 显然，这个问题可以抽象为：给定一个元素序列，找出一个点，将序列分成两半，使分割后的序列颜色相间。 那么，我们需要满足两个条件： 序列内没有连续 \(3\) 个及以上相同元素相邻； 序列内连续 \(2\) 个及以上相同元素相邻的组的个数最多只有 \(1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a, b; cin >> a >> b; string x, y; cin >> x >> y; reverse(y.begin(), y.end()); x += y; int n = a + b; char pre = -1; int cnt = 0; bool ans = true, found = false; for(int i=0;i&lt;n;i++)&#123; char cur = x[i]; if(cur == pre) &#123; cnt ++; if(cnt == 2)&#123; if(found)&#123; ans = false; break; &#125; found = true; &#125; if(cnt >= 3)&#123; ans = false; break; &#125; &#125;else cnt = 1; pre = cur; &#125; cout &lt;&lt; (ans ? "YES\n" : "NO\n"); &#125; return 0; &#125; 漏条件了，淦 B. Ideal Point 题意 给定 \(n\) 个区间，判断是否能删去一些区间，让 \(k\) 成为被最多数量的区间包含的点。 思路 显然，若不希望让其他节点成为被最多数量的区间包含的点，我们就希望两个区间的交集为一个点，也就是说，我们只需删到最后只剩下 \([x, k], [k, y]\) 即可。 换句话说，我们只需找出这样的区间，满足左边界为 \(k\) 或右边界为 \(k\)。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a, b; cin >> a >> b; string x, y; cin >> x >> y; reverse(y.begin(), y.end()); x += y; int n = a + b; char pre = -1; int cnt = 0; bool ans = true, found = false; for(int i=0;i&lt;n;i++)&#123; char cur = x[i]; if(cur == pre) &#123; cnt ++; if(cnt == 2)&#123; if(found)&#123; ans = false; break; &#125; found = true; &#125; if(cnt >= 3)&#123; ans = false; break; &#125; &#125;else cnt = 1; pre = cur; &#125; cout &lt;&lt; (ans ? "YES\n" : "NO\n"); &#125; return 0; &#125; nnd，一个水题卡半天 C. Tea Tasting 题意 给定 \(n\) 壶茶和 \(n\) 个品茶师，第 \(i\) 壶茶有 \(a_i\) 数量的茶，第 \(i\) 位品茶师一次可以喝 \(b_i\) 数量的茶。 规定有 \(n\) 轮喝茶，第 \(i\) 轮由 \([i, n]\) 内的品茶师喝 \([1, n - i + 1]\) 内的茶。 输出每位品茶师最后喝了多少。 思路 首先，我们可以发现，对于第 \(i\) 轮，我们考虑从第 \(i\) 位开始求和后第一个超过 \(a_i\) 的数的下标，此时我们就可以确定一轮下来有哪些品茶师喝了茶。 考虑到只有最后一个品茶师有可能喝到多余的茶，其余的品茶师喝的量都是次数乘上 \(b_i\)，那么我们不妨单独统计多余喝的量，其余的统计我们考虑使用差分。 当然，上述求和找下标的操作可以采用 前缀和+二分。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], b[N], sum[N], drunk[N], ans[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; for(int i=1;i&lt;=n;i++) cin >> a[i]; for(int i=1;i&lt;=n;i++) &#123; cin >> b[i]; drunk[i] = 0; ans[i] = 0; &#125; sum[0] = drunk[0] = ans[0] = 0; for(int i=1;i&lt;=n;i++) sum[i] = sum[i - 1] + b[i]; for(int i=1;i&lt;=n;i++) &#123; int x = lower_bound(sum + i, sum + n + 1, a[i] + sum[i - 1]) - sum - 1; //x为能吃的最后一个玩意儿 //if(x == 0) continue; int left = a[i] + sum[i - 1] - sum[x]; if(x &lt; n) ans[x + 1] += left; drunk[i] ++; drunk[x + 1] --; &#125; for(int i=1;i&lt;=n;i++)&#123; drunk[i] += drunk[i - 1]; ans[i] += drunk[i] * b[i]; cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; return 0; &#125; 过于模拟以至于思路很清晰也很单一 D. Triangle Coloring 题意 给定一个有 \(\frac{n}{3}\) 个连通块的带权无向有环图，每个连通块的三点均有一条边相连，构成 \(\frac{n}{3}\) 个三角形。将所有点染上两种颜色，满足两种颜色的点的个数相同，输出有多少方案让连接两个颜色不同的点的边的权值总和最大。 思路 显然，我们需要考虑一个连通块内权值重复的边，而我们关注的是最大值和次大值的情况： 全都相等，\(3\) 种选择； 次大值和最小值相等，\(2\) 种选择； 次大值和最大值相等，\(1\) 种选择； 没有一个相等，\(0\) 种选择。 照上述讨论，我们可以发现一个连通块的解等于最小值和多少条边是相等的。 而考虑到两种颜色的个数要相同，我们相当于在 \(t\) 个连通块中找出 \(\frac{t}{2}\) 个连通块染成同一种颜色，所以最后的答案即为所有连通块解的乘积乘上 \(C_{t}^{\frac{t}{2}}\)。 时间复杂度：不会分析 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 3e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N]; int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (!b) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= (a / b) * x; return d; &#125; int Inv(int a) &#123; int x, y; exgcd(a, mod, x, y); return (x % mod + mod) % mod; &#125; int C(int m, int n) &#123; int a = 1, b = 1; if (m &lt; n) return 0; while (n) &#123; a = (a * m) % mod; b = (b * n) % mod; m--; n--; &#125; return a * Inv(b) % mod; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin >> n; for (int i = 1; i &lt;= n; i++) cin >> a[i]; int t = n / 3; int ans = C(t, t / 2); for (int i = 0; i&lt;=n/3-1;i++) &#123; int minn = min(a[i * 3 + 3], min(a[i * 3 + 1], a[i * 3 + 2])); int cnt = 0; for (int j = 1; j &lt;= 3; j++) if (a[i * 3 + j] == minn) cnt++; ans = (ans * cnt) % mod; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0; &#125; 数组不要开小了！！ E. Explosions? 题意 给定一个数组 \(h\)，\(h_i\) 为第 \(i\) 个怪物的血量。每次操作可以使用任意数量的 \(MP\)，使任意一个怪物的血量扣除对应数量的值。 若怪物在遭到攻击后血量小于等于 \(0\)，那么怪物死亡。 定义"爆炸"为一个死亡的怪物将相邻的怪物的血量扣去 \(h_i - 1\)，若相邻的怪物血量被扣到 \(0\)，那么继续循环。 规定只能让"爆炸"发生一次或不发生，输出让所有怪物死亡的 \(MP\) 的最小值。 思路 答案的推导 首先，我们暂定爆炸的那个点下标为 \(p\)，之后再考虑 \(p\) 的选择。那么，我们不妨在最后使用爆炸，这样可以在爆炸前将所有元素调整到最好，也就是在 \([0,p]\) 内严格单调递增，\([p,n]\) 内严格单调递减。 我们不妨用补集的思路，算出最后满足上述条件的数组 \(h&#39;\) 的最大总和 \(sum\)，那么答案即为 \((\sum h_i) - sum\)。 总和的计算 首先，不难发现对于 \([0,p]\) 和 \([p, n]\) 的操作是类似的，那么我们不妨只考虑 \([0, p]\) 内的 \(sum&#39;\)。 "左边界" 对于 \(p - 1\) 点，假设该点满足 \(h_{p - 1} &gt; h _ p - 1\)，若需要构成连续爆炸，那么我们需要将 \(h_{p - 1}\) 改为 \(h_p - 1\)。同理，可推得对于 \(p - i\) 点，通式为 \(h_{p - i} &gt; h_p - i\)。 显然，因为严格单调递增，那么 \(h_p &gt; i\) 是一定成立的，也就是说，\(i \geq h_p\) 时到达边界。当然，按照上述的推导，\(p - i &lt; 0\) 或 \(h_{p - i} \leq h_p - i\) 时也会到达边界。 所以，对于左边界 \(j = p - i\)，将 \(i = p - j\) 和 \(h_{p - i} \leq h_p - i\) 联立，得到 \(h_j - j \leq h_p - p\)。 当然，若没有 \(j\) 满足上面的式子，那么我们将 \(j\) 设为 \(\max(-1, i - h_i)\)。 递推出总和 注意一下推导左边界的条件：\(h_{p - 1} &gt; h _ p - 1\)。这个条件有一个特点：我们目前所求得的"左边界"实际上是严格单调递增且相邻差值为 \(1\) 的序列的左边界，若出现了"断层"，那么 \(j\) 就有可能偏大了。 但是，不难发现 \(j\) 的推导和 \(p\) 后面的值是无关的，那么我们可以用递推的方式，先算出 \(j\) 前面"严格单调递增且相邻差值为 \(1\) 的序列"的总和，然后将这个总和加到 \(sum&#39;\) 中即可。 更具体地说，\(dp[i]\) 为以 \(i\) 点为右边界的"严格单调递增且相邻差值为 \(1\) 的序列"的总和，那么只要 \(j\) 对应的元素存在，我们就只需将 \(dp[i]\) 加上 \(dp[j]\) 。 有疑惑吗？请留意条件：\(h_{p - 1} \leq h _ p - 1\)。\(j\) 元素的值一定小于等于 \(j + 1\) 元素的值，所以加上 \(dp[j]\) 无额外条件。 计算 综上，我们只需对每个"严格单调递增且相邻差值为 \(1\) 的序列"求和即可，考虑到等差性，直接运用等差数列的求和公式即可。 因而， \(dp[i] = (i - j) \times h_i - \frac{(i - j)(i - j - 1)}{2}\)，\(j\) 存在时 \(dp[i] += dp[j]\)。 "左边界"的低复杂度求法 考虑到我们不可以在每次递推的时候都向前遍历满足条件的"左边界" \(j\)，因而我们需要一种更快的方法。 我们回归到条件 \(h_j - j \leq h_p - p\)。显然，我们需要找出满足该条件的 \(j\) 的最大值，而该思路恰好可以用单调栈实现（先入后出的逻辑适合本题），那么我们只需套上板子即可。 最后的答案 显然，上述操作是线性的，那么我们只需遍历所有的 \(p\)，然后输出最大值即可。 当然，因为 \(dpL\) 和 \(dpR\) 会有重叠，所以需要减去重叠的 \(h_i\)。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 3e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int hl[N], hr[N], dp[2][N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int sum = 0; for(int i=0;i&lt;n;i++) &#123; cin >> hl[i]; sum += hr[n - i - 1] = hl[i]; dp[0][i] = dp[1][i] = 0; &#125; for(int tp=0;tp&lt;2;tp++)&#123; int *h = tp == 0 ? hl : hr; stack&lt;pii> s; for(int i=0;i&lt;n;i++)&#123; while(!s.empty() &amp;&amp; s.top().first > h[i] - i) s.pop(); int j = max(-1LL, i - h[i]); if(!s.empty()) j = max(j, s.top().second); int len = i - j; dp[tp][i] = len * h[i] - len * (len - 1) / 2; if(j >= 0 &amp;&amp; len &lt; h[i]) dp[tp][i] += dp[tp][j]; s.emplace(h[i] - i, i); &#125; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; ans = max(ans, dp[0][i] + dp[1][n - i - 1] - hl[i] * 2); &#125; cout &lt;&lt; sum - ans &lt;&lt; '\n'; &#125; &#125; 好复杂.jpg]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 833 Div. 2</title>
    <url>/blog/posts/1795773139/</url>
    <content><![CDATA[Practice. A. The Ultimate Square 题意 给定 \(n\) 个方块，第 \(i\) 个方块的宽度为 \(1\)，长度为 \(\lceil \frac{i}{2} \rceil\)。选取一些方块横向拼接成一个正方形，输出正方形的最大边长。 思路 显然，当 \(n\) 为奇数的时候，我们一定能将所有方块都用上，拼成一个长为 \(\frac{n + 1}{2}\) 的正方形；当 \(n\) 为偶数的时候，一个大方块将会多出来，而剩余的方块按照奇数的情况处理即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; signed main()&#123; ios::sync_with_stdio(false); int t, n; cin >> t; while(t --)&#123; cin >> n; cout &lt;&lt; n / 2 + n % 2 &lt;&lt; '\n'; &#125; &#125; 猜测即可 B. Diverse Substrings 题意 给定一串数字 \(a\)，\(a_i \in [0, 9]\)，对于所有连续子串，输出满足下面条件的个数： 对于子串中出现次数最多的数字的次数 \(maxx\) 以及不同数字的种数 \(dif\)，满足 \(maxx \leq dif\)。 思路 考虑到满足条件的子串长度最多只有 \(10 \times 10\)，我们直接暴力枚举即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 20, inf = 0x3f3f3f3f, mod = 998244353; int cnt[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int ans = 0; for(int i=0;i&lt;n;i++)&#123; memset(cnt, 0, sizeof cnt); int dif = 0, maxx = 0; for(int j=i;j&lt;n&amp;&amp;j-i&lt;100;j++)&#123; if(cnt[s[j] - '0'] == 0) dif ++; cnt[s[j] - '0'] ++; maxx = max(maxx, cnt[s[j] - '0']); if(maxx &lt;= dif) ans ++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; return 0; &#125; 太暴力了，虽然双指针确实不可行 C. Zero-Sum Prefixes 题意 给定数组 \(a\)，定义操作为将任意一个值为 \(0\) 的点替换成任意值，输出操作后所有前缀和中值为 \(0\) 的个数。 思路 考虑到修改一个元素，会影响到后面的元素的前缀和值，所以我们不妨直接从后面开始遍历。我们不妨从后往前找 \(0\)，当然，在找的过程中，记录 \(0\) 后面的元素的前缀和的值的出现次数，然后，我们只需把 \(0\) 改成出现次数最多的前缀和的值的相反数即可，该情况下答案加上最多的出现次数，这样不会影响到前面的答案，并且可以让后面前缀和为 \(0\) 的数尽可能多。 时间复杂度：\(O(n)?\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f, mod = 998244353; int a[N], sum[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; sum[0] = 0; for(int i=1;i&lt;=n;i++) &#123; cin >> a[i]; sum[i] = sum[i - 1] + a[i]; &#125; int ans = 0; map&lt;int, int> mp; for(int i=n;i>=1;i--)&#123; mp[sum[i]] ++; if(a[i] == 0)&#123; int maxx = 0; for(auto &amp;e : mp) maxx = max(maxx, e.second); ans += maxx; mp.clear(); &#125; &#125; cout &lt;&lt; ans + mp[0]&lt;&lt; '\n'; &#125; return 0; &#125; 有点小贪心]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 834 Div. 3</title>
    <url>/blog/posts/3651755215/</url>
    <content><![CDATA[Practice. A. Yes-Yes? 题意 给定一个字符串，判断其是否是 \(YESYESYES...\) 的连续子串。 思路 判断多出的前缀是否满足条件，若满足条件，以 \(3\) 个字符为一组匹配 \(YES\)。剩余的后缀特判即可。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; string s; cin >> s; n = (int) s.size(); int i = 0; if(s[i] != 'Y')&#123; if(s[i] == 'e' &amp;&amp; (n == 1 || s[i + 1] == 's')) i = 2; else if(s[i] == 's') i = 1; else i = -1; &#125; if(i != -1) for(;i&lt;n;i+=3)&#123; if(s[i] == 'Y' &amp;&amp; (i + 1 >= n || s[i + 1] == 'e') &amp;&amp; (i +2 >= n || s[i + 2] == 's')) continue; i = -1; break; &#125; cout &lt;&lt; (i == -1 ? "NO\n" : "YES\n"); &#125; return 0; &#125; 读题即可 B. Lost Permutation 题意 给定一个丢失了部分元素的排列，丢失的元素的总和为 \(s\)，输出是否能补全该排列。 思路 模拟即可。 我们遍历一遍，找出当前最大值之前的空位，去掉这些空位后，若 \(s\) 还有剩余，那么继续从最大值 \(+1\) 往下遍历，若能将 \(s\) 恰好减为 \(0\)，输出 \(YES\)。 时间复杂度：\(O(n)?\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; bool a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n, s; cin >> n >> s; memset(a, 0, sizeof a); int maxx = -1; for(int i=0;i&lt;n;i++)&#123; int cur; cin >> cur; a[cur] = true; maxx = max(maxx, cur); &#125; int tot = 0; for(int i=1;i&lt;=maxx;i++) if(!a[i]) tot += i; if(tot > s) cout &lt;&lt; "NO\n"; else&#123; int i = maxx + 1; while(tot &lt; s)&#123; tot += i ++; &#125; cout &lt;&lt; (tot == s ? "YES\n" : "NO\n"); &#125; &#125; return 0; &#125; 模拟就完事了 C. Thermostat 题意 给定一段区间 \([l, r]\)，区间内有两个点 \(a, b\)，定义一次操作为将当前位置加上或减去 \(p\)，\(p \geq x\)，操作后的数需要落在区间内。输出从 \(a\) 运动到 \(b\) 需要的最少操作数。 思路 显然，最多只需进行 \(3\) 次操作。 考虑到对称性，我们不妨来考虑 \(l \leq a \leq b \leq r\) 的情况，分类讨论一下： 无需操作，此时 \(a = b\)； 操作一次，此时应满足 \(b - a \geq x\)； 操作两次，此时我们可以向两端移动，只需任意一个满足即可。若向 \(l\) 移动，那么向下移动需要满足 \(a - l \geq x\)，考虑到步数只需大于等于 \(x\)，我们可以直接移动到 \(l\)，然后移动到 \(b\)。因为 \(l\) 到 \(b\) 的距离大于 \(l\) 到 \(a\) 的距离，那么我们无需多考虑。而向 \(r\) 移动时，在满足 \(r - a \geq x\) 的前提下，还需满足能运动到 \(b\)，即 \(r - a \geq x + \min(b - a, x)\)。 操作三次，相类似地，我们可以得到下面的式子：向 \(r\) 移动，\(r - a \geq x\) 、\(b - l \geq x\)；向 \(l\) 移动，\(a - l \geq x\)，\(r - b \geq x\)。 时间复杂度：\(O(1)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a, b, l, r, x; cin >> l >> r >> x >> a >> b; if(a == b) cout &lt;&lt; 0 &lt;&lt; '\n'; else if(abs(b - a) >= x) cout &lt;&lt; 1 &lt;&lt; '\n'; else if(a &lt; b)&#123; int ans1 = inf, ans2 = inf; if(a - l >= x || r - a >= x + min(b - a, x)) ans1 = 2; if((r - a >= x &amp;&amp; b - l >= x) || (a - l >= x &amp;&amp; r - b >= x)) ans2 = 3; cout &lt;&lt; (min(ans1, ans2) == inf ? -1 : min(ans1, ans2)) &lt;&lt; '\n'; &#125;else&#123; int ans1 = inf, ans2 = inf; if(r - a >= x || a - l >= x + min(a - b, x)) ans1 = 2; if((a - l >= x &amp;&amp; r - b >= x) || (r - a >= x &amp;&amp; b - l >= x)) ans2 = 3; cout &lt;&lt; (min(ans1, ans2) == inf ? -1 : min(ans1, ans2)) &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 讨论死我了 D. Make It Round 题意 给定两个整数 \(n, m\)，找出 \(k \in [1, m]\)，使 \(n \times k\) 连续后缀 \(0\) 的个数最多。若有多解，输出最大的；若无解，输出 \(n \times m\)。 思路 考虑到 \(10\) 的质因子为 \(2, 5\)，我们不妨将 \(n\) 后面连续的 \(0\) 都去掉，然后统计 \(n\) 中因数 \(2, 5\) 的个数，并尽量在答案中用对应的 \(5, 2\) 与之配对，然后在答案最后尽可能拼上 \(0\)。最后得到的答案即为 \(0\) 个数最多的，因为存在多解，我们将答案乘上 \(m / ans\)。 时间复杂度：不会分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long signed main()&#123; ios::sync_with_stdio(false); int t, n, m; cin >> t; while(t --)&#123; cin >> n >> m; int ans = 1, p = n; while(p % 10 == 0) p /= 10; while(p % 2 == 0 &amp;&amp; ans * 5 &lt;= m)&#123; p /= 2; ans *= 5; &#125; while(p % 5 == 0 &amp;&amp; ans * 2 &lt;= m)&#123; p /= 5; ans *= 2; &#125; while(ans * 10 &lt;= m) ans *= 10; cout &lt;&lt; m / ans * n * ans &lt;&lt; '\n'; &#125; &#125; 配对配对，贪一下嘛~ E. The Humanoid 题意 给定 \(n\) 个人，每个人有能力值 \(a_i\)。对于一个初始攻击力为 \(h\) 的怪物，它可以干掉所有 \(a_i &lt; h\) 的人，并将自己的攻击力提高 \(\lceil \frac{a_i}{2} \rceil\)。怪物有两个道具，道具一总数为 \(2\)，可以将攻击力翻倍；道具二总数为 \(1\)，可以将攻击力变为原来的三倍。道具使用后消失。输出怪物可以干掉的最多人数。 思路 显然，若想让后续能倍乘的基数变得更大，我们就可以贪心地按能力值升序排序人，这样在需要道具的时候，就能获得尽可能多的攻击力。 然而，使用哪个道具是不确定的，虽然 \(3\) 翻的倍数最多，但放在前面还是后面是不确定的。 考虑到道具只有 \(3\) 个，我们不妨枚举道具使用的顺序，然后用递归解决即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; int a[N], n; int cal(int b, int i, int use, int h)&#123; if(i == n) return 0; if(a[i] &lt; h) return cal(b, i + 1, use, h + a[i] / 2) + 1; else&#123; if(use == 3) return 0; return cal(b, i, use + 1, h * (b == use ? 3 : 2)); &#125; &#125; signed main()&#123; ios::sync_with_stdio(false); int t, h; cin >> t; while(t --)&#123; cin >> n >> h; for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a, a + n); int ans = 0; for(int i=0;i&lt;3;i++) ans = max(ans, cal(i, 0, 0, h)); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 一开始错在道具的使用顺序上了，不可以贪心地使用当前能用的最小的翻倍数]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 835 Div. 4</title>
    <url>/blog/posts/3787113180/</url>
    <content><![CDATA[Practice A. Medium Number 题意 给定三个数，输出中位数。 思路 排序，输出中间的。 时间复杂度：\(O(1)\) (确信) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a[3]; for(int i=0;i&lt;3;i++) cin >> a[i]; sort(a, a + 3); cout &lt;&lt; a[1] &lt;&lt; '\n'; &#125; return 0; &#125; 过于打卡 B. Atilla's Favorite Problem 题意 给定一个字符串，输出最大字母在字母表的位置。 思路 如题，暴力模拟 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; string s; cin >> s; int r = 0; for(char e : s)&#123; r = max(r, (int) (e - 'a')); &#125; cout &lt;&lt; r + 1 &lt;&lt; '\n'; &#125; return 0; &#125; 为啥不直接学一段区间内的呢（划掉 C. Advantage 题意 给定一个数组 \(a\)，对于所有 \(a_i\)，输出其与除它之外的元素中的最大值的差值。 思路 如题，暴力模拟。 可以找出整个数组中的最大值和次大值，然后遍历到最大值时输出其与次大值的差即可，其余直接减去最大值。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int maxx = 0, smax = 0; for(int i=0;i&lt;n;i++)&#123; cin >> a[i]; if(a[i] >= maxx)&#123; smax = maxx; maxx = a[i]; &#125;else if(a[i] >= smax) smax = a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i] == maxx) cout &lt;&lt; a[i] - smax &lt;&lt; ' '; else cout &lt;&lt; a[i] - maxx &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; return 0; &#125; 差点没读懂题（ D. Challenging Valleys 题意 给定一个数组 \(a\)，输出是否只有一组满足下面条件的 \(l, r\)： \(0 \le l \le r \le n-1\) \(a_l = a_{l+1} = a_{l+2} = \dots = a_r\) \(l = 0\) 或 \(a_{l-1} &gt; a_{l}\) \(r = n - 1\) 或 \(a_r &lt; a_{r+1}\) 思路 我们可以遍历整个数组，找出所有拐点，并记录其与其之后的单调性。 之后，我们可以遍历整个拐点数组，找出所有 “递减，递增” 和 “递减，不变，递增” 段，统计数量。 特别地，考虑到条件 \(3, 4\) 的特殊性，我们还需找出下面的情况： 整个数组单调 第一段单调区间值不变，第二段单调区间单调递增 最后一段单调区间值不变，倒数第二段单调区间单调递减 统计数量，判断数量是否为 \(1\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int pre; cin >> pre; if(n == 1) &#123; cout &lt;&lt; "YES\n"; continue; &#125; vector&lt;int> trend; int inc = -1, cnt = 0; for(int i=1;i&lt;n;i++)&#123; int cur; cin >> cur; if(pre &lt; cur &amp;&amp; inc != 1) &#123; inc = 1; trend.emplace_back(inc), cnt ++; &#125;else if(pre == cur &amp;&amp; inc != 2)&#123; inc = 2; trend.emplace_back(inc), cnt ++; &#125;else if(pre > cur &amp;&amp; inc != 0)&#123; inc = 0; trend.emplace_back(inc), cnt ++; &#125; pre = cur; &#125; if(cnt == 1)&#123; cout &lt;&lt; "YES\n"; &#125; else &#123; int ans = 0; if ((trend[0] == 2 &amp;&amp; trend[1] == 1) || trend[0] == 1) ans++; if ((trend[cnt - 1] == 2 &amp;&amp; trend[cnt - 2] == 0) || trend[cnt - 1] == 0) ans++; for (int i = 0; i &lt; cnt; i++) &#123; if (trend[i] == 0) &#123; if(i + 1 &lt; cnt &amp;&amp; trend[i + 1] == 1) ans ++; if(i + 2 &lt; cnt &amp;&amp; trend[i + 1] == 2 &amp;&amp; trend[i + 2] == 1) ans ++; &#125; &#125; cout &lt;&lt; (ans == 1 ? "YES\n" : "NO\n"); &#125; &#125; return 0; &#125; 无脑模拟题，纯纯费时间 E. Binary Inversions 题意 给定一个二进制数组，定义操作为将任意元素 \(x\) 改为 \(1 - x\)，在操作最多只能执行一次的情况下，输出逆序对个数的最大值。 思路 显然，我们可以贪心地认为，我们只需找出最后一个 \(1\) 和第一个 \(0\)，判断不执行操作以及只对这两个元素执行操作后的结果的最大值。 对于找逆序对，我们可以维护一个前缀 \(1\) 个数的数组 \(pre\) 和后缀 \(0\) 个数的数组 \(suf\)，然后遍历所有的 \(0\)，统计 \(1\) 个数即可。 对于最后一个 \(1\) 的替换，价值为其前面 \(1\) 的个数，代价为后面 \(0\) 的个数。对第一个 \(0\) 的替换同理。 当然，需要特判整个数组只有一种元素的情况，根据上面的逻辑，输出 \(n - 1\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N], pre[N], suf[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; pre[0] = 0; //前面的1 suf[n + 1] = 0; //后面的0 int one = -1, zero = -1; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; pre[i] = pre[i - 1]; if(a[i] == 1) &#123; pre[i] ++; one = i; &#125;else if(zero == -1) zero = i; &#125; int ans = 0; for(int i=n;i>=1;i--)&#123; suf[i] = suf[i + 1]; if(a[i] == 0) &#123; suf[i] ++; ans += pre[i]; &#125; &#125; if(one == -1 || zero == -1) cout &lt;&lt; n - 1 &lt;&lt; '\n'; else &#123; int d1 = suf[zero] - 1 - pre[zero], d0 = pre[one] - 1 - suf[one]; cout &lt;&lt; max(ans, ans + max(d1, d0)) &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 依然是模拟（ F. Quests 题意 给定 \(n\) 个操作，操作 \(i\) 可以获得 \(a_i\) 个硬币，每隔 \(k\) 时间可以进行一次重复的操作。给定硬币的需求 \(c\) 和限定的时间 \(d\)，输出在限定时间内满足硬币需求的最大 \(k\)。 若不存在该 \(k\)，输出 \(impossible\)；若 \(k\) 无穷大，输出 \(infinity\)。 思路 考虑到 \(k\) 越大，能在 \(d\) 天内获得的硬币数量会减小，存在单调性，因而我们不妨考虑二分答案。 我们可以贪心地认为，我们只需每隔 \(k\) 输出降序排序后的前 \(k\) 个数，因为一次性能获得的硬币更多，我们能间隔的时间就越长。 所以，我们只需 \(check\) 一下按上述操作获得的 \(d\) 天内的硬币数，进行二分即可。 当然，若最后的答案落在左边界，输出 \(impossible\)，落在右边界输出 \(infinity\)。 时间复杂度：\(O(n \log n + t \log n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n, c, d; cin >> n >> c >> d; for(int i=0;i&lt;n;i++) cin >> a[i]; sort(a, a + n, greater&lt;>()); int l = 0, r = d + 2, mid; while(l &lt;= r)&#123; mid = (l + r + 1) >> 1; if(mid == 0) break; int tot = 0; for(int i=0;i&lt;d;i++) if(i % mid &lt; n) tot += a[i % mid]; if(tot >= c) l = mid + 1; else r = mid - 1; &#125; if(r == d + 2) cout &lt;&lt; "Infinity\n"; else if(l == 0) cout &lt;&lt; "Impossible\n"; else cout &lt;&lt; r - 1 &lt;&lt; '\n'; &#125; return 0; &#125; 二分一下就好简单（（ G. SlavicG's Favorite Problem 题意 给定一个带权值的无向无环图，给定两个点 \(a, b\)，定义 \(x = 0\)，从 \(a\) 开始向子节点走，到达节点 \(i\) 就会将 \(x\) 修改为 \(x\ XOR\ {w_i}\) 。在任意节点，可以选择传送到除 \(b\) 外的任意节点，并继续走。输出是否存在一种路径，使到达 \(b\) 后 \(x = 0\)。 思路 考虑到异或的性质，我们不妨跑两遍 \(Dfs\)，用回溯搜索即可，每次搜索的起始 \(x\) 值均为 \(0\)。 第一次搜索，我们从 \(a\) 节点开始走，计算所有 \(x\) 的可能值，用 \(map\) 记录下来； 第二次搜索，我们从 \(b\) 节点开始走，判断当前的 \(x\) 和 \(0\) 异或的值是否被记录过，若被记录过，那么我们一定可以用传送的方式使这两条路径联通，且最后答案符合要求。 当然，我们可以用邻接表存边。 时间复杂度：不会分析 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 2e5 + 10, inf = 0x3f3f3f3f; struct Node&#123; int to, w; &#125;; vector&lt;Node> e[N]; bool vis[N], ans; map&lt;int, bool> mp; int n, a, b; void add(int u, int v, int w)&#123; e[u].push_back(&#123;v, w&#125;); e[v].push_back(&#123;u, w&#125;); &#125; void dfs1(int r, int v)&#123; if(vis[r] || r == b) return; vis[r] = true; mp[v] = true; for(auto x : e[r])&#123; dfs1(x.to, v ^ x.w); &#125; vis[r] = false; &#125; void dfs2(int r, int v)&#123; if(vis[r]) return; vis[r] = true; if(r != b &amp;&amp; mp[v ^ 0])&#123; ans = true; return; &#125; for(auto a : e[r])&#123; dfs2(a.to, v ^ a.w); &#125; vis[r] = false; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; cin >> n >> a >> b; for(int i=1;i&lt;=n;i++) e[i].clear(), vis[i] = false; for(int i=1;i&lt;n;i++)&#123; int u, v, w; cin >> u >> v >> w; add(u, v, w); &#125; mp.clear(); dfs1(a, 0); ans = false; dfs2(b, 0); cout &lt;&lt; (ans ? "YES\n" : "NO\n"); &#125; return 0; &#125; 简简单单的思维 + dfs]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 836 Div. 2</title>
    <url>/blog/posts/959544692/</url>
    <content><![CDATA[Practice. A. SSeeeeiinngg DDoouubbllee 题意 给定一个字符串，将字符串复制一遍后拼接在一起得到一个新的字符串，将该字符串重新组合，输出一种回文组合。 思路 倒着拼到末尾。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; String s = scanner.next(); System.out.println(s + new StringBuilder(s).reverse()); &#125; &#125; &#125; 过于无脑 B. XOR = Average 题意 给定一个整数 \(n\)，构造一个长度为 \(n\) 的无重复元素的数组 \(a\)，满足 \(1 \leq a \leq 10 ^ 9\) 以及所有数的异或值等于平均值，即 \(a_1 \oplus a_2 \oplus \dots \oplus a_n = \frac{a_1 + a_2 + \dots + a_n}{n}\)。 输出数组的任意一种构造。 思路 我们来考虑奇偶性： \(n\) 为奇数时，我们只需输出 \(n\) 个 \(1\)，此时恰好满足条件； \(n\) 为偶数时，考虑到 \(1, 3\) 的平均数为 \(2\)，异或值也为 \(2\)，而偶数个相同数的异或值为 \(0\)，所以我们不妨输出 \(1,3\)，以及 \(n - 2\) 个 \(2\)，即可满足条件。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); if(n % 2 == 1)&#123; for(int i=0;i&lt;n;i++) System.out.print("1 "); System.out.println(); &#125;else&#123; System.out.print("1 3 "); for(int i=0;i&lt;n-2;i++) System.out.print("2 "); System.out.println(); &#125; &#125; &#125; &#125; 小的就足矣 C. Almost All Multiples 题意 给定整数 \(n, x\)，构建一个字典序最小的排列 \(p\)，满足下面的条件： \(p_1 = x, p_n = 1\)； \(p_i \% i = 0\)。 思路 显然，若不考虑条件，那么我们肯定会输出一个递增的排列。 当我们考虑条件后，我们不难发现 \(n\) 多余了，而 \(x\) 所在的原位置留空了。 但是，我们不可以直接将 \(x\) 的位置放上 \(n\)，因为我们需要考虑下面的两个条件： \(p_x = n \rightarrow n \% x\)； 字典序最小 对于条件 \(1\)，若不满足，输出 \(NO\) 即可。 对于条件 \(2\)，我们不难发现，当 \(n\) 的因数比较多的时候，满足 \(n \% kx\) 的 \(k\) 可以有好多个，此时若 \(x\) 位置放上 \(n\)，所得到的字典序不一定是最小的。 我们来举一个例子： 1 12 2 此时，字典序最小的应为下述输出： 2 4 3 12 5 6 7 8 9 10 11 1 因此，我们不妨循环操作，对于 \(x\)，找出第一个满足 \(n \% kx, k \geq 2\) 的 \(k\)，将 \(p_i\) 修改为 \(kx\)、\(x\) 的值替换为 \(kx\) ，然后继续循环，直到 \(x \geq x\)。 时间复杂度：不知道 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n, x; cin >> n >> x; if(n % x != 0) cout &lt;&lt; -1 &lt;&lt; '\n'; else&#123; vector&lt;int> ans(n); for(int i=1;i&lt;n-1;i++) ans[i] = i + 1; ans[n - 1] = 1; ans[0] = x; while(x &lt; n)&#123; for(int i=x*2;i&lt;=n;i+=x) &#123; if(n % i == 0)&#123; ans[x - 1] = i; x = i; break; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 一开始还真想着去直接交换了（ D. Range = √Sum 题意 给定一个整数 \(n\)，构建一个无重复元素的数组 \(a\)，满足 \(1 \leq a_i \leq 10 ^ 9\)，以及下面的式子： \(\max(a_1, a_2, \dots, a_n) - \min(a_1, a_2, \dots, a_n)= \sqrt{a_1 + a_2 + \dots + a_n}\)。 思路 我们来讨论 \(n\) 的奇偶性： 当 \(n\) 为偶数的时候，我们只需构建一个 \([n / 2, n / 2 + 1, \ldots, n - 1, n + 1, n + 2, \ldots, 3n / 2]\) 即可。 当 \(n\) 为奇数的时候，我们按照上述逻辑构建一个中间值为 \(n\)，向两端递减 \(1\) 的数组，此时，左边为 \(n\)，右边为 \(\sqrt {n (n + 1)}\)。 那么，我们希望构建一个数组，满足左右两边均为 \(n + 1\)。 我们执行下面的操作： ① 整个数组 \(+1\)； ② 左边界 \(-1\)，右边界 \(+1\)； ③ 倒数第二个数 \(+1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; if(n % 2 == 0) &#123; for(int i=n/2;i&lt;=n-1;i++) cout &lt;&lt; i &lt;&lt; ' '; for(int i=n+1;i&lt;=3*n/2;i++) cout &lt;&lt; i &lt;&lt; ' '; &#125; else &#123; vector&lt;int> ans(n); iota(ans.begin(), ans.end(), (n + 5) / 2); ans[0]--; ans[n - 1]++; ans[n - 2]++; for (int i = 0; i &lt; n; i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; return 0; &#125; 好一个思维 + 构造]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Polynomial Round 2022 Div. 1 + 2</title>
    <url>/blog/posts/266401019/</url>
    <content><![CDATA[Practice. 代码略去了快读模板 A. Add Plus Minus Sign 题意 给定一个长度为 \(n\) 的二进制字符串，输出 \(n-1\) 个加减运算符，满足最后的结果的绝对值最小。 思路 无视第一位，配对 \(1,1\)，对每一对输出 \(-,+\)，剩余的 \(1\) 输出 \(-\)，剩余的 \(0\) 输出任意符号。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; int n = console.nextInt(); char[] input = console.next().toCharArray(); int pre = -1, now = input[0] - '0'; char[] ans = new char[n - 1]; if(now == 1) pre = -2; for(int i=0;i&lt;n-1;i++)&#123; now = input[i + 1] - '0'; if(now == 0) ans[i] = '+'; else&#123; if(pre == -1) pre = i; else&#123; if(pre != -2) ans[pre] = '+'; ans[i] = '-'; pre = -1; &#125; &#125; &#125; if(pre != -1 &amp;&amp; pre != -2) ans[pre] = '+'; console.println(String.valueOf(ans)); &#125; console.close(); &#125; &#125; 略微简单的打卡题 B. Coloring 题意 给定 \(m\) 种颜色的数量，总量为 \(n\)，将长度为 \(n\) 的序列染上色，满足所有长度为 \(k\) 的连续子序列内没有相同的颜色，输出方案是否存在。 思路 我们不妨开一个数组记录所有的数量，然后降序排序。 显然，若一个颜色 \(p\) 在 \(x\) 位置出现了，那么在 \([x + 1, x + k - 1]\) 内都不能出现 \(p\)，那么我们不妨将序列按 \(k\) 分段，那么段数即为 \(d = \lceil \frac{n}{k} \rceil\)。 遍历排序后的数组，若 \(a_i &gt; d\)，那么就是无解的，输出 \(NO\) 即可，否则，我们只需将剩余的最少的颜色取出来和它一起配对为一个长为 \(d\) 的组合。 当然，配对次数过多时，我们会发现段数会减少 \(1\)，此时若能满足条件，就可以直接输出 \(YES\) 了。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; int n = console.nextInt(), m = console.nextInt(), k = console.nextInt(); Integer[] a = new Integer[m]; for(int i=0;i&lt;m;i++) a[i] = console.nextInt(); Arrays.sort(a, Comparator.comparingInt(o -> -o)); int d = n / k + (n % k == 0 ? 0 : 1), l = n % k; boolean ans = true; for(int i=0;i&lt;n;i++)&#123; int cur = a[i]; if(cur > d) &#123; ans = false; break; &#125; if(l == 0) break; l --; if(l == 0) d --; &#125; console.println(ans ? "YES" : "NO"); &#125; console.close(); &#125; &#125; 有点小贪心，因为不用考虑拿什么出来组合 C. Ice and Fire 题意 对于 \(n\) 个选手，选手 \(i\) 的能力值为 \(i\)。给定一个长为 \(n - 1\) 的二进制字符串 \(s\)，\(s_i\) 表示第 \(i\) 次比赛的输赢判定，\(0\) 则能力值低者胜，否则高者胜。对于所有 \(x \in [2,n]\)，输出选择不超过 \(x\) 个选手进行比赛，最后有多少个选手有机会成为胜者。 比赛机制为选择任意两个选手进行比赛，直至剩余最后一人，判定该选手为胜者。 思路 显然地，最后的获胜情况和最后一个输赢判定有直接关系。 更进一步地说，最后一段相同连续区间的长度决定了胜者的数量。 举一个例子，若 \(s\) 为 \(\ldots,1,0,0,0,0\)，那么能力值最大的三个选手一定不可能成为赢家，而恰好剩余的选手经过一定的排序都可以成为赢家。 因而，我们唯一关心的就是从后往前第一个不同的字符出现的位置，对于所有 \(x\)，输出数量即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); while(t -- > 0)&#123; int n = console.nextInt(); char[] in = console.next().toCharArray(); int p0 = 1, p1 = 1; for(int i=1;i&lt;n;i++)&#123; int now = in[i - 1] - '0'; if(now == 0)&#123; p0 = i + 1; console.print(p1 + " "); &#125;else&#123; p1 = i + 1; console.print(p0 + " "); &#125; &#125; console.println(); &#125; console.close(); &#125; &#125; 想通了就很简单的思维题]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 139</title>
    <url>/blog/posts/1807504053/</url>
    <content><![CDATA[Practice. A. Extremely Round 题意 给定一个整数 \(n\)，输出 \([1,n]\) 内只有一位非 \(0\) 的数的个数。 思路 显然，对于 \(t\) 位，有 \(9\) 个满足要求的数，我们只需考虑到何时停下枚举即可。 时间复杂度：\(O(\log_{10} n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int a = n, tot = 0; while(a >= 10) a /= 10, tot ++; cout &lt;&lt; tot * 9 + a &lt;&lt; '\n'; &#125; return 0; &#125; 简单打卡题 B. Notepad# 题意 给定一个长为 \(n\) 且由小写字母构成的字符串，输出是否存在两段及以上长度大于等于 \(2\) 的相同连续子序列。 思路 我们不妨只寻找长为 \(2\) 的重复子串，也就是说我们只需记录 \(n - 1\) 对子序列的情况。我们可以边记录边向后遍历，并判断当前字母以及前一个字母是否在之前被记录过，若记录过则输出存在即可。 此处我们需要排除如下情况：\(hhh\)，此处不满足题意但会被误判为 \(YES\)，因而我们可以记录该子串在当前状态之前最近被统计的位置，然后判断位置是否和当前位置出现了交集即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 30; int a[N][N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; string cur; cin >> cur; cur = ' ' + cur; memset(a, 0, sizeof a); bool ok = false; for(int i=1;i&lt;n;i++)&#123; int o1 = cur[i] - 'a', o2 = cur[i + 1] - 'a'; if(a[o1][o2] != 0 &amp;&amp; a[o1][o2] != i - 1) &#123; ok = true; break; &#125; if(a[o1][o2] == 0) a[o1][o2] = i; &#125; cout &lt;&lt; (ok ? "YES" : "NO") &lt;&lt; '\n'; &#125; return 0; &#125; WA了好几遍捏 C. Hamiltonian Wall 题意 给定一个长为 \(n\)，宽为 \(2\) 的矩阵，矩阵元素为 \(B\) 或 \(W\)，输出是否可以从最左边列的某个元素 \(B\) 开始一笔画，在不重复经过同一个元素以及不经过元素 \(W\) 的前提下连接所有元素 \(B\)。不可以沿对角线连接。 思路 我们可以直接模拟，判断前者的入口在何处，若出现冲突就直接输出 \(NO\)。 具体按照下面的方法模拟： 找出第一个不是 \(BB\) 的列； 将入口更新为 \(B\) 出现的位置； 若相邻出现 \(WB,BW\) 或 \(BW,WB\)，输出 \(NO\); 若出现多个 \(BB\)，根据奇偶性判断之后的入口； 遇到 \(WW\) 直接输出 \(NO\)。 无冲突输出 \(YES\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10; bool a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; char c; cin >> t; while(t --)&#123; cin >> n; for(int i=0;i&lt;n;i++)&#123; cin >> c; a[i] = c == 'B'; &#125; bool f = false, ans = true; int pre; cin >> c; if(a[0] &amp;&amp; c == 'B') pre = 2, f = true; else if(a[0]) pre = 0; else if(c == 'B') pre = 1; else pre = -1; for(int i=1;i&lt;n;i++)&#123; cin >> c; if(!ans) continue; int now; if(a[i] &amp;&amp; c == 'B') now = 2; else if(a[i]) now = 0; else if(c == 'B') now = 1; else now = -1; if(f &amp;&amp; now == 2) continue; f = false; if((pre == -1 &amp;&amp; now != -1) || (pre == 0 &amp;&amp; now == 1) || (pre == 1 &amp;&amp; now == 0))&#123; ans = false; continue; &#125; if(now == 2) now = 1 - pre; pre = now; &#125; cout &lt;&lt; (ans ? "YES" : "NO") &lt;&lt; '\n'; &#125; return 0; &#125; 太模拟了，不过貌似一笔画不止可以暴力模拟（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 852 Div. 2</title>
    <url>/blog/posts/185684192/</url>
    <content><![CDATA[Contestant(alt). Rank 6738. Rating -86 (+414 -500). A. Yet Another Promotion 题意 定义两天内提供购物服务，每天的货物价格分别为 \(a, b\)，在第一天存在促销活动，购买 \(m\) 个货物后会赠送一个。输出购买 \(n\) 个货物的最少花费。 思路 对于 \(m+1\) 个所需货物，$m a $ 和 \((m + 1) \times b\) 分别为第一天和第二天的价格，那么我们只需分类讨论即可： 前者小，那么我们将能参与促销的货物全都在第一天购买，也就是总共有 \(\lfloor \frac{n}{m + 1} \rfloor \times m\) 个货物是参与了促销。此时，我们得到了 \(\lfloor \frac{n}{m + 1} \rfloor \times (m + 1)\) 个货物，那么剩余的货物就作为正常购买，我们用 \(\min(a,b)\) 购买即可； 后者小，直接全都在第二天买即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int a, b, n, m; cin >> a >> b >> n >> m; cout &lt;&lt; min(n * b, (n / (m + 1)) * m * a + (n - (n / (m + 1)) * (m + 1)) * min(a, b)) &lt;&lt; '\n'; &#125; return 0; &#125; 一个大铸币没看懂题卡了半天 B. Fedya and Array 题意 给出如下定义： 若一个元素的相邻元素都比它大，那么定义其为 local minimum；若一个元素的相邻元素都比它小，那么定义其为 local maximum。 给定一个首尾相连的序列中 local maximum 的总和和 local minimum 的总和 \(x, y\)，构建该序列，满足相邻数相差 \(1\)，且长度最短。 思路 显然，\(y, y-1, \ldots , x , x + 1 , \ldots, y - 1\) 一定是一个符合条件的序列，下面我们来证明一下可行性： 若 \(a_i\) 和 \(b_i\) 为相邻的 local maximum 和 local minimum ，那么对于 \(a_i\)，想要得到 \(b_i\)，就必须得有 \(a_i - b_i\) 个数字，因而我们可以得到下面的式子： \(len = (a_1 - b_1) + (a_2 - b_1) + (a_2 - b_2) + \ldots + (a_k - b_k) + (a_1 - b_k)\) 化简即可得到 \(2(x - y)\)，证毕。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(0); int t, x, y; cin >> t; while(t --)&#123; cin >> x >> y; vector&lt;int> ans; for(int i=x;i>y;i--) ans.emplace_back(i); for(int i=y;i&lt;x;i++) ans.emplace_back(i); cout &lt;&lt; ans.size() &lt;&lt; '\n'; for(auto &amp;i : ans) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; return 0; &#125; 好妙的做法 C. Dora and Search 题意 给定一个排列，输出一段连续区间的左右端点的下标，满足两个端点既不是区间内的最大值，也不是区间内的最小值。 思路 我们可以用类似双指针的方法，从两侧开始夹逼，只要去除区间外的点后，最大值和最小值都不在端点，那就直接输出。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; #define int long long const int N = 2e5 + 10, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(0); int t, n; cin >> t; while(t --)&#123; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; int l = 0, r = n - 1, vl = 1, vr = n; while(l &lt;= r)&#123; if(a[l] == vl) l ++, vl ++; else if(a[l] == vr) l ++, vr --; else if(a[r] == vl) r --, vl ++; else if(a[r] == vr) r --, vr --; else break; &#125; if(l &lt;= r) cout &lt;&lt; l + 1 &lt;&lt; ' ' &lt;&lt; r + 1 &lt;&lt; '\n'; else cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; return 0; &#125; 不是排列的话就只有找拐点了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 851 Div. 2</title>
    <url>/blog/posts/989416061/</url>
    <content><![CDATA[Contestant. Rank 2650. Rating +7. A. One and Two 题意 给定一个包含 \(1\) 和 \(2\) 的数组，输出最小的 \(k\)，满足 \(a_1 \cdot a_2 \cdot \ldots \cdot a_k = a_{k+1} \cdot a_{k+2} \cdot \ldots \cdot a_n\)。 思路 维护一个后缀和，统计前面和后面的 \(2\) 的个数，输出第一个 \(k\)，满足 \(2\) 的个数一致。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; int a[N], suf[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; memset(a, 0, sizeof a); memset(suf, 0, sizeof suf); for(int i=1;i&lt;=n;i++)cin >> a[i]; for(int i=n;i>=1;i--) &#123; suf[i] = suf[i + 1]; if(a[i] == 2) suf[i] ++; &#125; int tot = 0; bool f = true; for(int i=1;i&lt;n;i++)&#123; if(a[i] == 2) tot ++; if(tot == suf[i + 1])&#123; cout &lt;&lt; i &lt;&lt; '\n'; f = false; break; &#125; &#125; if(f) cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; return 0; &#125; 你一个大铸币是怎么会想着纯模拟的啊（（ B. Sum of Two Numbers 题意 给定一个整数 \(n\)，定义 \(f(x) = x十进制下每位之和\)，输出任意两个数 \(x,y\)，满足 \(x + y = n, |f(x)-f(y)| \leq 1\)。 思路1 我们不妨除以 \(2\)，此时，若 \(n\) 为偶数，直接输出。 若 \(n\) 为奇数，则不可避免会出现十位不相同的情况（进位了）。此时，我们不妨遍历所有 \(i\)，将大的数减 \(5\)，小的数加 \(5\)，那么最后一定可以找到一组满足条件的数。 对上述思路的证明 我们令除 \(2\) 之后较小的数为 \(a\)，较大的数为 \(b\)。 首先，我们只需考虑 \(n\) 的个位为 \(9\) ，且十位为奇数的情况，此时 \(a+1\) 存在向前进位。那么，我们希望能尽量让 \(a\) 的高位总和降低，并让 \(b\) 的高位总和提高。 考虑到个位为 \(9\)，那么我们不妨先让 \(a\) 和 \(b\) 的个位分别变为 \(4\) 和 \(5\)，这样我们只需让高位的所有数之和相等，或者 \(a\) 的高位之和比 \(b\) 的高位之和大 \(1\)。 那么，我们来考虑高位的情况： 若 \(n\) 的十位小于 \(9\)，不难发现，我们只需让 \(a\) 的十位变为 \(b\) 的十位加一，这样可以让 \(a,b\) 的所有位之和相等，也就是说，只要输出 \(a+5,b-5\) 即可； 若 \(n\) 的十位为 \(9\)，那么事态发生了微妙的变化：存在进 \(2\) 位的情况了。但，只要百位不是奇数，我们依然可以按照情况 \(1\) 找出一个答案； 若 \(n\) 的十位为 \(9\)，百位为奇数，且千位不为 \(9\) 时，那么按照上述操作后，\(a+5\) 存在进 \(1\) 位的情况，方案不成立了； 此时，有趣的现象出现了：\(a+5\) 和 \(b-5\) 恰好差了 \(9\)，那么我们不妨把个位改为 \(9, 0\)，此时，我们可以构造出 \(a+10,b-10\)，满足差值为 \(1\)； 当千位、乃至更高位都为 \(9\) 时，差值会更大，但根据打表我们不难发现，\(a+5\) 和 \(b-5\) 的差值均为 \(9\) 的倍数，那么我们只要让高位的差值降低，最后一定能得到解。 时间复杂度：懒得分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; int a[N], suf[N]; int cal(int x)&#123; int res = 0; while(x > 0)&#123; res += x % 10; x /= 10; &#125; return res; &#125; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; int p = n / 2, q = n - p; while(abs(cal(p) - cal(q)) > 1) p += 5, q -= 5; cout &lt;&lt; p &lt;&lt; ' ' &lt;&lt; q &lt;&lt; '\n'; &#125; return 0; &#125; 思路2 按照上述证明的思路，我们可以找出一个规律： 首先，偶数直接输出 \(\frac{n}{2},\frac{n}{2}\)； 其次，个位不是 \(9\)，直接输出 \(\frac{n}{2},n-\frac{n}{2}\)； 否则，从证明思路，我们可以发现，以 \(10\) 为单位枚举从 \(9\) 开始的所有数，需要加减 \(5\) 的次数每隔 \(20,200,2000 \ldots\) 会变为一个特定值，该值我们可以打表找出，记该数组为 \(ans\)。 因此，对于该情况，我们只需从低位向高位枚举，找出第一个不是 \(9\) 的位置 \(cnt\)，以及该位置的数 \(val\)。若 \(val\) 为偶数，那么加减 \(ans[cnt-1] \times 5\)，否则加减 \(ans[cnt] \times 5\)。 时间复杂度：\(O(\log_{10} n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; int ans[10] = &#123;0, 1, 2, 10, 18, 100, 180, 1000, 1800, 10000&#125;; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; if(n % 2 == 0) cout &lt;&lt; n / 2 &lt;&lt; ' ' &lt;&lt; n / 2 &lt;&lt; '\n'; else if(n % 10 != 9) cout &lt;&lt; n / 2 &lt;&lt; ' ' &lt;&lt; n - n /2 &lt;&lt; '\n'; else&#123; int p = n / 2, q = n - p; int cnt = 0; while(n % 10 == 9) n /= 10, cnt ++; int val = n % 10; if(val == 0) val = 9, cnt --; if(val % 2 == 0) cout &lt;&lt; p + ans[cnt - 1] * 5 &lt;&lt; ' ' &lt;&lt; q - ans[cnt - 1] * 5 &lt;&lt; '\n'; else cout &lt;&lt; p + ans[cnt] * 5 &lt;&lt; ' ' &lt;&lt; q - ans[cnt] * 5 &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 我好蠢 C. Matching Numbers 题意 给定一个整数 \(n\)，配对 \(1,2n\) 内的所有数，使 \(n\) 对数的和按照升序排列后单调递增，且相邻数相差 \(1\)。输出一种配对。 思路 我们不难发现，若是偶数的话，我们是找不出这个序列的，可以通过计算验证。 对于奇数的话，我们可以根据等差公式算出中间的值 \(2n+1\)，而对于右边的数，我们不妨将小的数加上 \(2\)，大的数减去 \(1\)，这样就可以满足差值为 \(1\)，那么，如果中间的那对数为 \(1,2n\)，那么刚好右边可以组成 \(\frac{n}{2}\) 对，而剩下的数，我们恰好可以得到两对连续的数字，将小的和大的相加，恰好就是我们想要的。 输出即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 1010; int a[N], suf[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; if(n % 2 == 0) cout &lt;&lt; "No\n"; else&#123; cout &lt;&lt; "YES\n"; for(int i=1;i&lt;=n/2+1;i++)&#123; cout &lt;&lt; i * 2 - 1 &lt;&lt; ' ' &lt;&lt; 2 * n - i + 1 &lt;&lt; '\n'; &#125; for(int i=1;i&lt;=n/2;i++)&#123; cout &lt;&lt; i * 2 &lt;&lt; ' ' &lt;&lt; 2 * n - i - n / 2 &lt;&lt; '\n'; &#125; &#125; &#125; return 0; &#125; md，思路很清晰但wa了一发 D. Moving Dots 题意 给定 \(n\) 个数轴上升序排序的点，所有点在同一时刻以相同的速度向与相邻数差值最小的数的方向移动（若差值相同，向左移动），两点相遇则停止移动。对于所有可不连续的子序列，统计每个子序列最后汇聚的点的个数，并输出总数。 思路 我们将问题转化为：对于所有 \([i,j]\) 内让点汇聚到两个及以上点的区间，排除这个区间内的所有数，剩下的数一定会汇聚到一个点，那么对于每个点，有选与不选两种情况，因此最后输出 \(2^p\)，\(p\) 为剩余的数的数量。 那么，对于这个区间的确定，我们不妨来考虑下面的两种情况： 对于汇聚到左边的点，最左边的点 \(i\) 应该向右边移动，那么我们找出从 \(i\) 开始，往前找第一个向左移动的即可，也就是说，应满足 \(k &lt; x_i, x_i - k \leq x_j - x_i\)。 同理，满足 \(k &gt; x_j,k - x_j &lt; x_j - x_i\)。 综上，\(2x_i - x_j \leq k &lt; 2x_j - x_i\)。 考虑到单调性，我们可以用二分查找。 时间复杂度：\(O(n^2 \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 3010; int x[N], pows[N], mod = 1e9 + 7; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin >> n; pows[0] = 1; for(int i=1;i&lt;=n;i++) &#123; //Awesome but strange solution from the official tutorial. cin >> x[i]; pows[i] = (pows[i - 1] * 2) % mod; &#125; int ans = 0; for(int i=1;i&lt;n;i++) for(int j=i+1;j&lt;=n;j++) &#123; int l = lower_bound(x + 1, x + n + 1, 2 * x[i] - x[j]) - (x + 1), r = lower_bound(x + j + 1, x + n + 1, 2 * x[j] - x[i]) - x; ans = (ans + pows[n - r + l + 1]) % mod; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; return 0; &#125; 妙啊]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 140</title>
    <url>/blog/posts/1562475734/</url>
    <content><![CDATA[Practice. A. Cut the Triangle 题意 给定三个点，判断是否存在水平或数值的切割线，能将三个点所构成的三角形切割成两个三角形。 思路 很显然，我们只需判断是否存在直角三角形即可。 因为我们不知道哪个是直角，所以我们不妨找出所有 \(x\) 轴值相等的点和 \(y\) 轴相等的点。 更具体地说，我们统计一下满足上述条件的点，若为 \(1\) 个及以下，那么就可行，否则不可行。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 110; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int x1, y1, x2, y2, x3, y3; cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3; cout &lt;&lt; ((x1 == x2 || x2 == x3 || x1 == x3) &amp;&amp; (y1 == y2 || y2 == y3 || y1 == y3) ? "NO" : "YES") &lt;&lt; '\n'; &#125; return 0; &#125; 简简单单打卡题 B. Block Towers 题意 给定 \(n\) 个柱子，定义操作为选定两个大小不相等的柱子，并将大的柱子的一个方块移到小的柱子上。在任意次操作后，输出第一个柱子可能的最大方块数量。 思路 我们不妨直接排个序，然后找出第一个柱子的位置，并模拟。 当然，找位置可以用二分。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; int a0 = a[0]; sort(a, a + n); int t = upper_bound(a, a + n, a0) - a; for(int i=t;i&lt;n;i++)&#123; if(a[i] > a0) a0 += (a[i] - a0 + 1) / 2; &#125; cout &lt;&lt; a0 &lt;&lt; '\n'; &#125; return 0; &#125; 好模拟 C. Count Binary Strings 题意 给定一个数字 \(n\)，以及指定的约束，构造一个二进制字符串。 对于 \(n\) 行输入，第 \(i\) 行有 \(n - i + 1\) 个数字。 第 \(i\) 行第 \(j\) 列元素的值表示 \([i+j-1, n]\) 区间内容满足下面的约束： 值为 \(1\)，那么区间内所有元素必须一致； 值为 \(2\)，那么区间内至少存在一个数和其他数不同； 值为 \(0\)，无约束。 输出在上述约束下能构造多少个字符串。 思路 我们不难发现，要构造出不同的字符串，那么该位必须可以选 \(0\) 和 \(1\)。 又或者说，对于点 \(i\)，我们需要知道 \([1,i-1]\) 之间有多少和 \(i\) 不同的值。 考虑到前者的约束会影响后者，我们不妨考虑 \(dp\)。 我们可以枚举所有 \(i\)，与其不同的元素位于 \(j\)（当然，如果没有这个元素，\(j=0\) 即可），那么我们可以找出下面两种情况： 当前位和前一位相同，那么 \(dp[i+1][j]\ += dp[i][j]\)； 当前位和前一位不同，那么 \(dp[i+1][i]\ += dp[i][j]\)。 接下来，我们来考虑约束： 对于约束右区间为 \(i\)： 首先，对于情况 \(1\)，我们不能让 \(j\) 前面的约束存在 \(1\)，也不能让后面的约束存在 \(2\)，这样我们可以判断 \(dp[i][j]\) 是否可行，也可以判断 \(dp[i+1][j]\) 是否成立。 其次，对于情况 \(2\)，我们也不能让 \(i\) 之前的约束存在 \(1\)，否则 \(dp[i+1][i]\) 不成立。 满足上述条件后，对于递推的结果，枚举所有不同的点，右区间为 \(n\)，求和即可。 时间复杂度：\(O(n^3)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 110, mod = 998244353; int a[N][N], dp[N][N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin >> n; for(int i=0;i&lt;n;i++) for(int j=i;j&lt;n;j++) cin >> a[i][j]; if(a[0][0] != 2) dp[1][0] = 2; for(int i=1;i&lt;n;i++) for(int j=0;j&lt;i;j++)&#123; bool f = true; for(int k=0;k&lt;j;k++)&#123; if(a[k][i] == 1) f = false; &#125; for(int k=j;k&lt;=i;k++)&#123; if(a[k][i] == 2) f = false; &#125; if(f) dp[i + 1][j] = ((dp[i + 1][j] % mod) + (dp[i][j] % mod)) % mod; f = a[i][i] != 2; if(f) for(int k=0;k&lt;i;k++)&#123; if(a[k][i] == 1) f = false; &#125; if(f) dp[i + 1][i] = ((dp[i + 1][i] % mod) + (dp[i][j] % mod)) % mod; &#125; int ans = 0; for(int i=0;i&lt;n;i++) ans = (ans % mod + dp[n][i] % mod) % mod; cout &lt;&lt; ans; //好绕 return 0; &#125; 难死了，md D. Playoff 题意 给定一个整数 \(n\)，对于一个任意 \(2^n\) 的排列，存在 \(n\) 场比赛，\(2i\) 和 \(2i+1\) 进行比赛，满足下述比赛规则，获胜者进入下一轮，直到决出最后的胜利者。输出对于任意排列，胜利者会是哪些人。 规则：给定一个长度为 \(n\) 的二进制字符串，第 \(i\) 位决定了第 \(i\) 场比赛的输赢。若值为 \(0\) ，那么数值小的一方获胜，否则数值大的一方获胜。 思路 我们不妨先来找规律： 对于题例数据，我们不难发现，统计一下 \(1\) 的个数 \(x\) 和 \(0\) 的个数 \(y\)，答案即为 \([2^x,2^n-2^y+1]\) 内的所有数。 下面给出证明： 首先，我们不难发现，交换字符串某两位的位置，对最后两端的输赢是无影响的，只会决定最后的赢家； 并且，当值为 \(1\) 的时候，一定是大一点的值获胜，为 \(0\) 时一定时小一点的值获胜。 换句话说，决定了 \(1\) 和 \(0\) 的个数后，升序排序下两端一定范围内的值是一定不会取到的，因为在多场比赛后，一定会被筛去。 而正好相反地，除去这些一定会被筛去的值，剩余值一定有一种排列可以使它们成为赢家，因此证明了结论的正确性。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n; cin >> n; int x = 0, y = 0; for(int i=0;i&lt;n;i++)&#123; char now; cin >> now; if(now == '1') x ++; else y ++; &#125; for(int i=(1 &lt;&lt; x);i&lt;=((1 &lt;&lt; n) - (1 &lt;&lt; y) + 1);i++) cout &lt;&lt; i &lt;&lt; ' '; return 0; &#125; 妥妥一个找规律（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 2022 光棍新生欢乐赛</title>
    <url>/blog/posts/137870688/</url>
    <content><![CDATA[Rank 1. AC 4/9. 因为11.11为四根棍，所以注定只能写四题 A. 乘方 CSP 2022 T1 题意 比较 \(a ^ b\) 和 \(10 ^ 9\) 的大小关系。 思路1 try-catch 用大数算法直接算，如果算得出来，那就比较；算不出来，也就是溢出了，那么一定是大于 \(1e9\) 的，利用语言特性，捕获这个异常然后输出 \(-1\) 即可。 对应AC代码 import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); try&#123; BigInteger a = new BigInteger(scanner.next()); int b = scanner.nextInt(); BigInteger ans = a.pow(b); if(ans.compareTo(BigInteger.valueOf(1000000000L)) > 0) System.out.println(-1); else System.out.println(ans); &#125;catch(Throwable e)&#123; System.out.println(-1); //投机取巧.jpg &#125; &#125; &#125; 思路2 很简单，我们只需要循环 \(b\) 次把 \(a\) 乘上自己，判断一下是否大于 \(1e9\) 即可。 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(), b = scanner.nextInt(); long ans = 1L; for(int i=0;i&lt;b;i++) &#123; ans *= a; if(ans > 1000000000L) &#123; System.out.println(-1); return; &#125; &#125; System.out.println(ans); &#125; &#125; 对思路2的优化 可以使用快速幂降低时间复杂度。 注意：可能会爆long long，用大数解。 对应AC代码 import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); BigInteger weight = BigInteger.valueOf(scanner.nextLong()); int b = scanner.nextInt(); BigInteger ans = BigInteger.ONE; while(b > 0)&#123; if(b % 2 == 1) &#123; //二进制非递归快速幂 ans = ans.multiply(weight); if(ans.compareTo(BigInteger.valueOf(1000000000L)) > 0) &#123; System.out.println(-1); return; &#125; &#125; weight = weight.multiply(weight); //这里在测试点9会爆long b >>= 1; &#125; System.out.println(ans); &#125; &#125; 怎么能叫投机取巧呢（ B. 解密 CSP 2022 T2 题意 对于方程组 \(n = p q\) , \(ed = (p - 1) (q - 1) + 1\)，给定 \(n, d, e\)，解方程并输出 \(p, q\)。 思路 化简第二个式子得到 \(p + q = n - e d + 2\)，设其为 \(m\). 由第一个式子得到 \(p = \frac{n}{q}\). 由1和2，\(\frac{n}{q} + q = m \rightarrow q ^ 2 - m q + n = 0\). 求 \(\Delta = m ^ 2 - 4 n\)，\(\Delta &lt; 0\) 即为无解的第一种情况. 运用求根公式求出 \(p, q\)，\(p\) 和 \(q\) 不为整数为无解的第二种情况，为整数就输出. 注意点： 肉眼可见会爆 \(int\)，用长整型. 不要用 \(java\)，会 \(tle\). 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; int main()&#123; int k; long long n, d, e; scanf("%d", &amp;k); for(int w=0;w&lt;k;w++)&#123; scanf("%lld %lld %lld", &amp;n, &amp;d, &amp;e); long long m = n + 2 - e * d; long long delta = m * m - 4 * n; if(delta &lt; 0) printf("NO\n"); else &#123; double p = (m - sqrt(delta)) / 2, q = (m + sqrt(delta)) / 2; if((int) p != p || (int) q != q) printf("NO\n"); else printf("%d %d\n", (int) p, (int) q); &#125; &#125; &#125; 简简单单数学题 C. 报数 NOIP 2021 提高组 题意 某数字为 \(x\) 的倍数， \(x\) 的特点是至少有一位有 \(7\) (与 \(7\) 相关)，则该数字不能被报出。 报到与 \(7\) 相关的数，输出 \(-1\)，否则输出下一个非 \(7\) 相关的数。 思路 做一个类似于埃氏筛的预处理。 我们用类似于埃氏筛的思路，筛掉与 \(7\) 相关的数的倍数。 开一个数组，记录下一个非 \(7\) 相关的数，否则赋值为自己（或者可以是任意非正数）。 读它。 值得注意的是，\(1e7\) 后面第一个非 \(7\) 相关的数是 \(10000010\)，所以我们不妨开 \(1e7+11\) 大小的数组，防止溢出。 对应AC代码 import java.util.*; public class Main&#123; private static boolean relate(int x)&#123; //是否与7相关 while(x > 0)&#123; if(x % 10 == 7) return true; x /= 10; &#125; return false; &#125; private static int[] preTreat()&#123; int[] next = new int[10000011]; for(int i=1;i&lt;10000011;i++)&#123; if(next[i] == 0 &amp;&amp; relate(i))&#123; //类似于埃氏筛 for(int j=1;i*j&lt;10000011;j++) next[i * j] = 1; &#125; &#125; int last = 1; for(int i=2;i&lt;10000011;i++)&#123; if(next[i] == 0)&#123; next[last] = i; last = i; &#125; else next[i] = i; //反正只要后面可以特判就行 &#125; return next; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); int[] next = preTreat(); for(int w=0;w&lt;t;w++)&#123; int cur = scanner.nextInt(); System.out.println(next[cur] == cur ? -1 : next[cur]); &#125; &#125; &#125; 算是第一次接触数论了（ D. 逻辑表达式 CSP 2022 T3 题面 在编程语言中，存在逻辑表达式“短路”的现象，如：当判断 \(\&amp;\) 时，若前面为 \(false\)，那么后面的条件直接不判断了。 给定一个由 \(0\)、\(1\)、\(\&amp;\) 、 \(|\) 和括号组成的逻辑表达式，其中 \(1\) 和 \(0\) 分别表示真与假。输出表达式的结果，以及形如 \(a \&amp; b\) 和 \(a | b\) 的短路各出现了几次。 思路1 expr 可以用类似于求中缀表达式的值的思路来做。 中缀表达式转后缀表达式 建立表达式树 计算并统计 这个方法码量有点大，dfs有点深，只能上cpp了（ 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; struct Node&#123; int val, left, right; &#125;; int ansAnd = 0, ansOr = 0, nodeSize = 0; vector&lt;Node> nodes; //expr 中缀转后缀 vector&lt;int> toSuffix(const string&amp; mid) &#123; vector&lt;int> ex; stack&lt;char> ts; map&lt;char, int> pri; pri['&amp;'] = 4; pri['|'] = 3; pri['('] = 2; for (char each : mid) &#123; if (each == '@') &#123; while (!ts.empty()) ex.push_back(pri[ts.top()]), ts.pop(); break; &#125; else if (each >= '0' &amp;&amp; each &lt;= '9') ex.push_back(each - '0'); else &#123; if (each == '(') ts.push(each); else if (each == ')') &#123; while (ts.top() != '(') ex.push_back(pri[ts.top()]), ts.pop(); ts.pop(); //弹出左括号 &#125; else &#123; while (!ts.empty() &amp;&amp; pri[ts.top()] >= pri[each]) ex.push_back(pri[ts.top()]), ts.pop(); ts.push(each); &#125; &#125; &#125; return ex; &#125; //建表达式树 void build(const vector&lt;int>&amp; suffix)&#123; stack&lt;int> index; for(int each : suffix)&#123; if(each == 0 || each == 1)&#123; nodes.push_back(&#123;each, -1, -1&#125;); index.push(nodeSize ++); &#125;else&#123; int r = index.top(); index.pop(); int l = index.top(); index.pop(); nodes.push_back(&#123;each, l, r&#125;); index.push(nodeSize ++); &#125; &#125; &#125; int dfs(int index) &#123; if (nodes[index].val == 0 || nodes[index].val == 1) return nodes[index].val; int l = dfs(nodes[index].left); if (l == 0 &amp;&amp; nodes[index].val == 4) &#123; ansAnd++; return 0; &#125; if (l == 1 &amp;&amp; nodes[index].val == 3) &#123; ansOr++; return 1; &#125; return dfs(nodes[index].right); //既然不断路，那么值一定只和右边的值有关 &#125; int main() &#123; string mid; cin >> mid; mid += "@"; build(toSuffix(mid)); printf("%d\n", dfs(nodeSize - 1)); printf("%d %d\n", ansAnd, ansOr); &#125; 思路2 分治 对于一个表达式，我们会先去找没有括号的优先级最高的符号，然后计算左右两边的值，这便是中缀表达式的直观求法。 由 \(1\) 所述，我们可以将表达式分层，并从优先级最高的那个符号开始左右分治求解，同时特判左边的值即可。 显然，我们不可能在每次求左右表达式的时候都遍历一遍字符串找符号，这肯定会 \(tle\)。于是乎，我们需要一个预处理，将当前位置之前该层最近的符号找出并记录它的下标。这样我们只要每次读取一下记录的下标是否在区间内即可。 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; int nowAnd[1000010], nowOr[1000010], lastAnd[1000010], lastOr[1000010]; string mid; int ansAnd, ansOr; int dc(int l, int r) &#123; if (nowOr[r] >= l) &#123; //or的优先级更高 int left = dc(l, nowOr[r] - 1); if (left == 1) &#123; ansOr++; return 1; &#125; return left | dc(nowOr[r] + 1, r); &#125; else if (nowAnd[r] >= l) &#123; int left = dc(l, nowAnd[r] - 1); if (left == 0) &#123; ansAnd++; return 0; &#125; return left &amp; dc(nowAnd[r] + 1, r); &#125; else if (mid[l] == '(' &amp;&amp; mid[r] == ')') return dc(l + 1, r - 1); return mid[l] - '0'; &#125; int main() &#123; cin >> mid; int n = mid.size(), layer = 0; mid = " " + mid; for (int i = 1; i &lt; n + 1; i++) &#123; //预处理 switch (mid[i]) &#123; case '(': layer++; break; case ')': layer--; break; case '|': lastOr[layer] = i; break; case '&amp;': lastAnd[layer] = i; break; &#125; nowAnd[i] = lastAnd[layer]; nowOr[i] = lastOr[layer]; &#125; printf("%d\n", dc(1, n)); printf("%d %d\n", ansAnd, ansOr); &#125; 怎么比赛里面还有码农题（ E. 音量调节 HAOI 2012 题意 给定一个初始值 \(beginLevel\) 以及最大值 \(maxLevel\)，对于一个数组 \(c\)，在第 \(i\) 次操作时，可选择将当前的值加上或减去 \(c_i\)，或不操作。输出最后的最大值。 思路 一眼丁真，鉴定为 分组背包 不会做的去看背包九讲 题目特点：每个 \(c\) 都要选上，可以 \(+c\) 可以 \(-c\)，有范围限定。 分组：分成 \(c\) 组，每组为 \(c\) 和 \(-c\)。 我们可以用 \(boolean\) 类型的 \(dp\) 数组存储当前音量能否达到，对此，有如下状态转移方程: \(dp[i][v] = dp[i][v] || dp[i - 1][v ± c]\) 套模板即可。 对应AC代码 import java.util.*; //快乐分组背包呀 public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int N = scanner.nextInt(), begin = scanner.nextInt(), V = scanner.nextInt(); boolean[][] dp = new boolean[N + 1][V + 1]; dp[0][begin] = true; for(int i=1;i&lt;=N;i++)&#123; int c = scanner.nextInt(); for(int v = V;v>=0;v--)&#123; if(v - c >= 0) dp[i][v] |= dp[i - 1][v - c]; if(v + c &lt;= V) dp[i][v] |= dp[i - 1][v + c]; &#125; &#125; for(int v=V;v>=0;v--) if(dp[N][v])&#123; System.out.println(v); return; &#125; System.out.println(-1); &#125; &#125; 略微变化了一下的分组背包 F. 上升点列 CSP 2022 T4 题意 给定 \(n\) 个点坐标，可添加 \(k\) 个任意坐标，求出最长单调欧几里得距离序列。 思路 这道题如果联想到最长上升子序列就迎刃而解了。 用二维dp做，前 \(i\) 个点插入 \(j\) 个点的最长长度。 观察欧几里得距离可发现，若要使i~j序列可取，那么需要加上 \(d\) 个点， \(d = xi - xj + yi - yj + 1\)。 类似于最长上升子序列，得到状态转移方程： $dp[i][p] = max(dp[i][p], dp[j][p - d] + d + 1), p∈[d, k] $。 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), k = scanner.nextInt(); int[][] data = new int[n + 1][2]; for(int i=1;i&lt;=n;i++) &#123; data[i][0] = scanner.nextInt(); data[i][1] = scanner.nextInt(); &#125; Arrays.sort(data, 1, n + 1, (o1, o2) -> o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0]); int[][] dp = new int[n + 1][k + 1]; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=k;j++) dp[i][j] = j + 1; //差了j个那就塞上j个 for(int i=2;i&lt;=n;i++)&#123; for(int j=i-1;j>=1;j--)&#123; //i状态由j状态推得 if(data[j][1] > data[i][1]) continue; //因为i状态由j状态推得，所以需要至少d个点才能满足欧几里得距离 int d = data[i][0] - data[j][0] + data[i][1] - data[j][1] - 1; for(int p=d;p&lt;=k;p++) dp[i][p] = Math.max(dp[i][p], dp[j][p - d] + d + 1); //最长上升子序列模板 &#125; &#125; int ans = 0; for(int i=1;i&lt;=n;i++) ans = Math.max(ans, dp[i][k]); System.out.println(ans); &#125; &#125; 想不到就废了（悲 G. 星球大战 JSOI 2008 题意 给定一个无向图，输出断开指定边后图中联通块的数量。 思路 首先是建立无向图，可以使用邻接表的方式存储。 标记这些需要断开的边，然后依次遍历各个边，若端点的根节点一样，那么就处于同一个连通块了。 因为至少存在 \(n\) 条边，那么连通块最多为 \(n-k\) 个。 综合 \(2\) 和 \(3\) 可知，答案即为 \(n - k - cnt\)，其中 \(cnt\) 为满足 \(2\) 条件的个数。 至于要输出每次打击后的值，我们可以逆向思维，将最后的状态还原到最初状态即可。 优化 我们可以使用并查集算法来优化。 没有解释地很清楚哈，还是有点难写的 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; typedef struct&#123; int a, b; //两点 int to; &#125;Edge; int parent[400010]; Edge edges[400010]; int tot = 0; int head[400010], broken[400010], ans[400010]; bool visited[400010]; //并查集查询，返回父节点id并将child全设为父节点直属下司( int findParent(int child) &#123; int ground = child, father = child; while (father != parent[father]) father = parent[father]; //更新father while (ground != parent[ground]) &#123; int tmp = ground; ground = parent[ground]; parent[tmp] = father; &#125; return father; &#125; //联通两个子树的爸爸即可(把一个爸爸设为另一个爸爸的直属下司 void unionIt(int x, int y) &#123; parent[findParent(x)] = findParent(y); &#125; void addEdge(int a, int b)&#123; edges[++tot].a = a; edges[tot].b = b; edges[tot].to = head[a]; head[a] = tot; &#125; int main() &#123; int n, m, u, v, k; long long w; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) parent[i] = i; //初始化并查集，我是我爸爸 for (int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; scanf("%d", &amp;k); for(int i=1;i&lt;=k;i++)&#123; scanf("%d", &amp;broken[i]); visited[broken[i]] = true; &#125; int united = n - k; for (int i = 0; i &lt; 2 * m; i++) &#123; if (!visited[edges[i].a] &amp;&amp; !visited[edges[i].b] &amp;&amp; findParent(edges[i].a) != findParent(edges[i].b)) &#123;//爸爸不一样，由union函数的写法可以看出俩玩意儿没联通 united --; unionIt(edges[i].a, edges[i].b); &#125; &#125; ans[k + 1] = united; for(int i=k;i>=1;i--)&#123; int x = broken[i]; visited[x] = false; united ++; for (int j = head[x]; j != 0; j = edges[j].to) &#123; int nowB = edges[j].b; if(!visited[nowB] &amp;&amp; findParent(x) != findParent(nowB))&#123; united --; unionIt(x, nowB); &#125; &#125; ans[i] = united; &#125; for(int i=1;i&lt;=k+1;i++) printf("%d\n", ans[i]); &#125; 反着想有时候会更简单 H. 虚拟内存 HNOI 2005 题意 设计一个程序完成题面所指的算法。 太模拟了，建议看原题（ 思路 一道逻辑很清楚但是不好写的模拟题。 我们很明显能发现，不可以 \(O(mn)\)，会寄，想想有序性，不难发现可以用优先队列。 我们需要存一下当前某一页的状态，方便找空页，我们可以用 \(map\)。 模拟 如果使用HashMap，对于某些如java的语言需要重写一下类的hashCode()和equals()方法，不然会像我一样WA。 当然，最好用cpp写，其他语言容易卡到tle和mle 对应AC代码 import java.util.*; public class Main&#123; private static class Page&#123; int id, cnt, time; Page(int id, int cnt, int time) &#123; this.id = id; this.cnt = cnt; this.time = time; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; Page page; //java版本低，用ide自动生成的还得改改（（（ if (!(o instanceof Page)) return false; page = (Page) o; return id == page.id &amp;&amp; cnt == page.cnt &amp;&amp; time == page.time; &#125; @Override public int hashCode() &#123; return Objects.hash(id, cnt, time); &#125; &#125; private static class Pair&lt;A, B>&#123; A A; B B; Pair(A a, B b) &#123; A = a; B = b; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; Pair&lt;?, ?> pair; if (!(o instanceof Pair&lt;?, ?>)) return false; pair = (Pair&lt;?, ?>) o; return Objects.equals(A, pair.A) &amp;&amp; Objects.equals(B, pair.B); &#125; @Override public int hashCode() &#123; return Objects.hash(A, B); &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); //优先队列 int n = scanner.nextInt(), m = scanner.nextInt(); Map&lt;Integer, Pair&lt;Integer, Integer>> data = new HashMap&lt;>(); PriorityQueue&lt;Page> least = new PriorityQueue&lt;>(((o1, o2) -> o1.cnt == o2.cnt ? o1.time - o2.time : o1.cnt - o2.cnt)); int ans = 0; for (int i = 0; i &lt; m; i++) &#123; int query = scanner.nextInt(); if(data.containsKey(query))&#123; int cnt = data.get(query).A, time = data.get(query).B; least.remove(new Page(query, cnt, time)); least.offer(new Page(query, cnt + 1, time)); data.put(query, new Pair&lt;>(cnt + 1, time)); ans ++; &#125;else if(data.size() &lt; n)&#123; data.put(query, new Pair&lt;>(1, i)); least.offer(new Page(query, 1, i)); &#125;else&#123; Page page = least.poll(); data.remove(page.id); data.put(query, new Pair&lt;>(1, i)); least.offer(new Page(query, 1, i)); &#125; &#125; System.out.println(ans); &#125; &#125; 题目读半天... I. 泡泡堂 ZJOI 2008 题意 给定两个队的选手的实力，在分配最好和最坏的情况下，分别输出 \(ZJ\) 队的分数。 思路 田忌赛马 1. 田忌最快的马比齐王最快的马快，比之 2. 田忌最快的马比齐王最快的马慢，用田忌最慢的马跟齐王最快的马比 3. 田忌最快的马的速度与齐王最快的马速度相等 ①田忌最慢的比齐王最慢的快，比之。 ②田忌最慢的比齐王最慢的慢，田忌慢马 \(VS\) 齐王快马 ③田忌最慢的与齐王最慢的相等，田忌慢马 \(VS\) 齐王快马 不予证明。 更具体地说 维护双指针$ head$ 和 \(end\), 按上述思路写 对应AC代码 import java.util.*; public class Main&#123; //md，一个贪心想了我好久 private static long judge(int n, long[] a, long[] b)&#123; int score = 0; int headA = 0, headB = 0, endA = n - 1, endB = n - 1; //双指针？ while(headA &lt;= endA &amp;&amp; headB &lt;= endB)&#123; if(a[headA] > b[headB])&#123; score += 2; headA ++; headB ++; &#125;else if(a[endA] > b[endB])&#123; score += 2; endA --; endB --; &#125; else &#123; if(a[headA] == b[endB]) score ++; headA ++; endB --; &#125; &#125; return score; &#125; //我就猜一猜 public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); long[] zj = new long[n], sb = new long[n]; for(int i=0;i&lt;n;i++) zj[i] = scanner.nextLong(); for(int i=0;i&lt;n;i++) sb[i] = scanner.nextLong(); Arrays.sort(zj); Arrays.sort(sb); System.out.printf("%d %d\n", judge(n, zj, sb), 2L * n - judge(n, sb, zj)); //有个小技巧（（（ &#125; &#125; md，一个贪心想了我好久]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 2022 第四场世纪大战 - 带佐的回家路</title>
    <url>/blog/posts/1494271354/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/contest/p/29?tid=635bad6e691055e12dce5282 题意 带佐在数轴上。\(0\) 时刻，带佐位于 \(0\) 处。在时刻 \(i−1\) 和 \(i\) 之间的时间段中，带佐要么待在当前位置，要么向左或向右跳 \(i\) 个单位长度。输出带佐最早在哪个时刻可以到达 \(X\)。 思路 首先，结论是：首项为 \(1\)，公差为 \(1\) 的等差数列的前 \(n\) 项和满足 \(S_n &gt; x\) 的最小 \(n\) 即为答案。 下面给出证明思路： 上述结论的做法是： 令 \(m = 满足条件的最小 n\)，\(t = Sm - x\)，则只需在 \(t\) 时刻停留即可保证最后一步恰好走到 \(x\)。 上述结论的合理性： ① 我们不可能折回，因为折回后如果直接返回，只能前进 \(1\)，代价大于在 \(t\) 时刻停留的代价（可以根据等差数列理解，列方程来严格证明），而停留后返回代价明显更大（停留需要很长时间，而折回后返回前进的距离远没有这么长）。 ② 我们不可以停留太久，显然停留一次比停留多次代价小。 因此，用一个 \(while\) 轻松解决。 值得注意的是，上述证明不严密。 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); long x = scanner.nextLong(), t = 0, i = 1; while(t &lt; x)&#123; t += i; i ++; &#125; System.out.println(i - 1); &#125; &#125; 暴力就完事了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 模拟 - Air Conditioner</title>
    <url>/blog/posts/3649205289/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/P1304C 空调凉凉~ 题意 一个餐馆中有个空调，给定空调的初始温度为 \(m\)，每分钟可以选择上调或下调 \(1\) 个单位的温度，或选择不变。 给定 \(n\) 个食客的到达时间 \(t_i\) 以及所能适应的温度范围 \([l_i, r_i]\)，每个食客只会在 \(t_i\) 时刻逗留。 如果温度不在食客的适应范围内，他就会不舒服。输出空调能否使得所有食客都感到舒服。 思路 当初第一反应是维护一个温度值，根据食客的需求改变温度。但这里存在问题：对于有限的操作，最后能落在温度区间的温度是不唯一的。如果是这样，很多种可能叠加，不难发现会超时。 也许我们可以贪心地认为只要满足最低条件即可，但我们不能保证下一个本因可行的区间可能被判为不可行（如一直递增的温度区间）。 单个值失败了，那就多个值呗。 我们只要维护一个区间，让每次所有的可行解落在该区间。然后，对于每一个区间，将其与后面的区间进行区间重叠运算。 对于重叠的区间，有四种可能： 1.可行区间 \(cur\) 和后一个温度区间没有重叠 2.两区间左侧或右侧部分重叠 3.可行区间 \(cur\) 包含于后一个温度区间 4.可行区间 \(cur\) 被包含于后一个温度区间 对应AC代码 import java.util.*; public class Main &#123; static class Person&#123; long t, l, h; Person(long t, long l, long h)&#123; this.t = t; this.l = l; this.h = h; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int q = scanner.nextInt(); g:for(int i=0;i&lt;q;i++)&#123; int n = scanner.nextInt(), m = scanner.nextInt(); Person[] p = new Person[n]; for(int j=0;j&lt;n;j++) p[j] = new Person(scanner.nextLong(), scanner.nextLong(), scanner.nextLong()); long left = m - p[0].t, right = m + p[0].t; //以第一个人的到达时间划分初始区间 for(int j=0;j&lt;n;j++)&#123; Person cur = p[j]; if(cur.h &lt; left || cur.l > right)&#123; System.out.println("NO"); continue g; &#125;else if(j == n - 1)&#123; //如果是最后一个，只要有交集就已经成功 System.out.println("YES"); continue g; &#125; if(cur.l >= left &amp;&amp; cur.h &lt;= right)&#123; //包含关系 left = cur.l; right = cur.h; &#125;else if(cur.l >= left) left = cur.l; //右侧有区间重叠 else if(cur.h &lt;= right) right = cur.h; //左侧有区间重叠 left -= p[j + 1].t - cur.t; right += p[j + 1].t - cur.t; &#125; &#125; &#125; &#125; 第一次写题解，可能交代的不是很清楚。]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 图论 - 车站分级</title>
    <url>/blog/posts/1900600766/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/532?tid=6363a9a5691055e12dd288dc 其实如果没有给出是图论题的话，这题就难在想不想得到拓扑了。 题意 定义"要求"：对于任意停靠的车站，存在优先级，需要满足其余大于等于该车站优先级的车站必须停靠的条件。 给出满足"要求"的几条线路，求出需要划分的最少优先级数量。 思路 首先，我们确定一下每条线路需要处理的车站：从起点到终点这一段路上的所有车站。 对于"优先"这个概念，我们可以联系到图论中的父子关系，也就是建立有向边。 对于有向边，当我们将优先级小的车站作为父节点、优先级大的作为子节点时，就可以采用拓扑排序的逻辑。在每次 \(push\) 的时候，我们只需存入当前节点的优先级，依次迭代并记录优先级的最大值即可。 对于建立有向边，我们可以遍历这条线路上所有非停靠站，将所有车站依次连到各个非停靠车站上即可。 对应AC代码 import java.util.*; public class Main&#123; private static class Point&#123; //防止构建泛型数组 int inDegree; List&lt;Integer> edges = new ArrayList&lt;>(); &#125; //实现cpp里面的pair private static class Pair&lt;A, B>&#123; A A; B B; public Pair(A a, B b) &#123; A = a; B = b; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Pair&lt;?, ?> pair = (Pair&lt;?, ?>) o; if (!Objects.equals(A, pair.A)) return false; return Objects.equals(B, pair.B); &#125; @Override public int hashCode() &#123; int result = A != null ? A.hashCode() : 0; result = 31 * result + (B != null ? B.hashCode() : 0); return result; &#125; &#125; static int n, ans; static Point[] points; static boolean[][] edgeVisited; static void addEdge(int x, int y)&#123; if(points[x] == null) points[x] = new Point(); if(points[y] == null) points[y] = new Point(); points[x].edges.add(y); points[y].inDegree ++; &#125; static void topSort() &#123; //拓扑排序 Queue&lt;Pair&lt;Integer, Integer>> queue = new LinkedList&lt;>(); for (int i = 1; i &lt;= n; i++) if (points[i] != null &amp;&amp; points[i].inDegree == 0) &#123; //多余的站不用管了 queue.offer(new Pair&lt;>(i, 1)); //入度为零，优先级最低为1 &#125; while (queue.size() > 0) &#123; Pair&lt;Integer, Integer> x = queue.poll(); for (int y : points[x.A].edges) &#123; if (--points[y].inDegree == 0) &#123; queue.offer(new Pair&lt;>(y, x.B + 1)); //当所有能遍历到y的点都经过了，那就可以can can y了(不然会有重复 ans = Math.max(ans, x.B + 1); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); n = scanner.nextInt(); int m = scanner.nextInt(); points = new Point[n + 1]; edgeVisited = new boolean[n + 1][n + 1]; for(int w=0;w&lt;m;w++)&#123; int s = scanner.nextInt(); List&lt;Integer> stations = new ArrayList&lt;>(); boolean[] isStation = new boolean[n + 1]; for(int i=0;i&lt;s;i++) &#123; int now = scanner.nextInt(); stations.add(now); isStation[now] = true; &#125; for(int i=stations.get(0); i&lt;=stations.get(s - 1);i++)&#123; //非车站作为车站的爸爸建有向边 if(isStation[i]) continue; for(int j : stations)&#123; if(!edgeVisited[i][j])&#123; edgeVisited[i][j] = true; addEdge(i, j); &#125; &#125; &#125; &#125; topSort(); System.out.println(ans); &#125; &#125; 这题也可以用邻接表。 要交题的话还是建议cpp，java有点卡时间了。]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 图论 - Sorting it all out</title>
    <url>/blog/posts/3592285520/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/542?tid=6363ac4a691055e12dd289de 最短路题单，但是可以用拓扑（ 题意 给定 \(A - Z\) 中前 \(n\) 个字母的大小顺序，且都为小于关系，共有 \(m\) 个条件，从前往后判断满足所有条件的序列是否存在且唯一。 对于从前往后的 \(t\) 次遍历中，若能确定最后输出，则略过后面的输入。 有唯一解，输出 \(Sorted \ sequence \ determined \ after \ t \ relations: yyy...y.\) 有多解（冲突），输出 \(Inconsistency \ found \ after \ t \ relations.\) 无解（没有给全所有点的条件），输出 \(Sorted \ sequence \ cannot \ be \ determined.\) 思路 因为题面提到需要整个序列的顺序输出，而联想到拓扑排序，它可以将一个有向图转换成一个有先后顺序的序列，这正是我们需要的。 一切都一样，只是我们的有向图多了一个条件： 除了根和叶外，其他节点都是入度和出度为 \(1\) 的。 联想到拓扑排序的实现，若我们在每次循环的时候都判断一下队列的元素个数，大于 \(1\) 标记有多解，即可满足上述条件了。 当然，为了计算 \(t\)，跑一遍拓扑是不够的，我们要在加边的同时拓扑，来判断在加入这个条件后是否出现了多解或者无解。 考虑到入度的计算，不采用先加完边再跑拓扑的做法。 翻车实录 注意输出的优先级，如果冲突且无解，应该输出冲突。 \(POJ\) 远端题，不要用万能头和 \(for-each\) 语句。 对应AC代码 #include &lt;cstdio> #include &lt;vector> #include &lt;queue> #include &lt;cstring> using namespace std; int n, m, inDegree[30], copyInDegree[30], visited[30][30]; vector&lt;int> edges[30], ans; bool addEdge(int x, int y) &#123; //在邻接表中添加一条有向边 if(visited[x][y]) return true; visited[x][y] = true; edges[x].push_back(y); inDegree[y]++; return false; &#125; int topSort() &#123; //拓扑排序 queue&lt;int> q; memset(copyInDegree, 0, sizeof copyInDegree); //每次拓扑后入度不能被修改呢 for (int i = 0; i &lt; n; i++) &#123; if (inDegree[i] == 0) q.push(i); copyInDegree[i] = inDegree[i]; &#125; ans.clear(); bool inc = false; while (!q.empty()) &#123; if(q.size() > 1) inc = true; int x = q.front(); ans.push_back(x); q.pop(); for(int i=0;i&lt;edges[x].size();i++)&#123; int y = edges[x][i]; if (--copyInDegree[y] == 0) &#123; q.push(y); &#125; &#125; &#125; if(ans.size() &lt; n) return 2; if(inc) return 3; return 1; &#125; int main() &#123; scanf("%d %d", &amp;n, &amp;m); while (n != 0 || m != 0) &#123; memset(inDegree, 0, sizeof inDegree); memset(visited, 0, sizeof visited); memset(edges, 0, sizeof edges); bool skip = false; int t = 0, result = 3; for (int i = 1; i &lt;= m; i++) &#123; char input[4] = &#123;0&#125;; scanf("%s", input); if (addEdge(input[0] - 'A', input[2] - 'A')) continue; if (skip) continue; //跳过也得读完呐... result = topSort(); t++; if (result == 3) continue; //无解了 skip = true; //冲突和求出唯一解是只需判断一次的，后面直接跳过即可 &#125; if (result == 1) &#123; printf("Sorted sequence determined after %d relations: ", t); for (int i = 0; i &lt; ans.size(); i++) printf("%c", ans[i] + 'A'); printf(".\n"); &#125; else if (result == 2) printf("Inconsistency found after %d relations.\n", t); else printf("Sorted sequence cannot be determined.\n"); scanf("%d %d", &amp;n, &amp;m); &#125; &#125; 找个时间写写floyd的思路]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 树型dp - 三色二叉树</title>
    <url>/blog/posts/3903312395/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/512?tid=633d6550d2fe705a3c4684c7 之所以来写这个题解，是因为思路真的太清晰啦（（ 题意 给定一段由 \(0, 1, 2\) 组成的二叉树序列 \(S\)，序列由下面三种元素构成： \(0\)：表示该树没有节点； \(1 S_1\)：表示该数有一个节点，\(S_1\) 为其子树的二叉树序列； \(2 S_1 S_2\)：表示该树有两个子节点，\(S_1\) 和 \(S_2\) 分别表示其两个子树的二叉树序列。 根据上述序列建树，并标上红蓝绿三种颜色，相邻颜色不能重复，子节点颜色不能重复，求出这棵树中绿色节点的最大和最小数量。 思路 我们考虑下面的两个问题。 如何建树 根据题给条件，在给出根节点后，后面将会有一段数字作为根节点的子树，而其子树又可向右找到他的子树，以此类推。 但我们要如何确定下一个节点从哪里开始呢？显然，在上一个子节点遍历完后，下一个下标即为另一个子节点的开始下标。 于是乎，我们可以记录一下当前的下标在哪个位置，然后..... 这里也有两种写法。 递归写法 我们只需向下一次调用传递当前下标的位置，并返回处理结束后的下标位置（也可以开一个全局变量存储下标，效果是一样的）即可。 对应代码 void buildTree(int father)&#123; if(curIndex == inputTree.size()) return; cnt[father] = inputTree[curIndex ++] - '0'; for(int i=0;i&lt;cnt[father];i++) &#123; nodes[father][i] = ++tot; buildTree(tot); &#125; &#125; STL写法 我们不妨这么想，在找到根节点后，我们需要寻找它的两个子节点，而因为需要建树，我们需要知道这两个子节点对应的父节点是什么。 所以，我们可以使用一个数据结构存储这个根节点，在嵌套寻找的时候能正确获取上一个根节点，并能在两个子节点处理完后移除这个根节点。 这个数据结构满足一个特点：先进先出。 没错，就是栈结构。 对应代码 void buildTree() &#123; stack&lt;pair&lt;int, int>> root; //index, sum int cur = 0; root.push(pair&lt;int, int>(++tot, inputTree[0] - '0')); while (!root.empty()) &#123; pair&lt;int, int> father = root.top(); root.pop(); int now = inputTree[++cur] - '0'; father.second--; nodes[father.first][cnt[father.first]++] = ++tot; //建树 if (father.second > 0) root.push(father); if (now > 0) root.push(pair&lt;int, int>(tot, now)); &#125; &#125; 如何dp 在说之前，先吐槽一句我的代码，它看起来好蠢 我们不妨用状态机的写法，开一个二维 \(dp\) 数组第一维为下标，第二维为当前节点的一个状态。 显然，作为一个节点，他有三种状态——红蓝绿。 初始状态 将叶节点的所有状态赋值 \(1\). 状态转移 首先，如果一个父节点要成为绿色，那么他的子节点一定是红色、蓝色，或者蓝色、红色。当然如果只有一个子节点，那么这个子节点就是蓝色或者红色。 所以，对于一个父节点，对于一种颜色，它总会有两种取法，而又因为两种取法不影响父节点的颜色，所以 \(dp\) 的最大值就是两种情况的最大值，最小值同理。 这是最直接的思路，而按照这么写，代码会很冗长。 对应代码 void dfs(int root) &#123; for (int i = 0; i &lt; cnt[root]; i++) dfs(nodes[root][i]); if (cnt[root] == 0) &#123; dpMax[root][1] = 1; dpMin[root][1] = 1; &#125; else if (cnt[root] == 1) &#123; dpMax[root][0] = max(dpMax[nodes[root][0]][1], dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1], dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][1]); &#125; else if (cnt[root] == 2) &#123; dpMax[root][0] = max(dpMax[nodes[root][0]][1] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][1] + dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][1], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][1] + dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][1], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][1]); &#125; &#125; 是不是很蠢，我看着就想笑 最终结果 根节点分别为红蓝绿时，所记录下来的最大值和最小值即为答案。 对应AC代码 (递归) #include &lt;bits/stdc++.h> using namespace std; //你问我啥用cpp写，因为Java栈溢出了 int tot; int nodes[500010][2], dpMin[500010][3], dpMax[500010][3]; //0是红，1是绿，2是蓝，dp的值是绿色点的个数 int cnt[500010]; string inputTree; int curIndex = 0; void buildTree(int father)&#123; if(curIndex == inputTree.size()) return; cnt[father] = inputTree[curIndex ++] - '0'; for(int i=0;i&lt;cnt[father];i++) &#123; nodes[father][i] = ++tot; buildTree(tot); &#125; &#125; void dfs(int root) &#123; //好蠢 for (int i = 0; i &lt; cnt[root]; i++) dfs(nodes[root][i]); if (cnt[root] == 0) &#123; //断子绝孙 dpMax[root][1] = 1; dpMin[root][1] = 1; &#125; else if (cnt[root] == 1) &#123; //一个节点 dpMax[root][0] = max(dpMax[nodes[root][0]][1], dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1], dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][1]); &#125; else if (cnt[root] == 2) &#123; dpMax[root][0] = max(dpMax[nodes[root][0]][1] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][1] + dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][1], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][1] + dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][1], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][1]); &#125; &#125; int main() &#123; cin >> inputTree; buildTree(++ tot); dfs(1); cout &lt;&lt; max(dpMax[1][0], max(dpMax[1][1], dpMax[1][2])) &lt;&lt; " " &lt;&lt; min(dpMin[1][0], min(dpMin[1][1], dpMin[1][2])); &#125; 对应AC代码 (STL) #include &lt;bits/stdc++.h> using namespace std; //你问我啥用cpp写，因为Java栈溢出了 int tot; int nodes[500010][2], dpMin[500010][3], dpMax[500010][3]; //0是红，1是绿，2是蓝，dp的值是绿色点的个数 int cnt[500010]; string inputTree; void buildTree() &#123; stack&lt;pair&lt;int, int>> root; //index, sum int cur = 0; root.push(pair&lt;int, int>(++tot, inputTree[0] - '0')); while (!root.empty()) &#123; pair&lt;int, int> father = root.top(); root.pop(); int now = inputTree[++cur] - '0'; father.second--; nodes[father.first][cnt[father.first]++] = ++tot; //建树 if (father.second > 0) root.push(father); if (now > 0) root.push(pair&lt;int, int>(tot, now)); &#125; &#125; void dfs(int root) &#123; //好蠢 for (int i = 0; i &lt; cnt[root]; i++) dfs(nodes[root][i]); if (cnt[root] == 0) &#123; //断子绝孙 dpMax[root][1] = 1; dpMin[root][1] = 1; &#125; else if (cnt[root] == 1) &#123; //一个节点 dpMax[root][0] = max(dpMax[nodes[root][0]][1], dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0], dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1], dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0], dpMin[nodes[root][0]][1]); &#125; else if (cnt[root] == 2) &#123; dpMax[root][0] = max(dpMax[nodes[root][0]][1] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][1] + dpMax[nodes[root][0]][2]); dpMax[root][1] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][2], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][2]) + 1; dpMax[root][2] = max(dpMax[nodes[root][0]][0] + dpMax[nodes[root][1]][1], dpMax[nodes[root][1]][0] + dpMax[nodes[root][0]][1]); dpMin[root][0] = min(dpMin[nodes[root][0]][1] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][1] + dpMin[nodes[root][0]][2]); dpMin[root][1] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][2], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][2]) + 1; dpMin[root][2] = min(dpMin[nodes[root][0]][0] + dpMin[nodes[root][1]][1], dpMin[nodes[root][1]][0] + dpMin[nodes[root][0]][1]); &#125; &#125; int main() &#123; cin >> inputTree; buildTree(); dfs(1); cout &lt;&lt; max(dpMax[1][0], max(dpMax[1][1], dpMax[1][2])) &lt;&lt; " " &lt;&lt; min(dpMin[1][0], min(dpMin[1][1], dpMin[1][2])); &#125; 其实递归是写本题解的时候想到的，而有趣的是它反而是最优解。]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 树和堆 - 合并果子</title>
    <url>/blog/posts/2422309672/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/369?tid=6301e681027d8fe886628d9d 感觉之前写得太蠢了就重新写一下（ 题意 每次把最小的两个拿出来合并并将数量作为本次体力消耗，输出最小体力消耗值。 思路1 显然，我们只需边枚举边排序，考虑到数据范围够小，暴力是完全可行的。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; int d[20001]; int main() &#123; int n; cin >> n; for(int i=0;i&lt;n;i++) cin >> d[i]; sort(d, d + n); int ans = 0; for(int i=1;i&lt;n;i++)&#123; d[i] += d[i - 1]; ans += d[i]; sort(d + i, d + n); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; 思路2 不难发现，上面暴力的做法无非就是两个步骤：①排序 ②取最小两个加起来放回去 很巧的是，这些步骤完全可以使用封装好的堆结构来实现。 时间复杂度和上述暴力方法完全一致。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); PriorityQueue&lt;Integer> queue = new PriorityQueue&lt;>(); int n = scanner.nextInt(); for(int i=0;i&lt;n;i++) queue.offer(scanner.nextInt()); int ans = 0; while(true)&#123; if(queue.isEmpty()) break; int a = queue.poll(); if(queue.isEmpty()) break; int b = queue.poll(); queue.offer(a + b); ans += a + b; &#125; System.out.println(ans); &#125; &#125; 堆 = 暴力（暴论]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 搜索剪枝策略 - 靶形数独</title>
    <url>/blog/posts/1232478877/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/491?tid=633184a5ea0e1b063194593d 杰尼龟刚刚接触了信息学竞赛，有一天它遇到了这样一个题：靶形数独。 “简单！”杰尼龟心想，同时很快就写出了一份程序，可是测试时却出现了错误。 题意 完成一个每格具有分数的数独，使分数和最大。 铺垫 先来看看这题 数独 - 洛谷. 显然，我们只需要用 \(dfs\) 就可以了。 我们传递两个参数，代表当前我们搜索的点。 然后我们判断一下列有没有超出最大值，有的话跳到下一行即可。 不过需要注意的是，我们没有必要嵌套两个 \(for\) (你喜欢的话记得 \(break\) )，只需在传递参数的时候把当前列 \(+1\) 即可。 思路 首先，我们很容易想到直接套数独的模板，然后记录一下最高分即可。 这没有错，但你会喜提 \(2tle\)。 为什么呢？你可以试试用你的思维来解数独。 当拿到一个数独的时候，你的第一反应是什么？ 没错，自然是从空格最少的行填起。 这里就存在一个剪枝：对行排序。 我们可以用桶排序的方式，记录下排序后下标对应原行的下标即可。 还有一件事，你会如何算这个分数呢？ 用空间换时间，即数组 int k[10][10]=&#123; 0,0,0,0,0,0,0,0,0,0, 0,6,6,6,6,6,6,6,6,6, 0,6,7,7,7,7,7,7,7,6, 0,6,7,8,8,8,8,8,7,6, 0,6,7,8,9,9,9,8,7,6, 0,6,7,8,9,10,9,8,7,6, 0,6,7,8,9,9,9,8,7,6, 0,6,7,8,8,8,8,8,7,6, 0,6,7,7,7,7,7,7,7,6, 0,6,6,6,6,6,6,6,6,6 &#125;; 整出来一个公式：\(10 - \max(abs(i - 4), abs(j - 4))\) 对应AC代码 import java.util.*; public class Main &#123; static int[][] data = new int[10][10]; static boolean[][] rowVisited = new boolean[10][10], columnVisited = new boolean[10][10], squareVisited = new boolean[10][10]; static Integer[] reflectRow = new Integer[9]; static int ans = -1; private static void dfs(int x, int y)&#123; if(x == 9)&#123; int now = 0; for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; now += data[i][j] * (10 - Math.max(Math.abs(i - 4), Math.abs(j - 4))); &#125; ans = Math.max(ans, now); return; &#125; if(y == 9)&#123; dfs(x + 1, 0); return; &#125; int realX = reflectRow[x]; if(data[realX][y] != 0) dfs(x, y + 1); else &#123; int squareId = realX / 3 * 3 + y / 3; for (int i = 1; i &lt;= 9; i++) &#123; if (!rowVisited[realX][i] &amp;&amp; !columnVisited[y][i] &amp;&amp; !squareVisited[squareId][i]) &#123; rowVisited[realX][i] = true; columnVisited[y][i] = true; squareVisited[squareId][i] = true; data[realX][y] = i; dfs(x, y + 1); rowVisited[realX][i] = false; columnVisited[y][i] = false; squareVisited[squareId][i] = false; data[realX][y] = 0; //好久没写回溯了 &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); for(int i=0;i&lt;9;i++) reflectRow[i] = i; int[] cnt = new int[9]; for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++)&#123; data[i][j] = scanner.nextInt(); rowVisited[i][data[i][j]] = true; columnVisited[j][data[i][j]] = true; squareVisited[i / 3 * 3 + j / 3][data[i][j]] = true; if(data[i][j] > 0) cnt[i] ++; &#125; Arrays.sort(reflectRow, (o1, o2) -> cnt[o2] - cnt[o1]); dfs(0, 0); System.out.println(ans); &#125; &#125; 好久不玩数独了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>FjnuOJ - 模拟 - 立体图</title>
    <url>/blog/posts/1619629406/</url>
    <content><![CDATA[原题：https://fjnuacm.top/d/junior/p/464?tid=62e26edd3a711450d9b817c5 题意 小渊很懒，给你各个位置的高度，让你画立体图。 思路 首先，根据题单名称，我们可以知道要模拟。 方块之间的前后视觉遮挡问题 首先，我们来考虑这个本题最难的点。 显然，对于斜二测画法的立体图，后面靠左的区域会被前者覆盖。那么我们自然会发现，从前往后画，覆盖问题会变得很复杂（不过也不是不能做）。 所以，我们不妨试试从俯视视角的左上角开始画。 我们以一个方块为一个单位开始画图。这里我们定义一个 \(char\) 二维数组来存储一个方块，并用题给的 \(.\) 符号来表示空区域。 char[][] one = &#123; "..+---+".toCharArray(), "./ /|".toCharArray(), "+---+ |".toCharArray(), "| | +".toCharArray(), "| |/.".toCharArray(), "+---+..".toCharArray() &#125;; 然后，对于每一个新加入的方块，我们只要对 \(one\) 进行行列的遍历，如果不为 \(.\)，就将前者对应位置覆盖。 定位 每个方块的大小是 \(6 \times 7\)，格子的数目也给出了范围，此处我们可以开一个存储数据的容量为 \(500 \times 500\) 的数组（其实是随便输的，可能还不满足最大的容量，只能说测试数据不够全面，反正开大一点就好啦~），那么右下角的点坐标就为 \((499, 499)\)。 好的，那我们先拿几个图来推一下坐标的式子。 此处定义每个格子的坐标为 \((i, j, h)\) 注：为了更加形象一点，我就直接定义 \(h\) 下标从 \(1\) 开始，而 \(i\) 和 \(j\) 仍从 \(0\) 开始。 image 对于左下角的高度为1的方块（即坐标为 \((m - 1, 0, 1)\) 的方块），他的左上顶点位于 \((494, 0)\)。 image 对于 \((m - 2, 1, 1)\) 的方块，他的左上顶点位于 \((492, 2)\)。 可见对于横纵坐标的改动，会有以 \(2\) 为倍数的改变，在高度为 \(1\) 时，我们可以推出下面的坐标式子： \((494 - 2(m - i - 1), 4j + 2(m - i - 1))\) 高度变化对坐标的影响是显而易见的。每当高度加 \(1\)，横坐标会减少 \(3\)（不能理解的话可以对照一下题面中两个方块上下相邻的图）。因此我们完善一下式子如下： \((497 - 2(m - i - 1) - 3h, 4j + 2(m - i - 1))\) 然后我们只需从俯视视角的左上角开始循环添加方块就 \(ok\) 了。 如何输出 在每次添加方格的时候，我们可以记录一下上区间和右区间，上区间就是所有左上顶点的纵坐标最小值，右区间就是所有右上顶点横坐标最大值。 对应AC代码 (java) import java.util.*; public class Main &#123; static char[][] one = &#123; "..+---+".toCharArray(), "./ /|".toCharArray(), "+---+ |".toCharArray(), "| | +".toCharArray(), "| |/.".toCharArray(), "+---+..".toCharArray() &#125;; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); char[][] ans = new char[500][500]; //开数组 for(int i=0;i&lt;500;i++) for(int j=0;j&lt;500;j++) ans[i][j] = '.'; //空位置填上占位符"." int m = scanner.nextInt(), n = scanner.nextInt(); int[][] height = new int[m][n]; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) height[i][j] = scanner.nextInt(); int top = 500, right = 0; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) for(int h=1;h&lt;=height[i][j];h++)&#123; //从左上角画起，存到数组底部，到时候记录最高和最右的位置即可 int startI = 497 - 2 * (m - i - 1) - 3 * h, startJ = 4 * j + 2 * (m - i - 1); top = Math.min(top, startI); right = Math.max(right, startJ + 6); for(int p=0;p&lt;6;p++) for(int q=0;q&lt;7;q++)&#123; if(one[p][q] != '.') ans[startI + p][startJ + q] = one[p][q]; &#125; &#125; for(int i=top;i&lt;=499;i++) &#123; for(int j=0;j&lt;=right;j++) System.out.print(ans[i][j]); System.out.println(); &#125; &#125; &#125; 对应AC代码 (cpp) #include &lt;bits/stdc++.h> using namespace std; char one[6][8] = &#123; "..+---+", "./ /|", "+---+ |", "| | +", "| |/.", "+---+.." &#125;; char ans[500][500]; //开数组 int height[52][52]; int main() &#123; for (int i = 0; i &lt; 500; i++) for (int j = 0; j &lt; 500; j++) ans[i][j] = '.'; //空位置填上占位符"." int m, n; scanf("%d %d", &amp;m, &amp;n); for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) scanf("%d", &amp;height[i][j]); int top = 500, right = 0; for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) for (int h = 1; h &lt;= height[i][j]; h++) &#123; //从左上角画起，存到数组底部，到时候记录最高和最右的位置即可 int startI = 497 - 2 * (m - i - 1) - 3 * h, startJ = 4 * j + 2 * (m - i - 1); top = min(top, startI); right = max(right, startJ + 6); for (int p = 0; p &lt; 6; p++) for (int q = 0; q &lt; 7; q++) &#123; if (one[p][q] != '.') ans[startI + p][startJ + q] = one[p][q]; &#125; &#125; for (int i = top; i &lt;= 499; i++) &#123; for (int j = 0; j &lt;= right; j++) printf("%c", ans[i][j]); printf("\n"); &#125; &#125; 过于模拟]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>FjnuOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 838 Div. 2</title>
    <url>/blog/posts/1762526761/</url>
    <content><![CDATA[Practice. A. Divide and Conquer 题意 给定一个数组 \(a\)，定义操作为选定一个元素并将其除 \(2\) 后向下取整，输出最少操作数，使整个数组的和为奇数。 思路 考虑到数据量比较小，我们不妨直接用“分治”的方法，考虑每个元素需要多少次才能改变奇偶性，然后找出操作数最少的元素，对应的操作数就是我们想要的答案。 当然，本来就是奇数的话就直接输出 \(0\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 60, inf = 0x3f3f3f3f; int a[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; memset(a, 0, sizeof a); cin >> n; int sum = 0, mn = inf; for(int i=0;i&lt;n;i++)&#123; int cnt = 0, x; cin >> x; a[i] = x; sum += a[i]; while(x % 2 == a[i] % 2 &amp;&amp; x > 0)&#123; cnt ++; x /= 2; &#125; mn = min(mn, cnt); &#125; if(sum % 2 == 0) cout &lt;&lt; 0 &lt;&lt; '\n'; else cout &lt;&lt; mn &lt;&lt; '\n'; &#125; return 0; &#125; 真就“分治”呗 B. Make Array Good 题意 给定一个数组 \(b\)，定义操作为将任意元素加上不超过其本身的自然数，操作数量不限，输出一种操作方案，使得对于任意的 \(i, j\)，有 \(\min(b_i, b_j) | \max(b_i, b_j)\)。 思路 既然操作数量不限，那么我们不妨把所有数加到 \(2\) 的倍数。 更具体地说，我们只需加到每个元素最近的 \(2\) 的次幂即可。 时间复杂度：\(O(n \log_2 n)?\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 60, inf = 0x3f3f3f3f; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; cout &lt;&lt; n &lt;&lt; '\n'; for(int i=1;i&lt;=n;i++)&#123; int x; cin >> x; int to = 1; while(to &lt; x) to *= 2; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; to - x &lt;&lt; '\n'; &#125; &#125; return 0; &#125; 限次数就难搞了 C. Binary Strings are Fun 题意 在二进制数组的条件下给出两个定义： 如果对于一个长度为奇数的数组，对于它的所有奇数下标 \(i\)，满足 \(b_i\) 是 \([1,i]\) 内出现次数至少占总数的一半的数，那么这个数组是好的。 若对于一个长度为 \(k\) 的数组 \(a\) 和一个长度为 \(2k-1\) 的数组 \(b\)，满足对于任意 \(i \in [1,k]\)，有 \(a_i = b_{2i-1}\)，那么称 \(b\) 是 \(a\) 的拓展数组。 现在，给定一个二进制数组 \(s\)，对于 \(s\) 的所有前缀，统计其 好的 拓展数组 的数量之和，并输出。 思路 首先，我们不难发现，若前两位是不相同的，那么我们可选的拓展值是唯一确定的，也就是说，想要让两个元素之间的拓展值有两种取法，那么这两个元素一定是相同的。 其次，若我们遇到了连续相同的一段，但后面被打断之后，那么我们就不得不在相同的这一段填上与之相反的值，否则无法满足后面的条件，所以我们应寻找后缀连续相同段的长度。 我们不妨记这个长度为 \(len\)，那么方案数即为 \(2^{len-1}\)。 显然，我们可以直接从左向右遍历，此时我们对应地判断+更新 \(len\) 与答案即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 60, inf = 0x3f3f3f3f, mod = 998244353; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; char pre = ' '; int ans = 1, tot = 0; for(int i=1;i&lt;=n;i++)&#123; char now; cin >> now; if(now == pre) ans = (ans * 2) % mod; else ans = 1; pre = now; tot = (tot + ans) % mod; &#125; cout &lt;&lt; tot &lt;&lt; '\n'; &#125; return 0; &#125; 算是想出来了一大半（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 841 Div. 2</title>
    <url>/blog/posts/4132653795/</url>
    <content><![CDATA[Practice. A. Joey Takes Money 题意 给定一个包含 \(n\) 个 \(\geq 1\) 的元素的数组 \(a\)，定义操作为： 选定 \(i, j, i \neq j\)； 选两个 \(\geq 1\) 的正整数 \(x, y\)，满足 \(x \cdot y = a_i \cdot a_j\)； 将 \(a_i, a_j\) 改为 \(x, y\)。 输出任意次操作后数组的和的最大值 x2022。 思路 显然，对于 \(a_i, a_j\)，\(1 + a_i \cdot a_j\) 一定是所有操作中最大的和，那么我们可以依次从左到右将所有数都执行一遍该操作，得到 \(1, 1, 1, \ldots, \prod a_i\)，求和即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t-- > 0)&#123; int n = scanner.nextInt(); long[] a = new long[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); for(int i=0;i&lt;n-1;i++)&#123; a[n - 1] = a[n - 1] * a[i]; a[i] = 1; &#125; System.out.println(2022 * ((long) (n - 1) + a[n - 1])); &#125; &#125; &#125; 简单思维题 &amp; 2022x1 B. Kill Demodogs 题意 给定一个 \(n \times n\) 的矩阵，\((i, j)\) 位置的元素值为 \(i \times j\)。定义人物从 \((1, 1)\) 走到 \((n, n)\)，期间人物只能向下或向右移动一格，输出到达终点后经过的元素的值的总和的最大值。 思路 显然，我们走对角线是最优的，此时横坐标和纵坐标的值最相近。 此时，我们可以得到下面的式子： \(1 \times 1 + 1 \times 2 + 2 \times 2 + \ldots + (n - 1) \times n + n \times n\)。 我们将其拆成两个式子： \(1 \times 1 + 2 \times 2 + \ldots + n \times n\)； \(1 \times 2 + 2 \times 3 + \ldots + (n - 1) \times n\)。 对于上述两个式子，我们套用公式即可。 最后，我们可以得到下面的式子： \(\frac{n (n + 1) (2n + 1)}{6} + \frac{(n - 1) n (n + 1)}{3}\)。 此时，我们有两个选择：大数或者逆元。任选其一即可。 时间复杂度：\(O(1)?\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(), mod = 1000000007; while(t -- > 0)&#123; long n = scanner.nextInt(); System.out.println((2022 * ((BigInteger.valueOf(n).multiply(BigInteger.valueOf(n + 1)).multiply(BigInteger.valueOf(2 * n + 1)).divide(BigInteger.valueOf(6)).mod(BigInteger.valueOf(mod)).longValue() + BigInteger.valueOf(n - 1).multiply(BigInteger.valueOf(n)).multiply(BigInteger.valueOf(n + 1)).divide(BigInteger.valueOf(3)).mod(BigInteger.valueOf(mod)).longValue()) % mod)) % mod); &#125; &#125; &#125; 大数yyds C. Even Subarrays 题意 给定一个长度为 \(n\) 的数组 \(a\)，\(1 \leq a_i \leq n\)，输出连续的子序列的个数，子序列需满足子序列的异或值有偶数个因数。 思路 这里需要用到一个性质：只有完全平方数的因数数量是奇数。 所以，我们不妨找完全平方数，然后取一个补集即可。 考虑到异或的交换性，我们不妨用答案来枚举。 更具体地说，我们不妨从前向后遍历，\(cur\) 为前 \(i\) 个元素的异或值，我们用 \(m\) 数组存储这些异或值出现的次数，然后，我们枚举所有可能的答案，算出 \(cur\) 需要和 前面的哪一段区间的异或值 进行异或后得到完全平方数，用类似于前缀和的方式记录答案。 考虑到 \(a_i\) 的范围，我们只需枚举 \(2n\) 及以下的完全平方数即可。 时间复杂度：\(O(n \sqrt n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); long[] m = new long[2 * n]; int cur = 0; long cnt = 0; m[cur] = 1; for(int i=0;i&lt;n;i++)&#123; cur ^= a[i]; for(int j=0;j*j&lt;2*n;j++)&#123; int now = cur ^ (j * j); if(now &lt; 2 * n) cnt += m[now]; &#125; m[cur] ++; &#125; System.out.println((long) n * (n - 1) / 2 + n - cnt); &#125; &#125; &#125; 异或的性质太多力]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 840 Div. 2</title>
    <url>/blog/posts/1344553303/</url>
    <content><![CDATA[Practice A. Absolute Maximization 题意 给定一个数组 \(a\)，定义操作为选择两个元素 \(a_i, a_j\)，并交换它们二进制下的第 \(b\) 位。输出任意次操作后的 \(\max(a) - \min(a)\) 的最大值。 思路 既然可以无限次交换，那么我们只要找出最高位，从最高位开始往下找，只要有一个元素该位存在 \(1\)，那么我们就拿过来构建新的数字，这样即可得到最大值。反之同理。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); for(int w=0;w&lt;t;w++)&#123; int n = scanner.nextInt(); int[] min = new int[12], max = new int[12]; for(int i=0;i&lt;12;i++)&#123; min[i] = 1; max[i] = 0; &#125; int maxLen = 0; String[] input = new String[n]; for(int i=0;i&lt;n;i++) &#123; input[i] = Integer.toBinaryString(scanner.nextInt()); maxLen = Math.max(maxLen, input[i].length()); &#125; for(int i=0;i&lt;n;i++) &#123; while(input[i].length() != maxLen) input[i] = "0" + input[i]; for(int j=0;j&lt;maxLen;j++) &#123; int now = input[i].charAt(j) - '0'; max[j] = Math.max(max[j], now); min[j] = Math.min(min[j], now); &#125; &#125; int maxx = 0, minn = 0; for(int i=0;i&lt;maxLen;i++) &#123; maxx = maxx * 2 + max[i]; minn = minn * 2 + min[i]; &#125; System.out.println(maxx - minn); &#125; &#125; &#125; 简单思维题 B. Incinerate 题意 给定 \(n\) 个怪物的生命值 \(h_i\) 以及攻击力 \(p_i\)，主角的攻击力为 \(k\)，定义一次攻击为将所有怪物扣去 \(k\) 点生命值，生命值小于等于 \(0\) 的怪物死亡，剩余攻击力最低的怪物将会将主角的攻击力削减到 \(k - p_i\)。输出是否可以将怪打完。 思路 模拟。 我们可以先按照生命值升序排序，维护一个存活的怪物的开始下标 \(index\)，那么想要快速获取到存活的怪物中攻击力最低的，我们可以维护一个后缀数组，存储 \(index\) 及以后的 \(p_{\min}\)。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.util.*; public class Main &#123; private static class Monster&#123; int h, p; Monster(int h)&#123; this.h = h; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); for(int w=0;w&lt;t;w++)&#123; int n = scanner.nextInt(), k = scanner.nextInt(); Monster[] m = new Monster[n]; for(int i=0;i&lt;n;i++) m[i] = new Monster(scanner.nextInt()); for(int i=0;i&lt;n;i++) m[i].p = scanner.nextInt(); Arrays.sort(m, Comparator.comparingInt(o -> o.h)); int[] suf = new int[n + 1]; suf[n] = Integer.MAX_VALUE; for(int i=n-1;i>=0;i--) suf[i] = Math.min(suf[i + 1], m[i].p); int index = 0, attack = 0; while(k > 0)&#123; for(int i=index;i&lt;n;i++)&#123; if(m[i].h - attack > k) break; index ++; &#125; if(index >= n) break; attack += k; k -= suf[index]; &#125; System.out.println(k > 0 ? "YES" : "NO"); &#125; &#125; &#125; 略微暴力但又不暴力（ C. Another Array Problem 题意 给定一个数组 \(a\)，定义操作为选择 \(i, j,i \neq j\)，将所有 \(a_k, k \in [i, j]\) 修改为 \(|a_i - a_j|\)。在任意次操作后，输出数组的总和的最大值。 思路 我们来考虑一下 \(4\) 个及以上的情况： 在这个情况里，我们不妨找出最大值所在的下标 \(imax\)，然后用类似下面的思路完成： \(\begin{array}{l}&gt;&gt;1\ 2\ 4\ 3 \\ =&gt; 1\ 1\ 4\ 3 \\ =&gt; 0\ 0\ 4\ 3 \\ =&gt; 4\ 4\ 4\ 3 \\ =&gt; 4\ 4\ 1\ 1 \\ =&gt; 4\ 4\ 0\ 0 \\ =&gt; 4\ 4\ 4\ 4\end{array}\) 也就是说，我们只需找出最大的值，最后一定有方案将所有数全都改为最大值。 那么 \(3\) 个数呢？此时存在局限性，若最大值在两端，那么和上述一致，但最大值在中间时，我们就只能找出两端的 \(\min , \max\)，然后取 \(a[1]-\min\) 和 \(\max\) 的最大值。 同上，两个数的时候，最大值即为两个元素的差。 当然，我们也可以不操作，所以需要取一下操作后的答案和原总和的最大值。 时间复杂度：\(O(n)?\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); for(int w=0;w&lt;t;w++)&#123; int n = scanner.nextInt(); long[] a = new long[n]; int maxIndex = 0; long sum = 0; for(int i=0;i&lt;n;i++)&#123; a[i] = scanner.nextLong(); sum += a[i]; maxIndex = a[maxIndex] &lt; a[i] ? i : maxIndex; &#125; long ans; if(n == 2) &#123; ans = Math.abs(a[1] - a[0]) * 2; &#125;else if(n == 3)&#123; if(maxIndex == 0 || maxIndex == 2) ans = a[maxIndex] * n; else&#123; long min = Math.min(a[0], a[2]), sMin = Math.max(a[0], a[2]); ans = Math.max(a[maxIndex] - min, sMin) * 3; &#125; &#125;else ans = a[maxIndex] * n; System.out.println(Math.max(sum, ans)); &#125; &#125; &#125; 很巧妙的思维题]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 839 Div. 3</title>
    <url>/blog/posts/3095280907/</url>
    <content><![CDATA[Practice. A. A+B? 题意 给定一个形如 \(a+b\) 的字符串，输出答案。\(a, b \in [0, 9]\)。 思路 模拟。 时间复杂度：\(O(1)\) import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; String[] a = scanner.next().split("\\+"); System.out.println(Integer.parseInt(a[0]) + Integer.parseInt(a[1])); &#125; &#125; &#125; 过于签到，应该有语言可以一行解决吧 B. Matrix Rotation 题意 给定一个 \(2 \times 2\) 的矩阵，定义操作为将矩阵旋转 \(90°\)，输出任意次操作后，能否使矩阵满足下面的条件： 每一行的第一个元素小于第二个元素； 每一列的第一个元素小于第二个元素。 思路 模拟。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt: while(t -- > 0)&#123; int a = scanner.nextInt(), b = scanner.nextInt(), c = scanner.nextInt(), d = scanner.nextInt(); for(int i=0;i&lt;4;i++)&#123; if(a &lt; b &amp;&amp; b &lt; d &amp;&amp; a &lt; c &amp;&amp; c &lt; d)&#123; System.out.println("YES"); continue nxt; &#125; int tmp = b; b = a; a = c; c = d; d = tmp; &#125; System.out.println("NO"); &#125; &#125; &#125; 模拟就完事了 C. Different Differences 题意 给定两个整数 \(k, n\)，构造长度为 \(k\) 且严格递增的数组 \(a\)，其中 \(a_{k - 1} \leq n\)。输出一种构造，使数组 \([a_2 - a_1, a_3 - a_2, \ldots a_k - a_{k - 1}]\) 内不相同的元素数量最大。 思路 若数组无长度和大小限制，那么我们只需输出以 \(1\) 为首项和公差的等差数列的前 \(n\) 项和即可。 考虑到限制，我们在输出第 \(i\) 项的时候，还因考虑它的最大值 \(i + n - k\)，取一个最小值即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int k = scanner.nextInt(), n = scanner.nextInt(); int a = 1; for(int i=1;i&lt;=k;i++)&#123; System.out.printf("%d ", Math.min(a, i + n - k)); a += i; &#125; System.out.println(); &#125; &#125; &#125; 简单构造题 D. Absolute Sorting 题意 给定一个数组 \(a\)，所有元素均为正整数。输出一个 \(x\)，满足将所有数减掉 \(x\) 后取绝对值后的序列不递减。若无解，输出 \(-1\)。 思路 由题意，我们需要满足 \(|a_i - x| \leq |a_{i + 1} - x|\)。 我们不妨先来考虑 \(a_i &lt; a_{i + 1}\) 的情况： \(x \leq a_i\)，那么原式化为 \(a_i \leq a_{i + 1}\)，恒成立； \(x \geq a_{i + 1}\)，那么原式化为 \(a_i \geq a_{i + 1}\)，不成立； \(a_i &lt; x &lt; a_{i + 1}\)，那么原式化为 \(x - a_i \leq a_{i + 1} - x\)，即 \(x \leq \lfloor \frac{a_i + a_{i + 1}}{2} \rfloor\)。 综上所述，\(x \le \lfloor \frac{a_i + a_{i+1}}{2} \rfloor\)。 同理，当 \(a_i &gt; a_{i + 1}\) 时，\(x \ge \lceil \frac{a_i + a_{i+1}}{2} \rceil\)。 因而，我们只需求出左端点的最大值 \(l\) 和右端点的最小值 \(r\)，然后判断 \(l \leq r\) 是否成立即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int pre = scanner.nextInt(); int l = 0, r = Integer.MAX_VALUE; for(int j = 1; j &lt; n; j++) &#123; int cur = scanner.nextInt(); if(pre > cur) l = Math.max(l, (pre + cur + 1) / 2); if(pre &lt; cur) r = Math.min(r, (pre + cur) / 2); pre = cur; &#125; System.out.println(l &lt;= r ? l : -1); &#125; &#125; &#125; 简单的拆绝对值分类讨论]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - TypeDB Forces 2023 Div. 1 + 2</title>
    <url>/blog/posts/1090672605/</url>
    <content><![CDATA[Contestant. Rank 3808. Rating +17. A. Exponential Equation 题意 给定整数 \(n\)，输出一对 \(x, y\)，满足 \(x ^ y \cdot y + y ^ x \cdot x = n\)。 思路 不妨令 \(x = 1\)，那么 \(y = n / 2\)。 显然，当 \(n\) 为奇数的时候，一定是无解的，因为 \(x ^ y \cdot y\) 和 \(y ^ x \cdot x\) 的奇偶性一定是一致的。 所以，\(n\) 为偶数的时候，输出 \(1, n / 2\)。 时间复杂度：\(O(1)\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt: while (t-- > 0) &#123; int n = scanner.nextInt(); if(n % 2 == 1) System.out.println(-1); else System.out.printf("%d %d\n", 1, n / 2); &#125; &#125; &#125; 你说我怎么就这么蠢 B. Number Factorization 题意 给定一个整数 \(n\)，构建数组 \(a, p\)，使 \(n = \prod a_i^{p_i}\)。其中，\(a_i\) 必须为不相同的质数的乘积。 输出 \(\sum a_i \cdot p_i\) 的最大值。 思路 显然，\(a_i ^ {p_i} = a_i \cdot a_i \cdot \ldots\)，那么我们不妨直接拆开，令所有 \(p_i = 1\)。 那么，我们只需分解质因数，分别将出现次数 \(\geq 1\) 次、\(\geq 2\) 次 ... 的数相乘后求和即可。 时间复杂度：不会分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 500010, inf = 0x3f3f3f3f; #define int long long vector&lt;int> primes; bool vis[N]; void init() &#123; for (int i = 2; i &lt;= N; ++i) &#123; if (!vis[i]) &#123; primes.emplace_back(i); &#125; for (int j : primes) &#123; if (1ll * i * j > N) break; vis[i * j] = true; if (i % j == 0) break; &#125; &#125; &#125; vector&lt;tuple&lt;int, int, bool>> fact(int x) &#123; vector&lt;tuple&lt;int, int, bool>> f; for (int i : primes) &#123; if(i > x) break; if (x % i == 0) &#123; int cnt = 0; while (x % i == 0) x /= i, cnt ++; if(cnt != 0) f.emplace_back(i, cnt, false); &#125; &#125; if (x != 1) &#123; f.emplace_back(x, 1, false); &#125; return f; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t, n; cin >> t; while(t --) &#123; cin >> n; vector&lt;tuple&lt;int, int, bool>> f = fact(n); int ans = 0, cnt = f.size(); while(cnt > 0)&#123; int now = 1; for(auto &amp;e : f)&#123; int x, p, ok; tie(x, p, ok) = e; if(ok) continue; now *= x; p --; if(p == 0) get&lt;2>(e) = true, cnt --; get&lt;1>(e) = p; &#125; ans += now; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 写得好乱 C. Remove the Bracket 题意 给定一个数组 \(a\) 以及一个整数 \(s\)，对于所有 \(i \in [2, n- 1]\)，有 \(x_i+y_i=a_i\) 且 \((x_i - s)(y_i - s) \geq 0\)。 构造 \(x_i, y_i\)，让下列式子的值最小，并输出这个值 \(F = a_1 \cdot x_2+y_2 \cdot x_3+y_3 \cdot x_4 + \ldots + y_{n - 2} \cdot x_{n-1}+y_{n-1} \cdot a_n\) 思路 我们不妨来单独考虑 \(x_i,y_i\)： 将其放入式子，我们可以得到 \(\ldots+ y_{i-1}\cdot x_i+y_i\cdot x_{i+1}+\ldots\)。在这段式子里，若 \(x_i + 1,y_i - 1\)，那么整个式子将会减少 \(x_{i + 1} - y_{i - 1}\)。 也就是说，我们希望 \(x_i\) 或 \(y_i\) 取到 \(s\)，因为只有在边界才能找到最值。 因而，我们可以用 \(dp\) 枚举所有我们希望的情况中的最小值。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(), s = console.nextInt(); long[] min = new long[n + 1], max = new long[n + 1]; for(int i=1;i&lt;=n;i++)&#123; int cur = console.nextInt(); if(i == 1 || i == n)&#123; min[i] = max[i] = cur; &#125;else if(cur &lt;= s)&#123; min[i] = 0; max[i] = cur; &#125;else&#123; min[i] = Math.min(s, cur - s); max[i] = Math.max(s, cur - s); &#125; &#125; long[][] dp = new long[n + 1][2]; for(int i=2;i&lt;=n;i++)&#123; dp[i][0] = Math.min(dp[i - 1][0] + max[i - 1] * min[i], dp[i - 1][1] + min[i - 1] * min[i]); dp[i][1] = Math.min(dp[i - 1][0] + max[i - 1] * max[i], dp[i - 1][1] + min[i - 1] * max[i]); &#125; console.println(dp[n][0]); &#125; console.close(); &#125; //快读模板 此处略去 //public static class Console implements Closeable &#123;&#125; &#125; 论想不到dp于是乱找规律这件事]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 849 Div. 4</title>
    <url>/blog/posts/752853425/</url>
    <content><![CDATA[Contestant. Rank 3392. Rating -15. 代码略去了快读模板 A. Codeforces Checking 题意 给定一个字符，判断是否在 \(codeforces\) 字符串中出现。 思路 数组记录 + 读数组。 时间复杂度：\(O(1)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); boolean[] have = new boolean[26]; for(char each : "codeforces".toCharArray()) have[each - 'a'] = true; while(t -- > 0)&#123; console.println(have[console.next().toCharArray()[0] - 'a'] ? "YES" : "NO"); &#125; console.close(); &#125; &#125; 语法题 x1 B. Following Directions 题意 给定一个由 \(U,D,L,R\) 组成的字符串，分别代表向上、下、左、右移动一个单位距离。输出从原点开始移动，途中是否经过 \((1,1)\)。 思路 模拟。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); String step = console.next(); int x = 0, y = 0; for(char each : step.toCharArray())&#123; if(each == 'L') x --; else if(each == 'R') x ++; else if(each == 'U') y ++; else y --; if(x == 1 &amp;&amp; y == 1)&#123; console.println("YES"); continue nxt; &#125; &#125; console.println("NO"); &#125; console.close(); &#125; &#125; 语法题 x2 C. Prepend and Append 题意 给定一个二进制字符串，定义操作为在字符串左端拼接上 \(0\) 并在右端拼接上 \(1\)，或者在字符串左端拼接上 \(1\) 并在右端拼接上 \(0\)。给定的字符串为一个原字符串经过多次操作后得到的。输出最小的原字符串。 思路 遍历，找到第一个位置，满足两端的值相同。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); String in = console.next(); int cnt = 0; for(int i=0;i&lt;n/2;i++)&#123; if((in.charAt(i) == '0' &amp;&amp; in.charAt(n - i - 1) == '1') || (in.charAt(i) == '1' &amp;&amp; in.charAt(n - i - 1) == '0')) cnt ++; else break; &#125; console.println(n - cnt * 2); &#125; console.close(); &#125; &#125; 签到题 x3 D. Distinct Split 题意 给定一个字符串，将字符串分割为两个字符串，第一个字符串中不同字母的数量和第二个字符串中不同字母的数量之和最大，并输出这个最大值。 思路 维护一个前缀不同字母数量和后缀不同字母数量，然后枚举每一位，求 \(pre[i] + suf[i + 1]\) 的最大值。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); char[] s = console.next().toCharArray(); boolean[] ok1 = new boolean[26], ok2 = new boolean[26]; int[] pre = new int[n + 2], suf = new int[n + 2]; for(int i=1;i&lt;=n;i++)&#123; char e = s[i - 1]; pre[i] = pre[i - 1]; if(!ok1[e - 'a']) pre[i] ++; ok1[e - 'a'] = true; &#125; for(int i=n;i>=1;i--)&#123; char e = s[i - 1]; suf[i] = suf[i + 1]; if(!ok2[e - 'a']) suf[i] ++; ok2[e - 'a'] = true; &#125; int ans = 0; for(int i=0;i&lt;n;i++)&#123; ans = Math.max(ans, pre[i] + suf[i + 1]); &#125; console.println(ans); &#125; console.close(); &#125; &#125; 略微有点不签到起来了（（ E. Negatives and Positives 题意 给定一个数组 \(a\)，定义操作为选两个相邻的元素并将它们都取相反数。输出任意次操作后数组的总和的最大值。 思路 首先，因为操作数量不限制，我们不妨来考虑选几个连续的相邻元素。 举个例子，如 \([a,b,c,d,e]\)，我们从第一位开始操作到倒数第二位，操作看起来是这样的： \(\begin{array}{l} &gt;&gt; [-a, -b, c, d, e] \\ =&gt; [-a, b, -c, d, e] \\ =&gt; [-a, b, c, -d, e] \\ =&gt; [-a, b, c, d, -e]\end{array}\) 显然，只要是连续的操作，那么每次操作等效于移动负号的位置。 或者，换句话说，我们完全不需要考虑 “相邻” 这个条件，跳着操作是完全可行的。 那么，我们只需升序排序，然后将负数一对一对取反。 当然，若负数的数量为奇数，那么对于最后剩余的那个奇数，我们只需将其和最小的非负数比较绝对值即可。若负数的绝对值较大，那么直接把负数和最小非负数的符号交换一下即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); long[] a = new long[n]; long sum = 0; int cnt = 0; for(int i=0;i&lt;n;i++)&#123; int cur = console.nextInt(); sum += cur; a[i] = cur; if(a[i] &lt; 0) cnt ++; &#125; Arrays.sort(a); for(int i=0;i&lt;cnt/2*2;i++) sum -= 2 * a[i]; if(cnt % 2 == 1)&#123; int p = cnt / 2 * 2; if(p + 1 &lt; n)&#123; if(-a[p] > a[p + 1])&#123; sum -= 2 * a[p]; sum -= 2 * a[p + 1]; &#125; &#125; &#125; console.println(sum); &#125; console.close(); &#125; &#125; 简单思维题，但是也可以dp~ F. Range Update Point Query 题意 给定一个数组 \(a\) 以及 \(q\) 个询问，询问为下列情况任选其一： 给定 \(l, r\)，将 \([l,r]\) 内的所有数更新为每个数 十进制下每一位的和； 给定 \(x\)，输出 \(a_x\)。 输出询问所要求的内容。 思路 首先，询问 \(1\) 的操作具有收敛性，在 \(1e9\) 的范围内，第一次操作后的最大值只有 \(8 \times 9 = 72\)，那么我们不难发现，对于一个数，我们最多只能操作 \(3\) 次，超过 \(3\) 次后值一定不变。 我们定义一个数组 \(b\)，\(b_i\) 表示第 \(i\) 位已经操作了多少遍。 因而，我们只需考虑一个问题：怎么让区间更新和单点查询效率更高呢？ 没错，就是线段树。 不难发现，我们只需套上线段树的板子，然后略微修改即可。 时间复杂度：不会分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long int n, a[200005][4], d[600000], b[600000]; void update(int l, int r, int c, int s, int t, int p) &#123; if (l &lt;= s &amp;&amp; t &lt;= r) &#123; d[p] += (t - s + 1) * c, b[p] += c; // 如果区间被包含了，直接得出答案 return; &#125; int m = s + ((t - s) >> 1); if (b[p]) d[p &lt;&lt; 1] += b[p] * (m - s + 1), d[(p &lt;&lt; 1) | 1] += b[p] * (t - m), b[p &lt;&lt; 1] += b[p], b[(p &lt;&lt; 1) | 1] += b[p]; b[p] = 0; if (l &lt;= m) update(l, r, c, s, m, p &lt;&lt; 1); // 本行和下面的一行用来更新p*2和p*2+1的节点 if (r > m) update(l, r, c, m + 1, t, (p &lt;&lt; 1) | 1); d[p] = d[p &lt;&lt; 1] + d[(p &lt;&lt; 1) | 1]; // 计算该节点区间和 &#125; int getsum(int l, int r, int s, int t, int p) &#123; if (l &lt;= s &amp;&amp; t &lt;= r) return d[p]; int m = s + ((t - s) >> 1); if (b[p]) d[p &lt;&lt; 1] += b[p] * (m - s + 1), d[(p &lt;&lt; 1) | 1] += b[p] * (t - m), b[p &lt;&lt; 1] += b[p], b[(p &lt;&lt; 1) | 1] += b[p]; b[p] = 0; int sum = 0; if (l &lt;= m) sum =getsum(l, r, s, m, p &lt;&lt; 1); // 本行和下面的一行用来更新p*2和p*2+1的答案 if (r > m) sum += getsum(l, r, m + 1, t, (p &lt;&lt; 1) | 1); return sum; &#125; signed main() &#123; ios::sync_with_stdio(0); int t; cin >> t; while(t --) &#123; memset(a, 0, sizeof a); memset(d, 0, sizeof d); memset(b, 0, sizeof b); int q; cin >> n >> q; for (int i = 1; i &lt;= n; i++) &#123; int cur; cin >> cur; a[i][0] = cur; for(int j=1;j&lt;=3;j++)&#123; int x = a[i][j - 1]; while(x > 0)&#123; a[i][j] += x % 10; x /= 10; &#125; &#125; &#125; while (q--) &#123; int i1; cin >> i1; if(i1 == 1)&#123; int l, r; cin >> l >> r; update(l, r, 1, 1, n, 1); &#125;else&#123; int w; cin >> w; int t = getsum(w, w, 1, n, 1); t = min(3ll, t); cout &lt;&lt; a[w][t] &lt;&lt; '\n'; &#125; &#125; &#125; return 0; &#125; 不可以用Set的lower_bound来略微优雅一点地暴力，会炸 G1. Teleporters (Easy Version) 题意 给定一个数组 \(a\) 以及一个整数 \(c\)，\(c\) 为硬币的总数量，\(a_i\) 表示该传送点需要的硬币数量。定义每自主移动一步会扣除 \(1\) 个硬币，传送点是否使用是可选的，若使用传送点，将会使人物传送到原点，同时消耗对应数量的硬币。初始状态下，人物一定在原点，输出可使用传送点的最大数量。 思路 将 \(a\) 数组的所有数加上离原点的距离，升序排序 \(a\) 然后枚举即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(), c = console.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = console.nextInt() + (i + 1); Arrays.sort(a); int cnt = 0; for(int i=0;i&lt;n;i++)&#123; c -= a[i]; if(c &lt; 0) break; cnt ++; &#125; console.println(cnt); &#125; console.close(); &#125; &#125; 略微有点么签到 G2. Teleporters (Hard Version) 题意 在 \(G1\) 的基础上，传送点可以传送到原点 \(0\) 或 \(n + 1\)，但人物的初始位置一定是原点。 思路 显然，我们一定得枚举，若讨论的话，会特别复杂。 我们考虑存储 \(a_i\) 加上离两端距离的最小值，以及其加上离原点的最大值，按照前者升序排序。 然后，我们枚举所有点，对于所枚举到的点 \(a_i\)，我们将其视为第一个使用的传送点，那么剩余的硬币数量即为 \(c - a[i][1]\)。 也许我们可以像前一题那样直接遍历，但那样显然太复杂了。 我们不妨用前缀和 + 二分的方式，这样便可快速找出最大的满足条件的数量了。 当然，使用前缀和要考虑排除当前作为第一个传送点的点。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(), c = console.nextInt(); long[][] a = new long[n][2]; for(int i=0;i&lt;n;i++) &#123; int cur = console.nextInt(); a[i] = new long[]&#123;cur + Math.min(i + 1, n - i), cur + i + 1&#125;; &#125; Arrays.sort(a, Comparator.comparingLong(o -> o[0])); long[] pre = new long[n + 1]; for(int i=1;i&lt;=n;i++) pre[i] = pre[i - 1] + a[i - 1][0]; long cnt = 0; for(int i=0;i&lt;n;i++)&#123; long nc = c - a[i][1]; int l = 0, r = n, mid, max = 0; while(l &lt;= r)&#123; mid = (l + r) >> 1; if(pre[mid] - ((mid > i) ? a[i][0] : 0) &lt;= nc)&#123; max = Math.max(mid + (mid > i ? 0 : 1), max); l = mid + 1; &#125;else r = mid - 1; &#125; cnt = Math.max(cnt, max); &#125; console.println(cnt); &#125; console.close(); &#125; &#125; 草，赛时一直在分类讨论，快死了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 850 Div. 2</title>
    <url>/blog/posts/2626568649/</url>
    <content><![CDATA[Contestant. Rank 530. Rating +127. 代码略去了快读模板 A1. Non-alternating Deck (easy version) 题意 给定 \(n\) 个颜色相同的卡片，取卡片顺序为 \(A,B,B,A,A,B,B,A,A,B,B,...\)，每次取卡片的数量依次递增，当无法继续取的时候，按照正常顺序，下一个取卡片的人取完所有卡片。输出 \(A,B\) 各取了多少卡片。 思路 暴力模拟。 时间复杂度：\(O(\sqrt n)?\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt() - 1; int w = 2; boolean who = false; int a = 1, b = 0, cnt = 0; while(n >= w)&#123; if(who) a += w; else b += w; n -= w; w ++; cnt ++; if(cnt == 2) &#123; who = !who; cnt = 0; &#125; &#125; if(who) a += n; else b += n; console.print(a + " " + b + "\n"); &#125; console.close(); &#125; &#125; 快速打卡 A2. Alternating Deck (hard version) 题意 给定 \(n\) 个颜色相间的卡片，第一个为白色，取卡片顺序为 \(A,B,B,A,A,B,B,A,A,B,B,...\)，每次取卡片的数量依次递增，当无法继续取的时候，按照正常顺序，下一个取卡片的人取完所有卡片。输出 \(A,B\) 各取了多少白色卡片和多少黑色卡片。 思路 暴力模拟。 多加几个变量标记即可。 时间复杂度：\(O(\sqrt n)?\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt() - 1; int w = 2; boolean who = false; int a1 = 1, b1 = 0, a2 = 0, b2 = 0, cnt = 0; while(n >= w)&#123; if(who) &#123; a1 += w / 2 + w % 2; a2 += w / 2; &#125; else &#123; b1 += w / 2; b2 += w / 2 + w % 2; &#125; n -= w; w ++; cnt ++; if(cnt == 2) &#123; who = !who; cnt = 0; &#125; &#125; if(who) &#123; a1 += n / 2 + n % 2; a2 += n / 2; &#125; else &#123; b1 += n / 2; b2 += n / 2 + n % 2; &#125; console.print(a1 + " " + a2 + " " + b1 + " " + b2 + "\n"); &#125; console.close(); &#125; &#125; 依然是快速打卡 B. Cake Assembly Line 题意 给定 \(n\) 个蛋糕的中心点 \(a\) 以及 \(n\) 个巧克力酱的固定涂抹范围的中心点 \(b\)，蛋糕的大小为 \([a_i - w, a_i + w]\)，巧克力酱的涂抹范围为 \([b_i - h, b_i + h]\)。所有蛋糕均在传送带上，且相对位置不变。输出是否可以移动传送带，让所有的巧克力酱都涂在蛋糕上。 思路 我们设 \(a_l = a[i] - w, a_r = a[i] + w, b_l = b[i] - h, b_r = b[i] + h\)。 显然，我们不可能模拟移动，因为数据范围太大了。 考虑到每一个蛋糕都有对应的最小和最大移动距离，那么我们只需枚举所有蛋糕，更新最小移动距离的最大值和最大移动距离的最小值即可，这样操作之后，\([\min,\max]\) 内的所有移动距离都可以满足条件了。 我们以左边界为参考点，那么对于一个蛋糕，移动距离的最小值为 \(br - ar\)，最大值为 \(bl - al\)。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(), w = console.nextInt(), h = console.nextInt(); long[] a = new long[n], b = new long[n]; for(int i=0;i&lt;n;i++) a[i] = console.nextInt(); for(int i=0;i&lt;n;i++) b[i] = console.nextInt(); long min = Long.MIN_VALUE, max = Long.MAX_VALUE; for(int i=0;i&lt;n;i++)&#123; long al = a[i] - w, ar = a[i] + w, bl = b[i] - h, br = b[i] + h; min = Math.max(min, br - ar); max = Math.min(max, bl - al); &#125; console.println(min &lt;= max ? "YES" : "NO"); &#125; console.close(); &#125; &#125; 只要一个参考点就够了 C. Monsters (easy version) 题意 给定一个序列 \(a\)，定义两种操作为： 选择任意一个非 \(0\) 数，将其减 \(1\)； 将整个序列所有非 \(0\) 数减 \(1\)，若减完后出现至少一个数为 \(0\)，那么本操作循环执行。 输出让整个序列为 \(0\) 的操作 \(1\) 的最小数量。 思路 显然，我们只需升序排序序列，然后构造一个不递减，相邻数之差 \(\leq 1\) 的序列即可。 如 \(1,1,1,4,4,5\)，将其构造为 \(1,1,1,2,2,3\)。 答案即为原序列和该序列的差。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = console.nextInt(); Arrays.sort(a); long cnt = 0, w = 0; for(int i=0;i&lt;n;i++)&#123; if(a[i] != w)&#123; w ++; cnt += a[i] - w; &#125; &#125; console.println(cnt); &#125; console.close(); &#125; &#125; 逾越丁真，鉴定为不开long long D. Letter Exchange 题意 给定 \(m\) 个由 \(w,i,n\) 构成的长度为 \(3\) 的字符串，定义一次操作为指定两个人互换他们的任意一个字符。输出操作数的最小值以及对应的操作方案。 思路 思维+模拟。 首先，由于题给限制，方案一定是存在的，那么互换字符会出现两种可能： \(A\) 缺了 \(a\)，但多了 \(b\)；\(B\) 缺了 \(b\)，但多了 \(a\)；那么 \(A,B\) 交换一下； \(A\) 缺了 \(a\)，但多了 \(c\)；\(B\) 缺了 \(c\)，但多了 \(b\)；\(C\) 缺了 \(b\)，但多了 \(a\)；那么三者互换一下。 对于上述操作，操作 \(1\) 的交换次数是 \(1\)，操作 \(2\) 的交换次数是 \(2\)。 显然，若只执行上面的两个操作，只要不出现无意义操作，操作数一定是最小的。 那么，我们可以执行完所有操作 \(1\) 后再执行操作 \(2\)，因为配对是最容易的，而且配对结束后，剩下的字符一定是满足操作 \(2\) 的条件的。 那么我们可以用数组存储所有 多 \(a\) 少 \(b\) 的数量，然后略微暴力模拟一下即可。 时间复杂度：懒得分析 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt: while(t -- > 0)&#123; int n = console.nextInt(); List&lt;List&lt;Integer>> a = new ArrayList&lt;>(); for(int i=0;i&lt;6;i++) a.add(new ArrayList&lt;>()); //0 wi, 1 wn, 2 iw, 3 in, 4 nw, 5 ni for(int i=1;i&lt;=n;i++)&#123; String now = console.next(); int[] cnt = new int[3]; for(int j=0;j&lt;3;j++)&#123; char e = now.charAt(j); if(e == 'w') cnt[0] ++; else if(e == 'i') cnt[1] ++; else cnt[2] ++; &#125; if(cnt[0] == 1 &amp;&amp; cnt[1] == 1 &amp;&amp; cnt[2] == 1) continue; if(cnt[0] == 3) &#123; a.get(0).add(i); a.get(1).add(i); &#125;else if(cnt[1] == 3)&#123; a.get(2).add(i); a.get(3).add(i); &#125;else if(cnt[2] == 3)&#123; a.get(4).add(i); a.get(5).add(i); &#125;else if(cnt[0] == 2 &amp;&amp; cnt[1] == 0)&#123; a.get(0).add(i); &#125;else if(cnt[0] == 2 &amp;&amp; cnt[2] == 0)&#123; a.get(1).add(i); &#125;else if(cnt[1] == 2 &amp;&amp; cnt[0] == 0)&#123; a.get(2).add(i); &#125;else if(cnt[1] == 2 &amp;&amp; cnt[2] == 0)&#123; a.get(3).add(i); &#125;else if(cnt[2] == 2 &amp;&amp; cnt[0] == 0)&#123; a.get(4).add(i); &#125;else if(cnt[2] == 2 &amp;&amp; cnt[1] == 0)&#123; a.get(5).add(i); &#125; &#125; int cnt = Math.min(a.get(0).size(), a.get(2).size()) + Math.min(a.get(1).size(), a.get(4).size()) + Math.min(a.get(3).size(), a.get(5).size()); int left = Math.max(a.get(0).size(), a.get(2).size()) + Math.max(a.get(1).size(), a.get(4).size()) + Math.max(a.get(3).size(), a.get(5).size()) - cnt; cnt += left / 3 * 2; console.println(cnt); for(int i=0;i&lt;Math.min(a.get(0).size(), a.get(2).size());i++)&#123; console.println(a.get(0).get(i) + " w " + a.get(2).get(i) + " i"); &#125; for(int i=0;i&lt;Math.min(a.get(1).size(), a.get(4).size());i++)&#123; console.println(a.get(1).get(i) + " w " + a.get(4).get(i) + " n"); &#125; for(int i=0;i&lt;Math.min(a.get(3).size(), a.get(5).size());i++)&#123; console.println(a.get(3).get(i) + " i " + a.get(5).get(i) + " n"); &#125; if(left > 0) &#123; boolean b1 = a.get(0).size() > a.get(2).size(), b2 = a.get(1).size() > a.get(4).size(), b3 = a.get(3).size() > a.get(5).size(); for (int i = 0; i &lt; left / 3; i++) &#123; if(b1 &amp;&amp; !b2 &amp;&amp; b3)&#123; console.println(a.get(0).get(a.get(2).size() + i) + " w " + a.get(3).get(a.get(5).size() + i) + " i"); console.println(a.get(4).get(a.get(1).size() + i) + " n " + a.get(3).get(a.get(5).size() + i) + " w"); &#125;else&#123; console.println(a.get(2).get(a.get(0).size() + i) + " i " + a.get(1).get(a.get(4).size() + i) + " w"); console.println(a.get(5).get(a.get(3).size() + i) + " n " + a.get(1).get(a.get(4).size() + i) + " i"); &#125; &#125; &#125; &#125; console.close(); &#125; &#125; 依托答辩，但是Accepted.]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 6</title>
    <url>/blog/posts/3918832662/</url>
    <content><![CDATA[Rank 663/3064. AC 7/12. A. 阿宁的签到题 题意 根据分数输出等级。 思路 一门编程语言的基础之基础。 时间复杂度：\(O(1)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long x = scanner.nextLong(); if(1 &lt;= x &amp;&amp; x &lt;= 7) System.out.println("very easy"); else if(x &lt;= 233) System.out.println("easy"); else if(x &lt;= 10032) System.out.println("medium"); else if(x &lt;= 114514) System.out.println("hard"); else if(x &lt;= 1919810) System.out.println("very hard"); else System.out.println("can not imagine"); &#125; &#125; 送分还不写快点啊（（ B. 阿宁的倍数 题意 给定一个长度为 \(n\) 的数组 \(a\)，下标从 \(1\) 开始，对于 \(q\) 次操作，输出需要输出的内容。 操作分为两种： 修改操作：数组末尾增加一个数 \(x\)。 询问操作：对于所有 \(i&gt;x\)，输出有多少 \(a_i\) 是 \(a_x\) 的倍数。 思路 我们考虑维护两个数组 \(tot,pre\)。 其中，\(tot[a[i]]\) 表示整个序列有多少数是 \(a[i]\) 的倍数，\(pre[i]\) 表示 \([0, i]\) 区间内有多少数是 \(a[i]\) 的倍数。 那么，对于每次查询的 \(x\)，输出 \(tot[a[x]]-pre[x]\) 即可。 我们来考虑一下这两个数组如何构建： 我们可以从前往后遍历，枚举 \(a[i]\) 的所有因数 \(j\)，将所有 \(tot[j]\) 加上 \(1\)，那么我们可以保证最后得到的 \(tot\) 是我们想要的数组，与此同时， 按照上述遍历方法，\(tot[a[i]]\) 就是 \(pre[i]\) 的值。 在修改操作时，我们只需在加入新加的数 \(x\) 的同时，更新 \(tot,pre\) 即可。 时间复杂度：\(O(n \sqrt n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 400010; int a[N], tot[N], pre[N]; signed main() &#123; ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); int n, q; cin >> n >> q; for(int i=1;i&lt;=n;i++)&#123; cin >> a[i]; for(int j=1;j&lt;=a[i]/j;j++)&#123; if(a[i] % j == 0)&#123; tot[j] ++; if(j != a[i] / j) tot[a[i] / j] ++; &#125; &#125; pre[i] = tot[a[i]]; &#125; while(q --)&#123; int op, x; cin >> op >> x; if(op == 1)&#123; a[++ n] = x; for(int j=1;j&lt;=a[n]/j;j++)&#123; if(a[n] % j == 0)&#123; tot[j] ++; if(j != a[n] / j) tot[a[n] / j] ++; &#125; &#125; pre[n] = tot[a[n]]; &#125;else cout &lt;&lt; tot[a[x]] - pre[x] &lt;&lt; '\n'; &#125; return 0; &#125; 比较暴力但又不太暴力的做法 C. 阿宁的大背包 题意 给定背包的数量 \(n\)，\(n\) 个背包的大小构成一个 \(n\) 的排列，按照将相邻背包合成一个新的大背包的方式，经过 \(n-1\) 次合并，得到一个大背包。输出一个排列，满足最终背包最大，并输出值。 合并方式：\([a, b, c, d] \rightarrow [a + b , b + c , c + d]\) 思路 我们直接来考虑 \(5\) 个物品时的合并结果： \(\begin{array}{l}&gt;&gt;[a, b, c, d, e] \\ =&gt; [a + b, b + c, c + d, d + e] \\ =&gt; [a + 2b + c, b + 2c + d, c + 2d + e] \\ =&gt; [a + 3b + 3c + d, b + 3c + 3d + e] \\ =&gt; [a + 4b + 6c + 4d + e] \end{array}\) 我们不妨留意一下从第二次合并后每项的系数，没错，就是杨辉三角。 于是，构建数组就非常明显了：我们只要按 中间向两侧递减 排列即可。 接着，考虑到数据范围并不大，于是下列两种方法均可行： 暴力合并； 计算出杨辉三角，作为系数和数组相乘。 考虑到暴力合并更不用脑子，这边采取方案 \(1\)。 时间复杂度：\(O(n ^ 2)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int n = console.nextInt(); long mod = 1000000007; int[] a = new int[n]; for(int i=0;i&lt;n/2;i++) a[i] = i * 2 + 1; if(n % 2 == 1) a[n / 2] = n; for(int i=0;i&lt;n/2;i++) a[n - i - 1] = (i + 1) * 2; List&lt;Integer> ans = new ArrayList&lt;>(); for(int i=0;i&lt;n;i++) ans.add(a[i]); for(int t=n;t>=2;t--)&#123; List&lt;Integer> now = new ArrayList&lt;>(); for(int i=0;i&lt;t-1;i++) now.add((int)(((long) ans.get(i) + ans.get(i + 1)) % mod)); ans = now; &#125; console.println(ans.get(0)); for(int i=0;i&lt;n;i++) console.print(a[i] + " "); console.close(); &#125; //快读模板，此处略去 //public static class Console implements Closeable &#123;&#125; &#125; 优雅的暴力 D. 阿宁的毒瘤题 题意 给定一个字符串 \(s\)，修改任意一个字符为其他字符，让子序列 \(udu\) 的数量最小，子序列不一定连续。输出修改后的 \(s\)。 思路 不是 \(dp\) !!!! 首先，如果不删掉字符的话，做法就是很简单的 \(dp\)，但这题如果用 \(dp\) 解的话，会特别麻烦，且我无法证明正确性。 反而，这题是一道偏模拟的前缀和。 我们分别考虑删掉一个 \(d\) 和删掉一个 \(u\) 的代价： 对于一个 \(d\)，它的价值为 \(u_{pre} \times u_{suf}\)； 对于一个 \(u\)，它的价值为 \(ud_{pre} + du_{suf}\)。 于是，我们可以考虑前缀和的方法，统计正方向第 \(i\) 位前面有多少 \(u\)，反方向后面有多少 \(u\) 即可。 注意，不止有 \(u,d\) 这两个字符，不要偷懒不写 \(else\ if\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010, inf = 0x3f3f3f3f; int pre[N], ps[N], ss[N]; string s; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> s; int n = s.length(); int cu = 0; for(int i=0;i&lt;n;i++) if(s[i] == 'u') cu ++; int maxx = 0, maxi = 0; for(int i=0;i&lt;n;i++)&#123; if(i > 0) &#123; pre[i] = pre[i - 1]; ps[i] = ps[i - 1]; &#125; if(s[i] == 'u')&#123; pre[i] ++; &#125;else if(s[i] == 'd')&#123; if(maxx &lt; pre[i] * (cu - pre[i]))&#123; maxx = pre[i] * (cu - pre[i]); maxi = i; &#125; ps[i] += pre[i]; &#125; &#125; for(int i=n-1;i>=0;i--)&#123; ss[i] = ss[i + 1]; if(s[i] == 'd') ss[i] += (cu - pre[i]); else if(s[i] == 'u')&#123; if(maxx &lt; ps[i] + ss[i])&#123; maxx = ps[i] + ss[i]; maxi = i; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) cout &lt;&lt; (maxi == i ? 'a' : s[i]); &#125; 做了一个小时dp，最后10分钟才大彻大悟，人快哭出来力 E. 阿宁的生成树 待补充 F. 阿宁的二进制 题意 给定一个长度为 \(n\) 的数组 \(a\)，下标从 \(1\) 开始，定义 \(F(x)=cnt_1\ of\ binary\ x\)。如 \(F(5)=2\)。 对于独立的 \(q\) 次询问，定义一次操作为选定任意一个 \(i\)，执行 \(a_i=F(a_i)\)。给定操作数 \(k\) ，输出 整个数组的最大值 的最小值。 每次询问输出答案后，数组 \(a\) 恢复原样。 思路 我们不妨来考虑 \(1e9\) 范围内二进制下 \(1\) 最多的数，它总共有 \(30\) 个 \(1\)。 对于最大值 \(30\)，我们可以知道，第二次操作后最多只会有 \(4\) 个 \(1\)。 继续操作，剩下最多 \(2\) 个 \(1\)； 继续操作，剩下 \(1\) 个 \(1\)。 也就是说，对于任意 \(1e9\) 范围内的数，我们最多也只能进行 \(4\) 次操作，之后值就为固定的 \(1\)。 换句话说，题给 \(k\) 的范围是唬人的，真正 \(k\) 的范围应为 \(8 e 5\)。 那么，我们不妨先将所有询问都读入，然后桶排序一下，再枚举操作 \(p\) 次后的答案，若次数和询问相同，那么记录答案。我们不妨用大根堆来存储，让时间复杂度降到 \(k \log k\)。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010; pair&lt;int, int> qs[N]; int ans[N]; int F(int x) &#123; int cnt = 0; while (x != 0) &#123; if ((x &amp; 1) == 1) cnt++; x >>= 1; &#125; return cnt; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, q; cin >> n >> q; priority_queue&lt;int> pq; for(int i=0;i&lt;n;i++) &#123; int t; cin >> t; pq.emplace(t); &#125; for(int i=0;i&lt;q;i++)&#123; int t; cin >> t; qs[i] = &#123;t, i&#125;; &#125; sort(qs, qs + q, [](pair&lt;int, int> o1, pair&lt;int, int> o2)&#123;return o1.first &lt; o2.first;&#125;); int i = 0, to = 0; while(to &lt; q)&#123; int t = pq.top(); if(t == 1) break; pq.pop(); i ++; pq.push(F(t)); while(to &lt; q &amp;&amp; qs[to].first == i) ans[qs[to ++].second] = pq.top(); &#125; for(int t=0; t &lt; q; t++) &#123; if(ans[t] == 0) cout &lt;&lt; 1 &lt;&lt; '\n'; else cout &lt;&lt; ans[t] &lt;&lt; '\n'; &#125; &#125; 自从上次做过某题后，老想着会不会可以收敛（（ G. 阿宁的整数配对 题意 给定一个长度为 \(n\) 的数组 \(a\)，选出 \(k\) 对整数，输出每对整数相乘并求和的最大值。 思路 排一个序，从两端取即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), k = scanner.nextInt(); long[] a = new long[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); int l = 0, r = n - 1; long ans = 0; for(int i=0;i&lt;k;i++)&#123; if(a[l] * a[l + 1] > a[r] * a[r - 1])&#123; ans += a[l] * a[l + 1]; l += 2; &#125;else&#123; ans += a[r] * a[r - 1]; r -= 2; &#125; &#125; System.out.println(ans); &#125; &#125; 打卡打卡~ H. 阿宁讨伐虚空 题意 给定 \(x\) 个敌人，在 \([L,R]\) 内随机选一个 \(y\) ，若 \(y &lt; x\)，那么敌人能被攻击到。输出能被攻击到的概率。 思路 如题，分类讨论算一下概率即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 100010; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int x, l, r; cin >> x >> l >> r; if(l > x - 1) cout &lt;&lt; 0; else if(r &lt; x) cout &lt;&lt; 1; else cout &lt;&lt; ((double) (x - l) / (double) (r - l + 1)); &#125; 简简单单签到题 I. 阿宁前往沙城 题意 给定一个无向图，定义操作为选定两条边，将一条边删除，并将另一条边的长度改为 \(1\)。在 操作可在任意时间可执行无限次 的条件下，输出 \(1\) 到 \(n\) 的最短路。 思路 很显然，从第二条路开始，我们直接把前面的路毁掉即可。 所以我们不妨直接把所有边改成 \(1\)，用 \(dijkstra\) 跑一遍最短路即可。 但得到的答案会出现一种特殊情况：最短路将所有边都覆盖了。 在该情况下，第一条只能用原来的长度替代了。 因此，直接套板子然后略微修改一下即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 200010; struct edge &#123; int v, w; &#125;; struct node &#123; int dis, u; bool operator>(const node&amp; a) const &#123; return dis > a.dis; &#125; &#125;; vector&lt;edge> e[N]; int dis[N], vis[N], cnt[N]; priority_queue&lt;node, vector&lt;node>, greater&lt;> > q; void dijkstra(int s) &#123; memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; q.push(&#123;0, s&#125;); while (!q.empty()) &#123; int u = q.top().u; q.pop(); if (vis[u]) continue; vis[u] = 1; for (auto ed : e[u]) &#123; int v = ed.v, w = ed.w; if (dis[v] > dis[u] + w) &#123; dis[v] = dis[u] + w; cnt[v] = cnt[u] + 1; q.push(&#123;dis[v], v&#125;); &#125; &#125; &#125; &#125; signed main()&#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; int minn = 0x3f3f3f3f; for(int i=0;i&lt;m;i++)&#123; int u, v, w; cin >> u >> v >> w; if(u == 1 || v == 1) minn = min(minn, w); e[u].push_back(&#123;v, 1&#125;); e[v].push_back(&#123;u, 1&#125;); &#125; dijkstra(1); cout &lt;&lt; (cnt[n] &lt; m ? cnt[n] : dis[n] + minn - 1); &#125; oi-wiki的板子真好用（划掉 J. 阿宁指指点点 待补充 K. 阿宁大战小红 待补充 L. 阿宁睡大觉 题意 给定一个 \(n\) 行 \(n-i+1\) 列的地图（正方形的左上角），每行的最后一个格子是美梦格子，除 \(m\) 个噩梦格子外，其余格子都可以通过，输出从 \((1,1)\) 走到美梦格子的方案总数。 注意，\(m \leq 10\)。 思路 这题有一个很明显的特点：障碍数远小于总格子数。 不考虑噩梦格子的话，总方案数很好求，即为 \(2^{n-1}\)。但若用类似于 \(dfs\) 的方法去枚举能走的路径，显然是过于复杂的。 有没有一种算法，可以用类似于取补集的方法来大大降低时间复杂度呢？ 也许我们可以枚举不能走的路径，但暴力枚举也是不行的。 这里需要用到 容斥 。 对于两个噩梦格子，它们之间的方案数可以用组合数来求： 每条路径的节点数量是一致的，为 \((\Delta x - 1) + (\Delta y - 1)\)，而每条路径一定会有 \(\Delta x - 1\) 个节点是在 \(x\) 轴方向移动的，所以方案数即为 \(C_{\Delta x + \Delta y - 2}^{\Delta x - 1}\)。 于是，我们只需枚举所有选择即可，这里我们可以考虑用二进制进行状态压缩，直接用二进制位是否是 \(1\) 来考虑这个噩梦节点是否选上。当然也可以无脑递归套 \(for\)，但状压会更好写。 还有一个问题，若我们每次都算一遍两个节点的方案数，未免有些复杂，所以我们可以用 \(O1\) 复杂度的组合数求法。 容斥 我们来考虑三个集合，它们两两相交，且有一部分三个相交在一起，如下图： 容斥原理 - venn 图示例 对，这是一个韦恩图，而且我们可以很容易的得到下面这个式子： \(|A \cup B \cup C| = |A| + |B| + |C| - |A \cap B| - |B \cap C| - |C \cap A| + |A \cap B \cap C|\) 推广之后，对于 \(n\) 个集合的并集，我们只需按上述式子写，其中符号取决于选了几个集合，奇数为正偶数为负。 因而，对于所有噩梦格子的走法，利用容斥即可解决。 线性复杂度的组合数求法 显然，当数据量过大的时候，每次都用一遍 \(for\) 循环是不合理的，那么我们可以考虑预处理阶乘。 由于存在除法取模，我们需要用到乘法逆元，将除法取模转化为乘法取模。 逆元有一个很简单的求法，即费马小定理：对于 \(ab \equiv 1 \pmod p\)，乘法逆元 \(b = a ^ {p - 2}\)。 但每次用一遍快速幂也会提高时间复杂度，因而我们考虑线性求逆元，用到如下递推式： \(inv[i] = (mod - mod / i) \times inv[mod\%i] \ \%mod\) 对于阶乘的逆元，满足 \(facInv[i] = facInv[i - 1] \times inv[i]\ \% mod\) 满足上述条件后，\(C_n^m = fac[n] \times facInv[m]\ \% mod \times facInv[n - m]\ \% mod\)。 线性求逆元的证明 img 时间复杂度：\(O(m \times 2 ^ m)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long #define pii pair&lt;int, int> const int N = 400010, mod = 1e9 + 7; pii a[N], b[N]; int n, m, inv[N], fac[N], facInv[N], pow2[N]; //O1复杂度求组合数 int c(int n, int m)&#123; return fac[n] * facInv[m] % mod * facInv[n - m] % mod; &#125; signed main() &#123; ios::sync_with_stdio(0); cin >> n >> m; for(int i=0;i&lt;m;i++) cin >> a[i].first >> a[i].second; inv[1] = fac[0] = fac[1] = facInv[0] = facInv[1] = pow2[0] = 1; for(int i=2;i&lt;=n*2;i++)&#123; inv[i] = (mod - mod / i) * inv[mod % i] % mod; fac[i] = fac[i - 1] * i % mod; facInv[i] = facInv[i - 1] * inv[i] % mod; &#125; for(int i=1;i&lt;=n;i++) pow2[i] = pow2[i - 1] * 2 % mod; int ans = pow2[n - 1]; for(int i=1;i&lt;(1 &lt;&lt; m);i++)&#123; int t = 0; b[t ++] = &#123;1, 1&#125;; int sign = 1; for(int j=0;j&lt;m;j++)&#123; if((i >> j) &amp; 1)&#123; b[t ++] = a[j]; sign = -sign; &#125; &#125; sort(b, b + t); int now = pow2[n - 1 - (b[t - 1].first + b[t - 1].second - 2)]; for(int j=1; j &lt; t; j++)&#123; if(b[j - 1].second &lt;= b[j].second)&#123; int x = b[j].first - b[j - 1].first + 1, y = b[j].second - b[j - 1].second + 1; now = now * c(x + y - 2, x - 1) % mod; &#125;else&#123; now = 0; break; &#125; &#125; ans += sign * now; &#125; ans = (ans % mod + mod) % mod; cout &lt;&lt; ans &lt;&lt; '\n'; return 0; &#125; 有点震撼的说...]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 848 Div. 2</title>
    <url>/blog/posts/1674252080/</url>
    <content><![CDATA[Contestant. Rank 2756. Rating +40. A. Flip Flop Sum 题意 给定一个只包含 \(1,-1\) 的序列，要求必须进行一次操作，将任意 \(i\) 对应的 \(a_i,a_{i+1}\) 的值取反，输出操作后序列总和的最大值。 思路 显然，若序列是 \(1,-1,1,-1,...\) ，那么操作对总和无影响。 当序列中存在 \(-1,-1\) 时，总和加 \(4\)。 其余情况，即序列中全是 \(1\)，总和减 \(4\)。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int sum = 0, pre = scanner.nextInt(); sum += pre; boolean f1 = false, f2 = false; for(int i=1;i&lt;n;i++)&#123; int a = scanner.nextInt(); sum += a; if(a == pre)&#123; if(!f1) &#123; if (a == -1)&#123; sum += 4; f1 = true; &#125; &#125; &#125;else f2 = true; pre = a; &#125; if(!f1 &amp;&amp; !f2) sum -= 4; System.out.println(sum); &#125; &#125; &#125; 别看错题啊喂 B. The Forbidden Permutation 题意 给定长度为 \(n\) 的排列 \(p\)、长度为 \(m\) 的数组 \(a\)、以及一个正整数 \(d\)，其中数组 \(a\) 无重复元素，且对于任意 \(a_i\) 满足 \(a_i \in [1,n]\) 。定义一次操作为交换相邻元素，输出最少的操作数，满足存在 \(i \in [1,m)\)，有 \(p[a_i] \geq p[a_{i+1}]\) 或 \(p[a_{i+1}] &gt; p[a_i] + d\)。 思路 显然，我们令 \(b[i]=p[a_i]\)，那么只要数组 \(b\) 是非递增的，就无需操作。 否则，我们可以执行下面的两个操作： 找出数组 \(b\) 中相邻差值最小的两个元素，将它们交换位置； 找出数组 \(b\) 中相邻差值最大的两个元素，将小的元素向左移，大的元素向右移，直至距离大于 \(d\)。 因为我们无需考虑最后数组的情况，所以我们只需计算一下即可： 对于操作 \(1\)，\(cnt=dist_{\min}\)； 对于操作 \(2\)，\(cnt=d-dist_{\max}+1\)。 显然，当 \(d\) 过大时，我们无法将元素的距离扩大到 \(d\)，此时只能执行操作 \(1\)。 时间复杂度：\(O(m)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0) &#123; int n = scanner.nextInt(), m = scanner.nextInt(), d = scanner.nextInt(); int[] p = new int[n + 1]; for(int i=1;i&lt;=n;i++) p[scanner.nextInt()] = i; int[] a = new int[m + 1]; int minDist = Integer.MAX_VALUE, maxDist = 0; for(int i=1;i&lt;=m;i++)&#123; a[i] = scanner.nextInt(); a[i] = p[a[i]]; if(i >= 2)&#123; minDist = Math.min(minDist, a[i] - a[i - 1]); maxDist = Math.max(maxDist, a[i] - a[i - 1]); &#125; &#125; if(minDist &lt;= 0 || maxDist > d) System.out.println(0); else&#123; if(d - maxDist + 1 > n - maxDist - 1) System.out.println(minDist); else System.out.println(Math.min(minDist, d - maxDist + 1)); &#125; &#125; &#125; &#125; 分类讨论呐 C. Flexible String 题意 给定两个字符串 \(a,b\)，满足字符串 \(a\) 最多只有 \(10\) 种不同的字母，定义一次操作为： 选择一个 \(i\)，将 \(a_i\) 放入集合 \(Q\)； 任意挑选一个字母，将其放入 \(a_i\)。 其中，集合 \(Q\) 内需要满足最多只有 \(k\) 个不同的字母。 寻找操作方案，让 \(a[l,r]=b[l,r],1 \leq l \leq r \leq n\) 的数量最大，并输出这个最大值。 \(x_1[l,r]=x_2[l,r]\) 表示对于 \(x1,x2\)，它们在 \([l,r]\) 区间内的所有字符都一样。 思路 首先，我们只需考虑选 \(k\) 种不同的字母然后将其标记，最后遍历一遍计算答案即可。 因为数据量较小，且我们无需考虑选择字母的先后，那么 \(Dfs\) 可行。 更具体地说，我们只需找出所有满足 \(a[i] \neq b[i]\) 的 \(a[i]\) 的字母种类 \(cnt\)，然后枚举所有长度为 \(k\) 的组合并计算答案的最大值即可。 暴力即可。 时间复杂度：\(O(C_{cnt}^k \times n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 100010; int n, k; char a[N], b[N]; bool same[N]; char cnt[26]; int ans; vector&lt;int> w; bool use[26]; void dfs(int p, int t)&#123; if(t == k)&#123; int tot = 0, cur = 0; for(int i=0;i&lt;n;i++)&#123; if(same[i] || use[a[i] - 'a']) tot ++; else&#123; cur += (tot + 1) * tot / 2; tot = 0; &#125; &#125; if(tot != 0) cur += (tot + 1) * tot / 2; ans = max(ans, cur); &#125;else&#123; for(int i=p+1;i&lt;w.size();i++)&#123; use[w[i]] = true; dfs(i, t + 1); use[w[i]] = false; &#125; &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while (t--) &#123; memset(cnt, 0, sizeof cnt); cin >> n >> k >> a >> b; for (int i = 0; i &lt; n; i++) &#123; if (a[i] == b[i]) same[i] = true; else cnt[a[i] - 'a']++, same[i] = false; &#125; w.clear(); int sum = 0; for (int i = 0; i &lt; 26; i++) &#123; if (cnt[i]) &#123; w.emplace_back(i); sum ++; &#125; &#125; if (k == 0) &#123; int tot = 0, cur = 0; for (int i = 0; i &lt; n; i++) &#123; if (same[i]) tot++; else &#123; cur += (tot + 1) * tot / 2; tot = 0; &#125; &#125; if (tot != 0) cur += (tot + 1) * tot / 2; cout &lt;&lt; cur &lt;&lt; '\n'; &#125; else &#123; if (sum - k &lt;= 0) &#123; cout &lt;&lt; (n + 1) * n / 2 &lt;&lt; '\n'; &#125; else &#123; ans = 0; for (int i = 0; i &lt;= sum - k; i++) &#123; use[w[i]] = true; dfs(i, 1); use[w[i]] = false; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; &#125; &#125; 不要忘了初始化啊啊啊啊，在功亏一篑中屈服.jpg]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 5</title>
    <url>/blog/posts/1889400236/</url>
    <content><![CDATA[Rank 379/3037. AC 7/12. A. 小沙の好客 题意 给定 \(n\) 个商品，对于 \(Q\) 个询问，挑选最多 \(k\) 个价值不大于 \(x\) 的商品，输出价值和的最大值。 思路 二分前缀和。 或者使用 \(stl\) 里的 \(upperbound\)。 时间复杂度：\(O(n+\log n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), q = scanner.nextInt(); long[] a = new long[n + 1]; for(int i=1;i&lt;=n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); long[] sum = new long[n + 1]; for(int i=1;i&lt;=n;i++) sum[i] = sum[i - 1] + a[i]; while(q -- > 0)&#123; int k = scanner.nextInt(), x = scanner.nextInt(); int l = 1, r = n, mid; while (l &lt;= r) &#123; mid = (l + r) >> 1; if (a[mid] &lt;= x) l = mid + 1; else r = mid - 1; &#125; if(r >= k) System.out.println(sum[r] - sum[r - k]); else System.out.println(sum[r]); &#125; &#125; &#125; 二分别忘了咋写啊草 B. 小沙の博弈 题意 两个很聪明的人进行博弈，每个人面前有无数多个格子，每个格子可以放无限个石子。给定 \(n\) 个石子，两个人交替操作，每次操作可以从这对石子里拿出任意数量的石子并放入第一个没有石子的格子里。 胜负取决于两人面前格子的字典序大小，字典序小的人获胜。 思路 显然，要让字典序小，聪明的人绝对会只拿 \(1\) 个，那么整个问题就简化为对 \(n\) 的奇偶性判断了。 \(n\) 为奇数的时候，后手赢，\(n\) 为偶数的时候，平局。 先手没有必胜策略。 时间复杂度：\(O(1)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); System.out.println(n % 2 == 0 ? "win-win!" : "Yaya-win!"); &#125; &#125; 你这先手怎么这么菜啊.jpg C. 小沙の不懂 题意 对于两个可能含有前导 \(0\) 的数字 \(a,b\)，以及一个长度为 \(10\) 且从 \(0\) 开始的排列 \(p\)，给定 \(a,b\) 按照排列 \(p\) 进行映射操作后的数，数字可能也有前导 \(0\)，判断能否确定原数 \(a,b\) 的大小关系。 注：映射操作指 \(t_i=p_{a_i}\) 思路 分类讨论题。 我们设给定的数为 \(n,m\)，对应于 \(a,b\)。 若 \(n\) 和 \(m\) 的长度相同：若它们完全一致，那么 \(a\) 和 \(b\) 相等；否则无法判断。 若 \(n\) 的长度大于 \(m\)，那么我们先考虑将 \(n\) 和 \(m\) 右对齐后多出来的部分 \(t\)，因为考虑到前导 \(0\)，若 \(t\) 中有至少两个不同的数字，那么 \(t\) 对应的原数部分一定有一个数不是 \(0\)，那么 \(n\) 的位数一定比 \(m\) 多，\(n&gt;m\)；否则，我们设 \(t\) 中唯一出现的数为 \(x\) ，那么我们只要判断 \(n\) 剩下部分的最高位和 \(m\) 的最高位是否都是 \(x\) 即可，如果是的话就无法判断，否则 \(n\) 依旧大于 \(m\)。 反之同理。 时间复杂度：懒得分析 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String a = scanner.next(), b = scanner.next(); int la = a.length(), lb = b.length(); if(a.equals(b)) System.out.println("="); else if(la > lb)&#123; char p = a.charAt(0); boolean f = false; for(int i=1;i&lt;la-lb;i++) &#123; if(a.charAt(i) != p)&#123; f = true; break; &#125; &#125; if(f) System.out.println(">"); else&#123; if(b.charAt(0) == p &amp;&amp; a.charAt(la - lb) != p) System.out.println(">"); else System.out.println("!"); &#125; &#125; else if(lb > la)&#123; char p = b.charAt(0); boolean f = false; for(int i=1;i&lt;lb-la;i++) &#123; if(b.charAt(i) != p)&#123; f = true; break; &#125; &#125; if(f) System.out.println("&lt;"); else&#123; if(a.charAt(0) == p &amp;&amp; b.charAt(lb - la) != p) System.out.println("&lt;"); else System.out.println("!"); &#125; &#125;else System.out.println("!"); &#125; &#125; 题目太阅读理解了 D. 小沙の赌气 题意 两个人打游戏，打下一关需要满足前一关通关。对于每一个人，每轮会给定 \(1\) 个 \([l,r]\) 区间，只要 \(l-1\) 关已通关，那么 \([l,r]\) 内的所有关都瞬间通关，区间可保留到后面使用。输出每一轮的领先情况以及领先数量。 思路 对于一个人的通关情况，我们可以用一个数 \(num\) 来表示，对于每一个区间，我们可以判断它的左边界和 \(num+1\) 的大小关系，若大于，那么无法合并区间，我们将其存下来，否则，我们用右边界更新 \(num\)。 在每次 \(num\) 更新后，因为我们有区间存下来，所以我们需要判断是否可以继续合并。于是，我们可以维护一个左边界的小根堆，将所有左边界 \(\leq num+1\) 的区间全都更新一遍即可。 于是乎，我们比较 \(num\) 即可。 时间复杂度：\(O(n \log k)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; import java.util.concurrent.atomic.AtomicInteger; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[][] x = new int[n][2], y = new int[n][2]; for(int i=0;i&lt;n;i++) x[i] = new int[]&#123;scanner.nextInt(), scanner.nextInt()&#125;; for(int i=0;i&lt;n;i++) y[i] = new int[]&#123;scanner.nextInt(), scanner.nextInt()&#125;; AtomicInteger num1 = new AtomicInteger(0), num2 = new AtomicInteger(0); PriorityQueue&lt;int[]> q1 = new PriorityQueue&lt;>(Comparator.comparingInt(o -> o[0])), q2 = new PriorityQueue&lt;>(Comparator.comparingInt(o -> o[0])); for(int i=0;i&lt;n;i++)&#123; work(x[i], num1, q1); work(y[i], num2, q2); System.out.println(num1.get() == num2.get() ? "win_win!" : (num1.get() > num2.get() ? "sa_win!" : "ya_win!")); System.out.println(Math.abs(num1.get() - num2.get())); &#125; &#125; private static void work(int[] now, AtomicInteger num, PriorityQueue&lt;int[]> q)&#123; if(now[0] > num.get() + 1)&#123; q.offer(now); &#125;else&#123; int r = Math.max(num.get(), now[1]); while(!q.isEmpty())&#123; int[] c = q.peek(); if(c[0] &lt;= r + 1)&#123; q.poll(); r = Math.max(r, c[1]); &#125;else break; &#125; num.set(r); &#125; &#125; &#125; woc怎么这么简单 E. 小沙の印章 待补充 F. 小沙の串串 题意 给定一个字符串 \(n\)，定义一次操作为任意选择一个字符并将其移到最后，输出 \(k\) 次操作后字典序最大的字符串。 思路 因为考虑到字典序的贪心性：只要比较第一个不相同的字符即可判断字典序的大小。 也就是说，我们只需让前几位尽可能大即可。 那么，若两个字母之间存在比他们小的数，我们就可以考虑维护一个 \(l\)，将 \(l+k\) 内的所有元素都移到后面。 对于字符串的输出，我们可以用三个字符串分开存储，最后拼接在一起。 更具体地说，我们可以从大到小枚举所有字母，并从前往后枚举 \([l,l+k]\) 内的该字母，将这些字母全都移到后面，并更新 \(l,k\)。更新之后，可能存在剩余未移到后面的字母，因而在上一个操作前，我们可以直接把 \(l\) 之前的字母删除。 时间复杂度：\(O(n)?\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 100010; queue&lt;int> q[30]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, k; cin >> n >> k; string s, s1, s2, s3; cin >> s; for(int i=0;i&lt;n;i++)&#123; q[s[i] - 'a'].emplace(i); &#125; int l = 0, l1 = 0; while(k)&#123; for(int i=25;i>=0;i--)&#123; while(!q[i].empty() &amp;&amp; q[i].front() &lt; l) q[i].pop(); if(!q[i].empty() &amp;&amp; q[i].front() &lt;= l + k)&#123; int t = q[i].front(); q[i].pop(); k -= t - l; while(l &lt; t) s2 += s[l ++]; s1 += s[l ++]; l1 ++; break; &#125; &#125; if(l == n) break; &#125; for(int i=l;i&lt;n;i++) s3 += s[i]; while(!s1.empty() &amp;&amp; k)&#123; s2 += s1[l1 -- - 1]; s1.pop_back(); k --; &#125; sort(s2.rbegin(), s2.rend()); cout &lt;&lt; (s1 + s3 + s2); &#125; 草，这题很好听懂但很难说明白思路 G. 小沙の编码 待补充 H. 小沙の店铺 题意 给定初始价格 \(x\)，每卖出去 \(k\) 件，单价上涨 \(y\) 元。给定 \(n\) 个客户，第 \(i\) 个客户的购买 \(n - i + 1\) 个商品，单价在每一个客户买完后才会变化。若接待完 \(n\) 个客户都没有卖出去至少 \(T\) 元货物，输出 \(-1\)，否则输出卖出的价钱。 思路 纯模拟打卡题 时间复杂度：\(O(n)?\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 1010; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int x, y, k, n, t; cin >> x >> y >> k >> n >> t; int cnt = 0, tot = 0, now = 0; while("If the world love me")&#123; cnt ++; tot += n * (x + now / k * y); now += n; if(tot >= t) &#123; break; &#125; if(n - 1 &lt;= 0)&#123; cnt = -1; break; &#125; n --; &#125; cout &lt;&lt; cnt; &#125; 差点打卡题卡了一会儿 I. 小沙の金银阁 题意 给定 \(m\) 个灵石，在 \(n\) 次猜测中，给出灵石数量的猜测，猜错会扣除相同数量的灵石，规定只有一次会猜对，输出猜测的最优方案。 思路 乱猜，从 \(m\) 开始除 \(2\) 向上取整，剩余数放到第一位。 时间复杂度：\(O(\log_2 m)?\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long n = scanner.nextLong(), m = scanner.nextLong(); //1e15约2e50 if(n > 51 || m &lt; (1L &lt;&lt; (n - 1))) System.out.println(-1); else&#123; long[] out = new long[60]; for(int i=1;i&lt;n;i++)&#123; out[i] = m / 2 + m % 2; m /= 2; &#125; System.out.printf("%d ", m); for(int i=(int)n-1;i>0;i--) System.out.printf("%d ", out[i]); &#125; &#125; &#125; 正常一点的题解 乱猜就完事了（（ J. 小沙の最短路 待补充 K. 小沙の抱团 easy 题意 给定 \(n\) 个人，定义一个指令为要求以 \(x\) 人为单位抱团，落单的人淘汰，在所有操作都能被所有抱团的人认可的情况下，输出最少操作数。 思路 要让操作被所有人认可，那么应该满足少数服从多数的原则，因而我们可以以 $ + 1$ 为一组，让这样可以让留下的人最少。 暴力模拟求操作数即可 时间复杂度：\(O(\log_2 n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long n = scanner.nextLong(); long cnt = 0; while(n > 2)&#123; cnt ++; n = n / 2 + 1; &#125; System.out.println(cnt); &#125; &#125; 怎么感觉还是乱猜（（ L. 小沙の抱团 hard 题意 在上一题的基础上，指令是给定的，且每个指令有对应的代价，但每个指令可以被重复使用。输出让剩余人数最少的最小代价。 思路 考虑到代价以及重复使用，我们可以用类似于完全背包的写法。 当剩余 \(2\) 人时，一定无法让人数继续减少，所以我们可以从 \(n\) 个人的状态枚举到 \(2\) 个人的状态。 对于当前剩余 \(i\) 个人的情况下，我们枚举所有指令 \((b,x)\)，每个指令执行后剩余的人数即为 \(i - i \% x\)，因而我们可以得到下面的状态转移方程： \(dp[i - i \% x[i]] = min(dp[i - i \% x[i]], dp[i] + b[i])\) 当没有一个指令可行的时候，或者剩余 \(2\) 人时，输出结果。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long const int N = 100010, M = 510, inf = 10000000000ll; struct sb&#123; int b, x; &#125;o[M]; int dp[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i=0;i&lt;m;i++) cin >> o[i].b >> o[i].x; for(int i=2;i&lt;n;i++) dp[i] = inf; bool ok = false; for(int i=n;i>2;i--)&#123; if(dp[i] == inf) continue; bool f = true; for(int j=0;j&lt;m;j++)&#123; int mod = i % o[j].x; if(mod == 0 || i &lt;= o[j].x) continue; dp[i - mod] = min(dp[i - mod], dp[i] + o[j].b); f = false; &#125; if(f) &#123; cout &lt;&lt; dp[i]; ok = true; break; &#125; &#125; if(!ok) cout &lt;&lt; dp[2]; &#125; 简单的dp]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 4</title>
    <url>/blog/posts/127583546/</url>
    <content><![CDATA[Rank 445/3193. AC 6/13. A. 清楚姐姐学信息论 题意 给定 \(a\) 进制和 \(b\) 进制，用该进制下的一定数量的号码牌表示数字。输出用哪个进制可以用 \(a \times b\) 张号码牌表示更多的数。 思路 显然，我们只需比较 \(a ^ b\) 和 \(b ^ a\) 的大小，但我们无需模拟计算，因为只有 \(2,3\) 组合的时候，\(2 &lt; 3,2 ^ 3 &lt; 3 ^ 2\)，其余情况均为 \(a &lt; b , a ^ b &gt; b ^ a\)。所以对该情况特判即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(), b = scanner.nextInt(); if ((a == 2 &amp;&amp; b == 3) || (a == 3 &amp;&amp; b == 2)) System.out.println(3); else System.out.println(Math.min(a, b)); &#125; &#125; 淦，还有特判，被坑了 B. 清楚姐姐学构造 题意 给定数组 \(c\) 和质数 \(m\)，构造两个数组 \(a,b\)，满足下面的同余方程组： \(\left\{\begin{aligned} a_i \equiv a_{N-i-1} \pmod m \\ b_i \equiv -b_{N-i-1} \pmod m \\ c_i \equiv a_i+b_i \pmod m \end{aligned} \right.\) 若可构造，输出 \(YES\) 以及一种构造，否则输出 \(NO\)。 一句话题意 在模系下构造两个数列，一个满足奇函数性质，另一个满足偶函数性质，两个数列的和为任意给定数列。 思路 考虑到对称性，我们不妨设 \(a_i=a_{N-i-1}=x,b_i=m-b_{N-i-1}=y\)。 那么，\(a_i+b_i=x+y,a_{N-i-1}+b_{N-i-1}=x+m-y\)。 代入第三个式子，我们可以得到 \(x+y \equiv c_i \pmod m,x-y \equiv c_{N-i-1} \pmod m\)。 两式相加，\(2x \equiv c_i+c_{N-i-1} \pmod m\)，即 \(x=\frac{c_i+c_{N-i-1}+km}{2},k \in Z\)。 因而，我们只需判断分子的奇偶性，然后即可计算出 \(x\)。 同理可得 \(y\)。 若数组的长度为奇数，那么将会多出来一项 \(N/2\)，观察可得 \(a_i=c_i+km,b_i=0,k \in Z\) 符合题意。 遍历输出即可。 时间复杂度：\(O(\frac{n}{2})\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 100010; #define int long long int a[N], b[N], c[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i=0;i&lt;n;i++) cin >> c[i]; for(int i=0;i&lt;n/2;i++)&#123; int k1 = c[i] + c[n - i - 1], k2 = c[i] - c[n - i - 1], x, y; if(k1 % 2 == 0)&#123; if(m == 2) &#123; x = m + k1; y = m + k2; &#125; else &#123; x = m * 2L + k1; y = m * 2L + k2; &#125; &#125;else&#123; if(m == 2)&#123; cout &lt;&lt; "NO\n"; return 0; &#125;else &#123; x = m + k1; y = m + k2; &#125; &#125; x /= 2; y /= 2; a[i] = a[n - i - 1] = x; b[i] = y; b[n - i - 1] = m - y; &#125; if(n % 2 == 1) &#123; a[n / 2] = c[n / 2]; b[n / 2] = 0; &#125; cout &lt;&lt; "YES\n"; for(int i=0;i&lt;n;i++) cout &lt;&lt; a[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; for(int i=0;i&lt;n;i++) cout &lt;&lt; b[i] &lt;&lt; ' '; &#125; 不会有人暴力吧（（ C. 清楚姐姐学01背包(Easy Version) 题意 给定 \(n\) 个物品以及总容量 \(m\)，第 \(i\) 个物品的体积为 \(w_i\)，价值为 \(v_i\)。任选若干个物品放入背包，满足物品总体积小于容量 \(m\)，运用 \(01\) 背包求出最大价值 \(Val_{\max}\)。 现在，枚举每个物品，将该物品去除后，得到最大价值 \(Val&#39;_i\)，若\(Val&#39;_i&lt;Val_{\max}\)，那么该物品必选，输出 \(0\)；否则输出 \(x\)，满足该物品加上价值 \(x\) 后该物品必选。 \(N,M\) 均不超过 \(100\)。 思路 鉴于本题数据量很小，我们可以直接按照题面进行暴力模拟，对每个物品去掉后的情况进行 \(01\) 背包，若非必选，那么再以去掉该物品后的容量为总容量跑一遍 \(01\) 背包，将结果与 \(Val_{\max}\) 做差 \(+1\) 即可得到答案。 时间复杂度：\(O(nnm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 110, inf = 0x3f3f3f3f; #define int long long int n, m; int w[N], v[N], dp[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> n >> m; for(int i=1;i&lt;=n;i++)&#123; cin >> w[i] >> v[i]; &#125; for (int i = 1; i &lt;= n; i++) for (int l = m; l >= w[i]; l--) &#123; dp[l] = max(dp[l], dp[l - w[i]] + v[i]); &#125; int maxx = dp[m]; for(int i=1;i&lt;=n;i++)&#123; memset(dp, 0, sizeof dp); for (int p = 1; p &lt;= n; p++) &#123; int cw = p == i ? 0 : w[p], cv = p == i ? 0 : v[p]; for (int l = m; l >= cw; l--) &#123; dp[l] = max(dp[l], dp[l - cw] + cv); &#125; &#125; if(maxx > dp[m]) cout &lt;&lt; 0 &lt;&lt; '\n'; else&#123; memset(dp, 0, sizeof dp); for (int p = 1; p &lt;= n; p++) &#123; int cw = p == i ? 0 : w[p], cv = p == i ? 0 : v[p]; for (int l = m - w[i]; l >= cw; l--) &#123; dp[l] = max(dp[l], dp[l - cw] + cv); &#125; &#125; cout &lt;&lt; maxx - dp[m - w[i]] - v[i] + 1 &lt;&lt; '\n'; &#125; &#125; &#125; 令人感慨 D. 清楚姐姐学01背包(Hard Version) 题意 同 \(C\) 题，但 \(N,M\) 不超过 \(5000\)。 思路 暴力解决不了问题了。 我们回到 \(01\) 背包的二维实现：枚举所有物品，以及所有可能的最大容量，取 该状态的价值 和 前一个状态加上当前物品的价值 的最大值。 那么，我们自然可以发现，只要将 \(C\) 题的代码改成二维背包，那么至少最后一个 \(for\) 循环是不必要的，因为对于前 \(i-1\) 个物品，以 \(m-w[i]\) 为最大容量的 \(dp\) 值 我们已经 在前面 以 \(O(n^2)\) 的复杂度 推得了。 那么 \(i\) 后面物品的怎么办？从上面的分析我们可以知道，任意小于 \(m\) 的背包容量对应的答案均可通过 \(O(n^2)\) 的“预处理”得到，那么我们不妨从后往前跑一遍 \(01\) 背包，于是乎，对于第一维为 \(n-i\) 的 \(dp\) 数组，我们只需枚举容量即可。 更具体地 从前往后跑一遍 \(01\) 背包，得到二维数组 \(dpz\)；再从后往前跑一遍 \(01\) 背包，得到二维数组 \(dpf\)； 枚举每一个物品：维护对于 \(dpz\) 的 \(i\) 前一位的状态下容量的前缀最大值数组 \(mxz\)，对于 \(dpf\) 的 \(i\) 后一位的状态下容量的后缀最大值数组 \(mxf\)。然后，遍历前 \(i-1\) 个的最大容量 \(j\)，剩余的分给去掉前 \(i\) 个物品后剩下物品的最大容量，那么，\(mxz[j]+mxf[m-j]\) 的最大值即为 去掉 \(i\) 后的最大价值 \(Val&#39;_i\)。 综合步骤 \(2\) 和暴力做法的最后一个 \(for\) 循环，我们只需将 前 \(i-1\) 个物品，第 \(i\) 个物品，剩下的物品 抽象为三个物品，然后利用 \(01\) 背包的第二层循环计算出必须将 \(i\) 选中的最大值 \(Val&#39;_p\)。 输出 \(\max(0,Val&#39;_i-Val&#39;_p+1)\) 即可。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 5010; #define int long long int n, m; int w[N], v[N], dpz[N][N], dpf[N][N], mxz[N], mxf[N]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> n >> m; for (int i = 1; i &lt;= n; i++) &#123; cin >> w[i] >> v[i]; &#125; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) &#123; dpz[i][j] = dpz[i - 1][j]; dpf[i][j] = dpf[i - 1][j]; if (j >= w[i]) dpz[i][j] = max(dpz[i][j], dpz[i - 1][j - w[i]] + v[i]); if (j >= w[n - i + 1]) dpf[i][j] = max(dpf[i][j], dpf[i - 1][j - w[n - i + 1]] + v[n - i + 1]); &#125; for (int i = 1; i &lt;= n; i++) &#123; memset(mxz, 0, sizeof mxz); memset(mxf, 0, sizeof mxf); for (int j = 1; j &lt;= m; j++) &#123; mxz[j] = max(mxz[j - 1], dpz[i - 1][j]); mxf[j] = max(mxf[j - 1], dpf[n - i][j]); &#125; int vi = 0, vp = 0; for (int j = 0; j &lt;= m; j++) &#123; vi = max(vi, mxz[j] + mxf[m - j]); if (m - j >= w[i]) vp = max(vp, max(mxz[j] + mxf[m - j - w[i]] + v[i], mxf[j] + mxz[m - j - w[i]] + v[i])); &#125; cout &lt;&lt; max(0ll, vi - vp + 1) &lt;&lt; '\n'; &#125; &#125; 居然有点想出来了，毕竟背包就是贪心嘛 E. 清楚姐姐打怪升级 题意 给定 \(N\) 只怪物，第 \(i\) 只怪物的生命值上限为 \(h_i\)，生命恢复速度为 \(v_i\)。主角的攻击间隔为 \(t\)，攻击力为 \(a\)。 对于每个怪物，每个时刻初，恢复 \(v_i\) 点生命值，直至上限 \(h_i\)。 在 \(1+k \times t\) 时刻末，主角挑选一只怪物，扣除 \(a\) 点生命值，若剩余生命值为非正数，则判定怪物死亡。 输出在哪个时刻末可杀死所有怪物。若永远无法杀死则输出 \(-1\)。 思路 贪心。 我们采取将一只怪物杀死再去杀另一只的做法，使每只需要杀死的怪物能恢复的生命值最小。 显然，在下次攻击前，怪物能恢复 \(v_i \times t\) 点血量，如果恢复的血量大于主角攻击力 \(a\)，那么直接输出 \(-1\)。 否则： 如果一击秒杀，时刻 \(+1\)； 否则，在每次砍怪物之后，有效扣血为 \(a - v \times t\)，将其与第一次剩余的血量 \(h-a\) 进行除法运算即可。注意需要特判可能出现的一次砍完的情况。 因最后一只怪物的计算会多出一个单位等待时间，所以我们将其减去。 时间复杂度：\(O(n)\) 对应AC代码 import java.math.*; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long n = scanner.nextLong(), t = scanner.nextLong(), a = scanner.nextLong(); long tick = 0; for(int i=0;i&lt;n;i++)&#123; long h = scanner.nextLong(), v = scanner.nextLong(); if(h &lt;= a) &#123; tick ++; continue; &#125; if(v * t >= a)&#123; System.out.println(-1); return; &#125;else &#123; if ((h - a) % (a - v * t) == 0) tick += ((h - a) / (a - v * t) + 1); else tick += ((h - a) / (a - v * t) + 2); &#125; &#125; System.out.println((tick - 1) * t + 1); &#125; &#125; 模拟+贪心呐 F. 清楚姐姐学树状数组 题意 构建一个 \(2^k\) 的树状数组对应的二叉树，二叉树的中序遍历为节点编号，如下图： 给定 \(q\) 个查询，输出询问的节点在前、中、后序遍历中分别是第几个。 思路 \(Dfs\)。 我们从 \(2^k\) 开始向下遍历，根据树状数组的特性，我们可以知道下一个需要遍历的点的值： 若向左，\(nxt=now-\frac{lowbit(now)}{2}\)；若向右，\(nxt=now+\frac{lowbit(now)}{2}\)。 接着，我们先来看前序遍历的规律：对于下一个节点，若向左子树移动，那么前序遍历的值会 \(+1\)，否则会 \(+lowbit(now)\)。 而对于后序遍历，类似于前序：对于下一个节点，若向右子树移动，那么后序遍历的值会 \(-1\)，否则会 \(-lowbit(now)\)。 特别地，在后续遍历中，从 \(2^k\) 移动到 \(2^{k-1}\) 时，后序遍历只相差 \(1\)，特判即可。 注： 当然，我们也可以用递推的方式，初始化数组后按照找对称点的方式解题。 时间复杂度：\(O(q \log_2x)\) #include &lt;bits/stdc++.h> using namespace std; #define int long long int ans, maxx, x; int lb(int x)&#123; return x &amp; (-x); &#125; void dfs(int now, bool inc) &#123; if (now == x) return; if (now > x) &#123; if (inc) ans++; else ans -= (now == maxx ? 1 : lb(now)); dfs(now - lb(now) / 2ll, inc); &#125; else &#123; if (inc) ans += lb(now); else ans--; dfs(now + lb(now) / 2ll, inc); &#125; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int k, q; cin >> k >> q; maxx = (1ll &lt;&lt; k); while(q --)&#123; cin >> x; ans = 1; dfs(maxx, true); cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; x &lt;&lt; ' '; ans = maxx; dfs(maxx, false); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 你说你这个蠢人怎么连找规律都找不出来呢.jpg G. 清楚姐姐逛街(Easy Version) 题意 给定一个迷宫，终点按照固定方式移动，以题给字符确定方向。给定多个查询，包括一个起点，输出从起点开始到可变终点的最短路。 思路 考虑到查询数量很少，我们采用暴力的做法： 从起点开始 \(Bfs\)，确定能到达的每个点的最短路径长度。 模拟终点移动，若遍历到的点存在路径长度小于等于当前终点移动的长度，那么输出答案。 时间复杂度：\(O(nmq)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 810; #define int long long char mp[N][N]; int dis[N][N], dx[4] = &#123;0, 0, -1, 1&#125;, dy[4] = &#123;-1, 1, 0, 0&#125;; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m, xs, ys, Q; cin >> n >> m >> xs >> ys >> Q; for(int i=0;i&lt;n;i++) cin >> mp[i]; memset(dis, 0x3f, sizeof dis); queue&lt;pair&lt;int, int>> q; q.emplace(xs, ys); dis[xs][ys] = 0; while(!q.empty())&#123; auto t = q.front(); q.pop(); int px = t.first, py = t.second; for(int i=0;i&lt;4;i++)&#123; int x = px + dx[i], y = py + dy[i]; if(x >= 0 &amp;&amp; x &lt; n &amp;&amp; y >= 0 &amp;&amp; y &lt; m &amp;&amp; mp[x][y] != '#' &amp;&amp; dis[x][y] > dis[px][py] + 1) &#123; dis[x][y] = dis[px][py] + 1; q.emplace(x, y); &#125; &#125; &#125; while(Q --)&#123; int x, y, ans, step = 1; cin >> x >> y; while(true)&#123; char cur = mp[x][y]; if(cur == 'L' &amp;&amp; mp[x][y - 1] != '#') y --; else if(cur == 'R' &amp;&amp; mp[x][y + 1] != '#') y ++; else if(cur == 'U' &amp;&amp; mp[x - 1][y] != '#') x --; else if(cur == 'D' &amp;&amp; mp[x + 1][y] != '#') x ++; else &#123; if(dis[x][y] == -1) &#123; ans = -1; break; &#125; &#125; if(dis[x][y] &lt;= step) &#123; ans = step; break; &#125; step ++; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 为啥BFS要这么写才对捏 H. 清楚姐姐逛街(Hard Version) 待补充，倍增+二分答案 I. 清楚姐姐采蘑菇 待补充，莫队+单调性 J. 清楚姐姐学排序 题意 给定数组 \(a\) 的 \(M\) 对元素大小关系，求顺序确定的位置和该位置的元素。 即对于位置 \(k\)，若确定位置在第 \(i\) 位，那么 \(b_k=i\)，否则 \(b_k=-1\)。输出顺序数组 \(b\)。 思路 显然，如果对于一个数，有 \(a\) 个数小于它，\(b\) 个数大于它，那么如果满足 \(a+b+1=n\)，该数的位置就一定唯一确定。 因此，我们直接枚举每个点即可。因为可能存在包含关系 \(a&lt;b,b&lt;c,a&lt;c\)，所以我们需要 \(Dfs\)。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 1010; #define int long long vector&lt;int> e[N][2]; int res[N], vis[N]; int dfs(int x, int t)&#123; if(vis[x]) return -1; vis[x] = true; int ans = 0; for(int each : e[x][t])&#123; ans += dfs(each, t) + 1; &#125; return ans; &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; for(int i=0;i&lt;m;i++)&#123; int x, y; cin >> x >> y; e[x][0].emplace_back(y); e[y][1].emplace_back(x); &#125; memset(res, -1, sizeof res); for(int i=1;i&lt;=n;i++)&#123; memset(vis, 0, sizeof vis); int cntl = dfs(i, 1); vis[i] = false; int cntr = dfs(i, 0); if(cntl + cntr == n - 1) res[cntl + 1] = i; &#125; for(int i=1;i&lt;=n;i++) cout &lt;&lt; res[i] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; 不该不做这题... K. 清楚姐姐玩翻翻乐 待补充 L. 清楚姐姐的三角形I 题意 对于 \(\Delta ABC\)，顶点对应的边分别为 \(l_a, l_b, l_c\)。记 \(V_A=l_b+l_c,V_B=l_a+l_c,V_C=l_a+l_b\)，给定 \(V_A,V_B,V_C\)，输出 \(l_a,l_b,l_c\)。无解输出 \(NO\)。 思路 显然，\(l_a=\frac{V_B+V_C-V_A}{2},l_b=\frac{V_A+V_C-V_B}{2},l_c=\frac{V_A+V_B-V_C}{2}\)，那么我们只需判断两边之和大于第三边以及分子是否为偶数即可。 时间复杂度：\(O(1)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 500010, inf = 0x3f3f3f3f; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, va, vb, vc; cin >> t; while(t -- > 0)&#123; cin >> va >> vb >> vc; int la = vb + vc - va, lb = va + vc - vb, lc = va + vb - vc; if(la % 2 == 1 || lb % 2 == 1 || lc % 2 == 1)&#123; cout &lt;&lt; "NO\n"; &#125;else&#123; la /= 2; lb /= 2; lc /= 2; if(la + lb > lc &amp;&amp; la + lc > lb &amp;&amp; lb + lc > la)&#123; cout &lt;&lt; "YES" &lt;&lt; '\n' &lt;&lt; la &lt;&lt; ' ' &lt;&lt; lb &lt;&lt; ' ' &lt;&lt; lc &lt;&lt; '\n'; &#125;else cout &lt;&lt; "NO\n"; &#125; &#125; &#125; 怎么可以暴力呢 M. 清楚姐姐的三角形II 题意 给定数组长度 \(N\)，构造一个数组，满足相邻三个数不能构成三角形。 思路 \(1,1,2,1,1,2,1,1,2,1,...\) 输出即可 时间复杂度：\(O(n/3)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 500010, inf = 0x3f3f3f3f; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n; cin >> n; for(int i=0;i&lt;n/3;i++)&#123; cout &lt;&lt; "1 1 2 "; &#125; if(n % 3 == 1) cout &lt;&lt; "1"; if(n % 3 == 2) cout &lt;&lt; "1 1"; &#125; 差点斐波那契（（]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 847 Div. 3</title>
    <url>/blog/posts/3800321871/</url>
    <content><![CDATA[Practice. A. Polycarp and the Day of Pi 题意 将输入与 "\(314159265358979323846264338327\)" 比对，输出从头开始匹配成功的最大数量。 思路 模拟即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; String a = "314159265358979323846264338327"; String b = scanner.next(); int n = b.length(), cnt = 0; for(int i=0;i&lt;n;i++)&#123; if(a.charAt(i) != b.charAt(i)) break; cnt ++; &#125; System.out.println(cnt); &#125; &#125; &#125; 题例有给圆周率的值，草 B. Taisia and Dice 题意 给定 \(3\) 个整数 \(n, s, r\)，构造一个数组 \(a\)，满足最大值为 \(s - r\)，数组的长度为 \(n\)，总和为 \(s\)。 思路 从大到小放入能放的最大数即可，上限需要考虑后面是否可以放 \(1\)。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; int s, r; cin >> n >> s >> r; int maxx = s - r; cout &lt;&lt; maxx &lt;&lt; ' '; s -= maxx; for(int i=n-2;i>=0;i--)&#123; int cur = min(6ll, max(1ll, min(maxx, s - i))); cout &lt;&lt; cur &lt;&lt; ' '; s -= cur; &#125; cout &lt;&lt; '\n'; &#125; &#125; 反正别用DFS就行 C. Premutation 题意 给定 \(n\) 的一种排列分别去掉每一位后构成的 \(n-1\) 个子序列，输出原排列。 思路 考虑第一位即可。 第一位中出现次数最多的数即为原排列的第一个数，而出现最少的数所在子序列即为原排列去掉第一个数后的子序列，拼起来即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 110; int a[N][N]; #define int long long signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --) &#123; memset(a, 0, sizeof a); cin >> n; int h1, h2, c1 = 0, c2 = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n - 1; j++) &#123; cin >> a[i][j]; &#125; if(c1 == 0 || h1 == a[i][0]) h1 = a[i][0], c1 ++; else h2 = a[i][0], c2 ++; &#125; int h = c1 > c2 ? h1 : h2; for(int i=0;i&lt;n;i++)&#123; if(a[i][0] != h)&#123; cout &lt;&lt; h &lt;&lt; ' '; for(int j=0;j&lt;n-1;j++) cout &lt;&lt; a[i][j] &lt;&lt; ' '; break; &#125; &#125; cout &lt;&lt; '\n'; &#125; &#125; 找规律就行力 D. Matryoshkas 题意 给定一个数组 \(a\)，将其拆分成任意数量的子序列，满足子序列升序排序后相邻元素相差 \(1\)，且无重复元素，输出子序列的最小数量。 思路 我们可以考虑模拟的做法，将所有子序列抽象为序列中最大的数，作为几堆候选区域： 在升序排序数组 \(a\) 后，我们依次将元素 \(a_i\) 放入，放入前，我们先拿出候选中数值最小的，然后分类讨论： 如果满足 \(+1\) 后和\(a_i\) 相同，那么我们直接将元素放入该候选区域； 如果两数相同，那么两数均可作为下一个数的可能候选区域，所以新建一个区域并放入该数； 否则，那么这个候选区域无法再进行匹配，直接取出并计数。 最后，剩下的堆数加上被取出的堆数即为答案。 当然，为了降低复杂度，考虑使用优先队列。 时间复杂度：\(O(nt \log t),t为队列长度\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); int[] a = new int[n]; PriorityQueue&lt;Integer> q = new PriorityQueue&lt;>(Comparator.comparingInt(o -> o)); for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); int cnt = 0; for(int i=0;i&lt;n;i++)&#123; boolean ok = false; while(!q.isEmpty())&#123; int now = q.poll(); if(now + 1 == a[i]) &#123; q.offer(a[i]); ok = true; break; &#125;else if(now == a[i])&#123; q.offer(a[i]); q.offer(a[i]); ok = true; break; &#125; else cnt ++; &#125; if(!ok) q.offer(a[i]); &#125; System.out.println(cnt + q.size()); &#125; &#125; &#125; 其实可以不用这么模拟，太模拟了（（ E. Vlad and a Pair of Numbers 题意 给定一个整数 \(n\)，满足 \(a \oplus b = \frac{a+b}{2}=n\)，输出满足条件的任意一组 \(a,b\)。 思路 我们先来考虑 \(a \oplus b = a+b=t\)： 对于任意二进制数 \(t\)，当我们从高位向低位遍历时，若遇到 \(1\)，那么我们不妨在 \(a\) 的该位填上 \(1\)，在 \(b\) 的该位上填上 \(0\)，这样即可满足异或运算和加法运算的值一致。 而对于 \(a \oplus b = \frac{a+b}{2}=n\)： 我们注意到有除 \(2\) 的运算，该操作等效于将 \(a+b\) 的二进制结果向低位移动一位，此时，若按照上述做法，我们会发现 \(1\) 的位置恰好差了一位，那么我们就希望能出现进位的操作。 考虑到对于二进制运算，\(11+01=100\)，那么我们不妨在上述做法的基础上，在 \(1\) 后面一位对应的 \(a,b\) 位置上分别填上 \(1,0\)，这样就可以满足我们的需求了。 而显而易见，当 \(1\) 出现在最后一位（奇数），或者有连续的 \(1\) 存在时，即为无解。 时间复杂度：\(O(\log_2n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt: while (t-- > 0) &#123; int n = scanner.nextInt(); //有连着的1就不行 if(n % 2 == 1)&#123; System.out.println(-1); continue nxt; &#125; int a = 0, b = 0; boolean f = false; for(char e : Integer.toBinaryString(n).toCharArray())&#123; int p = e - '0'; if (f) &#123; if (p == 1) &#123; System.out.println(-1); continue nxt; &#125; else &#123; a = a * 2 + 1; b = b * 2 + 1; f = false; &#125; &#125; else &#123; f = p == 1; a *= 2; b *= 2; if(f) a ++; &#125; &#125; System.out.printf("%d %d\n", a, b); &#125; &#125; &#125; 真的不是找规律题么（（ F. Timofey and Black-White Tree 题意 对于一个 \(n\) 个点 \(n-1\) 个边的无向无环图，给定操作顺序，将 \(n\) 个点按照顺序涂成黑色，输出从第 \(2\) 个操作开始，对于每次操作后，所有任意两个黑点的距离的最小值。 思路 我们可以考虑树形 \(dp\) 的写法，其中 \(dp[i]\) 表示第 \(i\) 个点 在涂色前 该点的所有子节点中 黑色的点到该点的最短距离。 难道我们要把子节点全都遍历一遍吗？显然不用。 这是一个无向无环图，那么显然一个点只有一个父节点，只要根节点确定了，我们构建一个数组即可。 因此，我们不妨从要涂色的点开始，向上 \(Dfs\) 到根节点，在遍历的同时记录当前已经遍历的边数 \(st\)。在遍历到节点 \(i\) 时，我们以这个点为跳板，用 \(dp[i]+st\) 更新最终答案，并将 \(dp[i]\) 更新为 \(\min(dp[i],st)\) 即可。 深搜剪枝 根节点的确定：在绝大多数情况下，取子节点最多的点作为根节点是更优的，这样可以让链条结构更多，从而一定程度降低时间复杂度； 只遍历父节点 \(st&gt;=ans\) 时，结束遍历：显然，我们需要求答案的最小值，那么就算我们继续遍历，最后更新的 \(dp\) 值是一定大于等于 \(ans\) 的，因而我们就没必要 让其他将要涂黑的点 以这个点为跳板 来更新 \(ans\) 了。而恰恰因为我们至少遍历了 \(ans-1\) 个，可以保证 最小路径所在边 一定被我们遍历过了，因而答案没有问题。 整体来看 确定根节点； 从根节点开始向下 \(Dfs\) 一遍，求出每个点的父节点； 依次遍历要涂黑的点，向上 \(Dfs\) 并更新 \(dp\) 值。 时间复杂度：不会分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 200010, inf = 0x3f3f3f3f; #define int long long vector&lt;int> e[N]; int dp[N], c[N], root, ans, vis[N], f[N];//cut2: 只遍历爹，因为爹只有一个（无环 void dfs1(int fa)&#123; for(int p : e[fa])&#123; if(vis[p]) continue; vis[p] = true; f[p] = fa; dfs1(p); &#125; &#125; void dfs2(int child, int st)&#123; if(st >= ans) return; //cut3: 步数那么多就没必要继续走，防止每次都被卡O(n) if(dp[child] != inf) ans = min(ans, dp[child] + st); dp[child] = min(st, dp[child]); if(child != root) dfs2(f[child], st + 1); &#125; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --) &#123; cin >> n >> c[0]; for(int i=1;i&lt;n;i++) &#123; cin >> c[i]; dp[i] = inf; vis[i] = false; e[i].clear(); &#125; dp[n] = inf; vis[n] = false; e[n].clear(); int maxx = -1; root = 1; //cut1: 根节点选分支最多的 for(int i=1;i&lt;n;i++)&#123; int u, v; cin >> u >> v; e[u].emplace_back(v); e[v].emplace_back(u); int s1 = e[u].size(), s2 = e[v].size(); if(max(s1, s2) > maxx) &#123; maxx = max(s1, s2); root = s1 > s2 ? u : v; &#125; &#125; dfs1(root); ans = inf; dfs2(c[0], 0); for(int i=1;i&lt;n;i++)&#123; dfs2(c[i], 0); cout &lt;&lt; ans &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; &#125; &#125; 我趣，怎么一遍过]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 844 Div. 1 + 2</title>
    <url>/blog/posts/405635716/</url>
    <content><![CDATA[Contestant. Rank 4776. Rating -20 (+30 -50). A. Parallel Projection 题意 给定一个长方体，在长方体的顶部和底部各取一个点，一只蚂蚁只能在平面上向平行于边的方向移动，求出蚂蚁从一个点移动到另一个点的最短路径。 思路 从四个方向分别模拟一下求最小值即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int w = scanner.nextInt(), d = scanner.nextInt(), h = scanner.nextInt(); int a = scanner.nextInt(), b = scanner.nextInt(), f = scanner.nextInt(), g = scanner.nextInt(); int p1 = Math.min(a + f + Math.abs(g - b), b + g + Math.abs(f - a)); a = w - a; b = d - b; f = w - f; g = d - g; int p2 = Math.min(a + f + Math.abs(g - b), b + g + Math.abs(f - a)); System.out.println(h + Math.min(p1, p2)); &#125; &#125; &#125; 还是用蚂蚁理解更加经典（（ B. Going to the Cinema 题意 给定数组 \(a\)，对于任意 \(i\)，提出一个要求：“我只在 不算上我的前提下 至少有 \(a_i\) 个人陪我一起去 的前提下去电影院，否则我会难过。” 注意考虑逆否命题：“我不去电影院，而且只有不到 \(a_i\) 个人抛下我去电影院，我依然是开心的，否则我也会难过。” 输出所有不让任何人伤心的安排的总数。 思路 首先，显然我们一定得让 \(a_i=0\) 的人全都去电影院，不然逆否命题一定不成立。 接着，我们遍历剩下按升序排序的 \(a_i\)，同理找出必须去的人，在找出第一个不一定要去的人的时候停止遍历。 然后，我们遍历后面可以不选上的人，并在选上后判断后者是否必须去。 最后，所有可以不选上的人的个数即为答案，因为若在递增序列里间隔选人，会导致命题不成立。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); int[] a = new int[n]; for (int i = 0; i &lt; n; i++) a[i] = scanner.nextInt(); Arrays.sort(a); int c = 0, i = 0, ans = 0; for(;i&lt;n;i++)&#123; if(a[i] == 0) c ++; else if(a[i] &lt;= c) c ++; else break; &#125; ans++; while (i++ &lt; n) &#123; c++; if (a[i] &lt;= c) &#123; ans++; while (i &lt; n &amp;&amp; a[i] &lt;= c) &#123; i++; c++; &#125; &#125; &#125; System.out.println(ans); &#125; &#125; &#125; 云里雾里 C. Equal Frequencies 题意 给定一个字符串 \(s\)，定义一次操作为替换 \(s_i\) 为任意其他字母，输出操作数最少的结果，使结果中所有字母出现的次数均相同。 思路 考虑到小写字母只有 \(26\) 个，我们不妨枚举所有可能的段数，找出操作数最少的情况然后输出即可。 如何判断操作数最少呢？对于每个字母 \(c\)，我们不难发现：\(\min(\frac{n}{k},freq_c)\) 即为当前需要保留的数量。因此，去除保留的数量，剩余即为操作数。 确定段数之后，我们先将字符串中各个字母按照出现次数降序排序，然后从头开始遍历每一个字母，若字母数量过多，那么将多出来的位置留空，如果过少，那么在留空的位置填上缺少的字母。最后将序列输出即可。 时间复杂度：\(O(n^2)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); char[] o = scanner.next().toCharArray(); List&lt;Pair&lt;Integer, List&lt;Integer>>> f = new ArrayList&lt;>(); for(int i=0;i&lt;26;i++) f.add(new Pair&lt;>(i, new ArrayList&lt;>())); for(int i=0;i&lt;n;i++) f.get(o[i] - 'a').B.add(i); f.sort(Comparator.comparingInt(o1 -> -o1.B.size())); int best = 0, cnt = 1, cur; for(int i=1;i&lt;=26;i++)&#123; if(n % i > 0) continue; cur = 0; for(int j=0;j&lt;i;j++) cur += Math.min(n / i, f.get(j).B.size()); if(best &lt; cur)&#123; best = cur; cnt = i; &#125; &#125; System.out.println(n - best); List&lt;Integer> extra = new ArrayList&lt;>(); char[] res = new char[n]; for(int i=0;i&lt;cnt;i++)&#123; for(int j=0;j&lt;n/cnt;j++)&#123; if(j &lt; f.get(i).B.size())&#123; res[f.get(i).B.get(j)] = (char) ('a' + f.get(i).A); &#125;else&#123; extra.add(f.get(i).A); &#125; &#125; &#125; int p = 0; for(int i=0;i&lt;n;i++)&#123; System.out.printf("%c", res[i] == 0 ? (char) ('a' + extra.get(p ++)) : res[i]); &#125; System.out.println(); &#125; &#125; //实现cpp里的pair 此处略去 //public static class Pair&lt;A, B>&#123;&#125; &#125; 没想到暴力直接取段数 D. Many Perfect Squares 题意 给定数组 \(a\)，输出将整个数组加上任意非负数 \(x\) 后完全平方数的最多个数。 思路 首先，答案绝对是 \(\geq1\) 的，那么我们来考虑 \(&gt; 1\) 的情况，也就是在该情况下枚举所有 \(a_i,a_j\)，满足 \(a_i+x=p^2,a_j+x=q^2\)，然后再枚举所有数，统计完全平方数个数即可。 那么我们来考虑下如何枚举 \(x\)： 显然，\(a_j - a_i = q^2 - p^2 = (q - p)(q + p)\)，那么 \(q-p\) 即为 \(a_j-a_i\) 的因数，因为数据范围不大，直接暴力枚举所有因数是可行的。 设因数为 \(d\)，我们可以得到下面的式子 \(\begin{cases} q - p = d \\ q + p = \frac{a_j - a_i}{d} \end{cases}\) 继续化简，得到 \(\begin{cases} p = \frac{1}{2}(\frac{a_j - a_i}{d} - d) \\ q = \frac{1}{2}(\frac{a_j - a_i}{d} + d) \\ \end{cases}\) 也就是说，只要括号内的式子是偶数，那么 \(d\) 即为一种可行解。 时间复杂度：\(O(n^2f(x)),f(x)为差值的因数个数\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 500010; #define int long long int a[60]; signed main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, n; cin >> t; while(t --)&#123; cin >> n; for(int i=0;i&lt;n;i++) cin >> a[i]; int ans = 1; for(int i=0;i&lt;n-1;i++) for(int j=i+1;j&lt;n;j++) &#123; int d = a[j] - a[i], x; for (int p=1;p&lt;=d/p;p++) &#123; if(d % p == 0)&#123; if((d / p - p) % 2 == 1 || (d / p + p) % 2 == 1) continue; x = ((d / p - p) / 2) * ((d / p - p) / 2) - a[i]; if(x &lt; 0) continue; int cnt = 0; for(int e=0;e&lt;n;e++)&#123; int s = floor(sqrt(a[e] + x)); if(s * s == a[e] + x) cnt ++; &#125; ans = max(ans, cnt); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 好一个暴力枚举]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 845 Div. 2 and ByteRace 2023</title>
    <url>/blog/posts/1008203407/</url>
    <content><![CDATA[Practice. A. Everybody Likes Good Arrays! 题意 给定一个数组 \(a\)，定义一次操作为将奇偶性相同的相邻元素相乘并合并为一个元素，输出让数组 \(a\) 满足所有相邻数奇偶性不同的最小操作数量。 思路 显然，奇偶性相同的两个数相乘后奇偶性是不变的，那么我们只需统计有多少组相邻元素的奇偶性相同即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int cur = scanner.nextInt() % 2; int cnt = 0; for(int i=1;i&lt;n;i++)&#123; int a = scanner.nextInt(); if(a % 2 == cur) cnt ++; else cur = a % 2; &#125; System.out.println(cnt); &#125; &#125; &#125; 还是挺简单的思维题 B. Emordnilap 题意 给定一个整数 \(n\)，对于所有 \(n\) 的排列，分别将各个排列镜像复制到右边，输出所有新数对的逆序对的总数量。 思路 可以证明，对于任意一个排列，所有大于 \(1\) 的数字 \(t\) 总能在其右边找到总共为 \(2 \times (t-1)\) 个比它小的数，从而构成对应数量的逆序对。因而，对于一个长度为 \(n\) 的排列，进行镜像复制后，逆序对总数为 \(2 \times (1+2+...+(n-1))=n \times (n-1)\)。 显然，对于 \(n\)，总共有 \(A_n^n\) 种排列，与上式相乘即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; long n = scanner.nextInt(); long fact = 1L, mod = 1000000007; for(long i=2;i&lt;=n;i++) fact = (fact * (i % mod)) % mod; System.out.println((((fact * (n % mod)) % mod) * ((n - 1) % mod)) % mod); &#125; &#125; &#125; 难得B题想的这么快 C. Quiz Master 题意 给定数组 \(a\)，选择任意可不连续的子序列 \(b\)，满足对于任意 \(t \in [1,m]\)，有 \(b_i \bmod t = 0\)，输出满足条件的子序列中 \(b_{\max}-b_{\min}\) 的最小值。 思路 双指针，类似于滑动窗口的解法。 我们考虑用双指针维护一个 \([l,r]\) 的满足题意的区间，在向右移动 \(r\) 的同时，找出满足条件的 \(l\) 的最小值即可。 更具体地说，我们可以开一个数组 \(cnt\) ，在向右移动 \(r\) 之前，我们先将 \(a[r]\) 的所有因子 \(f[a[r]]\) 对应的 \(cnt[f[a[r]]] +1\)，并在加之前判断值是否为 \(0\)，如果是，那么这个因数是第一次出现，因此即可统计 \([1,m]\) 是否被完全覆盖。向右移动 \(l\) 之前的操作与上述操作类似。 时间复杂度：\(O(n \times f(x)),f(x)为x的因数数量\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; static int N = 100010; private static List&lt;List&lt;Integer>> init()&#123; List&lt;List&lt;Integer>> res = new ArrayList&lt;>(); for(int i=0;i&lt;=N;i++) res.add(new ArrayList&lt;>()); for(int i=1;i&lt;=N;i++) for(int j=i;j&lt;=N;j+=i)&#123; res.get(j).add(i); &#125; return res; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); List&lt;List&lt;Integer>> f = init(); int t = scanner.nextInt(); nxt: while(t -- > 0)&#123; int n = scanner.nextInt(), m = scanner.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a); int l = 0, r = 0, best = Integer.MAX_VALUE, now = 0; int[] cnt = new int[N]; while(r &lt; n)&#123; for(int each : f.get(a[r]))&#123; if(each > m) break; if(cnt[each] == 0) now ++; cnt[each] ++; &#125; while(now == m)&#123; best = Math.min(a[r] - a[l], best); for(int each : f.get(a[l]))&#123; if(each > m) break; if(cnt[each] == 1) now --; cnt[each] --; &#125; l ++; &#125; r ++; &#125; System.out.println(best == Integer.MAX_VALUE ? -1 : best); &#125; &#125; &#125; 妙啊.jpg]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 846 Div. 2</title>
    <url>/blog/posts/871658605/</url>
    <content><![CDATA[Contestant. Unrated, with problem C removed. A. Hayato and School 题意 给定一个数组 \(a\)，输出一对下标，满足下标对应的元素的和为奇数。保证数组 \(a\) 至少有 \(3\) 个元素。 思路 分类讨论： 奇数元素数量大于 \(3\)，直接输出前三个奇数。 偶数只有 \(1\) 个，或者没有奇数，无解。 输出一对”奇，偶，偶“即可。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 310; pair&lt;int, int> a[N], b[N]; #define ll long long int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; int n; cin >> n; int o = 0, e = 0; for(int i=1;i&lt;=n;i++)&#123; int p; cin >> p; if(p % 2 == 0) a[e ++] = &#123;p, i&#125;; else b[o ++] = &#123;p, i&#125;; &#125; if(o >= 3)&#123; cout &lt;&lt; "YES" &lt;&lt; '\n'; cout &lt;&lt; b[0].second &lt;&lt; " " &lt;&lt; b[1].second &lt;&lt; " " &lt;&lt; b[2].second &lt;&lt; '\n'; &#125;else if(o == 0 || e == 1)&#123; cout &lt;&lt; "NO" &lt;&lt; '\n'; &#125;else&#123; cout &lt;&lt; "YES" &lt;&lt; '\n'; cout &lt;&lt; b[0].second &lt;&lt; " " &lt;&lt; a[0].second &lt;&lt; " " &lt;&lt; a[1].second &lt;&lt; '\n'; &#125; &#125; &#125; 这么签的题居然WA了，淦 B. GCD Partition 题意 给定一个数组 \(a\)，将数组 \(a\) 切割为任意数量的连续段，满足相邻区间头尾没有交集，对每段分别求和，输出求和后所有和的最大公约数的最大值。 思路 可以证明，分隔为两段后可以保证取到 \(gcd_{\max}\)，因此我们枚举即可。 若需略微证明，因求出的 \(gcd\) 一定是 \(sum_a / d\) (\(d\) 是段数) 的因数，显然 \(d\) 越小，能遍历到的因数就更多，所以分两段即可。 既然分两段，暴力即可。 时间复杂度：\(O(n \times f(x)),f(x)指gcd函数复杂度\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; private static long gcd(long a, long b) &#123; while(b != 0) &#123; long tmp = a; a = b; b = tmp % b; &#125; return a; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); long tot = 0; long[] a = new long[n + 1]; for(int i=1;i&lt;=n;i++) tot += a[i] = scanner.nextInt(); long ans = 1, sum = 0; for(int i=1;i&lt;n;i++)&#123; sum += a[i]; ans = Math.max(ans, gcd(sum, tot - sum)); &#125; System.out.println(ans); &#125; &#125; &#125; 怎么还会去想分段怎么分呢，真是，淦 D. Bit Guessing Game 题意 互动游戏，对于一个未知数 \(n\)，有最多 \(30\) 次的猜测机会。对于每次给出的二进制下 \(n\) 中 \(1\) 的个数，允许减去一个值 \(x\)，使 \(n=n-x\)，\(n\) 值得改变会影响下一轮数量的给出。若能确定答案，输出即可。 思路 我们考虑到题给范围为 \(10^9\)，此时二进制的最大位数恰好为 \(30\)，那么我们不妨枚举所有位的情况。 首先，对于一个二进制数，我们引入一个结论： 若某一位为 \(1\)，我们将该位减去后，一定可以保证 \(1\) 的数量恰好 \(-1\)； 而若某一位为 \(0\)，则恰好相反，我们找不出有一种情况满足 \(1\) 的数量恰好 \(-1\)。 因此，我们可以从低位向高位枚举，若满足条件，那么将目标数字的该位标为 \(1\)，否则，在下一次猜测的时候，我们需要减去原先被我们减去的值，以达到反悔的目的。而显然，无论我们减去多少原先的值，最后剩下的数一定大于 \(0\)，因此方案可行。 时间复杂度：\(O(\log_2n)\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int cnt = scanner.nextInt(); int ans = 0, b = 0, on = 0; while(cnt > 0)&#123; System.out.printf("- %d\n", (1 &lt;&lt; on) - b); System.out.flush(); int now = scanner.nextInt(); if(now == -1) return; //wa了... if(cnt - now == 1) &#123; b = 0; cnt = now; ans += 1 &lt;&lt; on; &#125; else b += (1 &lt;&lt; on) - b; on ++; &#125; System.out.printf("! %d\n", ans); System.out.flush(); &#125; &#125; &#125; 我跟自己写的代码玩游戏.jpg]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 843 Div. 2</title>
    <url>/blog/posts/1640782794/</url>
    <content><![CDATA[Contestant. Rank 6984. Rating -84 (+16 -100). A1. Gardener and the Capybaras (easy version) 题意 给定一个由 \(a\) 和 \(b\) 构成的字符串，将其分成三部分 \(a,b,c\)，输出一种分法，让 \(b\) 成为三者中的最值。 对于两个字符串 \(x\)，\(y\)，若 \(x &lt; y\)，当且仅当下面任意一个条件成立： \(x\) 是 \(y\) 的前缀，但\(x \neq y\)； \(x_1=&#39;a&#39;,y_1=&#39;b&#39;\)。 思路 我们分成两个情况考虑： 遍历 \([2,n-1]\)，若出现 \(a\)，那么让 \(&#39;a&#39;\) 单独成为中间的字符，这样中间的字符一定是最小的，直接输出即可。 如果不存在，那么我们让 \([2,n-1]\) 的所有字符作为中间的字符串，因为第一位为 \(b\)，且足够长，一定可以保证其为最大。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t -- > 0)&#123; char[] a = scanner.next().toCharArray(); int n = a.length; for(int i=1;i&lt;n-1;i++)&#123; if(a[i] == 'a')&#123; for(int j=0;j&lt;i;j++)&#123; System.out.print(a[j]); &#125; System.out.print(" a "); for(int j=i+1;j&lt;n;j++)&#123; System.out.print(a[j]); &#125; System.out.println(); continue nxt; &#125; &#125; System.out.printf("%c ", a[0]); for(int i=1;i&lt;n-1;i++) System.out.print(a[i]); System.out.printf(" %c", a[n - 1]); System.out.println(); &#125; &#125; &#125; 怎么会是呢，简单思维题怎么能想那么久呢 A2. Gardener and the Capybaras (hard version) 题意 参见 \(A1\) 题。差别是数据量更大。 思路 参见 \(A1\) 题。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main &#123; public static void main(String[] args) throws Throwable&#123; Console console = new Console(); int t = console.nextInt(); nxt:while(t -- > 0)&#123; char[] a = console.next().toCharArray(); int n = a.length; for(int i=1;i&lt;n-1;i++)&#123; if(a[i] == 'a')&#123; for(int j=0;j&lt;i;j++)&#123; console.print(a[j]); &#125; console.print(" a "); for(int j=i+1;j&lt;n;j++)&#123; console.print(a[j]); &#125; console.println(); continue nxt; &#125; &#125; console.print(a[0] + " "); for(int i=1;i&lt;n-1;i++) console.print(a[i]); console.print(" " + a[n - 1]); console.println(); &#125; console.close(); &#125; //快读模板 此处省略 //public static class Console implements Closeable &#123;&#125; &#125; java在输入多的时候记得用快读 B. Gardener and the Array 题意 给定数组 \(c\)，输出 是否有两个可不连续的不同子序列 满足 将 序列的所有数 进行 或运算 后得到的数相等。 思路 将每个数转为二进制，记录二进制下每一位有多少个数为 \(1\)。 遍历所有数，若有一个数每一位都出现了不止 \(2\) 次，那么这个数可以被删去，从而和整个序列的或运算值相等。 若没有一个数满足上面的条件，输出 \(NO\)。 不宜开二维数组。 时间复杂度：\(O(nk)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; int main() &#123; int T, n, k, p; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n); vector&lt;vector&lt;int>> c(n); map&lt;int, int> cnt; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;k); for (int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;p); c[i].push_back(p); cnt[p]++; &#125; &#125; bool res = false; for (int i=0;i&lt;n;i++) &#123; bool f = true; for (int j=0;j&lt;c[i].size();j++) &#123; if (cnt[c[i][j]] &lt; 2) f = false; &#125; if (f) &#123; res = true; break; &#125; &#125; printf(res ? "Yes\n" : "No\n"); &#125; &#125; 既然不好用二维数组，那就果断vector C. Interesting Sequence 题意 给定两个数 \(n,x\)，输出满足 \(n\&amp;(n+1)\&amp;(n+2)\&amp;...\&amp;m=x\) 的 \(m\) 值，若不存在，输出 \(-1\)。 思路 首先，观察可得，我们无法让 \(n\) 变大，因为随着 \(n\) 的递增，较低位会出现 \(0\)，从而使整个数减小。 其次，我们只能让一些低位变成 \(0\)，所以我们可以遍历每一位，此处可以分类讨论： \(n\) 中是 \(0\) ，但 \(x\) 中是 \(1\) ：无解，结束遍历； \(n\) 中是 \(1\) ，但 \(x\) 中是 \(0\) ：标记此点，且该点以后若 \(x\) 中出现 \(1\)，那么为无解，结束遍历； \(n\) 中是 \(0\) ，且 \(x\) 中是 \(0\) ：若未遇到 \(2\) 类情况，那么记录下最后一个满足本情况的点 \(last0\)； \(n\) 中是 \(1\) ，且 \(x\) 中是 \(1\) ：既然匹配，那么 \(last0\) 应标为 \(-1\)，否则会影响整体的值。 最后，对于 \(n\)，在 \(last0\) 的位置将其改为 \(1\)，并把 \(last0\) 后的位置改为 \(0\)，转换为十进制输出即可。 时间复杂度：\(O(n)\)左右 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt: while (t-- > 0) &#123; long a = scanner.nextLong(), b = scanner.nextLong(); if (a == b) &#123; System.out.println(a); continue; &#125; if (b % 2 != 0) &#123; System.out.println(-1); continue; &#125; int[] ba = new int[64], bb = new int[64]; int la = 0, lb = 0; while (a > 0) &#123; ba[la++] = (int) (a % 2); a /= 2; &#125; if (b == 0) &#123; long ans = 1; for (int i = 0; i &lt; la; i++) ans *= 2; System.out.println(ans); continue; &#125; while (b > 0) &#123; bb[lb++] = (int) (b % 2); b /= 2; &#125; if (lb != la) &#123; System.out.println(-1); continue; &#125; int last0 = -1; boolean f = false; for (int i = 0; i &lt; la; i++) &#123; int ta = ba[la - i - 1], tb = bb[lb - i - 1]; if (ta == tb) &#123; if (!f &amp;&amp; ta == 0) last0 = la - i - 1; if(ta == 1) last0 = -1; continue; &#125; if (ta == 0 &amp;&amp; tb == 1) &#123; System.out.println(-1); continue nxt; &#125; if (ta == 1 &amp;&amp; tb == 0) f = true; &#125; if (last0 == -1) &#123; System.out.println(-1); &#125; else &#123; long ans = 0; for (int i = la - 1; i > last0; i--) ans = ans * 2 + ba[i]; ans = ans * 2 + 1; for (int i = last0 - 1; i >= 0; i--) ans *= 2; System.out.println(ans); &#125; &#125; &#125; &#125; 写得有点过度码农了]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 141</title>
    <url>/blog/posts/707152960/</url>
    <content><![CDATA[Contestant. Rank 3946. Rating +15 (+165 -150). A. Make it Beautiful 题意 给定一个数组 \(a\)，将其重新排列，使其满足对于任意 \(a_i\)，均满足前缀和 \(sum_{i-1} \neq a_i\)。 思路 将数组降序排列即可。 需要特判一种情况，当降序排列后，第一个数和第二个数重复，那么需要向后枚举，找到第一个不一样的数，将其和第一个数交换即可。若没有这个数，输出 \(NO\)。 时间复杂度：最坏\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t -- > 0)&#123; int n = scanner.nextInt(); int[] sum = new int[n + 1]; Integer[] a = new Integer[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); Arrays.sort(a, (o1, o2) -> o2 - o1); if(a[0] != a[1])&#123; System.out.println("YES"); for(int i=0;i&lt;n;i++) System.out.printf("%d ", a[i]); System.out.println(); continue nxt; &#125; boolean flag = false; for(int i=2;i&lt;n;i++)&#123; if(a[i] != a[1])&#123; int tmp = a[i]; a[i] = a[1]; a[1] = tmp; flag = true; break; &#125; &#125; if(flag)&#123; System.out.println("YES"); for(int i=0;i&lt;n;i++) System.out.printf("%d ", a[i]); System.out.println(); &#125;else System.out.println("NO"); &#125; &#125; &#125; 签到签到，简单的贪心 B. Matrix of Differences 题意 给定矩阵的规模 \(n\)，构造一个 \(n \times n\) 的矩阵，使所有相邻的 \(x,y\) 的 \(|x-y|\) 值中不同的数值的个数最大。 思路 既然要让不同的差值出现，那么我们可以按照 \(1,n-1,2,n-2,...\) 的方式排列，为了让这个排列的数字能相邻，最简单的方法就是按蛇形排布，输出这个排列即可。 时间复杂度：\(O(n^2)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t -- > 0)&#123; int n = scanner.nextInt(); int[][] a = new int[n][n]; int now = 1; boolean flag = true; int l = 1, r = n * n; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; int p = i % 2 == 0 ? j : n - j - 1; a[i][p] = flag ? l ++ : r --; flag = !flag; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++)&#123; System.out.printf("%d ", a[i][j]); &#125; System.out.println(); &#125; &#125; &#125; &#125; 怎么赛时就是想了那么久呢... C. Yet Another Tournament 题意 给定数组 \(a\)，规定自己和其他的对手的输赢取决于准备时间，如果将要打败的对手的等待时间总和小于等于 \(m\) ，那么判定为获胜。而其他的对手之间的输赢取决于下标，\(i&gt;j\) 时 \(i\) 赢。在允许出现同名次的条件下，打败的对手越多，排名越靠前，输出自己的排名。 思路 我们把这两个类型拆分成两个问题，最后合并在一起： 升序排序准备时间，统计能打败多少人，记为 \(ans\)； 因为 \(ans+1 &gt; ans\)，所以 \(ans+1\) 的排名会更高，所以我们需要将 \(ans+1\) 对应的值替换过来，否则排名会向后移一位。所以我们需要判断 \(ans+1\) 在排序前数组中对应的值是否可以替换掉 \(ans\) 在排序后数组中对应的值，如果不可以，那么将排名后移。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t -- > 0) &#123; int n = scanner.nextInt(), m = scanner.nextInt(); int[] a = new int[n + 2], b = new int[n + 1]; for (int i = 1; i &lt;= n; i++) a[i] = b[i] = scanner.nextInt(); Arrays.sort(b, 1, n + 1); int ans = 0, sum = 0; for (int i = 1; i &lt;= n; i++) &#123; if(sum + b[i] > m) break; sum += b[i]; ans ++; &#125; if (sum + a[ans + 1] - b[ans] > m) System.out.println(n - ans + 1); else System.out.println(Math.max(n - ans, 1)); &#125; &#125; &#125; 题目要看清]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Educational Codeforces Round 142</title>
    <url>/blog/posts/3006209530/</url>
    <content><![CDATA[Contestant. Rank 2570. Rating +70. A. GamingForces 题意 给定一个数组 \(a\)，定义操作可任选其一： 将其中两个元素减 \(1\) 将某个元素减为 \(0\) 输出最少的操作数，使 \(a\) 的所有元素都减为 \(0\)。 思路 将所有为 \(1\) 的元素配对，扣去偶数个 \(1\) 后，剩下的元素全都执行操作 \(2\) 即可。 时间复杂度：最坏\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int cnt = 0; for(int i=0;i&lt;n;i++) if(scanner.nextInt() == 1) cnt ++; System.out.println(n - cnt / 2); &#125; &#125; &#125; 简单签到题 B. Stand-up Comedian 题意 给定整数 \(a_1\)，\(a_2\)，\(a_3\)，\(a_4\)，\(4\) 个整数代表了四个类型对应的笑话数量： \(A\) 和 \(B\) 都喜欢 \(A\) 喜欢，\(B\) 不喜欢 \(B\) 喜欢，\(A\) 不喜欢 \(A\) 和 \(B\) 都不喜欢 初始状态下，两人的心情值都为 \(0\)，对于喜欢的笑话，心情会 \(+1\)，否则会 \(-1\)。 输出最多能讲多少个笑话。 思路 模拟+思维 首先，我们先把类型 \(1\) 讲完，如果 \(a_1=0\)，直接判 \(1\) 个。 接着，我们讨论 \(|a_2-a_3|\) 和 \(a_1\) 的大小关系，若 \(a_1\) 较小，那么笑话是讲不完的，只有 \(2 \times (a_1+\min(a_2,a_3)) + 1\) 个笑话可以讲。 否则，将 \(|a_2-a_3|\) 讲完后，判断剩余的可以讲多少个 \(a_4\) 即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int[] a = new int[4]; for(int i=0;i&lt;4;i++) a[i] = scanner.nextInt(); if(a[0] == 0)&#123; System.out.println(1); continue; &#125; int n = Math.min(a[1], a[2]), ans = 0; ans += a[0] + n * 2; int m = Math.max(a[1] - n, a[2] - n); if(a[0] &lt; m)&#123; System.out.println(2 * (a[0] + n) + 1); &#125;else&#123; ans += m; ans += Math.min(a[0] - m + 1, a[3]); System.out.println(ans); &#125; &#125; &#125; &#125; 思路好乱 C. Min Max Sort 题意 给定一个排列 \(p\)，定义一次操作为任选两个元素，将其从原排列中取出，将较小元素放至排列头部，较大元素放至排列尾部，输出最小的操作数，使最后的排列升序。 思路 逆向思维 显然，我们需要对形如 \([i,n-i+1]\) 的元素对进行操作。 考虑到一个不需要移动的元素对，应满足三个条件： \(i\) 在 \(n-i+1\) 前面 \(i\) 在 \(i+1\) 前面 \(n-i\) 在 \(n-i+1\) 前面 筛出所有不需要移动的元素对并取补集即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(); int[] w = new int[n + 1]; int ans = n / 2; for (int i = 1; i &lt;= n; i++) w[scanner.nextInt()] = i; for (int i = n / 2; i >= 1; i--) &#123; //排除不用移动的 if (w[i] &lt; w[i + 1] &amp;&amp; w[n - i + 1] > w[n - i] &amp;&amp; w[i] &lt; w[n - i + 1]) ans--; else break; &#125; System.out.println(ans); &#125; &#125; &#125; 反着想简单多了 D. Fixed Prefix Permutations 题意 给定整数 \(n\) 和 \(m\)，定义两个排列 \(p\)，\(q\) 的乘积为一个新的排列 \(r\)，其中 \(r_j=q_{p_j}\)。给定长度为 \(m\) 的 \(n\) 个排列，对于每一个排列，输出其与所有 \(n\) 个排列的乘积构成的排列的最大美丽值。其中美丽值定义为满足 \(p_1=1,p_2=2,...,p_k=k\) 的 \(k\) 的最大值（\(p_1 \neq 1\)时美丽值为 \(0\)）。 思路 显然，对于给定的排列 \(p\) 和 \(q\)，若已知 \(q\)，那么所构造出来的 \(r\) 和 \(p\) 是一一对应的。所以，我们可以将问题转化一下： 对于所有 \(q\)，先预处理构造出满足 \(k=m\) 的排列 \(p_t\) ，然后对于每一个 \(p\) ，在所有 \(p_t\) 中依次匹配，输出从第一个开始最大的连续匹配数量。 为了让匹配的复杂度降到最低，我们可以采用字典树。 时间复杂度：\(O(nm)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 50010; int n, m; int a[N][20], tmp[20]; class Trie &#123; private: vector&lt;Trie*> children; public: Trie() : children(12)&#123;&#125; void insert() &#123; Trie* node = this; for (int i=0;i&lt;m;i++) &#123; int ch = tmp[i]; if (node->children[ch] == nullptr) &#123; node->children[ch] = new Trie(); &#125; node = node->children[ch]; &#125; &#125; int find(int index) &#123; Trie* node = this; int dep = 0; for (int i=0;i&lt;m;i++) &#123; int ch = a[index][i]; if (node->children[ch] == nullptr) &#123; return dep - 1; &#125; node = node->children[ch]; dep ++; &#125; return dep; &#125; &#125;; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --)&#123; Trie root = *new Trie(); cin >> n >> m; for(int i=0;i&lt;n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cin >> a[i][j]; tmp[a[i][j]] = j; &#125; root.insert(); &#125; for(int i=0;i&lt;n;i++)&#123; cout &lt;&lt; root.find(i) &lt;&lt; " "; &#125; cout &lt;&lt; '\n'; &#125; &#125; 题目真的很难看懂...]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 842 Div. 2</title>
    <url>/blog/posts/3350941822/</url>
    <content><![CDATA[Contestant. Rank 7746. Rating -64 (+186 -250). A. Greatest Convex 题意 给定 \(k\)，输出满足条件的 \(x\)，使 \(x!+(x-1)!\) 为 \(k\) 的倍数。 思路 \(x!+(x-1)!=(x-1)!(x+1)\)，显然，令 \(x+1=k\) 即可，答案即为 \(k-1\)。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; System.out.println(scanner.nextInt() - 1); &#125; &#125; &#125; 怎么会有这么签到的题 B. Quick Sort 题意 给定整数 \(k\) 以及一个排列 \(p\)，定义一次操作为选择 \(k\) 个数并将其升序移至排列末尾。输出最少操作数，使整个排列升序。 思路 显然，最后的排列一定是 \(1,2,3,...\)，那么，我们不妨先来考虑单个元素是否需要移至后面。 对于一个元素 \(t\)，如果它的前面没有出现 \(t-1\)，那么显然我们只有将他移动至最后才能让排列成功构造出来，否则我们就无需操作。 所以，我们只需统计需要移动的元素数量 \(sum\)，然后输出 \(\lfloor \frac{sum}{k} \rfloor\) 即可，因为每次移动我们可以选多个。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(), k = scanner.nextInt(); boolean[] a = new boolean[n + 1]; int sum = 0; for(int i=0;i&lt;n;i++)&#123; int cur = scanner.nextInt(); a[cur] = true; if(cur != 1)&#123; if(!a[cur - 1]) &#123; a[cur] = false; sum ++; &#125; &#125; &#125; System.out.println((int) Math.ceil((double) sum / k)); &#125; &#125; &#125; 从一个推向多个是否合理呢 C. Elemental Decompress 题意 给定数组 \(a\) 以及其长度 \(n\)，规定 \(1 \leq a_i \leq n\)。构造两个排列 \(p\)，\(q\)，满足 \(\max(p_i,q_i)=a_i\)。若能构造，输出 \(YES\) 以及其中一种构造，否则输出 \(NO\)。 思路1 显然，一个数不能出现三次及以上，否则无法构造。 并且，我们可以发现，排序后的数组，若出现元素满足 \(a_i&lt;i\)，那么也无法构造（可以使用反证法） 那么，我们可以降序排序数组，并执行下面的两个操作： 遍历数组，将重复两次的数分散到两个数组内，做拆分（此时可排除出现三次及以上的数）； 遍历数组，如果 \(a_i\) 在 \(p\) 内，那么寻找不在 \(q\) 中的最大值，将其放入 \(q\)，反之亦如此。 遍历结束后，若全都填满了就是有解，输出即可。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.io.*; import java.math.*; import java.util.*; public class Main &#123; public static void main(String[] args) throws Exception&#123; Console console = new Console(); int t = console.nextInt(); nxt:while(t -- > 0)&#123; int n = console.nextInt(); int[][] a = new int[n + 1][2]; boolean[] inp = new boolean[n + 1], inq = new boolean[n + 1]; for(int i=1;i&lt;=n;i++) a[i] = new int[]&#123;i, console.nextInt()&#125;; Arrays.sort(a, 1, n + 1, Comparator.comparingInt(o -> -o[1])); int[] p = new int[n + 1], q = new int[n + 1]; for(int i=1;i&lt;=n;i++)&#123; int k = a[i][0], v = a[i][1]; if(inp[v] &amp;&amp; inq[v])&#123; console.println("NO"); continue nxt; &#125; if(inp[v])&#123; q[k] = v; inq[v] = true; &#125;else&#123; p[k] = v; inp[v] = true; &#125; &#125; int rp = n, rq = n; for(int i=1;i&lt;=n;i++)&#123; int k = a[i][0]; if(p[k] == 0)&#123; while(inp[rp]) rp --; inp[rp] = true; if(rp > q[k])&#123; console.println("NO"); continue nxt; &#125; p[k] = rp --; &#125;else&#123; while(inq[rq]) rq --; inq[rq] = true; if(rq > p[k])&#123; console.println("NO"); continue nxt; &#125; q[k] = rq --; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!inp[i] &amp;&amp; !inq[i])&#123; console.println("NO"); continue nxt; &#125; &#125; console.println("YES"); for(int i=1;i&lt;=n;i++) console.print(p[i] + " "); console.println(); for(int i=1;i&lt;=n;i++) console.print(q[i] + " "); console.println(); &#125; console.close(); &#125; //快读模板，此处略去 //public static class Console implements Closeable &#123;&#125; &#125; 思路2 首先，这种思路无法通过 \(Test3\)。 若未考虑到 思路\(1\) 中第二个结论，那么我们可以考虑使用链表的方式，遍历排序后的数组的时候，我们可以把求得的解对应的元素删去，从而获取到我们想要的元素。 时间复杂度约为\(O(n^2)\)，无法通过 对应AC代码 在赛时可以思考能否得出一些特定的结论出来]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Hello 2023</title>
    <url>/blog/posts/3186977285/</url>
    <content><![CDATA[Contestant. Rank 3574. Rating +50 (+400 -350). A. Hall of Fame 题意 给定一个只有 \(L\) 和 \(R\) 的长度为 \(n\) 的字符串，对于第 \(i\) 个字符，\(L\) 表示将 \([1,i-1]\) 照亮，\(R\) 表示将 \([i+1,n]\) 照亮。对于该字符串，允许选择一个 \(i\)，将 \(i\) 和 \(i+1\) 对应的字符交换，该操作最多可执行一次。判断是否可以将所有点照亮。若无需交换，输出 \(0\)；若交换后才满足条件，输出 \(i\)；若无法满足条件，输出 \(-1\)。 思路 很显然，只要出现 \(R,...,L\) 的排列，就一定可以满足条件。 那么，我们首先可以寻找第一个 \(R\) 之后有没有 \(L\)，只要找到了 \(L\) 就直接输出 \(0\) 即可。 否则，我们就需要寻找 \(LR\)，并将其交换，并输出 \(L\) 对应的下标。 否则，输出 \(-1\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t-- > 0)&#123; int n = scanner.nextInt(); char[] a = scanner.next().toCharArray(); int l = 0, r = 0, lr = -1; boolean preR = false; for(int i=0;i&lt;a.length;i++)&#123; if(i &lt; a.length - 1 &amp;&amp; lr == -1 &amp;&amp; a[i] == 'L' &amp;&amp; a[i + 1] == 'R') lr = i + 1; if(a[i] == 'R') preR = true; else if(preR)&#123; System.out.println(0); continue nxt; &#125; &#125; System.out.println(lr); &#125; &#125; &#125; 简单思维题 B. MKnez's ConstructiveForces Task 题意 给定数组的长度 \(n\)，构造一个非零数组 \(s\)，满足对于任何 \(i \in [1,n)\)，有 \(s_1+s_2+...+s_n=s_i+s_{i+1}\)。若不可构造，输出 \(NO\)，否则输出 \(YES\)，以及所构造的数组。 思路 将等式右边移到左边，那么我们只需满足任意取出两个数后数组的和都为 \(0\) 即可。那么很显然，当 \(n\) 为偶数时，我们只需构造一个 \(1,-1,1,-1,...\) 的数组即可。 而当 \(n\) 为奇数的时候，既然等式左边有 \(n\) 项，而右边有 \(2\) 项，若仍然考虑相邻数的和相等的构造方式的话，我们不妨让这个相等的和为 \(1\)，这样的话，式子将会变为 \(s_x+\frac{n}{2}=1\)，那么多出来的项 \(s_x\) 即为 \(1-\frac{n}{2}\) 。因而，令 \(w=\frac{n}{2}\)，我们只需构造 \(1-w,w,1-w,w,1-w,...\) 即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t-- > 0)&#123; int n = scanner.nextInt(); if(n == 3) System.out.println("NO"); else&#123; System.out.println("YES"); if(n % 2 == 0)&#123; for(int i=0;i&lt;n/2;i++) System.out.print("1 -1 "); &#125;else&#123; int w = n / 2; System.out.printf("%d ", 1 - w); for(int i=0;i&lt;n/2;i++) System.out.printf("%d %d ", w, 1 - w); &#125; System.out.println(); &#125; &#125; &#125; &#125; 既然是成对的，那就让和也成对呗 C. Least Prefix Sum 题意 给定一个数组 \(a\)，定义一次操作为任取一个数并将其改为它的相反数。输出最少的操作数，使 \(a\) 的前 \(m\) 项和为 \(a\) 的所有前 \(k\) 项和（\(k \in [1,n]\)）中的最小值。 思路 对于题给式子 \(a_1+a_2+...+a_k \geq a_1+a_2+...+a_m\)， 当 \(k \leq m\) 时，将不等式左边移到右边，我们可以得到第一个条件：以 \(m\) 为结尾的不包括 \(a_1\) 的后缀和均为非正数。 同理，当 \(k \geq m\) 时，将不等式右边移到左边，我们可以得到第二个条件：以 \(m+1\) 为第一项的前缀和均为非负数。 因为上述两者差不多，我们不妨来考虑前者。 显然，在遍历所有后缀和的时候，我们不可以在发现某一项不满足时直接把这一项取相反数，因为我们不能保证后面的项比这一项小，而将最大值取反才是最优解。 因此，为了每次查询的复杂度降到一个合理的值，我们可以采用优先队列。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t-- > 0) &#123; int n = scanner.nextInt(), m = scanner.nextInt(); long[] a = new long[n + 1]; for(int i=1;i&lt;=n;i++) a[i] = scanner.nextInt(); PriorityQueue&lt;Long> positive = new PriorityQueue&lt;>((o1, o2) -> Math.toIntExact(o2 - o1)); PriorityQueue&lt;Long> negative = new PriorityQueue&lt;>(Comparator.comparingLong(o -> o)); long cnt = 0, sum = 0; for(int i=m;i>=2;i--)&#123; sum += a[i]; if(a[i] > 0) positive.offer(a[i]); while(sum > 0) &#123; sum -= 2 * positive.poll(); cnt ++; &#125; &#125; sum = 0; for(int i=m + 1;i&lt;=n;i++)&#123; sum += a[i]; if(a[i] &lt; 0) negative.offer(a[i]); while(sum &lt; 0) &#123; sum -= 2 * negative.poll(); cnt ++; &#125; &#125; System.out.println(cnt); &#125; &#125; &#125; 优先队列yyds]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 3</title>
    <url>/blog/posts/2583580825/</url>
    <content><![CDATA[Rank 196/3562. AC 7/11. 这标题显然是参考了arcaea的final verdict包的剧情，对吧 A. 不断减损的时间 题意 给定一个数组，数值可以为负数。对于无限次的操作，你可以任选一个偶数并将其除以 \(2\)，输出最后总和的最大值。 思路 将所有正偶数暴力除到奇数为止，并求和即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); long ans = 0; for(int i=0;i&lt;n;i++)&#123; int a = scanner.nextInt(); if(a &lt;= 0) ans += a; else&#123; while(a % 2 == 0) a /= 2; ans += a; &#125; &#125; System.out.println(ans); &#125; &#125; 快速签到 B. 勉强拼凑的记忆 题意 给定 \(n\) 块矩形积木，积木的大小为 \(1 \times k\)，\(k\) 可在 \([1,\lceil \frac{n}{2} \rceil ]\) 内任意选择，若能使用所有积木搭成正方形，输出最大的边长，否则输出 \(-1\)。 思路 很难说思路，因为可以打表打出规律（（ 前 \(30\) 个根据打表得到 \(1,-1,2,2,3,4,5,5,6,6,\) \(7,8,9,9,10,10,11,12,13,13,\) \(14,14,15,16,17,17,18,18,19,20\) 很容易就可以得到一个通式 \(ans=\frac{(q \times 2 + q \bmod 2)}{3}\) 至于为什么会这样，我们可以考虑 \(6\) 以上的数，因为横放几个最长的方块，然后再竖着放一个方块，最后在最后一行填满方块，即为 \(6 -11\) 之间的规律，而 \(12\) 以上，我们就可以发现最底下还可以再塞一行，然后在右边再放上一个方块依然是可行的，以此类推... 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; long q = scanner.nextLong(); if(q == 2) System.out.println(-1); //下面式子会算成0... else System.out.println((q * 2 + q % 2) / 3); &#125; &#125; &#125; 打表好累.jpg C. 忽远忽近的距离 题意 构造一个排列，满足 \(2 \leq |a_i-i| \leq 3\)。 思路 打表，暴力找规律即可。 可以发现是 \(4\) 个为一块有规律输出的，处理结尾数字即可。 时间复杂度：\(O(1)\) （确信 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n; cin >> n; if(n &lt; 4) cout &lt;&lt; -1 &lt;&lt; '\n'; else if(n == 4) cout &lt;&lt; "3 4 1 2\n"; else if(n == 5) cout &lt;&lt; "4 5 1 2 3\n"; else if(n == 6) cout &lt;&lt; "4 5 6 1 2 3\n"; else if(n == 7) cout &lt;&lt; -1 &lt;&lt; '\n'; else if(n == 8) cout &lt;&lt; "3 4 1 2 7 8 5 6\n"; else if(n == 9) cout &lt;&lt; "3 4 1 2 7 8 9 5 6\n"; //狠狠地打表 else &#123; int i = 0; if (n % 4 == 3) for (; i &lt; n / 4 - 2; i++) cout &lt;&lt; i * 4 + 3 &lt;&lt; " " &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " "; else for (; i &lt; n / 4 - 1; i++) cout &lt;&lt; i * 4 + 3 &lt;&lt; " " &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " "; if (n % 4 == 0) cout &lt;&lt; i * 4 + 3 &lt;&lt; " " &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2; else if (n % 4 == 1) cout &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 5 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " " &lt;&lt; i * 4 + 3; else if (n % 4 == 2) cout &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 5 &lt;&lt; " " &lt;&lt; i * 4 + 6 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " " &lt;&lt; i * 4 + 3; else cout &lt;&lt; i * 4 + 4 &lt;&lt; " " &lt;&lt; i * 4 + 5 &lt;&lt; " " &lt;&lt; i * 4 + 1 &lt;&lt; " " &lt;&lt; i * 4 + 2 &lt;&lt; " " &lt;&lt; i * 4 + 3 &lt;&lt; " " &lt;&lt; i * 4 + 9 &lt;&lt; " " &lt;&lt; i * 4 + 10 &lt;&lt; " " &lt;&lt; i * 4 + 11 &lt;&lt; " " &lt;&lt; i * 4 + 6 &lt;&lt; " " &lt;&lt; i * 4 + 7 &lt;&lt; " " &lt;&lt; i * 4 + 8; &#125; &#125; 打表好累.jpeg D. 宿命之间的对决 题意 给定一个正整数 \(n\)，小红和小紫轮流取当前数的因子 \(x\) ，使当前数减少 \(x\) 。如果小红获胜，则输出 "\(kou\)"，否则输出 "\(yukari\)" 思路 简单的博弈题。 我们先假设每个人都只拿 \(1\) 个，那么最后一定是第一次拿的时候当前数为偶数的一方获胜。 然而，输的一方肯定想要获胜，那么他一定要拿掉偶数个才行，而无论他怎么拿，获胜方都可以只拿掉奇数来使他只能从奇数的因数中取，从而不可能取到偶数，因而必输。 所以，判奇偶即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println(scanner.nextLong() % 2 == 1 ? "yukari" : "kou"); &#125; &#125; 次世代の宿命之红砍光光（？ E. 公平守望的灯塔 题意 给定在平面直角坐标系的整点 \(A(x_A,y_A)\) 和 \(B(x_B,y_B)\) ，输出一个整点 \(C\) ，使得 \(\Delta ABC\) 为以 \(AB\) 为斜边的 等腰\(Rt\Delta\)。 思路 "K型全等"，找出中点后用全等即可解出。 当 \(A\) 和 \(B\) 横坐标的差值和纵坐标的差值的奇偶性不一致时，\(C\) 点一定会有小数 \(0.5\) 存在，因此该条件无解。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); long xa = scanner.nextLong(), ya = scanner.nextLong(), xb = scanner.nextLong(), yb = scanner.nextLong(); if(Math.abs(xa - xb) % 2 == Math.abs(ya - yb) % 2)&#123; //初中数学？ long mid2x = xa + xb, mid2y = ya + yb; System.out.printf("%d %d\n", (mid2x + mid2y) / 2 - ya, (mid2y - mid2x) / 2 + xa); &#125;else System.out.println("No Answer!\n"); &#125; &#125; 画个图，不就是个初中数学题嘛 F. 迎接终结的寂灭 题意 输出 \(42\)。 思路 输出 \(42\)。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; System.out.println(42); &#125; &#125; 怎么会是呢 G. 严肃古板的秩序 题意 给定一个运算式，其中等式左边的符号全都被替换成 \(?\)，等式右边只有一个数字，符号只有三种可能：\(+\)，\(-\)， #，其中定义\(a\)#\(b=a^a \bmod b,a&gt;0且b&gt;0\)，三个符号的优先级相同，输出一个合法的式子，否则输出 \(-1\)。 思路 暴力 \(Dfs\) 即可，其中模幂运算需要使用快速幂。 时间复杂度：\(O(3^x \log n),x \leq 12\) 对应AC代码 import java.math.BigInteger; import java.util.*; public class Main&#123; static int n; static long ans; static long[] nums; static char[] op; static boolean ok = false; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); String[] s = scanner.next().split("\\?"); n = s.length; nums = new long[n]; for(int i=0;i&lt;n-1;i++) nums[i] = Long.parseLong(s[i]); nums[n - 1] = Long.parseLong(s[n - 1].split("=")[0]); ans = Long.parseLong(s[n - 1].split("=")[1]); op = new char[n - 1]; dfs(0, nums[0]); if(!ok) System.out.println(-1); &#125; private static void dfs(int index, long last)&#123; if(index == n - 1)&#123; if(last == ans) &#123; ok = true; print(); &#125; return; &#125; if(ok) return; op[index] = '+'; dfs(index + 1, last + nums[index + 1]); if(ok) return; op[index] = '-'; dfs(index + 1, last - nums[index + 1]); if(ok || last &lt;= 0 || nums[index + 1] &lt;= 0) return; op[index] = '#'; dfs(index + 1, BigInteger.valueOf(last).modPow(BigInteger.valueOf(last), BigInteger.valueOf(nums[index + 1])).longValue()); &#125; private static void print()&#123; System.out.printf("%d", nums[0]); for(int i=1;i&lt;n;i++)&#123; System.out.printf("%c%d", op[i - 1], nums[i]); &#125; System.out.printf("=%d\n", ans); &#125; &#125; 很经典的回溯搜索 H. 穿越万年的轮回 待补充 I. 灵魂碎片的收集 题意 定义 \(S(n)\) 为 \(n\) 的所有不包括 \(n\) 的因数的和，给定正整数 \(x\)，输出满足 \(S(n)=x\) 的正整数 \(n\)，否则输出 \(-1\)。 限制 对于输入的 \(x\)，有以下限制： \(x\%2=0\)，则 \(x-1\) 和 \(x-3\) 之间一定有一个是质数。 \(x\%2=1\)，则无限制 思路 我们可以直接从限制入手： 若 \(x\) 为偶数，且 \(x-1\) 是质数，那么显然只有一种分解 \(S(n)=1+(x-1)=x\)，那么 \(n=(x-1)^2\)。 若 \(x\) 为偶数，且 \(x-3\) 是质数，那么也只有一种分解 \(S(n)=1+2+(x-3)=x\)，那么 \(n=2(x-3)\)。 若 \(x\) 为奇数，因为 \(1\) 一定是其中一个因子，那么剩下的一定是偶数。因为所有偶数都可以分解为两个质数之和，那么我们可以直接暴力，枚举出一种可能即可。 当然，为了判定素数方便，我们采取用线性筛打表的方式来让查询的复杂度降到 \(O(1)\)。 时间复杂度：懒得分析 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 1000010; #define ll long long vector&lt;int> primes; bool vis[N + 1], isPrime[N + 1]; void init() &#123; for (int i = 2; i&lt;= N; ++i) &#123; if (!vis[i]) &#123; primes.emplace_back(i); isPrime[i] = true; &#125; for (int &amp;j : primes) &#123; if (1ll * i * j > N) break; vis[i * j] = true; if (i % j == 0) break; &#125; &#125; &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); init(); int t; ll x; cin >> t; int ans[] = &#123;0, -1, -1, 4, 9, -1, 25, 8&#125;; while (t--) &#123; cin >> x; if(x &lt;= 7) cout &lt;&lt; ans[x] &lt;&lt; '\n'; else &#123; if (x % 2 == 0) &#123; if (isPrime[x - 1]) cout &lt;&lt; (x - 1) * (x - 1) &lt;&lt; '\n'; else cout &lt;&lt; 2 * (x - 3) &lt;&lt; '\n'; &#125; else &#123; for (int i = 2; i &lt;= x; i++) &#123; if(isPrime[i] &amp;&amp; isPrime[x - i - 1]) &#123; cout &lt;&lt; (ll)i * (x - i - 1) &lt;&lt; '\n'; break; &#125; &#125; &#125; &#125; &#125; &#125; 赛时眼瞎了没看到限制 J. 无法磨灭的悔恨 待补充 K. 永恒守候的爱恋 题意 假设 \(p_1,p_2,...,p_n\) 为前 \(n\) 个素数，定义 \(S\) 为 \(a_i\) 个 \(p_i\) 组成的多重集合 \((i \in [1,n])\)。 例如，多重集{2,2,3,3,3,7}可以表示为： \(n=4,a=[2,3,0,1]\)。 定义\(f(i)\) 为一个数组前 \(i\) 个元素的乘积的因子数量，给定 \(n\) 和数组 \(a\)，他表示了一个大小为 \(\displaystyle{size=\sum_{i=1}^{n}a_i}\) 的多重集。用这个多重集的所有元素构造一个大小为 \(size\) 的数组，输出 \(\displaystyle{\sum_{i=1}^{size}f(i)}\) 的最大值，对 \(10^9+7\) 取模。 思路 \(Buff\) 叠满的数学题。 我们先来考虑因子个数：根据算数基本定理，对于一个分解式 \(x=P_1^{\alpha_1}P_2^{\alpha_2}...P_n^{\alpha_n}\)，因数数量为 \((\alpha_1 + 1)(\alpha_2 + 1)...(\alpha_n+1)\)。 那么既然我们要让这个乘积更大，我们就可以每次都不重复地将数字放上去，如 \(|2,3,7||2,3||3|\)。那么对于第一块，结果为 \(2 \times 1 \times 1\)、\(2 \times 2 \times 1\)、\(2 \times 2 \times 2\)。对于第二块，结果为 \(3 \times 2 \times 2\)、\(3 \times 3 \times 2\)。对于第三块，结果为 \(4 \times 3 \times 2\)。 显然，上述式子是分块的等比数列求和，其中 \(q=2,\frac{3}{2},\frac{4}{2},...\) 因而，我们只需一块一块地处理即可。 当然，为了快速求出每一块的元素个数，我们只需在读入的时候使用差分的方法，具体地来说： 横向从左到右绘制一张柱状图，那么纵切面的数量即为每块的元素数量。 时间复杂度：不好评价 对应AC代码 注意，此代码不一定能运行通过，有概率会超时 import java.math.BigInteger; import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] t = new int[200010]; for(int i=0;i&lt;n;i++)&#123; t[scanner.nextInt() + 1] --; t[1] ++; &#125; int max = 0; for(int i=1;i&lt;200010;i++) &#123; t[i] += t[i - 1]; if(t[i] == 0) &#123; max = i - 1; break; &#125; &#125; long ans = 0, a1 = 1, an; BigInteger res = BigInteger.ONE, ip1, mod = BigInteger.valueOf(1000000007L); for(int i=1;i&lt;=max;i++)&#123; //规避一下逆元 int now = t[i], nxt = t[i + 1]; ip1 = BigInteger.valueOf(i + 1); res = res.multiply(ip1.modPow(BigInteger.valueOf(now - nxt), mod)).mod(mod); a1 = (a1 * (i + 1)) % 1000000007L; an = res.multiply(ip1.modPow(BigInteger.valueOf(nxt), mod)).mod(mod).longValue(); ans = (ans + (an * (i + 1)) % 1000000007L + 1000000007L - a1) % 1000000007L; a1 = an; &#125; System.out.println(ans); &#125; &#125; 不用考虑第几个质数是啥呢]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 2</title>
    <url>/blog/posts/4009320463/</url>
    <content><![CDATA[Rank 906/3920. AC 5/12. A. Tokitsukaze and a+b=n (easy) 题意 在两个闭区间 \([L1, R1]\) 和 \([L2, R2]\) 之间取两个数 \(a\)，\(b\)，满足 \(a+b=n\)。\(a \neq b\) 时交换两者可算作两种选法。输出选法总数。 思路 暴力枚举 \(a\)，\(b\)。快速签到。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T = scanner.nextInt(); while(T -- > 0)&#123; int n = scanner.nextInt(); int l1 = scanner.nextInt(), r1 = scanner.nextInt(); int l2 = scanner.nextInt(), r2 = scanner.nextInt(); int cnt = 0; for(int i=l1;i&lt;=r1;i++)&#123; int j = n - i; if(j >= l2 &amp;&amp; j &lt;= r2) cnt ++; &#125; System.out.println(cnt); &#125; &#125; &#125; 先签了再说 B. Tokitsukaze and a+b=n (medium) 题意 同\(A\)题，只有样例数量增加了。 思路 一个取交集的思路： 当两个集合有交集时，那么将存在一段值相等的区间，因而我们化 \(a+b=n\) 为 \(a=n-b\) ，求等式两边集合的交集的元素数量即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T = scanner.nextInt(); while (T-- > 0) &#123; int n = scanner.nextInt(); long l1 = scanner.nextInt(), r1 = scanner.nextInt(), l2 = scanner.nextInt(), r2 = scanner.nextInt(); System.out.println(Math.max(0, Math.min(n - l1, r2) - Math.max(n - r1, l2) + 1)); &#125; &#125; &#125; 这么好的思路，赛时怎么就没想到呢，淦 C. Tokitsukaze and a+b=n (hard) 题意 给定 \(m\) 个区间，在不同的区间内分别取 \(a\)，\(b\)，同 \(AB\)，输出方案数。 思路 在 \(B\) 题的思路基础上，我们只需先用差分快速求出一个点 \(t_i\) 被多少个区间覆盖，求和后便可很快算出一段区间内有多少元素在交集之内了，这里我们可以使用两次前缀和。注意，这里需要排除在相同区间内取交集。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; static final int N = 400010, mod = 998244353; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); int[] l = new int[m], r = new int[m]; long[] sum = new long[N + 1]; for(int i=0;i&lt;m;i++)&#123; l[i] = scanner.nextInt(); r[i] = scanner.nextInt(); sum[r[i] + 1] --; sum[l[i]] ++; &#125; for(int i=1;i&lt;=N;i++) &#123; sum[i] += sum[i - 1]; sum[i] %= mod; &#125; for(int i=1;i&lt;=N;i++) &#123; //差分转前缀和 sum[i] += sum[i - 1]; sum[i] %= mod; &#125; long ans = 0; for(int i=0;i&lt;m;i++)&#123; int l1 = l[i], r1 = r[i], l2 = n - r[i], r2 = n - l[i]; if(r2 &lt; 1) continue; l2 = Math.max(1, l2); ans += sum[r2] - sum[l2 - 1]; ans -= Math.max(0, Math.min(r1, r2) - Math.max(l1, l2) + 1); while(ans &lt; 0) ans += mod; ans %= mod; &#125; System.out.println(ans); &#125; &#125; 想不出来B题那个简单的做法这题就寄咯 D. Tokitsukaze and Energy Tree 题意 给定一个根为 \(1\) 、有 \(n\) 个节点的树，将 \(n\) 个为 \(v_i\) 的能量球放到 \(n\) 个节点上，在每次放置时可获得自己加上子树的所有能量，输出能获得的最大能量。 思路1 显然，我们可以贪心地认为从小到大从顶部往下按层放置即可，这样就可以保证最大的能量在层数最大的叶节点。 因而，我们可以直接用 \(BFS\) 暴力模拟解决问题。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long const int N = 200020; int n; vector&lt;int> e[N]; int w[N], idx = 1; ll ans = 0; int v[N]; bool vis[N]; void bfs()&#123; queue&lt;pair&lt;int, int>> q; q.emplace(1, 1); ans += v[idx ++]; vis[1] = true; while(q.size())&#123; auto t = q.front(); q.pop(); for(int c : e[t.first])&#123; if(vis[c]) continue; vis[c] = true; ans += (t.second + 1) * v[idx ++]; q.emplace(c, t.second + 1); &#125; &#125; &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> n; for(int i=1;i&lt;n;i++)&#123; int f; cin >> f; e[f].emplace_back(i + 1); &#125; for(int i=1;i&lt;=n;i++) cin >> v[i]; sort(v + 1, v + n + 1); bfs(); cout &lt;&lt; ans &lt;&lt; '\n'; &#125; 思路2 题目输入有限制，在给出节点 \(i\) 的父亲的时候，满足父亲的下标小于 \(i\) ，所以是没必要 \(BFS\) 的，直接用数组即可。 时间复杂度：\(O(n)\) #include&lt;bits/stdc++.h> using namespace std; const int N = 200010; #define ll long long ll v[200005], d[200005]; int main() &#123; int n, f, ans = 0; d[1] = 1; cin >> n; for(int i=2;i&lt;=n;i++) &#123; cin >> f; d[i] = d[f] + 1; &#125; for(int i=1;i&lt;=n;i++) cin >> v[i]; sort(v + 1, v + n + 1); sort(d + 1, d + n + 1); for(int i=1;i&lt;=n;i++) ans += v[i] * d[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; 看清题目的输入啊，完全没必要BFS E. Tokitsukaze and Function 题意 给定函数 \(f(x)= \lfloor \frac{n}{x} \rfloor + x - 1\) 以及区间 \([L,R]\)，输出 使 \(f(t)\) 最小 的 最小整数 \(t\) 。 思路 首先，去掉向下取整符号后，这是一个对勾函数，那么最小值将在 \(\sqrt x\) 处取到。 保留符号后，最小值会在 \(\lfloor \sqrt x \rfloor\) 和 \(\lceil \sqrt x \rceil\) 处取到，我们记为 \(p\)。 显然，在尝试几个数后，我们可以发现存在至少一段值都为最小值的区间，且 \(p\) 在区间内部。 不过，因为我们需要取 \(t_{\min}\)，所以我们只需从 \(p\) 点向左找转折点，即左边的值大于自身的那个点。 我们先来特判几个情况： \(p \leq L\) 时，输出 \(l\) 即可。 \(p &gt; R\) 时，我们可以将寻找转折点的区间缩小为 题给区间 \([L,R]\) 。 我们可以发现，题目给的数据量特别大，而且我们要找的区间是有单调性的，二分查找即可。 时间复杂度：\(O(\log x)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T = scanner.nextInt(); while(T -- > 0) &#123; long n = scanner.nextLong(), l = scanner.nextLong(), r = scanner.nextLong(); long p = Math.round(Math.sqrt(n)) + 1; if(p &lt;= l)&#123; System.out.println(l); continue; &#125; if (f(n, p - 1) &lt;= f(n, p)) p --; if(p > r) p = r; long left = l, right = p, mid; while(left &lt; right)&#123; mid = (left + right) >> 1; if(f(n, mid) &lt;= f(n, right)) right = mid; else left = mid + 1; &#125; System.out.println(left); &#125; &#125; private static long f(long n, long x)&#123; return n / x + x - 1; &#125; &#125; 不要死磕在一道题 F. Tokitsukaze and Gold Coins (easy) 题意 给定 \(n \times 3\) 有障碍迷宫，输出从 \((1，1)\) 到 \((n, 3)\) 的所有路径中经过的点的个数，不重复计算。 思路 正反两遍 \(BFS\)，统计被访问两遍的点的个数即可，无需找规律。 时间复杂度：\(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long const int N = 500010; int n; bool have[N][4], vis[N][4][2]; void bfs(pair&lt;int, int> s, int w) &#123; queue&lt;pair&lt;int, int>> q; q.emplace(s); while (!q.empty()) &#123; auto t = q.front(); q.pop(); if(vis[t.first][t.second][w]) continue; vis[t.first][t.second][w] = true; if (w) &#123; if (t.first - 1 > 0 &amp;&amp; !have[t.first - 1][t.second]) q.emplace(t.first - 1, t.second); if (t.second - 1 > 0 &amp;&amp; !have[t.first][t.second - 1]) q.emplace(t.first, t.second - 1); &#125; else &#123; if (t.first + 1 &lt;= n &amp;&amp; !have[t.first + 1][t.second]) q.emplace(t.first + 1, t.second); if (t.second + 1 &lt;= 3 &amp;&amp; !have[t.first][t.second + 1]) q.emplace(t.first, t.second + 1); &#125; &#125; &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t, k, x, y; cin >> t; while (t--) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= 3; j++) &#123; vis[i][j][0] = vis[i][j][1] = have[i][j] = false; &#125; cin >> n >> k; while (k--) &#123; cin >> x >> y; have[x][y] = !have[x][y]; &#125; bfs(&#123;1, 1&#125;, 0); bfs(&#123;n, 3&#125;, 1); vis[1][1][0] = vis[1][1][1] = false; long long cnt = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= 3; j++) if (vis[i][j][0] &amp;&amp; vis[i][j][1]) cnt++; cout &lt;&lt; cnt &lt;&lt; '\n'; &#125; &#125; 先试试暴力啊，怎么会t呢？ G. Tokitsukaze and Gold Coins (hard) 待补充 H. Tokitsukaze and K-Sequence 题意 给定数组 \(a\)，将其划分为 \(k\) 个非空可不连续的子序列，输出 \(k \in [1, n]\) 时子序列的总和的最大值。定义子序列的值为只出现一次的数字个数。 思路 定义 \(cnt_i\) 为出现 \(i\) 次的数的个数。 \(k=1\) 时，显然答案为 \(cnt_1\)。 \(k&gt;1\) 时，我们可以将 \(cnt_p,p \in [k,n]\) 对应数都留下一个，其余全都取出作为新子序列，此时答案为上一个答案的基础上加上 \(cnt_k+(cnt_k+cnt_{k+1}+...+cnt_{n})\)。 可以证明此时的个数最大。 因此，我们可以用类似于后缀和的方法写。 当然也有更简单的写法。 时间复杂度：\(O(n)\) 对应AC代码 import java.io.*; import java.math.BigInteger; import java.util.*; public class Main&#123; //快读，此处略过 //public static class Console implements Closeable &#123;&#125; public static void main(String[] args) throws Throwable&#123; Console scanner = new Console(); int T = scanner.nextInt(); while(T -- > 0)&#123; int n = scanner.nextInt(); Map&lt;Integer, Integer> cnt = new HashMap&lt;>(); int max = 0; for(int i=0;i&lt;n;i++) &#123; int b = scanner.nextInt(); int p = cnt.getOrDefault(b, 0) + 1; cnt.put(b, p); max = Math.max(max, p); &#125; int[] p = new int[max + 1], suf = new int[max + 1]; for(int e : cnt.keySet()) p[cnt.get(e)] ++; suf[max] = p[max]; for(int i=max-1;i>=1;i--) suf[i] = suf[i + 1] + p[i]; long ans = p[1]; scanner.println(ans); for(int i=2;i&lt;=max;i++)&#123; ans += suf[i] + p[i]; scanner.println(ans); &#125; for(int i=max+1;i&lt;=n;i++) scanner.println(ans); &#125; scanner.close(); &#125; &#125; 很签的题呢 I. Tokitsukaze and Musynx 题意 对于 \(n\) 个 \(Note\)，有 \(5\) 个判定区间，每个区间有对应分数，输出调整谱面延时后分数的最大值。 给定 \(n\) 个音符，每个音符有对应判定分 \(x\)，定义五个判定区间 \((- \infty,a)\), \([a,b)\), \([b,c)\), \([c,d]\), \((d,+\infty)\)，\(x\) 落在区间内可获得对应分数 \(v_1\)，\(v2\)，\(v3\)，\(v4\)，\(v5\)。输出将所有的 \(x\) 加上或减去任意值后判定分总和的最大值。 思路 考虑到枚举 \(h\) 的时间复杂度过大，我们尝试另一种暴力枚举的方法： 将所有 \(x\) 减去一个较大的值，使所有的音符全都落在第一个判定区间内； 用数组存储每一个音符达到下一个判定区间的 \(\Delta x\)，以及对应的分数改变量； 按 \(\Delta x\) 升序排序，枚举所有改变量并算出分数的最大值即可。 时间复杂度：\(O(4n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long const ll N = 200010, inf = 1e18; ll x[N]; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int t; cin >> t; while(t --) &#123; int n, a, b, c, d, v1, v2, v3, v4, v5; cin >> n; for (int i = 0; i &lt; n; i++) &#123; cin >> x[i]; x[i] -= 2ll * 1e9; &#125; cin >> a >> b >> c >> d >> v1 >> v2 >> v3 >> v4 >> v5; vector&lt;pair&lt;ll, int>> p; for (int i = 0; i &lt; n; i++) &#123; p.emplace_back(a - x[i], v2 - v1); p.emplace_back(b - x[i], v3 - v2); p.emplace_back(c - x[i], v4 - v3); p.emplace_back(d + 1 - x[i], v5 - v4); &#125; sort(p.begin(), p.end()); ll cur = v1 * n, ans = cur; for (auto &amp;e: p) &#123; cur += e.second; ans = max(ans, cur); &#125; cout &lt;&lt; ans &lt;&lt; '\n'; &#125; &#125; 一个音游人居然没开这题 J. Tokitsukaze and Sum of MxAb 题意 给定数组 \(a\)，定义 \(MxAb(i,j)=\max(|a_i-a_j|,|a_i+a_j|)\)，求 \(\displaystyle{\sum_{i=1}^n\sum_{j=1}^nMxAb(i,j)}\)。 思路 很显然，同号取和的绝对值，异号取差的绝对值，总和显然是和所有 \(|a_i|\) 的总和有关的。 可以贪心的认为，\(ans=sum\{|a_i|\} \times 2n\)。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int T = scanner.nextInt(); while(T -- > 0)&#123; int n = scanner.nextInt(); int[] a = new int[n]; long ans = 0; for(int i=0;i&lt;n;i++) &#123; a[i] = scanner.nextInt(); ans += Math.abs(a[i]); &#125; System.out.println(ans * 2 * n); &#125; &#125; &#125; 签到题呢 K. Tokitsukaze and Synthesis and Traits 待补充 L. Tokitsukaze and Three Integers 题意 给定序列 \(a\) 和正整数 \(p\)，对于所有 \(x=0...p-1\)，输出满足条件的三元组 \([i,j,k]\) 的数量。 满足条件： $i j \(，\)i k\(，\)j k$； \((a_i·a_j+a_k) \equiv x \pmod p\) 思路 因为 \(n\) 为 \(1e3\) 级别，所以可以考虑时间复杂度为 \(n^2\) 的做法。 我们可以把式子分解成 \((a_i·a_j) \bmod p =(x-a_k) \bmod p\)，因此我们只需计算等式左右两边的配对情况即可。 需要注意的是，\(k\) 不能和 \(i\)，\(j\) 相等，所以最后需要排除。 时间复杂度：\(O(n^2)\) 对应AC代码 import java.io.*; import java.math.BigInteger; import java.util.*; public class Main&#123; //快读，此处略过 //public static class Console implements Closeable &#123;&#125; public static void main(String[] args) throws Throwable&#123; Console console = new Console(); int n = console.nextInt(), p = console.nextInt(); long[] a = new long[n + 1]; for(int i=1;i&lt;=n;i++) a[i] = console.nextInt(); long[] cnt = new long[p]; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) cnt[(int)((a[i] * a[j]) % p)] += 2; long[] ans = new long[p]; for(int x=0;x&lt;p;x++) for(int k=1;k&lt;=n;k++)&#123; long i = x - a[k]; if (i &lt; 0) i += (-i / p + 1) * p; ans[x] += cnt[(int)(i % p)]; &#125; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++)&#123; ans[(int)((a[i] * a[j] + a[i]) % p)] -= 2; ans[(int)((a[i] * a[j] + a[j]) % p)] -= 2; &#125; for(int i=0;i&lt;p;i++) console.print(ans[i] + " "); console.close(); &#125; &#125; 别看了仔细想想就切题啊喂]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客2023寒假集训 - 1</title>
    <url>/blog/posts/2012230069/</url>
    <content><![CDATA[Rank 449/4376. AC 7/13. A. World Final? World Cup! (I) 题意 \(A\)队与\(B\)队轮流点球，\(A\)先手，判断\(10\)场内是否有某队必胜，输出该场次，或者输出\(-1\) 思路 对于第 \(i\) 场 \((i \in [0,9])\) ，剩余 \(left=10-i-1\) 场未打。 分开判断\(A\)队和\(B\)队， 对于\(A\)队，还有 \(left/2+(1-i\%2)\) 场； 对于\(B\)队，还有 \(left/2\) 场。 计算差值即可。 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int a = 0, b = 0; char[] in = scanner.next().toCharArray(); int i = 0; for(;i&lt;10;i++) &#123; if (i % 2 == 0) a += in[i] - '0'; else b += in[i] - '0'; int left = 10 - i - 1; if (a > b + left / 2 + (1 - i % 2)) break; if (b > a + left / 2) break; &#125; System.out.println(i != 10 ? i + 1 : -1); &#125; &#125; &#125; 很签的题要做快一点 B. World Final? World Cup! (II) 待补充 C. 现在是，学术时间 (I) 题意 每个教授有一篇引用量为 \(a_i\) 的论文，一个教授可发表多篇论文，找出一种分配方式使所有教授的 \(H\) 指数最大。\(H\) 指数定义为使得"该教授发表的所有论文中，有至少 \(H\) 篇论文的引用量大于等于 \(H\) "这一命题成立的最大的 \(H\)。 思路 很容易发现，我们只需升序将文章分配，如果遇到有一篇论文分配不能让 \(h_i\) 增大，那就让另一个教授发表。因为每个教授只有一篇论文，所以论文无处可放的可能只有一个：引用量为 \(0\)。 \(ans=n-cnt_0\) 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int cnt = n; for(int i=0;i&lt;n;i++) &#123; int a = scanner.nextInt(); if(a == 0) cnt --; &#125; System.out.println(cnt); &#125; &#125; &#125; 能贪心就别想着去模拟 D. 现在是，学术时间 (II) 题意 在平面直角坐标系中，给定两个与坐标轴平行的矩形，第一个矩形由对角线上的两点 \((0,0)\) 和 \((x,y)\) 确定，第二个矩形的一个顶点为点 \(P(x_p,y_p)\)。记两矩形的交集面积为 \(S_1\)， 并集面积为 \(S_2\)， 输出 \(\{\frac{S_1}{S_2}\}_{\max}\)。 思路 根据糖水原理，分子小于分母时，分子和分母各加上\(k\)，分式结果变大。 那么，我们只需在每个方向上取交集的最大值，然后计算即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; //写太乱了，不建议做参考 int x = scanner.nextInt(), y = scanner.nextInt(), xp = scanner.nextInt(), yp = scanner.nextInt(); if(xp &lt;= x &amp;&amp; yp &lt;= y)&#123; System.out.println((double) Math.max(Math.max((x - xp) * (y - yp), xp * (y - yp)), Math.max(xp * yp, (x - xp) * yp)) / (x * y)); &#125;else if(xp > x &amp;&amp; yp > y)&#123; System.out.println((double) (x * y) / (xp * yp)); &#125;else if(xp > x &amp;&amp; yp &lt;= y)&#123; System.out.println(Math.max((double) (x * yp) / (x * y + yp * (xp - x)), (double) (x * (y - yp)) / (x * y + (y - yp) * (xp - x)))); &#125;else&#123; System.out.println(Math.max((double) (y * xp) / (x * y + xp * (yp - y)), (double) (y * (x - xp)) / (x * y + (x - xp) * (yp - y)))); &#125; &#125; &#125; &#125; 猜就完事了 E. 鸡算几何 题意 一根夹角不为 \(180°\) 和 \(360°\) 的 \(L\) 型铁丝，先后给出在平面中的三个点的坐标，判断是否出现了以边为轴的翻转。 思路1 计算四条边和 \(x\) 轴正半轴的夹角，判断较长边是否出现在较短边的顺时针方向。 时间复杂度：\(O(1)?\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int xa = scanner.nextInt(), ya = scanner.nextInt(), xb = scanner.nextInt(), yb = scanner.nextInt(), xc = scanner.nextInt(), yc = scanner.nextInt(); double xd = scanner.nextDouble(), yd = scanner.nextDouble(), xe = scanner.nextDouble(), ye = scanner.nextDouble(), xf = scanner.nextDouble(), yf = scanner.nextDouble(); if(calLen(xa, ya, xb, yb) == calLen(xc, yc, xb, yb))&#123; System.out.println("NO"); continue; &#125; System.out.println(judge(xa, ya, xb, yb, xc, yc) == judge(xd, yd, xe, ye, xf, yf) ? "NO" : "YES"); &#125; &#125; //返回较长边是否在较短边的顺时针方向 private static boolean judge(double xd, double yd, double xe, double ye, double xf, double yf)&#123; double de = calLen(xe, ye, xd, yd), ef = calLen(xe, ye, xf, yf); double dde = calDegree(xe, ye, xd, yd), def = calDegree(xe, ye, xf, yf); if(de > ef)&#123; if(dde > def)&#123; if(dde - def > 180) return true; else return false; &#125;else&#123; if(def - dde > 180) return false; else return true; &#125; &#125;else &#123; if(dde > def)&#123; if(dde - def > 180) return false; else return true; &#125;else&#123; if(def - dde > 180) return true; else return false; &#125; &#125; &#125; private static double calDegree(double startX, double startY, double endX, double endY)&#123; double tan = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI; if(tan &lt; 0) tan += 360; return tan; &#125; private static double calLen(double x1, double y1, double x2, double y2)&#123; return Math.sqrt(Math.pow(Math.abs(x1 - x2), 2) + Math.pow(Math.abs(y1 - y2), 2)); &#125; &#125; 思路2 通过叉乘的方式，判断较长边和较短边的位置关系。 时间复杂度：\(O(1)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; double calLen(double x1, double y1, double x2, double y2)&#123; return sqrt(pow(abs(x2 - x1), 2) + pow(abs(y2 - y1), 2)); &#125; double calCross(double x1, double y1, double x2, double y2)&#123; return x1 * y2 - x2 * y1; &#125; int main() &#123; int t, xa, ya, xb, yb, xc, yc; double xd, yd, xe, ye, xf, yf; cin >> t; while(t --)&#123; cin >> xa >> ya >> xb >> yb >> xc >> yc >> xd >> yd >> xe >> ye >> xf >> yf; double ab = calLen(xa, ya, xb, yb), bc = calLen(xb, yb, xc, yc), de = calLen(xd, yd, xe, ye), ef = calLen(xe, ye, xf, yf); if(ab == bc)&#123; cout &lt;&lt; "NO\n"; continue; &#125; //叉乘判断的是一个边在另一个边的哪个方向，那我们就需要用长边叉乘短边（或者换过来 if(ab &lt; bc) swap(xa, xc), swap(ya, yc); if(de &lt; ef) swap(xd, xf), swap(yd, yf); cout &lt;&lt; (calCross(xa - xb, ya - yb, xc - xb, yc - yb) * calCross(xd - xe, yd - ye, xf - xe, yf - ye) &lt; 0 ? "YES\n" : "NO\n"); &#125; return 0; &#125; L型到底是不是直角呢？ F. 鸡玩炸蛋人 题意 给出一个不一定联通的无向图以及每个点的标记情况。一个符合要求的方案定义为在一个连通块内取两个可以重复的点作为起点和终点，在路上按题给要求做上标记，并不能经过已经做过标记的点。若起点和终点有一个不同即视为方案不同。输出方案数，若无合法方案，输出 \(0\) 。 思路 因为标记后才不能回溯，所以我们完全可以以 \(DFS\) 深度遍历，并在回溯时做上标记。 也就是说，只要起点终点确定，一定能使方案符合要求。 因而，一个连通图的方案数即为 \(pow(cnt，2)\) ，\(cnt\) 为连通图的大小（点的数量）。 根据有标记的连通块个数分三种情况输出答案即可。 时间复杂度：\(O(tnm)\)，\(t\)为连通块数量 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long const int N = 200020; vector&lt;int> e[N]; int egg[N], n, m; bool vis[N]; pair&lt;ll, bool> dfs(int root)&#123; if(vis[root]) return &#123;0, false&#125;; vis[root] = true; ll cnt = 1; //我自己 bool have = egg[root] > 0; for(int t : e[root])&#123; auto c = dfs(t); if(c.second) have = true; cnt += c.first; &#125; return &#123;cnt, have&#125;; &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin >> n >> m; for(int i=0;i&lt;m;i++)&#123; int u, v; cin >> u >> v; e[u].emplace_back(v); e[v].emplace_back(u); &#125; for(int i=1;i&lt;=n;i++) cin >> egg[i]; ll tot = 0, cnt, eggCnt = 0; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]) continue; auto one = dfs(i); tot += one.first * one.first; if(one.second)&#123; eggCnt ++; cnt = one.first * one.first; &#125; &#125; if(eggCnt == 0) cout &lt;&lt; tot &lt;&lt; '\n'; else if(eggCnt == 1) cout &lt;&lt; cnt &lt;&lt; '\n'; else cout &lt;&lt; 0 &lt;&lt; endl; &#125; 多看看题，这题真的比上一题好做多了 G. 鸡格线 题意 给定数组 \(a\) ，对于 \(m\) 次询问，分成两种操作处理： 输入 \(l\)，\(r\)，\(k\)，对区间 \([l,r]\) 中的所有数字执行 \(k\) 次赋值操作：\(a_i=round(10\sqrt x)\)。 输出所有数字的和 重点 当操作次数 \(k \geq 20\) 时，\(f(x)=x\)，可以根据收敛证明。 思路1 维护一个 \(Set\)，存放剩下需要操作的数，然后暴力即可。 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); long[] a = new long[n + 1]; long sum = 0; TreeSet&lt;Integer> left = new TreeSet&lt;>(); for(int i=1;i&lt;=n;i++) &#123; sum += a[i] = scanner.nextInt(); if(f(a[i]) != a[i]) left.add(i); &#125; while(m -- > 0)&#123; int op = scanner.nextInt(); if(op == 1)&#123; int l = scanner.nextInt(), r = scanner.nextInt(), k = scanner.nextInt(); while(true)&#123; Object next = left.higher(l - 1); if(next == null) break; int nxt = Integer.parseInt(String.valueOf(next)); if(nxt > r) break; for(int i=1;i&lt;=Math.min(k, 20);i++)&#123; //最多20次操作即可让x0=f(x0) sum -= a[nxt]; a[nxt] = f(a[nxt]); sum += a[nxt]; &#125; if(a[nxt] == f(a[nxt])) left.remove(nxt); l = nxt + 1; &#125; &#125;else System.out.println(sum); &#125; &#125; private static long f(long x)&#123; return Math.round(Math.sqrt(x) * 10); &#125; &#125; 思路2 如果 \(l\) 已完成，那么可以用并查集的方式找到一个连通块后面的未完成点，开数组记录完成情况以及完成后连通块指向的点即可。 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; #define ll long long const int N = 100010; ll a[N]; int p[N], ne[N]; bool ok[N]; int find(int x) &#123; return p[x] == x ? x : p[x] = find(p[x]); &#125; void merge(int x, int y) &#123; x = find(x), y = find(y); p[y] = x; ne[x] = max(ne[x], ne[y]); &#125; ll f(ll x)&#123; return round(sqrt(x) * 10); &#125; int main() &#123; ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int n, m; cin >> n >> m; ll sum = 0; for (int i = 1; i &lt;= n; i++) &#123; cin >> a[i]; sum += a[i]; ne[i] = i + 1; p[i] = i; &#125; while (m-- > 0) &#123; int op; cin >> op; if (op == 1) &#123; int l, r, k; cin >> l >> r >> k; while (true) &#123; int nxt = ok[l] ? ne[find(l)] : l; if (nxt > r) break; for (int i = 1; i &lt;= min(k, 20); i++) &#123; //最多20次操作即可让x0=f(x0) sum -= a[nxt]; a[nxt] = f(a[nxt]); sum += a[nxt]; &#125; if (a[nxt] == f(a[nxt])) &#123; ok[nxt] = true; if (nxt &lt; n &amp;&amp; ok[nxt + 1]) merge(nxt, nxt + 1); if (nxt > 1 &amp;&amp; ok[nxt - 1]) merge(nxt, nxt - 1); &#125; l = nxt + 1; &#125; &#125; else cout &lt;&lt; sum &lt;&lt; '\n'; &#125; &#125; 思路3 一眼线段树，但我不会写。 对应AC代码 待补充 这题其实难在k H. 本题主要考察了DFS 题意 一个拼图有 \(n^2\) 块，部分块之间用凸出和缺口固定，缺口面积和凸出面积相等。一块拼图可用 上右下左 边的情况来表现状态，\(0\) 平整，\(1\) 缺口，\(2\) 凸起。给出 \(n^2-1\) 块，输出剩下的那块拼图的成本（\(10-cnt_1+cnt_2\)）。 思路 标题骗人，配对\(1\)和\(2\)即可 时间复杂度：\(O(n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t -- > 0)&#123; int n = scanner.nextInt(); int one = 0, two = 0; for(int i=0;i&lt;n * n -1;i++)&#123; String s = scanner.next(); for(char each : s.toCharArray())&#123; if(each == '1') one ++; else if(each == '2') two ++; &#125; &#125; int need = 10; if(one &lt; two)&#123; need -= two - one; &#125;else if(one > two)&#123; need += one - two; &#125; System.out.println(need); &#125; &#125; &#125; 这题还能做得再快点！ I. 本题也主要考察了DFS 待补充 J. 本题竟也主要考察了DFS 待补充 K. 本题主要考察了dp 题意 构建长为 \(n\)，只有 \(m\) 个 \(1\) 的 \(01\) 字符串，使连续的长度为\(3\)的子区间中满足 \(cnt_1&gt;cnt_0\) 的子区间的数量最小，并输出数量。 思路1 可以证明在 \(100,100,100,...\) 序列的最后插 \(1\) 的情况下数量最小。 那么，我们可以分三种情况： \(n \geq 3m-2\) 时，\(100\) 排不到结束，数量为 \(0\)。 \(n==m\)，一定只有 \(n - 2\) 个，不能再多了。 我们寻找成对出现的 \(00\) 和 \(0?0\)，可以得到对数为 \(\frac{3}{2}(n-m) + (n-m)\%2 + 1\)，用总对数 \(n-2\) 扣除即可。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); if(n >= 3 * m - 2)&#123; System.out.println(0); &#125;else if(n == m)&#123; System.out.println(n - 2); &#125;else&#123; System.out.println(n - 1 - (n - m) / 2 * 3 - (n - m) % 2); &#125; &#125; &#125; 思路2 根据思路\(1\)的第一句话，模拟建立字符串并遍历统计个数。 时间复杂度：\(O(n)\) 对应AC代码 待补充 思路3 状压\(dp\)可解。 对应AC代码 待补充 来波逆向思维~ L. 本题主要考察了运气 题意 \(5\) 个团体，每个团体 \(4\) 人，对于猜测次数，输出\((\)猜对的数学期望\(-3.45)/0.05\)。 思路 五个团体，\(x=0.2 \times 1 + 0.2 \times 2 + 0.2 \times 3 + 0.4 \times 4=2.8\)； 四个人，\(y=0.25 \times 1+0.25 \times 2 + 0.5 \times 3=2.25\)； \(ans=32(5.05)\)。 时间复杂度：\(O(1)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; System.out.println(32); &#125; &#125; 6遍就猜对了哈哈哈 M. 本题主要考察了找规律 题意 将 \(m\) 份仙贝分给 \(n\) 位朋友。若分给某个好朋友时，还剩 \(x\) 个仙贝，并给了他 \(y\) 个仙贝，那么定义每个朋友的好感度为 \(\frac{y}{x}\)。求出总好感度的最大值。 思路 动态规划，不是找规律！！！ \(dp[i][j]\) 为 目前给了 \(i\) 个人仙贝，总共给了 \(j\) 个仙贝的最大总好感度。 枚举第 \(i\) 个人分到的仙贝数 \(k\)，得到状态转移方程： \(dp[i][j]=max(dp[i-1][j-k]+\frac{k}{m-(j-k)}),k \leq j\) 时间复杂度：小于\(O(nm^2)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); double[][] dp = new double[n + 1][m + 1]; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; double max = 0; for(int k=1;k&lt;=j;k++)&#123; max = Math.max(max, dp[i - 1][j - k] + (double) k / (m - j + k)); &#125; dp[i][j] = max; &#125; &#125; System.out.println(dp[n][m]); &#125; &#125; 防诈骗]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>牛客2023寒假集训</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Round 837 Div. 2</title>
    <url>/blog/posts/2672195264/</url>
    <content><![CDATA[Practice. Solved 3 of 6. A. Hossam and Combinatorics 题意 定义数对 \((a_i,a_j)\) 满足 \(i \neq j\)。给定数组 \(a\)，输出满足 \(|a_i-a_j|\) 最大的数对数量。 思路 既然要找出 \(\max(|a_i-a_j|)\)，那么我们就需要先把它求出来。更具体地说，我们在读入数组 \(a\) 的时候可以顺便记录下来最大值 \(maxx\) 和最小值 \(minn\)，方便后续操作。 考虑到我们不可能再对数组进行多次遍历，我们可以在读入数组 \(a\) 的时候也记录一下每个数字出现的次数 \(cnt\)，为节省空间我们可以用 \(map\) 存储。 令 \(maxx-minn=dist\)，那么对于一个数对 \((a_i,a_j)\)，我们只需满足 \(|a_i-a_j|=dist\)，去掉绝对值，我们便可以得到两个式子：\(a_j=a_i-dist\)，\(a_j=a_i+dist\)。不妨记此时的 \(a_j\) 为左值和右值，那我们就只需遍历所有 \(a_i\)，判断一下 \(cnt[a_j]\) 是否大于 \(0\) 即可。对于左值和右值，我们可以分开标记以防重复计算（看到题解并没有这么做，待考证.jpg) 对于每次遍历的统计，我们只需 \(ans+=cnt[a_i] \times cnt[a_j] \times 2\) 即可。 时间复杂度：最坏 \(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 100010, inf = 0x3f3f3f3f; int a[N]; bool stl[N], str[N]; int main() &#123; int T, n; scanf("%d", &amp;T); while (T--) &#123; memset(a, 0, sizeof a); memset(stl, 0, sizeof stl); memset(str, 0, sizeof str); scanf("%d", &amp;n); map&lt;int, long long> cnt; int minn = inf, maxx = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;a[i]); cnt[a[i]] ++; minn = min(minn, a[i]); maxx = max(maxx, a[i]); &#125; int dist = maxx - minn; long long ans = 0; if(dist == 0) ans = (long long) n * (n - 1); else for(int i=0;i&lt;n;i++)&#123; if(!stl[a[i]]) &#123; stl[a[i]] = true; if (a[i] > dist &amp;&amp; cnt[a[i] - dist] > 0) &#123; str[a[i] - dist] = true; ans += cnt[a[i]] * cnt[a[i] - dist] * 2; &#125; &#125; if(!str[a[i]]) &#123; str[a[i]] = true; if (cnt[a[i] + dist] > 0) &#123; stl[a[i] + dist] = true; ans += cnt[a[i]] * cnt[a[i] + dist] * 2; &#125; &#125; &#125; printf("%lld\n", ans); &#125; &#125; 思维还是很重要滴 B. Hossam and Friends 题意 给定 \(m\) 组关系，约定除了这些关系外其他人都是好朋友，输出所有连续子序列中满足所有人都是好朋友的数量。 思路 我们先用一种双指针的思维来模拟一下：一开始，\(l=0,r=0\)，然后我们将 \(r\) 向后移，会发现我们能向右移的范围在缩小。因为每扩大一次区间，我们就会遇到更多对陌生人。为了处理这种情况，我们可以在读入关系 \((x,y)\) 的时候顺便记录下来 \(\min(x,y)\) 对应的 \(\max(x,y) -1\)，这样我们在每次遍历的时候就可以以 \(O(1)\) 的时间复杂度更新右端点最大值了，当无法继续时，我们再更改 \(l\)，直到结束。 上述思路是完全正确的，但存在一个问题：暴力模拟 \(1e10\) 的复杂度绝对是超时的。 顺着不行，我们来换个方向。依然是固定 \(l\)，但这次我们从 \(n-1\) 往回推，就不难发现一个递推式子了： 定义 \(nxt[i]\) 为以 \(i\) 为左边界的满足条件的最小右边界，那么 \(nxt[i]=\min(e[i],nxt[i+1])\) 。这里的 \(e\) 数组即为1中记录的关系 \((x,y)\)。 很好理解，在向左移动头节点的时候，尾节点已经遍历过后面的所有值，因而我们可以直接用动态规划的思路来推出 \(nxt\) 数组。 接下来就好办了，既然对于每个左边界 \(i\)，都能找到确定的右边界 \(nxt[i]\)，那么连续子区间数量就为 \(nxt[i]-i+1\) 了。 当然，\(e\) 数组和 \(nxt\) 数组完全可以合并。 时间复杂度： \(O(n)\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 100010, inf = 0x3f3f3f3f; int nxt[N]; int main() &#123; int T, n, m, x, y; scanf("%d", &amp;T); while (T--) &#123; //hey, this is easy. scanf("%d %d", &amp;n, &amp;m); for(int i=1;i&lt;=n;i++) nxt[i] = n; for(int i=0;i&lt;m;i++)&#123; scanf("%d %d", &amp;x, &amp;y); nxt[min(x, y)] = min(nxt[min(x, y)], max(x, y) - 1); &#125; for(int i=n-1;i>=1;i--) nxt[i] = min(nxt[i], nxt[i + 1]); long long ans = 0; for(int i=1;i&lt;=n;i++) ans += nxt[i] - i + 1; printf("%lld\n", ans); &#125; &#125; 都想到双指针了，何不换个方向想想看呢 C. Hossam and Trainees 题意 给定数组 \(a\)，输出是否有满足 \(gcd(a_i,a_j)&gt;1,i \neq j\) 的 \(i,j\)。 思路 优雅的暴力 我们只需打表，筛出所有我们需要的质数，然后分解质因数并记录每个因数出现的次数即可，只要有一个 \(cnt \geq 2\)，那么直接判YES即可。 当然，这么暴力是绝对超时的，我们可以考虑下面的优化思路： 线性筛法，复杂度降到 \(O(n)\)。 既然是分解质因数，那么我们只需分解小的那一半即可，大的无需考虑，因而我们可以把边界缩小到 \(\sqrt{10^9}=31623\)。 时间复杂度： \(O(\frac{n \sqrt{A}}{\log n})\) 对应AC代码 #include &lt;bits/stdc++.h> using namespace std; const int N = 1e5 + 5; vector&lt;int> primes; bool vis[N + 1]; map&lt;int, int> cnt; void init() &#123; for (int i = 2; i &lt;= N; ++i) &#123; if (!vis[i]) &#123; primes.emplace_back(i); &#125; for (int &amp;j : primes) &#123; if (1ll * i * j > N) break; vis[i * j] = true; if (i % j == 0) break; &#125; &#125; &#125; bool fact(int x) &#123; int max = (int) sqrt(x); for (int &amp;i : primes) &#123; if(i > max) break; if (x % i == 0) &#123; while (x % i == 0) x /= i; cnt[i] ++; if(cnt[i] == 2) return true; &#125; &#125; if (x != 1) &#123; cnt[x] ++; if(cnt[x] >= 2) return true; &#125; return false; &#125; int main() &#123; init(); int T, n; scanf("%d", &amp;T); while (T--) &#123; cnt.clear(); scanf("%d", &amp;n); bool ok = false; for(int i=0;i&lt;n;i++)&#123; int x; scanf("%d", &amp;x); if(ok) continue; if(fact(x)) ok = true; &#125; printf(ok ? "YES\n" : "NO\n"); &#125; &#125; 有时候可以想想暴力+优化的思路呢]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - Good Bye 2022</title>
    <url>/blog/posts/3334935914/</url>
    <content><![CDATA[Contestant. Rank 9289. Rating -54 (+446 -500). A. Koxia and Whiteboards 题意 给定序列 \(a\) , \(b\) , 执行 \(m\) 次操作，对于第 \(j\) 次操作，将序列 \(a\) 中任意数值修改为 \(b_j\) ，输出操作之后序列 \(a\) 的总和的最大值。 思路1 注意到题目所给 \(n\) 和 \(m\) 很小，因而我们可以遍历 \(b_j\)，在每次替换前 \(sort\) 一遍 \(a\) 数组，然后替换 \(a_0\) 即可。 一句话，暴力+模拟。 时间复杂度：\(O(mn \log n)\) 当然也可以用优先队列优化时间复杂度，不过优化后差不多，所以不放代码了。 对应AC代码 import java.util.*; public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while(t-- > 0)&#123; int n = scanner.nextInt(), m = scanner.nextInt(); int[] a = new int[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextInt(); for(int i=0;i&lt;m;i++) &#123; Arrays.sort(a, 0, n); a[0] = scanner.nextInt(); &#125; long ans = 0; for(int i=0;i&lt;n;i++) ans += a[i]; System.out.println(ans); &#125; &#125; &#125; 思路2 先大胆假设：既然对于 \(a\) 中的修改是任意的，那么我们只要把 \(a\) 升序排序，依次用降序排序的 \(b\) 中的值替换即可。 假设如此，但需要注意到一点：操作的顺序是不能更改的。 因此，在排序前，我们需要一并存下来 \(b_i\) 的下标。在替换时，我们需要记录访问到的 \(b_i\) 所存原下标的最大值 \(imax\)，如果 \(imax \neq m-1\)，那么肯定还有一些较小的值等待替换，这些值显然是小于剩下的 \(a_i\) 的。所以，我们可以贪心的认为，我们只需找到替换后的一个合适的 \(a_p\)，用 \(b_{m-1}\) 替换即可。 那么，我们来考虑如何选取这个 \(a_p\)： 因为替换后的 \(a\) 序列是先递减后递增的，那么最小值将出现在最后一次替换的 \(b_j\) 和未替换的第一个 \(a_{i+1}\) （ \(b_j\) 替换 \(a_i\) ）之间，即 \(a_p=\min(a_{i+1}, b_j)\)。当然，肯定要判一下 \(i\) 的大小，不能越界。 时间复杂度：\(O(n \log n)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); while (t-- > 0) &#123; int n = scanner.nextInt(), m = scanner.nextInt(); int[] a = new int[n]; int[][] b = new int[m][2]; for (int i = 0; i &lt; n; i++) a[i] = scanner.nextInt(); for (int i = 0; i &lt; m; i++) b[i] = new int[]&#123;i, scanner.nextInt()&#125;; int lastB = b[m - 1][1]; Arrays.sort(a); Arrays.sort(b, (o1, o2) -> o2[1] - o1[1]); long ans = 0; int i = 0, j = 0, lastChange = 0, lastChangedI = 0, approached = 0; for (; i &lt; n &amp;&amp; j &lt; m; i++) &#123; if (a[i] &lt; b[j][1]) &#123; approached = Math.max(approached, b[j][0]); lastChange = b[j][1]; lastChangedI = i; ans += b[j++][1]; &#125; else ans += a[i]; &#125; for (; i &lt; n; i++) ans += a[i]; if(j == 0) ans = ans - a[0] + lastB; else if(j &lt; m &amp;&amp; approached != m - 1) &#123; ans = ans - (lastChangedI + 1 > n - 1 ? lastChange : Math.min(lastChange, a[lastChangedI + 1])) + lastB; &#125; System.out.println(ans); &#125; &#125; &#125; 有时候很简单的签到题不要想太多 B. Koxia and Permutation 题意 给定 \(n\)，\(k\)，求出一种 \(n\) 的排列 \(p\)，使得对于每个长度为 \(k\) 的连续子序列中，最大值和最小值的和最小。 思路 既然要让最大值和最小值的和最小，那么我们就需要让最大值出现的次数尽量少，最小值出现的次数尽量多。 因而，结合区间的移动，我们可以先降序地输出 \(k-1\) 个数，然后再输出 \(1\)，此时1出现的次数被最大化。 同理，那么我们就可以在降序输出后升序输出 \(k\) 个数，然后重复上述2个步骤，循环输出至无数可输出为止。 当然，可以证明交替输出和上述思路得到的序列性质是一样的。 时间复杂度：\(O(n)\) 对应AC代码 #include&lt;bits/stdc++.h> using namespace std; int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; int n, k; scanf("%d %d", &amp;n, &amp;k); int l = 1, r = n, now = k - 1; for (int i = 1; i &lt;= n; i++) &#123; printf("%d ", now > 0 ? r-- : l++); now--; if (now == 1 - k) now = k - 1; &#125; printf("\n"); &#125; &#125; 思维题还是要多做做，写太慢了。 而且如果用java写的话，需要使用快读，否则会超时。 C. Koxia and Number Theory 题意 给定序列 \(a\) ，判断是否存在 \(x\) ，满足对于任意不同的两个下标 \(i\) , \(j\) ，都有 \(gcd(a_i+x,a_j+x)=1\)。 做法 显然不能出现重复数值 考虑每个质数 \(t\) , 遍历序列 \(a\) , 统计所有 \(a_i \% t\) 出现的次数，若全都大于2，判定NO 对于第二步的数学证明 假设 \(a_u\) 和 \(a_v\) 同余于质数 \(p\)，那么 \(a_u+x\) 和 \(a_v+x\) 同余于 \(p\)。 在1的条件下，要使 \(gcd(a_u+x,a_v+x)\) 不被 \(p\) 整除，则必须满足 \((x + a_u) \not\equiv 0 \pmod p\) 。 因而，我们需要存在至少一个 \(a_i \% p\) 的值 \(j\) ，满足 \(x \equiv (p-j) \pmod p\)，这样，我们就可以使用 中国剩余定理 (CRT) 解出 \(x\)。 任取一个 \(j\) ，若它的出现次数 \(cnt_j\geq2\)，那么存在 \(x\) 符合条件1的条件。此时，根据上面的证明，可以得出\(x \not\equiv (p-j) \pmod p\) 。 由上述证明，若所有 \(cnt_i\geq2\)，那么无法解出 \(x\) ，判定为NO。 对于上述证明的具体例子 判定YES的一个例子： 对于下面的输入 1 3 5 7 10 取 \(p = 2\)，则可得取余后的序列 \(1, 1, 0\)，此时 \(cnt_0&lt;2\)，\(cnt_1\geq2\)，有 \(x \equiv 2-0 \pmod 2\) 取 \(p = 3\)，则可得取余后的序列 \(2, 1, 1\)，此时 \(cnt_1\geq2\)，\(cnt_2&lt;2\)，有 \(x \equiv 3-2 \pmod 3\) ... 对于每一个 \(p\) ，都有一个同余方程组，可根据 \(CRT\) 求出 \(x\) 的一个通解。从而，我们可以联立后解出 \(x\)。 判定NO的一个例子： 对于下面的输入 1 11 6 9 12 14 16 17 18 20 25 28 30 取 \(p = 5\)，则可得取余后的序列 \(1,4,2,4,1,2,3,0,0,3,0\)，此时对于任意 \(j\)，都有 \(cnt_j\geq2\)，因而我们无法找到一个式子满足\(x \equiv (p-j) \pmod p\)，从而无法解得 \(x\) 。 中国剩余定理 (CRT) 对于 \(m_1, m_2, ...,m_n\)，满足 \(gcd(m_1,m_2,..,m_n)=1\)，则对于如下形式的一元线性同余方程组 \(\begin{cases} x \equiv a_1 \pmod{m_1}\\ x \equiv a_2 \pmod{m_2}\\ \cdots\\ x \equiv a_n \pmod{m_n} \end{cases}\) 计算 \(M=\prod\limits_{i=1}^n m_i,M_i=\dfrac{M}{m_i}\)，即 \(M_i\) 是除 \(m_i\) 之外其他整数的乘积； 设 \(t_i\) 为 \(M_i\) 模 \(m_i\) 的逆元，即求 \(t_i = (M_i)^{-1}\pmod{m_i}\)； 上述方程组的通解为：\(x=a_1t_1M_1+a_2t_2M_2+...+a_nt_nM_n+kM，k\in Z\) 。模 \(M\) 后，只有一个解 \(x=a_1t_1M_1+a_2t_2M_2+...+a_nt_nM_n\)。 更加直观的做法 枚举所有元素，若有重复则判NO； 枚举所有 \(2 \sim n/2\) 的数 \(p\)，若模 \(p\) 后的序列所有数字出现的次数都大于 \(2\)，那么判NO。 第二步的可行性 肉眼可见，当 \(n\) 足够大时，判断素数的步骤是超时的，但因为我们是从小到大枚举的，因而我们可以保证所有合数在被枚举到之前都已经被判断过，且加上对于合数的可行性判断后，时间复杂度在合理范围内。 对于右边界 \(n/2\)，我们考虑抽屉原理：将 \(n+1\) 个物品放入 \(n\) 个抽屉，肯定有至少一个抽屉有两个物品。 那么，对于 \(n\) 个物品，放入大于 \(n/2\) 个抽屉中，我们肯定无法让所有抽屉都放上 \(2\) 个物品。 因而，我们只需遍历到 \(n/2\) 即可。 时间复杂度：\(O\left(\frac{n^2}{\log n} \right)\) 对应AC代码 import java.util.*; public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int t = scanner.nextInt(); nxt:while(t -- > 0)&#123; int n = scanner.nextInt(); long[] a = new long[n]; for(int i=0;i&lt;n;i++) a[i] = scanner.nextLong(); for(int i=1;i&lt;n;i++) for(int j=i-1;j>=0;j--) if(a[i] == a[j])&#123; System.out.println("NO"); continue nxt; &#125; for(int i=2;i&lt;=n / 2;i++)&#123; int[] m = new int[i]; boolean f = false; for(int j=0;j&lt;n;j++) m[(int)(a[j] % i)] ++; for(int j=0;j&lt;i;j++) &#123; if(m[j] &lt; 2) &#123; f = true; break; &#125; &#125; if(!f)&#123; System.out.println("NO"); continue nxt; &#125; &#125; System.out.println("YES"); &#125; &#125; &#125; 数论得多看看力，有时候可以多尝试一些数据来找寻规律。]]></content>
      <categories>
        <category>算法竞赛题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
</search>
